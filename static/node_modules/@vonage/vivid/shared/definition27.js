import { F as FoundationElement, D as DOM, _ as __decorate, a as attr, o as observable, h as html, r as registerFactory } from './index.js';
import { a as iconRegistries } from './definition25.js';
import { f as focusRegistries } from './definition56.js';
import { A as AffixIcon, a as affixIconTemplateFactory } from './affix.js';
import { a as applyMixins } from './apply-mixins.js';
import { S as StartEnd } from './start-end.js';
import { D as Direction, g as getDirection } from './direction.js';
import { i as keyArrowLeft, h as keyArrowRight, a as keySpace, k as keyEnter, c as keyHome, b as keyEnd, e as keyArrowUp, d as keyArrowDown } from './key-codes.js';
import { I as Icon } from './icon.js';
import { i as isHTMLElement } from './dom.js';
import { f as focusTemplateFactory } from './focus2.js';
import { s as slotted, e as elements } from './slotted.js';
import { w as when } from './when.js';
import { c as classNames } from './class-names.js';

/**
 * Menu items roles.
 * @public
 */
const MenuItemRole$1 = {
    /**
     * The menu item has a "menuitem" role
     */
    menuitem: "menuitem",
    /**
     * The menu item has a "menuitemcheckbox" role
     */
    menuitemcheckbox: "menuitemcheckbox",
    /**
     * The menu item has a "menuitemradio" role
     */
    menuitemradio: "menuitemradio",
};
/**
 * @internal
 */
const roleForMenuItem = {
    [MenuItemRole$1.menuitem]: "menuitem",
    [MenuItemRole$1.menuitemcheckbox]: "menuitemcheckbox",
    [MenuItemRole$1.menuitemradio]: "menuitemradio",
};

/**
 * A Switch Custom HTML Element.
 * Implements {@link https://www.w3.org/TR/wai-aria-1.1/#menuitem | ARIA menuitem }, {@link https://www.w3.org/TR/wai-aria-1.1/#menuitemcheckbox | ARIA menuitemcheckbox}, or {@link https://www.w3.org/TR/wai-aria-1.1/#menuitemradio | ARIA menuitemradio }.
 *
 * @slot checked-indicator - The checked indicator
 * @slot radio-indicator - The radio indicator
 * @slot start - Content which can be provided before the menu item content
 * @slot end - Content which can be provided after the menu item content
 * @slot - The default slot for menu item content
 * @slot expand-collapse-indicator - The expand/collapse indicator
 * @slot submenu - Used to nest menu's within menu items
 * @csspart input-container - The element representing the visual checked or radio indicator
 * @csspart checkbox - The element wrapping the `menuitemcheckbox` indicator
 * @csspart radio - The element wrapping the `menuitemradio` indicator
 * @csspart content - The element wrapping the menu item content
 * @csspart expand-collapse-glyph-container - The element wrapping the expand collapse element
 * @csspart expand-collapse - The expand/collapse element
 * @csspart submenu-region - The container for the submenu, used for positioning
 * @fires expanded-change - Fires a custom 'expanded-change' event when the expanded state changes
 * @fires change - Fires a custom 'change' event when a non-submenu item with a role of `menuitemcheckbox`, `menuitemradio`, or `menuitem` is invoked
 *
 * @public
 */
let MenuItem$1 = class MenuItem extends FoundationElement {
    constructor() {
        super(...arguments);
        /**
         * The role of the element.
         *
         * @public
         * @remarks
         * HTML Attribute: role
         */
        this.role = MenuItemRole$1.menuitem;
        /**
         * @internal
         */
        this.hasSubmenu = false;
        /**
         * Track current direction to pass to the anchored region
         *
         * @internal
         */
        this.currentDirection = Direction.ltr;
        this.focusSubmenuOnLoad = false;
        /**
         * @internal
         */
        this.handleMenuItemKeyDown = (e) => {
            if (e.defaultPrevented) {
                return false;
            }
            switch (e.key) {
                case keyEnter:
                case keySpace:
                    this.invoke();
                    return false;
                case keyArrowRight:
                    //open/focus on submenu
                    this.expandAndFocus();
                    return false;
                case keyArrowLeft:
                    //close submenu
                    if (this.expanded) {
                        this.expanded = false;
                        this.focus();
                        return false;
                    }
            }
            return true;
        };
        /**
         * @internal
         */
        this.handleMenuItemClick = (e) => {
            if (e.defaultPrevented || this.disabled) {
                return false;
            }
            this.invoke();
            return false;
        };
        /**
         * @internal
         */
        this.submenuLoaded = () => {
            if (!this.focusSubmenuOnLoad) {
                return;
            }
            this.focusSubmenuOnLoad = false;
            if (this.hasSubmenu) {
                this.submenu.focus();
                this.setAttribute("tabindex", "-1");
            }
        };
        /**
         * @internal
         */
        this.handleMouseOver = (e) => {
            if (this.disabled || !this.hasSubmenu || this.expanded) {
                return false;
            }
            this.expanded = true;
            return false;
        };
        /**
         * @internal
         */
        this.handleMouseOut = (e) => {
            if (!this.expanded || this.contains(document.activeElement)) {
                return false;
            }
            this.expanded = false;
            return false;
        };
        /**
         * @internal
         */
        this.expandAndFocus = () => {
            if (!this.hasSubmenu) {
                return;
            }
            this.focusSubmenuOnLoad = true;
            this.expanded = true;
        };
        /**
         * @internal
         */
        this.invoke = () => {
            if (this.disabled) {
                return;
            }
            switch (this.role) {
                case MenuItemRole$1.menuitemcheckbox:
                    this.checked = !this.checked;
                    break;
                case MenuItemRole$1.menuitem:
                    // update submenu
                    this.updateSubmenu();
                    if (this.hasSubmenu) {
                        this.expandAndFocus();
                    }
                    else {
                        this.$emit("change");
                    }
                    break;
                case MenuItemRole$1.menuitemradio:
                    if (!this.checked) {
                        this.checked = true;
                    }
                    break;
            }
        };
        /**
         * Gets the submenu element if any
         *
         * @internal
         */
        this.updateSubmenu = () => {
            this.submenu = this.domChildren().find((element) => {
                return element.getAttribute("role") === "menu";
            });
            this.hasSubmenu = this.submenu === undefined ? false : true;
        };
    }
    expandedChanged(oldValue) {
        if (this.$fastController.isConnected) {
            if (this.submenu === undefined) {
                return;
            }
            if (this.expanded === false) {
                this.submenu.collapseExpandedItem();
            }
            else {
                this.currentDirection = getDirection(this);
            }
            this.$emit("expanded-change", this, { bubbles: false });
        }
    }
    checkedChanged(oldValue, newValue) {
        if (this.$fastController.isConnected) {
            this.$emit("change");
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
            this.updateSubmenu();
        });
        if (!this.startColumnCount) {
            this.startColumnCount = 1;
        }
        this.observer = new MutationObserver(this.updateSubmenu);
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        this.submenu = undefined;
        if (this.observer !== undefined) {
            this.observer.disconnect();
            this.observer = undefined;
        }
    }
    /**
     * get an array of valid DOM children
     */
    domChildren() {
        return Array.from(this.children).filter(child => !child.hasAttribute("hidden"));
    }
};
__decorate([
    attr({ mode: "boolean" })
], MenuItem$1.prototype, "disabled", void 0);
__decorate([
    attr({ mode: "boolean" })
], MenuItem$1.prototype, "expanded", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "startColumnCount", void 0);
__decorate([
    attr
], MenuItem$1.prototype, "role", void 0);
__decorate([
    attr({ mode: "boolean" })
], MenuItem$1.prototype, "checked", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "submenuRegion", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "hasSubmenu", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "currentDirection", void 0);
__decorate([
    observable
], MenuItem$1.prototype, "submenu", void 0);
applyMixins(MenuItem$1, StartEnd);

/**
 * A Menu Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#menu | ARIA menu }.
 *
 * @slot - The default slot for the menu items
 *
 * @public
 */
let Menu$1 = class Menu extends FoundationElement {
    constructor() {
        super(...arguments);
        this.expandedItem = null;
        /**
         * The index of the focusable element in the items array
         * defaults to -1
         */
        this.focusIndex = -1;
        /**
         * @internal
         */
        this.isNestedMenu = () => {
            return (this.parentElement !== null &&
                isHTMLElement(this.parentElement) &&
                this.parentElement.getAttribute("role") === "menuitem");
        };
        /**
         * if focus is moving out of the menu, reset to a stable initial state
         * @internal
         */
        this.handleFocusOut = (e) => {
            if (!this.contains(e.relatedTarget) && this.menuItems !== undefined) {
                this.collapseExpandedItem();
                // find our first focusable element
                const focusIndex = this.menuItems.findIndex(this.isFocusableElement);
                // set the current focus index's tabindex to -1
                this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
                // set the first focusable element tabindex to 0
                this.menuItems[focusIndex].setAttribute("tabindex", "0");
                // set the focus index
                this.focusIndex = focusIndex;
            }
        };
        this.handleItemFocus = (e) => {
            const targetItem = e.target;
            if (this.menuItems !== undefined &&
                targetItem !== this.menuItems[this.focusIndex]) {
                this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
                this.focusIndex = this.menuItems.indexOf(targetItem);
                targetItem.setAttribute("tabindex", "0");
            }
        };
        this.handleExpandedChanged = (e) => {
            if (e.defaultPrevented ||
                e.target === null ||
                this.menuItems === undefined ||
                this.menuItems.indexOf(e.target) < 0) {
                return;
            }
            e.preventDefault();
            const changedItem = e.target;
            // closing an expanded item without opening another
            if (this.expandedItem !== null &&
                changedItem === this.expandedItem &&
                changedItem.expanded === false) {
                this.expandedItem = null;
                return;
            }
            if (changedItem.expanded) {
                if (this.expandedItem !== null && this.expandedItem !== changedItem) {
                    this.expandedItem.expanded = false;
                }
                this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
                this.expandedItem = changedItem;
                this.focusIndex = this.menuItems.indexOf(changedItem);
                changedItem.setAttribute("tabindex", "0");
            }
        };
        this.removeItemListeners = () => {
            if (this.menuItems !== undefined) {
                this.menuItems.forEach((item) => {
                    item.removeEventListener("expanded-change", this.handleExpandedChanged);
                    item.removeEventListener("focus", this.handleItemFocus);
                });
            }
        };
        this.setItems = () => {
            const newItems = this.domChildren();
            this.removeItemListeners();
            this.menuItems = newItems;
            const menuItems = this.menuItems.filter(this.isMenuItemElement);
            // if our focus index is not -1 we have items
            if (menuItems.length) {
                this.focusIndex = 0;
            }
            function elementIndent(el) {
                const role = el.getAttribute("role");
                const startSlot = el.querySelector("[slot=start]");
                if (role !== MenuItemRole$1.menuitem && startSlot === null) {
                    return 1;
                }
                else if (role === MenuItemRole$1.menuitem && startSlot !== null) {
                    return 1;
                }
                else if (role !== MenuItemRole$1.menuitem && startSlot !== null) {
                    return 2;
                }
                else {
                    return 0;
                }
            }
            const indent = menuItems.reduce((accum, current) => {
                const elementValue = elementIndent(current);
                return accum > elementValue ? accum : elementValue;
            }, 0);
            menuItems.forEach((item, index) => {
                item.setAttribute("tabindex", index === 0 ? "0" : "-1");
                item.addEventListener("expanded-change", this.handleExpandedChanged);
                item.addEventListener("focus", this.handleItemFocus);
                if (item instanceof MenuItem$1) {
                    item.startColumnCount = indent;
                }
            });
        };
        /**
         * handle change from child element
         */
        this.changeHandler = (e) => {
            if (this.menuItems === undefined) {
                return;
            }
            const changedMenuItem = e.target;
            const changeItemIndex = this.menuItems.indexOf(changedMenuItem);
            if (changeItemIndex === -1) {
                return;
            }
            if (changedMenuItem.role === "menuitemradio" &&
                changedMenuItem.checked === true) {
                for (let i = changeItemIndex - 1; i >= 0; --i) {
                    const item = this.menuItems[i];
                    const role = item.getAttribute("role");
                    if (role === MenuItemRole$1.menuitemradio) {
                        item.checked = false;
                    }
                    if (role === "separator") {
                        break;
                    }
                }
                const maxIndex = this.menuItems.length - 1;
                for (let i = changeItemIndex + 1; i <= maxIndex; ++i) {
                    const item = this.menuItems[i];
                    const role = item.getAttribute("role");
                    if (role === MenuItemRole$1.menuitemradio) {
                        item.checked = false;
                    }
                    if (role === "separator") {
                        break;
                    }
                }
            }
        };
        /**
         * check if the item is a menu item
         */
        this.isMenuItemElement = (el) => {
            return (isHTMLElement(el) &&
                Menu.focusableElementRoles.hasOwnProperty(el.getAttribute("role")));
        };
        /**
         * check if the item is focusable
         */
        this.isFocusableElement = (el) => {
            return this.isMenuItemElement(el);
        };
    }
    itemsChanged(oldValue, newValue) {
        // only update children after the component is connected and
        // the setItems has run on connectedCallback
        // (menuItems is undefined until then)
        if (this.$fastController.isConnected && this.menuItems !== undefined) {
            this.setItems();
        }
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        DOM.queueUpdate(() => {
            // wait until children have had a chance to
            // connect before setting/checking their props/attributes
            this.setItems();
        });
        this.addEventListener("change", this.changeHandler);
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeItemListeners();
        this.menuItems = undefined;
        this.removeEventListener("change", this.changeHandler);
    }
    /**
     * Focuses the first item in the menu.
     *
     * @public
     */
    focus() {
        this.setFocus(0, 1);
    }
    /**
     * Collapses any expanded menu items.
     *
     * @public
     */
    collapseExpandedItem() {
        if (this.expandedItem !== null) {
            this.expandedItem.expanded = false;
            this.expandedItem = null;
        }
    }
    /**
     * @internal
     */
    handleMenuKeyDown(e) {
        if (e.defaultPrevented || this.menuItems === undefined) {
            return;
        }
        switch (e.key) {
            case keyArrowDown:
                // go forward one index
                this.setFocus(this.focusIndex + 1, 1);
                return;
            case keyArrowUp:
                // go back one index
                this.setFocus(this.focusIndex - 1, -1);
                return;
            case keyEnd:
                // set focus on last item
                this.setFocus(this.menuItems.length - 1, -1);
                return;
            case keyHome:
                // set focus on first item
                this.setFocus(0, 1);
                return;
            default:
                // if we are not handling the event, do not prevent default
                return true;
        }
    }
    /**
     * get an array of valid DOM children
     */
    domChildren() {
        return Array.from(this.children).filter(child => !child.hasAttribute("hidden"));
    }
    setFocus(focusIndex, adjustment) {
        if (this.menuItems === undefined) {
            return;
        }
        while (focusIndex >= 0 && focusIndex < this.menuItems.length) {
            const child = this.menuItems[focusIndex];
            if (this.isFocusableElement(child)) {
                // change the previous index to -1
                if (this.focusIndex > -1 &&
                    this.menuItems.length >= this.focusIndex - 1) {
                    this.menuItems[this.focusIndex].setAttribute("tabindex", "-1");
                }
                // update the focus index
                this.focusIndex = focusIndex;
                // update the tabindex of next focusable element
                child.setAttribute("tabindex", "0");
                // focus the element
                child.focus();
                break;
            }
            focusIndex += adjustment;
        }
    }
};
Menu$1.focusableElementRoles = roleForMenuItem;
__decorate([
    observable
], Menu$1.prototype, "items", void 0);

const styles = "/**\n * Do not edit directly\n * Generated on Tue, 17 Oct 2023 15:27:52 GMT\n */\n@supports selector(:focus-visible) {\n  :host(:focus-visible) {\n    outline: none;\n  }\n}\n:host([disabled]) {\n  cursor: not-allowed;\n}\n\n.base {\n  position: relative;\n  display: flex;\n  box-sizing: border-box;\n  align-items: center;\n  background-color: var(--_appearance-color-fill);\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  gap: 12px;\n  inline-size: 100%;\n  padding-block: 2px;\n  padding-inline: 16px;\n}\n.base {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:active, .active):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-soft);\n  --_appearance-color-outline: transparent;\n}\n.base:where(.selected, [aria-current]):where(:not(:disabled, .disabled, :hover, .hover)) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-dim);\n  --_appearance-color-outline: transparent;\n}\n.base:where(.selected, [aria-current]):where(:hover, .hover) {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-pale);\n  --_appearance-color-outline: transparent;\n}\n.base {\n  /* @cssprop [--vvd-menu-item-accent-primary=var(--vvd-color-canvas-text)] */\n  --_connotation-color-primary: var(--vvd-menu-item-accent-primary, var(--vvd-color-canvas-text));\n  /* @cssprop [--vvd-menu-item-accent-primary-text=var(--vvd-color-canvas)] */\n  --_connotation-color-primary-text: var(--vvd-menu-item-accent-primary-text, var(--vvd-color-canvas));\n  /* @cssprop [--vvd-menu-item-accent-primary-increment=var(--vvd-color-neutral-800)] */\n  --_connotation-color-primary-increment: var(--vvd-menu-item-accent-primary-increment, var(--vvd-color-neutral-800));\n  /* @cssprop [--vvd-menu-item-accent-faint=var(--vvd-color-neutral-50)] */\n  --_connotation-color-faint: var(--vvd-menu-item-accent-faint, var(--vvd-color-neutral-50));\n  /* @cssprop [--vvd-menu-item-accent-soft=var(--vvd-color-neutral-100)] */\n  --_connotation-color-soft: var(--vvd-menu-item-accent-soft, var(--vvd-color-neutral-100));\n  /* @cssprop [--vvd-menu-item-accent-pale=var(--vvd-color-neutral-300)] */\n  --_connotation-color-pale: var(--vvd-menu-item-accent-pale, var(--vvd-color-neutral-300));\n  /* @cssprop [--vvd-menu-item-accent-dim=var(--vvd-color-neutral-200)] */\n  --_connotation-color-dim: var(--vvd-menu-item-accent-dim, var(--vvd-color-neutral-200));\n}\n.base:not(.two-lines) {\n  min-block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n}\n.base.two-lines {\n  min-block-size: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) + calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2) - 16)));\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  cursor: pointer;\n}\n.base.disabled {\n  pointer-events: none;\n}\n\n.focus-indicator {\n  border-radius: 6px;\n}\n:host(:not(:focus-visible)) .focus-indicator {\n  display: none;\n}\n\n.icon {\n  flex-shrink: 0;\n  font-size: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) / 2);\n  line-height: 1;\n}\n\n.action,\n.decorative {\n  display: flex;\n  place-content: center;\n}\n\n.action {\n  color: var(--_appearance-color-text);\n}\n.base.trailing .action {\n  order: 1;\n  margin-inline-start: auto;\n}\n.base.has-meta .action {\n  order: 1;\n  margin-inline-start: auto;\n}\n\n.base:not(.disabled) .decorative {\n  color: var(--vvd-color-neutral-600);\n}\n.base.disabled .decorative {\n  color: var(--vvd-color-neutral-200);\n}\n.base.has-meta .decorative {\n  order: 1;\n  margin-inline-start: auto;\n}\n\n.chevron {\n  margin-inline-start: auto;\n}\n\n.text {\n  display: flex;\n  overflow: hidden;\n  flex-direction: column;\n}\n\n.text-primary,\n.text-secondary {\n  /* stylelint-disable value-no-vendor-prefix */\n  display: -webkit-box;\n  /* stylelint-enable value-no-vendor-prefix */\n  overflow: hidden;\n  -webkit-box-orient: vertical;\n  color: var(--_appearance-color-text);\n  font: var(--vvd-typography-base);\n}\n\n.text-primary {\n  -webkit-line-clamp: var(--text-primary-line-clamp, 1);\n}\n.base.two-lines .text-primary {\n  font: var(--vvd-typography-base-bold);\n}\n\n.text-secondary {\n  -webkit-line-clamp: var(--text-secondary-line-clamp, 1);\n}\n.base.two-lines .text-secondary {\n  color: var(--vvd-color-neutral-600);\n}";

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
const MenuItemRole = {
  ...MenuItemRole$1,
  presentation: "presentation"
};
var CheckAppearance = /* @__PURE__ */ ((CheckAppearance2) => {
  CheckAppearance2["Normal"] = "normal";
  CheckAppearance2["TickOnly"] = "tick-only";
  return CheckAppearance2;
})(CheckAppearance || {});
class MenuItem extends MenuItem$1 {
  constructor() {
    super();
    this.checkTrailing = false;
    this.#submenuArray = [];
    this.updateSubmenu = () => this.#updateSubmenu();
    this.addEventListener("expanded-change", this.#expandedChange);
  }
  #submenuArray;
  /**
   *
   *
   * @internal
   */
  slottedSubmenuChanged(_oldValue, newValue) {
    this.#submenuArray = newValue;
  }
  #updateSubmenu() {
    for (const submenu of this.#submenuArray) {
      this.submenu = submenu;
      this.submenu.anchor = this;
      this.submenu.placement = "right-start";
      this.submenu.collapseExpandedItem = () => this.#collapseExpandedItem();
    }
    this.hasSubmenu = this.submenu === void 0 ? false : true;
  }
  #collapseExpandedItem() {
    this.expanded = false;
  }
  #expandedChange() {
    if (this.hasSubmenu) {
      this.submenu.open = this.expanded;
    }
  }
}
__decorateClass$1([
  attr
], MenuItem.prototype, "text", 2);
__decorateClass$1([
  attr({ attribute: "text-secondary" })
], MenuItem.prototype, "textSecondary", 2);
__decorateClass$1([
  attr({ mode: "boolean", attribute: "check-trailing" })
], MenuItem.prototype, "checkTrailing", 2);
__decorateClass$1([
  attr({ attribute: "check-appearance" })
], MenuItem.prototype, "checkedAppearance", 2);
__decorateClass$1([
  observable
], MenuItem.prototype, "metaSlottedContent", 2);
__decorateClass$1([
  observable
], MenuItem.prototype, "slottedSubmenu", 2);
applyMixins(MenuItem, AffixIcon);

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class Menu extends Menu$1 {
  constructor() {
    super(...arguments);
    this.#anchorEl = null;
    this.#observeMissingAnchor = (anchorId) => {
      this.#observer = new MutationObserver(() => {
        const anchor = document.getElementById(anchorId);
        if (anchor) {
          this.#anchorEl = anchor;
          this.#setupAnchor(this.#anchorEl);
          this.#observer.disconnect();
          this.#observer = void 0;
        }
      });
      this.#observer.observe(document.body, { childList: true, subtree: true });
    };
    this.placement = "bottom";
    this.anchor = "";
    this.autoDismiss = false;
    this.open = false;
    this.#openIfClosed = () => {
      if (!this.open)
        DOM.queueUpdate(() => this.open = true);
    };
    this.#closeOnClickOutside = (e) => {
      if (!this.contains(e.target))
        this.open = false;
    };
  }
  #observer;
  #anchorEl;
  #observeMissingAnchor;
  anchorChanged(_, newValue) {
    if (this.#anchorEl)
      this.#cleanupAnchor(this.#anchorEl);
    this.#observer?.disconnect();
    this.#anchorEl = newValue instanceof HTMLElement ? newValue : document.getElementById(newValue);
    if (this.#anchorEl) {
      this.#setupAnchor(this.#anchorEl);
    } else {
      this.#observeMissingAnchor(newValue);
    }
  }
  autoDismissChanged(oldValue, newValue) {
    if (oldValue === void 0)
      return;
    if (newValue) {
      document.addEventListener("click", this.#closeOnClickOutside);
    } else {
      document.removeEventListener("click", this.#closeOnClickOutside);
    }
  }
  openChanged(_, newValue) {
    newValue ? this.$emit("open", void 0, { bubbles: false }) : this.$emit("close", void 0, { bubbles: false });
    if (this.#anchorEl) {
      this.#anchorEl.ariaExpanded = this.open.toString();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#anchorEl)
      this.#cleanupAnchor(this.#anchorEl);
    this.#observer?.disconnect();
    document.removeEventListener("click", this.#closeOnClickOutside);
  }
  #setupAnchor(a) {
    a.addEventListener("click", this.#openIfClosed, true);
    a.setAttribute("aria-haspopup", "menu");
  }
  #cleanupAnchor(a) {
    a.removeEventListener("click", this.#openIfClosed, true);
    a.removeAttribute("aria-hasPopup");
  }
  #openIfClosed;
  #closeOnClickOutside;
}
__decorateClass([
  attr({ mode: "fromView" })
], Menu.prototype, "placement", 2);
__decorateClass([
  attr({ mode: "fromView" })
], Menu.prototype, "anchor", 2);
__decorateClass([
  attr({ mode: "boolean", attribute: "auto-dismiss" })
], Menu.prototype, "autoDismiss", 2);
__decorateClass([
  attr({ mode: "boolean" })
], Menu.prototype, "open", 2);
__decorateClass([
  observable
], Menu.prototype, "headerSlottedContent", 2);
__decorateClass([
  observable
], Menu.prototype, "actionItemsSlottedContent", 2);

const getIndicatorIcon = (x) => {
  if (x.checkedAppearance === CheckAppearance.TickOnly) {
    return x.checked ? "check-line" : "";
  }
  const iconType = x.role === MenuItemRole.menuitemcheckbox ? "checkbox" : "radio";
  const iconStatus = x.checked ? "checked" : "unchecked";
  return `${iconType}-${iconStatus}-line`;
};
const getClasses = ({
  disabled,
  checked,
  role,
  text: text2,
  textSecondary,
  icon,
  metaSlottedContent,
  checkTrailing
}) => classNames(
  "base",
  ["disabled", Boolean(disabled)],
  ["selected", role !== MenuItemRole.menuitem && Boolean(checked)],
  ["trailing", role !== MenuItemRole.menuitem && (checkTrailing || Boolean(icon))],
  ["item-checkbox", role === MenuItemRole.menuitemcheckbox],
  ["item-radio", role === MenuItemRole.menuitemradio],
  ["two-lines", Boolean(text2?.length) && Boolean(textSecondary?.length)],
  ["has-meta", Boolean(metaSlottedContent?.length)]
);
function handleClick(x, { event }) {
  x.handleMenuItemClick(event);
  return x.role === MenuItemRole.presentation;
}
function checkIndicator(context) {
  const iconTag = context.tagFor(Icon);
  return html`${when(
    (x) => x.role === MenuItemRole.menuitemcheckbox || x.role === MenuItemRole.menuitemradio,
    html`<span class="action"><${iconTag} class="icon" name="${(x) => getIndicatorIcon(x)}"></${iconTag}></span>`
  )}`;
}
function text() {
  return html`${when(
    (x) => x.text || x.textSecondary,
    html`<span class="text">
			${when((x) => x.text, html`<span class="text-primary">${(x) => x.text}</span>`)}
			${when((x) => x.textSecondary, html`<span class="text-secondary">${(x) => x.textSecondary}</span>`)}
		</span>`
  )}`;
}
const MenuItemTemplate = (context) => {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  const iconTag = context.tagFor(Icon);
  return html`
	<template
		role="${(x) => x.role ? x.role : MenuItemRole.menuitem}"
		aria-haspopup="${(x) => x.hasSubmenu ? "menu" : void 0}"
		aria-checked="${(x) => x.role !== MenuItemRole.menuitem ? x.checked : void 0}"
		aria-disabled="${(x) => x.disabled}"
		aria-expanded="${(x) => x.expanded}"
		@keydown="${(x, c) => x.handleMenuItemKeyDown(c.event)}"
		@click="${handleClick}"
		@mouseover="${(x, c) => x.handleMouseOver(c.event)}"
		@mouseout="${(x, c) => x.handleMouseOut(c.event)}"
	>
		<div class="${getClasses}">
			${() => focusTemplate}
			<slot name="meta" ${slotted("metaSlottedContent")}></slot>
			${checkIndicator(context)}
			${when((x) => x.icon, html`<span class="decorative">${(x) => affixIconTemplate(x.icon)}</span>`)}
			${text()}
			${when((x) => x.hasSubmenu, html`<${iconTag} class="chevron" name="chevron-right-line"></${iconTag}>`)}
		</div>
		<slot name="submenu" ${slotted({ property: "slottedSubmenu", filter: elements(context.tagFor(Menu)) })}></slot>
	</template>
	`;
};

const menuItemDefinition = MenuItem.compose({
  baseName: "menu-item",
  template: MenuItemTemplate,
  styles
});
const menuItemRegistries = [menuItemDefinition(), ...iconRegistries, ...focusRegistries];
const registerMenuItem = registerFactory(menuItemRegistries);

export { Menu as M, menuItemRegistries as a, menuItemDefinition as m, registerMenuItem as r };
