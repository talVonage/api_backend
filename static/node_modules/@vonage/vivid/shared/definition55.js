import { F as FoundationElement, D as DOM, _ as __decorate, a as attr, o as observable, h as html, r as registerFactory } from './index.js';
import { T as TreeItem$1, i as isTreeItemElement } from './tree-item.js';
import { i as isHTMLElement, g as getDisplayedNodes } from './dom.js';
import { k as keyEnter, e as keyArrowUp, d as keyArrowDown, h as keyArrowRight, i as keyArrowLeft, b as keyEnd, c as keyHome } from './key-codes.js';
import { r as ref } from './ref.js';
import { s as slotted } from './slotted.js';
import { c as classNames } from './class-names.js';

/**
 * A Tree view Custom HTML Element.
 * Implements the {@link https://w3c.github.io/aria-practices/#TreeView | ARIA TreeView }.
 *
 * @slot - The default slot for tree items
 *
 * @public
 */
let TreeView$1 = class TreeView extends FoundationElement {
    constructor() {
        super(...arguments);
        /**
         * The tree item that is designated to be in the tab queue.
         *
         * @internal
         */
        this.currentFocused = null;
        /**
         * Handle focus events
         *
         * @internal
         */
        this.handleFocus = (e) => {
            if (this.slottedTreeItems.length < 1) {
                // no child items, nothing to do
                return;
            }
            if (e.target === this) {
                if (this.currentFocused === null) {
                    this.currentFocused = this.getValidFocusableItem();
                }
                if (this.currentFocused !== null) {
                    TreeItem$1.focusItem(this.currentFocused);
                }
                return;
            }
            if (this.contains(e.target)) {
                this.setAttribute("tabindex", "-1");
                this.currentFocused = e.target;
            }
        };
        /**
         * Handle blur events
         *
         * @internal
         */
        this.handleBlur = (e) => {
            if (e.target instanceof HTMLElement &&
                (e.relatedTarget === null || !this.contains(e.relatedTarget))) {
                this.setAttribute("tabindex", "0");
            }
        };
        /**
         * KeyDown handler
         *
         *  @internal
         */
        this.handleKeyDown = (e) => {
            if (e.defaultPrevented) {
                return;
            }
            if (this.slottedTreeItems.length < 1) {
                return true;
            }
            const treeItems = this.getVisibleNodes();
            switch (e.key) {
                case keyHome:
                    if (treeItems.length) {
                        TreeItem$1.focusItem(treeItems[0]);
                    }
                    return;
                case keyEnd:
                    if (treeItems.length) {
                        TreeItem$1.focusItem(treeItems[treeItems.length - 1]);
                    }
                    return;
                case keyArrowLeft:
                    if (e.target && this.isFocusableElement(e.target)) {
                        const item = e.target;
                        if (item instanceof TreeItem$1 &&
                            item.childItemLength() > 0 &&
                            item.expanded) {
                            item.expanded = false;
                        }
                        else if (item instanceof TreeItem$1 &&
                            item.parentElement instanceof TreeItem$1) {
                            TreeItem$1.focusItem(item.parentElement);
                        }
                    }
                    return false;
                case keyArrowRight:
                    if (e.target && this.isFocusableElement(e.target)) {
                        const item = e.target;
                        if (item instanceof TreeItem$1 &&
                            item.childItemLength() > 0 &&
                            !item.expanded) {
                            item.expanded = true;
                        }
                        else if (item instanceof TreeItem$1 && item.childItemLength() > 0) {
                            this.focusNextNode(1, e.target);
                        }
                    }
                    return;
                case keyArrowDown:
                    if (e.target && this.isFocusableElement(e.target)) {
                        this.focusNextNode(1, e.target);
                    }
                    return;
                case keyArrowUp:
                    if (e.target && this.isFocusableElement(e.target)) {
                        this.focusNextNode(-1, e.target);
                    }
                    return;
                case keyEnter:
                    // In single-select trees where selection does not follow focus (see note below),
                    // the default action is typically to select the focused node.
                    this.handleClick(e);
                    return;
            }
            // don't prevent default if we took no action
            return true;
        };
        /**
         * Handles the selected-changed events bubbling up
         * from child tree items
         *
         *  @internal
         */
        this.handleSelectedChange = (e) => {
            if (e.defaultPrevented) {
                return;
            }
            if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {
                return true;
            }
            const item = e.target;
            if (item.selected) {
                if (this.currentSelected && this.currentSelected !== item) {
                    this.currentSelected.selected = false;
                }
                // new selected item
                this.currentSelected = item;
            }
            else if (!item.selected && this.currentSelected === item) {
                // selected item deselected
                this.currentSelected = null;
            }
            return;
        };
        /**
         * Updates the tree view when slottedTreeItems changes
         */
        this.setItems = () => {
            // force single selection
            // defaults to first one found
            const selectedItem = this.treeView.querySelector("[aria-selected='true']");
            this.currentSelected = selectedItem;
            // invalidate the current focused item if it is no longer valid
            if (this.currentFocused === null || !this.contains(this.currentFocused)) {
                this.currentFocused = this.getValidFocusableItem();
            }
            // toggle properties on child elements
            this.nested = this.checkForNestedItems();
            const treeItems = this.getVisibleNodes();
            treeItems.forEach(node => {
                if (isTreeItemElement(node)) {
                    node.nested = this.nested;
                }
            });
        };
        /**
         * check if the item is focusable
         */
        this.isFocusableElement = (el) => {
            return isTreeItemElement(el);
        };
        this.isSelectedElement = (el) => {
            return el.selected;
        };
    }
    slottedTreeItemsChanged() {
        if (this.$fastController.isConnected) {
            // update for slotted children change
            this.setItems();
        }
    }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("tabindex", "0");
        DOM.queueUpdate(() => {
            this.setItems();
        });
    }
    /**
     * Handles click events bubbling up
     *
     *  @internal
     */
    handleClick(e) {
        if (e.defaultPrevented) {
            // handled, do nothing
            return;
        }
        if (!(e.target instanceof Element) || !isTreeItemElement(e.target)) {
            // not a tree item, ignore
            return true;
        }
        const item = e.target;
        if (!item.disabled) {
            item.selected = !item.selected;
        }
        return;
    }
    /**
     * Move focus to a tree item based on its offset from the provided item
     */
    focusNextNode(delta, item) {
        const visibleNodes = this.getVisibleNodes();
        if (!visibleNodes) {
            return;
        }
        const focusItem = visibleNodes[visibleNodes.indexOf(item) + delta];
        if (isHTMLElement(focusItem)) {
            TreeItem$1.focusItem(focusItem);
        }
    }
    /**
     * checks if there are any nested tree items
     */
    getValidFocusableItem() {
        const treeItems = this.getVisibleNodes();
        // default to selected element if there is one
        let focusIndex = treeItems.findIndex(this.isSelectedElement);
        if (focusIndex === -1) {
            // otherwise first focusable tree item
            focusIndex = treeItems.findIndex(this.isFocusableElement);
        }
        if (focusIndex !== -1) {
            return treeItems[focusIndex];
        }
        return null;
    }
    /**
     * checks if there are any nested tree items
     */
    checkForNestedItems() {
        return this.slottedTreeItems.some((node) => {
            return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
        });
    }
    getVisibleNodes() {
        return getDisplayedNodes(this, "[role='treeitem']") || [];
    }
};
__decorate([
    attr({ attribute: "render-collapsed-nodes" })
], TreeView$1.prototype, "renderCollapsedNodes", void 0);
__decorate([
    observable
], TreeView$1.prototype, "currentSelected", void 0);
__decorate([
    observable
], TreeView$1.prototype, "slottedTreeItems", void 0);

const styles = ".control {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}";

class TreeView extends TreeView$1 {
}

const getClasses = (_) => classNames("control");
const TreeViewTemplate = () => {
  return html`
	<template
		role="tree"
		${ref("treeView")}
		@keydown="${(x, c) => x.handleKeyDown(c.event)}"
		@focusin="${(x, c) => x.handleFocus(c.event)}"
		@focusout="${(x, c) => x.handleBlur(c.event)}"
		@click="${(x, c) => x.handleClick(c.event)}"
		@selected-change="${(x, c) => x.handleSelectedChange(c.event)}"
		>
		<div class="${getClasses}">
			<slot ${slotted("slottedTreeItems")}></slot>
		</div>
	</template>`;
};

const treeViewDefinition = TreeView.compose(
  {
    baseName: "tree-view",
    template: TreeViewTemplate,
    styles
  }
);
const treeViewRegistries = [treeViewDefinition()];
const registerTreeView = registerFactory(treeViewRegistries);

export { treeViewRegistries as a, registerTreeView as r, treeViewDefinition as t };
