/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/nexmoClient.js":
/*!****************************!*\
  !*** ./src/nexmoClient.js ***!
  \****************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Application Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst user_1 = __importDefault(require(\"./user\"));\nconst conversation_1 = __importDefault(require(\"./conversation\"));\nconst nxmCall_1 = __importDefault(require(\"./modules/nxmCall\"));\nconst sip_events_1 = __importDefault(require(\"./handlers/sip_events\"));\nconst rtc_events_1 = __importDefault(require(\"./handlers/rtc_events\"));\nconst application_events_1 = __importDefault(require(\"./handlers/application_events\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst page_config_1 = __importDefault(require(\"./pages/page_config\"));\nconst conversations_page_1 = __importDefault(require(\"./pages/conversations_page\"));\nconst user_sessions_page_1 = __importDefault(require(\"./pages/user_sessions_page\"));\nconst events_queue_1 = require(\"./handlers/events_queue\");\nconst member_1 = __importDefault(require(\"./member\"));\nlet sipEventHandler = null;\nlet rtcEventHandler = null;\nlet applicationEventsHandler = null;\n/**\n * Core application class for the SDK.\n * Application is the parent object holding the list of conversations, the session object.\n * Provides methods to create conversations and retrieve a list of the user's conversations, while it holds the listeners for\n * user's invitations\n * @class Application\n * @param {NexmoClient} SDK session Object\n * @param {object} params\n * @example <caption>Accessing the list of conversations</caption>\n *  rtc.createSession(token).then((application) => {\n *    console.log(application.conversations);\n *    console.log(application.me.name, application.me.id);\n *  }).catch((error) => {\n *    console.error(error);\n *  });\n * @emits Application#member:invited\n * @emits Application#member:joined\n * @emits Application#NXM-errors\n * @emits Application#rtcstats:analytics\n*/\nclass Application {\n    constructor(session, params) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.session = session;\n        this.conversations = new Map();\n        this.synced_conversations_count = 0;\n        this.start_sync_time = 0;\n        this.stop_sync_time = 0;\n        // conversation_id, nxmCall\n        this.calls = new Map();\n        // knocking_id, nxmCall\n        this._call_draft_list = new Map();\n        this.pageConfig = new page_config_1.default((session.config || {}).conversations_page_config);\n        this.conversations_page_last = null;\n        this.activeStreams = [];\n        sipEventHandler = new sip_events_1.default(this);\n        rtcEventHandler = new rtc_events_1.default(this);\n        applicationEventsHandler = new application_events_1.default(this);\n        this.me = null;\n        Object.assign(this, params);\n        WildEmitter.mixin(Application);\n    }\n    /**\n     * Update Conversation instance or create a new one.\n     *\n     * Pre-created conversation exist from getConversations\n     * like initialised templates. When we explicitly ask to\n     * getConversation(), we receive members and other details\n     *\n     * @param {object} payload Conversation payload\n     * @private\n    */\n    updateOrCreateConversation(payload) {\n        const conversation = this.conversations.get(payload.id);\n        if (conversation) {\n            conversation._updateObjectInstance(payload);\n            this.conversations.set(payload.id, conversation);\n        }\n        else {\n            this.conversations.set(payload.id, new conversation_1.default(this, payload));\n        }\n        return this.conversations.get(payload.id);\n    }\n    /**\n     * Application listening for member invited events.\n     *\n     * @event Application#member:invited\n     *\n     * @property {Member} member - The invited member\n     * @property {NXMEvent} event - The invitation event\n     *\n     * @example <caption>listen for member invited events on Application level</caption>\n     *  application.on(\"member:invited\",(member, event) => {\n     *    console.log(\"Invited to the conversation: \" + event.conversation.display_name || event.conversation.name);\n     *    // identify the sender.\n     *    console.log(\"Invited by: \" + member.invited_by);\n     *    //accept an invitation.\n     *    application.conversations.get(event.conversation.id).join();\n     *    //decline the invitation.\n     *     application.conversations.get(event.conversation.id).leave();\n     *  });\n    */\n    /**\n     * Application listening for member joined events.\n     *\n     * @event Application#member:joined\n     *\n     * @property {Member} member - the member that joined the conversation\n     * @property {NXMEvent} event - the join event\n     *\n     * @example <caption>listen for member joined events on Application level</caption>\n     *  application.on(\"member:joined\",(member, event) => {\n     *    console.log(\"JOINED\", \"Joined conversation: \" + event.conversation.display_name || event.conversation.name);\n     *  });\n  */\n    /**\n       * Entry point for queing events in Application level\n       * @private\n    */\n    async _enqueueEvent(response) {\n        if (this.session.config.enableEventsQueue) {\n            if (!this.eventsQueue) {\n                this.eventsQueue = new events_queue_1.EventsQueue((event) => this._handleEvent(event));\n            }\n            this.eventsQueue.enqueue(response, this);\n        }\n        else {\n            this._handleEvent(response);\n        }\n    }\n    /**\n     * Entry point for events in Application level\n     * @private\n    */\n    async _handleEvent(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const isEventFromMe = ((_a = event._embedded) === null || _a === void 0 ? void 0 : _a.from_user) ? ((_c = (_b = event._embedded) === null || _b === void 0 ? void 0 : _b.from_user) === null || _c === void 0 ? void 0 : _c.id) === ((_d = this.me) === null || _d === void 0 ? void 0 : _d.id)\n            : ((_f = (_e = event.body) === null || _e === void 0 ? void 0 : _e.user) === null || _f === void 0 ? void 0 : _f.user_id) === ((_g = this.me) === null || _g === void 0 ? void 0 : _g.id);\n        // check if user is already part of the conversation and if it has a member on a valid\n        // state (INVITED, JOINED) otherwise user is being re-invited and we need to fetch the\n        // conversation and members info again\n        const isUserReInvited = utils_1.default._checkIfUserIsReInvited(this.conversations, event);\n        if (event.type.startsWith('sip')) {\n            sipEventHandler._handleSipCallEvent(event);\n            return event;\n        }\n        if (this.conversations.has(event.cid) && event.type !== \"rtc:transfer\" && !isUserReInvited) {\n            if (event.type.startsWith('rtc')) {\n                rtcEventHandler._handleRtcEvent(event);\n            }\n            this.conversations.get(event.cid)._handleEvent(event);\n            if ((event.type === 'member:joined' || event.type === 'member:invited') && isEventFromMe) {\n                this._handleApplicationEvent(event);\n            }\n            return event;\n        }\n        else {\n            // if event has cid get the conversation you don't know about (case: joined by another user)\n            if (event.cid) {\n                try {\n                    if (isUserReInvited)\n                        this.conversations.delete(event.cid);\n                    let conversation;\n                    if (utils_1.default._isCallEvent(event)) {\n                        conversation = await this.getConversation(event.cid, Application.CONVERSATION_API_VERSION.v1);\n                    }\n                    else {\n                        conversation = await this.getConversation(event.cid, Application.CONVERSATION_API_VERSION.v3);\n                    }\n                    this.conversations.set(event.cid, conversation);\n                    await conversation._handleEvent(event);\n                    await this._handleApplicationEvent(event);\n                    if (event.type.startsWith(\"rtc\")) {\n                        rtcEventHandler._handleRtcEvent(event);\n                    }\n                    return Promise.resolve(event);\n                }\n                catch (error) {\n                    this.log.error(error);\n                    return Promise.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Update user's token that was generated when they were first authenticated.\n     * @param {string} token - the new token\n     * @returns {Promise}\n   * @example <caption>listen for expired-token error events and then update the token on Application level</caption>\n   * application.on('system:error:expired-token', 'NXM-errors', (error) => {\n   * \tconsole.log('token expired');\n   * \tapplication.updateToken(token);\n   * });\n  */\n    async updateToken(token) {\n        // SDK can be disconnected because of expired token\n        // this lets us update token for next reconnection attempt\n        if (this.session.connection && this.session.connection.disconnected) {\n            this.session.config.token = token;\n            this.session.connection.io.opts.query.token = token;\n            return Promise.resolve();\n        }\n        const reqObj = {\n            url: `${this.session.config.nexmo_api_url}/v0.2/sessions/${this.session.session_id}`,\n            type: 'PUT',\n            token\n        };\n        try {\n            await utils_1.default.networkRequest(reqObj);\n            if (this.me) {\n                this.session.config.token = token;\n                this.session.connection.io.opts.query.token = token;\n            }\n        }\n        catch (error) {\n            throw (new nexmoClientError_1.NexmoApiError(error));\n        }\n    }\n    /**\n     * Update the event to map local generated events\n     * in case we need a more specific event to pass in the application listener\n     * or f/w the event as it comes\n     * @private\n    */\n    async _handleApplicationEvent(event) {\n        try {\n            this.log.debug(\"_handleApplicationEvent: \", { event });\n            const processed_event = applicationEventsHandler.handleEvent(event);\n            const conversation = this.conversations.get(event.cid);\n            let member;\n            if (conversation.members.has((processed_event || {}).from)) {\n                member = conversation.members.get(processed_event.from);\n            }\n            else if (event.type === 'member:joined' || event.type === 'member:invited') {\n                const params = { ...event.body, ...(event.from && { member_id: event.from }) };\n                member = new member_1.default(conversation, params);\n            }\n            else {\n                try {\n                    member = await conversation.getMember(processed_event.from);\n                }\n                catch (error) {\n                    this.log.warn(`There is an error getting the member ${error}`);\n                }\n            }\n            this.emit(processed_event.type, member, processed_event);\n            return event;\n        }\n        catch (e) {\n            this.log.error(\"_handleApplicationEvent: \", e);\n            throw (e);\n        }\n    }\n    /**\n     * Creates a call to specified user/s.\n     * @classdesc creates a call between the defined users\n     * @param {string[]} usernames - the user names for those we want to call\n     * @returns {Promise<NXMCall>} a NXMCall object with all the call properties\n     * @example <caption>Create a call with users</caption>\n     *  application.on(\"call:status:changed\", (nxmCall) => {\n     *    if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) {\n     *\t\t  console.log('the call has started');\n     *\t\t}\n     *  });\n     *\n     *  application.inAppCall(usernames).then(() => {\n     *    console.log('Calling user(s)...');\n     *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n    */\n    async inAppCall(usernames) {\n        if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params'));\n        }\n        try {\n            const nxmCall = new nxmCall_1.default(this);\n            await nxmCall.createCall(usernames);\n            nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND;\n            return nxmCall;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Creates a call to phone a number.\n     * The call object is created under application.calls when the call has started.\n     * listen for it with application.on(\"call:status:changed\")\n     *\n     * You don't need to start the stream, the SDK will play the audio for you\n     *\n     * @classdesc creates a call to a phone number\n   * @param {string} user the phone number or the username you want to call\n   * @param {string} [type=\"phone\"] the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\")\n   * @param {object} [custom_data] custom data to be included in the call object, i.e. { yourCustomKey: yourCustomValue }\n     * @returns {Promise<NXMCall>}\n     * @example <caption>Create a call to a phone</caption>\n     *  application.on(\"call:status:changed\", (nxmCall) => {\n     *    if (nxmCall.status === nxmCall.CALL_STATUS.STARTED) {\n     *\t\t  console.log('the call has started');\n   *\t\t}\n   *  });\n   *\n     *  application.callServer(phone_number).then((nxmCall) => {\n     *    console.log('Calling phone ' + phone_number);\n   *    console.log('Call Object ': nxmCall);\n     *  }).catch((error) => {\n   *    console.error(error);\n   *  });\n    */\n    async callServer(user, type = 'phone', custom_data = {}) {\n        try {\n            const nxmCall = new nxmCall_1.default(this);\n            nxmCall.direction = nxmCall.CALL_DIRECTION.OUTBOUND;\n            await nxmCall.createServerCall(user, type, custom_data);\n            return nxmCall;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n       * Reconnect a leg to an ongoing call.\n       * You don't need to start the stream, the SDK will play the audio for you\n       *\n       * @classdesc reconnect leg to an ongoing call\n     * @param {string} conversation_id the conversation that you want to reconnect\n     * @param {string} rtc_id the id of the leg that will be reconnected\n     * @param {object} [mediaParams] - MediaStream params (same as Media.enable())\n       * @returns {Promise<NXMCall>}\n       * @example <caption>Reconnect a leg to an ongoing call</caption>\n       *  application.reconnectCall(\"conversation_id\", \"rtc_id\").then((nxmCall) => {\n       *    console.log(nxmCall);\n       *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n     *\n     * @example <caption>Reconnect a leg to an ongoing call without auto playing audio</caption>\n       *  application.reconnectCall(\"conversation_id\", \"rtc_id\", { autoPlayAudio: false }).then((nxmCall) => {\n       *    console.log(nxmCall);\n       *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n     *\n     * @example <caption>Reconnect a leg to an ongoing call choosing device ID</caption>\n       *  application.reconnectCall(\"conversation_id\", \"rtc_id\", { audioConstraints: { deviceId: \"device_id\" } }).then((nxmCall) => {\n       *    console.log(nxmCall);\n       *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n      */\n    async reconnectCall(conversationId, rtcId, mediaParams = {}) {\n        try {\n            if (!conversationId || !rtcId) {\n                throw new nexmoClientError_1.NexmoClientError('error:missing:params');\n            }\n            const conversation = await this.getConversation(conversationId, Application.CONVERSATION_API_VERSION.v1);\n            await conversation.media.enable({ ...mediaParams, reconnectRtcId: rtcId });\n            const nxmCall = new nxmCall_1.default(this, conversation);\n            // assigning the correct call status taking into account the sip status (outbound)\n            // on inbound calls the reconnect will happen after the call is estabilished and both legs are answered\n            const event_types = Array.from(conversation.events.values()).map(event => event.type);\n            if (event_types.includes('sip:answered'))\n                nxmCall.status = nxmCall.CALL_STATUS.ANSWERED;\n            else if (event_types.includes('sip:ringing'))\n                nxmCall.status = nxmCall.CALL_STATUS.RINGING;\n            else\n                nxmCall.status = nxmCall.CALL_STATUS.STARTED;\n            nxmCall.rtcObjects = conversation.media.rtcObjects;\n            this.calls.set(conversation.id, nxmCall);\n            return nxmCall;\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Query the service to create a new conversation\n     * The conversation name must be unique per application.\n     * @param {object} [params] - leave empty to get a GUID as name\n     * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped\n     * @param {string} params.display_name - the display_name of the conversation.\n     * @returns {Promise<Conversation>} - the created Conversation\n     * @example <caption>Create a conversation and join</caption>\n     *  application.newConversation().then((conversation) => {\n     *    //join the created conversation\n     *    conversation.join().then((member) => {\n     *      //Get the user's member belonging in this conversation.\n     *      //You can also access it via conversation.me\n     *      console.log(\"Joined as \" + member.user.name);\n   *    });\n     *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n    */\n    async newConversation(data = {}) {\n        try {\n            const response = await this.session.sendNetworkRequest({\n                type: 'POST',\n                path: 'conversations',\n                data\n            });\n            const conv = new conversation_1.default(this, response);\n            this.conversations.set(conv.id, conv);\n            // do a get conversation to get the whole model as shaped in the service,\n            return this.getConversation(conv.id, Application.CONVERSATION_API_VERSION.v1);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Query the service to create a new conversation and join it\n     * The conversation name must be unique per application.\n     * @param {object} [params] - leave empty to get a GUID as name\n     * @param {string} params.name - the name of the conversation. A UID will be assigned if this is skipped\n     * @param {string} params.display_name - the display_name of the conversation.\n     * @returns {Promise<Conversation>} - the created Conversation\n     * @example <caption>Create a conversation and join</caption>\n     *  application.newConversationAndJoin().then((conversation) => {\n     *    console.log(\"Joined as \" + conversation.me.display_name);\n     *  }).catch((error) => {\n     *    console.error(\"Error creating a conversation and joining \", error);\n     *  });\n    */\n    async newConversationAndJoin(params) {\n        const conversation = await this.newConversation(params);\n        await conversation.join();\n        return conversation;\n    }\n    /**\n     * Query the service to see if this conversation exists with the\n     * logged in user as a member and retrieve the data object\n     * Result added (or updated) in this.conversations\n     *\n     * @param {string} id - the id of the conversation to fetch\n   * @param {string} version=Application.CONVERSATION_API_VERSION.v3 {Application.CONVERSATION_API_VERSION.v1 || Application.CONVERSATION_API_VERSION.v3} - the version of the Conversation Service API to use (v1 includes the full list of the members of the conversation but v3 does not)\n     * @returns {Promise<Conversation>} - the requested conversation\n     * @example <caption>Get a conversation</caption>\n     *  application.getConversation(id).then((conversation) => {\n     *      console.log(\"Retrieved conversation: \", conversation);\n     *  }).catch((error) => {\n     *    console.error(error);\n     *  });\n    */\n    async getConversation(id, version = Application.CONVERSATION_API_VERSION.v3) {\n        if (version !== Application.CONVERSATION_API_VERSION.v1 && version !== Application.CONVERSATION_API_VERSION.v3) {\n            throw new nexmoClientError_1.NexmoClientError('error:conversation-service:version');\n        }\n        let response;\n        if (version === Application.CONVERSATION_API_VERSION.v1) {\n            try {\n                response = await this.session.sendNetworkRequest({\n                    type: 'GET',\n                    path: `conversations/${id}`\n                });\n                response['id'] = response['uuid'];\n                delete response['uuid'];\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n        }\n        else {\n            try {\n                response = await this.session.sendNetworkRequest({\n                    type: 'GET',\n                    path: `conversations/${id}`,\n                    version: 'v0.3'\n                });\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n        }\n        const conversation_object = this.updateOrCreateConversation(response);\n        if (version === Application.CONVERSATION_API_VERSION.v3 && !conversation_object.me) {\n            try {\n                const member = await conversation_object.getMyMember();\n                conversation_object.me = member;\n                conversation_object.members.set(member.id, member);\n            }\n            catch (error) {\n                // add a retry in case of a failure in fetching the member\n                try {\n                    const member = await conversation_object.getMyMember();\n                    conversation_object.me = member;\n                    conversation_object.members.set(member.id, member);\n                }\n                catch (error) {\n                    this.log.warn(`You don't have any membership in ${conversation_object.id}`);\n                }\n            }\n        }\n        if (this.session.config.sync === 'full') {\n            // Populate the events\n            const { items } = await conversation_object.getEvents();\n            conversation_object.events = items;\n            return conversation_object;\n        }\n        else {\n            return conversation_object;\n        }\n    }\n    /**\n     * Query the service to obtain a complete list of conversations of which the\n     * logged-in user is a member with a state of `JOINED` or `INVITED`.\n   * @param {object} params configure defaults for paginated conversations query\n   * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n   * @param {number} params.page_size the number of resources returned in a single request list\n   * @param {string} [params.cursor] string to access the starting point of a dataset\n     *\n     * @returns {Promise<Page<Map<Conversation>>>} - Populate Application.conversations.\n   * @example <caption>Get Conversations</caption>\n   *  application.getConversations({ page_size: 20 }).then((conversations_page) => {\n   *    conversations_page.items.forEach(conversation => {\n   *      render(conversation)\n   *    })\n   *  }).catch((error) => {\n   *      console.error(error);\n   *  });\n   *\n    */\n    async getConversations(params = {}) {\n        const url = `${this.session.config.nexmo_api_url}/beta2/users/${this.me.id}/conversations`;\n        // Create pageConfig if some elements given otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token);\n            response.application = this;\n            const conversations_page = new conversations_page_1.default(response);\n            this.conversations_page_last = conversations_page;\n            return conversations_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Application listening for sync status events.\n     *\n     * @event Application#sync:progress\n     *\n     * @property {number} status.sync_progress - Percentage of fetched conversations\n     * @example <caption>listen for changes in the synchronisation progress events on Application level</caption>\n     *  application.on(\"sync:progress\",(status) => {\n     *\t  console.log(status.sync_progress);\n     *  });\n    */\n    /**\n     * Fetching all the conversations and sync progress events\n    */\n    syncConversations(conversations) {\n        const conversation_array = Array.from(conversations.values());\n        const conversations_length = conversation_array.length;\n        const d = new Date();\n        this.start_sync_time = (typeof window !== 'undefined' && window.performance) ? window.performance.now() : d.getTime();\n        const fetchConversationForStorage = async () => {\n            this.synced_conversations_percentage = Number(((this.synced_conversations_count / conversations_length) * 100).toFixed(2));\n            const status_payload = {\n                sync_progress: this.synced_conversations_percentage\n            };\n            this.emit('sync:progress', status_payload);\n            this.log.info('Loading sync progress: ' + this.synced_conversations_count + '/' +\n                conversations_length + ' - ' + this.synced_conversations_percentage + '%');\n            if (this.synced_conversations_percentage >= 100) {\n                const d = new Date();\n                this.stop_sync_time = (typeof window !== 'undefined' && window.performance) ? window.performance.now() : d.getTime();\n                this.log.info('Loaded conversations in ' + (this.stop_sync_time - this.start_sync_time) + 'ms');\n            }\n            if (this.synced_conversations_count < conversations_length) {\n                await this.getConversation(conversation_array[this.synced_conversations_count].id);\n                fetchConversationForStorage();\n                this.synced_conversations_count++;\n                this.sync_progress_buffer++;\n            }\n        };\n        fetchConversationForStorage();\n    }\n    /**\n     * Get Details of a user by using their id. If no id is present, will return your own user details.\n     * @param {string} id - the id of the user to fetch, if skipped, it returns your own user details\n     * @returns {Promise<User>}\n     * @example <caption>Get User details</caption>\n     *  application.getUser(id).then((user) => {\n     *    console.log('User details: 'user);\n     *  }).catch((error) => {\n     *      console.error(error);\n     *  });\n    */\n    async getUser(user_id = this.me.id) {\n        try {\n            const response = await this.session.sendNetworkRequest({\n                type: 'GET',\n                path: `users/${user_id}`\n            });\n            return new user_1.default(this, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Query the service to obtain a complete list of userSessions of a given user\n   * @param {object} params configure defaults for paginated user sessions query\n   * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n   * @param {number} params.page_size the number of resources returned in a single request list\n   * @param {string} [params.cursor] string to access the starting point of a dataset\n   * @param {string} [params.user_id] the user id that the sessions are being fetched\n     *\n     * @returns {Promise<Page<Map<UserSession>>>}\n   * @example <caption>Get User Sessions</caption>\n   *  application.getUserSessions({ user_id: \"id\", page_size: 20 }).then((user_sessions_page) => {\n   *    user_sessions_page.items.forEach(user_session => {\n   *      render(user_session)\n   *    })\n   *  }).catch((error) => {\n   *      console.error(error);\n   *  });\n   *\n    */\n    async getUserSessions(params = {}) {\n        var _a;\n        const user_id = ((_a = params) === null || _a === void 0 ? void 0 : _a.user_id) || this.me.id;\n        const url = `${this.session.config.nexmo_api_url}/v0.3/users/${user_id}/sessions`;\n        // Create pageConfig if some elements given otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.session.config.token, Application.CONVERSATION_API_VERSION.v3);\n            response.application = this;\n            const user_sessions_page = new user_sessions_page_1.default(response);\n            this.user_sessions_page_last = user_sessions_page;\n            return user_sessions_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n}\nexports.default = Application;\n/**\n * Enum for Application getConversation version.\n * @readonly\n * @enum {string}\n * @alias Application.CONVERSATION_API_VERSION\n*/\nApplication.CONVERSATION_API_VERSION = {\n    v1: 'v0.1',\n    v3: 'v0.3'\n};\nmodule.exports = Application;\n\n},{\"./conversation\":2,\"./handlers/application_events\":7,\"./handlers/events_queue\":9,\"./handlers/rtc_events\":10,\"./handlers/sip_events\":11,\"./member\":13,\"./modules/nxmCall\":16,\"./nexmoClientError\":20,\"./pages/conversations_page\":22,\"./pages/page_config\":26,\"./pages/user_sessions_page\":27,\"./user\":29,\"./utils\":31,\"loglevel\":63,\"wildemitter\":107}],2:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Conversation Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst member_1 = __importDefault(require(\"./member\"));\nconst nxmEvent_1 = __importDefault(require(\"./events/nxmEvent\"));\nconst text_event_1 = __importDefault(require(\"./events/text_event\"));\nconst message_event_1 = __importDefault(require(\"./events/message_event\"));\nconst media_1 = __importDefault(require(\"./modules/media\"));\nconst conversation_events_1 = __importDefault(require(\"./handlers/conversation_events\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst page_config_1 = __importDefault(require(\"./pages/page_config\"));\nconst events_page_1 = __importDefault(require(\"./pages/events_page\"));\nconst members_page_1 = __importDefault(require(\"./pages/members_page\"));\nconst application_1 = __importDefault(require(\"./application\"));\n/**\n * A single conversation Object.\n * @class Conversation\n * @property {Member} me - my Member object that belongs to this conversation\n * @property {Application} application - the parent Application\n * @property {string} name - the name of the Conversation (unique)\n * @property {string} [display_name] - the display_name of the Conversation\n * @property {Map<string, Member>} [members] - the members of the Conversation keyed by a member's id\n * @property {Map<string, NXMEvent>} [events] - the events of the Conversation keyed by an event's id\n * @property {number} [sequence_number] - the last event id\n*/\nclass Conversation {\n    constructor(application, params) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this.id = null;\n        this.name = null;\n        this.display_name = null;\n        this.timestamp = null;\n        this.members = new Map();\n        this.events = new Map();\n        this.sequence_number = 0;\n        this.pageConfig = new page_config_1.default(((this.application.session || {}).config || {}).events_page_config);\n        this.events_page_last = null;\n        this.members_page_last = null;\n        this.conversationEventHandler = new conversation_events_1.default(application, this);\n        this.media = new media_1.default(this);\n        /**\n         * A Member Object representing the current user.\n         * Only set if the user is or has been a member of the Conversation,\n         * otherwise the value will be `null`.\n         * @type Member\n        */\n        this.me = null; // We are not in the conversation ourselves by default\n        // Map the params (which includes the id)\n        this._updateObjectInstance(params);\n        WildEmitter.mixin(Conversation);\n    }\n    /** Update Conversation object params\n     * @property {object} params the params to update\n     * @private\n    */\n    _updateObjectInstance(params) {\n        for (let key in params) {\n            switch (key) {\n                case 'id':\n                    this.id = params.id;\n                    break;\n                case 'name':\n                    this.name = params.name;\n                    break;\n                case 'display_name':\n                    this.display_name = params.display_name;\n                    break;\n                case 'members':\n                    // update the conversation javascript object\n                    params.members.forEach((m) => {\n                        if (this.members.has(m.member_id)) {\n                            this.members.get(m.member_id)._normalise(m);\n                            if (m.user_id === this.application.me.id && m.state !== 'LEFT') {\n                                this.me = this.members.get(m.member_id);\n                                this.members.set(this.me.id, this.me);\n                            }\n                        }\n                        else {\n                            const member = new member_1.default(this, m);\n                            if (m.user_id === this.application.me.id && m.state !== 'LEFT') {\n                                this.me = member;\n                            }\n                            this.members.set(member.id, member);\n                        }\n                    });\n                    break;\n                case 'timestamp':\n                    this.timestamp = params.timestamp;\n                    break;\n                case 'sequence_number':\n                    this.sequence_number = params.sequence_number;\n                    break;\n                case 'member_id':\n                    // filter needed params to create the object\n                    // the conversation list gives us the member_id to prepare the member/this object\n                    const object_params = {\n                        id: params.member_id,\n                        state: params.state,\n                        user: this.application.me\n                    };\n                    // update the member object or create a new instance\n                    if (this.members.has(params.member_id)) {\n                        const member_object = this.members.get(params.member_id);\n                        Object.assign(member_object, object_params);\n                    }\n                    else {\n                        const member = new member_1.default(this, object_params);\n                        this.me = member;\n                        this.members.set(member.id, member);\n                    }\n                    break;\n            }\n        }\n    }\n    /**\n     * Join the given User to this Conversation. Will typically be used this to join\n     * ourselves to a Conversation we create.\n     * Accept an invitation if our Member has state INVITED and no user_id / user_name is given\n     *\n     * @param {object} [params = this.application.me.id] The User to join (defaults to this)\n     * @param {string} params.user_name the user_name of the User to join\n     * @param {string} params.user_id the user_id of the User to join\n     * @returns {Promise<Member>}\n     *\n     * @example <caption>join a user to the Conversation</caption>\n     *\n     * conversation.join().then((member) => {\n     *  console.log(\"joined as member: \", member)\n     * }).catch((error) => {\n     *  console.error(\"error joining conversation \", error);\n     * });\n    */\n    async join(params) {\n        var _a, _b;\n        try {\n            let data = {\n                state: 'joined',\n                channel: {\n                    type: 'app'\n                },\n                user: {\n                    ...(!params && { name: this.application.me.name, id: this.application.me.id }),\n                    ...(params && params.user_name && { name: params.user_name }),\n                    ...(params && params.user_id && { id: params.user_id }),\n                },\n            };\n            if (((_a = this === null || this === void 0 ? void 0 : this.me) === null || _a === void 0 ? void 0 : _a.id) && ((_b = this === null || this === void 0 ? void 0 : this.me) === null || _b === void 0 ? void 0 : _b.state) !== 'LEFT') {\n                data[\"from\"] = this.me.id;\n            }\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/members`,\n                version: 'v0.3',\n                data\n            });\n            const member = new member_1.default(this, response);\n            if (response._embedded.user.id === this.application.me.id) {\n                this.me = member;\n                this.members.set(member.id, member);\n            }\n            // use case where between the time we got the conversation and the time we finished joining\n            // the conversation object changed.\n            this.application.getConversation(this.id, application_1.default.CONVERSATION_API_VERSION.v3);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Delete a conversation\n     * @returns {Promise}\n     * @example <caption>delete the Conversation</caption>\n     *\n     * conversation.del().then(() => {\n     *    console.log(\"conversation deleted\");\n     * }).catch((error) => {\n     *  console.error(\"error deleting conversation \", error);\n     * });\n    */\n    async del() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'DELETE',\n                path: `conversations/${this.id}`\n            });\n            this.application.conversations.delete(this.id);\n            return response;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Delete an NXMEvent (e.g. Text)\n     * @param {NXMEvent} event\n     * @returns {Promise}\n     * @example <caption>delete an Event</caption>\n     *\n     * conversation.deleteEvent(eventToBeDeleted).then(() => {\n     *  console.log(\"event was deleted\");\n     * }).catch((error) => {\n     *  console.error(\"error deleting the event \", error);\n     * });\n     *\n    */\n    deleteEvent(event) {\n        return event.del();\n    }\n    /**\n      * Invite the given user (id or name) to this conversation\n      * @param {Member} params\n      * @param {string} [params.id or user_name] - the id or the username of the User to invite\n      *\n      * @returns {Promise<Member>}\n      *\n      * @example <caption>invite a user to a Conversation</caption>\n      * const user_id = 'id of User to invite';\n      * const user_name = 'username of User to invite';\n      *\n      * conversation.invite({\n      *  id: user_id,\n      *  user_name: user_name\n      * }).then((member) => {\n      *  displayMessage(member.state + \" user: \" + user_id + \" \" + user_name);\n      * }).catch((error) => {\n      *  console.error(\"error inviting user \", error);\n      * });\n      *\n    */\n    async invite(params) {\n        var _a, _b;\n        if (!params || (!params.id && !params.user_name)) {\n            throw new nexmoClientError_1.NexmoClientError('error:invite:missing:params');\n        }\n        const data = {\n            state: 'invited',\n            user: {\n                ...(params.id && { id: params.id }),\n                ...(params.user_name && { name: params.user_name })\n            },\n            media: params.media,\n            channel: {\n                from: {\n                    type: 'app'\n                },\n                to: {\n                    type: 'app'\n                },\n                type: 'app'\n            }\n        };\n        if (((_a = this === null || this === void 0 ? void 0 : this.me) === null || _a === void 0 ? void 0 : _a.id) && ((_b = this === null || this === void 0 ? void 0 : this.me) === null || _b === void 0 ? void 0 : _b.state) !== 'LEFT') {\n            data[\"from\"] = this.me.id;\n        }\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/members`,\n                version: 'v0.3',\n                data\n            });\n            const member = new member_1.default(this, response);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Invite the given user (id or name) to this conversation with media audio\n      * @param {Member} params\n      * @param {string} [params.id or user_name] - the id or the username of the User to invite\n      *\n      * @returns {Promise<Member>}\n      *\n      * @example <caption>invite a user to a conversation</caption>\n      * const user_id = 'id of User to invite';\n      * const user_name = 'username of User to invite';\n      *\n      * conversation.inviteWithAudio({\n      *  id: user_id,\n      *  user_name: user_name\n      * }).then((member) => {\n      *  displayMessage(member.state + \" user: \" + user_id + \" \" + user_name);\n      * }).catch((error) => {\n      *  console.error(\"error inviting user \", error);\n      * });\n      *\n    */\n    inviteWithAudio(params) {\n        if (!params || (!params.id && !params.user_name)) {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:invite:missing:params'));\n        }\n        params.media = {\n            audio_settings: {\n                enabled: true,\n                muted: false,\n                earmuffed: false\n            }\n        };\n        return this.invite(params);\n    }\n    /**\n     * Leave from the Conversation\n     * @param {object} [reason] the reason for leaving the conversation\n     * @param {string} [reason.reason_code] the code of the reason\n     * @param {string} [reason.reason_text] the description of the reason\n     * @returns {Promise}\n     * @example <caption>leave the Conversation</caption>\n     *\n     * conversation.leave({reason_code: \"mycode\", reason_text: \"my reason for leaving\"}).then(() => {\n     *  console.log(\"successfully left conversation\");\n     * }).catch((error) => {\n     *  console.error(\"error leaving conversation \", error);\n     * });\n     *\n    */\n    leave(reason) {\n        return this.me.kick(reason);\n    }\n    /**\n      * Send a text message to the conversation, which will be relayed to every other member of the conversation\n      * @param {string} text - the text message to be sent\n      *\n      * @returns {Promise<TextEvent>} - the text message that was sent\n      *\n      * @example <caption> sending a text </caption>\n      * conversation.sendText(\"Hi Vonage\").then((event) => {\n      *  console.log(\"message was sent\", event);\n      * }).catch((error)=>{\n      *  console.error(\"error sending the message \", error);\n      * });\n      *\n      * @deprecated since version 8.3.0\n      *\n    */\n    async sendText(text) {\n        try {\n            if (this.me === null) {\n                throw new nexmoClientError_1.NexmoClientError('error:self');\n            }\n            const msg = {\n                type: 'text',\n                cid: this.id,\n                from: this.me.id,\n                body: {\n                    text\n                }\n            };\n            const { id, timestamp } = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data: msg\n            });\n            msg.id = id;\n            msg.body.timestamp = timestamp;\n            return new text_event_1.default(this, msg);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Send a custom event to the Conversation\n      * @param {object} params - params of the custom event\n      * @param {string} params.type the name of the custom event. Must not exceed 100 char length and contain only alpha numerics and '-' and '_' characters.\n      * @param {object} params.body customizable key value pairs\n      *\n      * @returns {Promise<NXMEvent>} - the custom event that was sent\n      *\n      * @example <caption> sending a custom event </caption>\n      * conversation.sendCustomEvent({ type: \"my-event\", body: { mykey: \"my value\" }}).then((event) => {\n      *  console.log(\"custom event was sent\", event);\n      * }).catch((error)=>{\n      *  console.error(\"error sending the custom event\", error);\n      * });\n      *\n    */\n    async sendCustomEvent({ type, body }) {\n        try {\n            if (this.me === null) {\n                throw new nexmoClientError_1.NexmoClientError('error:self');\n            }\n            else if (!type || typeof type !== 'string' || type.length < 1) {\n                throw new nexmoClientError_1.NexmoClientError('error:custom-event:invalid');\n            }\n            const data = {\n                type: `custom:${type}`,\n                cid: this.id,\n                from: this.me.id,\n                body\n            };\n            const { id, timestamp } = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data\n            });\n            data.id = id;\n            data.timestamp = timestamp;\n            return new nxmEvent_1.default(this, data);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Uploads an Image to Media Service.\n     * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest\n     *\n     * @param {File} file single input file (jpeg/jpg)\n     * @param {object} params - params of image sent\n     * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image\n     * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     * @param {string} [params.thumbnail_size_ratio = 30] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     *\n     * @returns {Promise<XMLHttpRequest>}\n     *\n     * @example <caption>uploading an image</caption>\n     * const params = {\n     *  quality_ratio : \"90\",\n     *  medium_size_ratio: \"40\",\n     *  thumbnail_size_ratio: \"20\"\n     * }\n     * conversation.uploadImage(fileInput.files[0], params).then((uploadImageRequest) => {\n     *  uploadImageRequest.onprogress = (e) => {\n     *    console.log(\"Image request progress: \", e);\n     *    console.log(\"Image progress: \" + e.loaded + \"/\" + e.total);\n     *  };\n     *  uploadImageRequest.onabort = (e) => {\n     *    console.log(\"Image request aborted: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     *  uploadImageRequest.onloadend = (e) => {\n     *    console.log(\"Image request successful: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     *  uploadImageRequest.onreadystatechange = () => {\n     *    if (uploadImageRequest.readyState === 4 && uploadImageRequest.status === 200) {\n     *      const representations = JSON.parse(uploadImageRequest.responseText);\n     *      console.log(\"Original image url: \", representations.original.url);\n     *      console.log(\"Medium image url: \", representations.medium.url);\n     *      console.log(\"Thumbnail image url: \", representations.thumbnail.url);\n     *    }\n     *  };\n     * }).catch((error) => {\n     *    console.error(\"error uploading the image \", error);\n     * });\n    */\n    async uploadImage(fileInput, params = {\n        quality_ratio: '100',\n        medium_size_ratio: '50',\n        thumbnail_size_ratio: '30'\n    }) {\n        const formData = new FormData();\n        formData.append('file', fileInput);\n        formData.append('quality_ratio', params.quality_ratio);\n        formData.append('medium_size_ratio', params.medium_size_ratio);\n        formData.append('thumbnail_size_ratio', params.thumbnail_size_ratio);\n        const imageRequest = await utils_1.default.networkRequest({\n            type: 'POST',\n            url: this.application.session.config.ips_url,\n            data: formData,\n            token: this.application.session.config.token\n        });\n        imageRequest.upload.addEventListener('progress', (evt) => {\n            if (evt.lengthComputable) {\n                this.log.debug('uploading image ' + evt.loaded + '/' + evt.total);\n            }\n        }, false);\n        imageRequest.onreadystatechange = () => {\n            if (imageRequest.status !== 200) {\n                this.log.error(imageRequest);\n            }\n        };\n        return imageRequest;\n    }\n    /**\n     * Send an Image message to the conversation, which will be relayed to every other member of the conversation.\n     * implements xhr (https://xhr.spec.whatwg.org/) - this.imageRequest\n     *\n     * @param {File} file single input file (jpeg/jpg)\n     * @param {object} params - params of image sent\n     * @param {string} [params.quality_ratio = 100] a value between 0 and 100. 0 indicates 'maximum compression' and the lowest quality, 100 will result in the highest quality image\n     * @param {string} [params.medium_size_ratio = 50] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     * @param {string} [params.thumbnail_size_ratio = 30] a value between 1 and 100. 1 indicates the new image is 1% of original, 100 - same size as original\n     *\n     * @returns {Promise<XMLHttpRequest>}\n     *\n     * @example <caption>sending an image</caption>\n     * const params = {\n     *  quality_ratio : \"90\",\n     *  medium_size_ratio: \"40\",\n     *  thumbnail_size_ratio: \"20\"\n     * }\n     * conversation.sendImage(fileInput.files[0], params).then((imageRequest) => {\n     *  imageRequest.onprogress = (e) => {\n     *    console.log(\"Image request progress: \", e);\n     *    console.log(\"Image progress: \" + e.loaded + \"/\" + e.total);\n     *  };\n     *  imageRequest.onabort = (e) => {\n     *    console.log(\"Image request aborted: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     *  imageRequest.onloadend = (e) => {\n     *    console.log(\"Image request successful: \", e);\n     *    console.log(\"Image: \" + e.type);\n     *  };\n     * }).catch((error) => {\n     *  console.error(\"error sending the image \", error);\n     * });\n     *\n     * @deprecated since version 8.3.0\n    */\n    async sendImage(fileInput, params = {\n        quality_ratio: '100',\n        medium_size_ratio: '50',\n        thumbnail_size_ratio: '30'\n    }) {\n        const imageRequest = await this.uploadImage(fileInput, params);\n        imageRequest.onreadystatechange = () => {\n            if (imageRequest.readyState === 4 && imageRequest.status === 200) {\n                try {\n                    this.application.session.sendNetworkRequest({\n                        type: 'POST',\n                        path: `conversations/${this.id}/events`,\n                        data: {\n                            type: 'image',\n                            from: this.me.id,\n                            body: {\n                                representations: JSON.parse(imageRequest.responseText)\n                            }\n                        }\n                    });\n                    this.log.info(imageRequest);\n                }\n                catch (error) {\n                    this.log.error(new nexmoClientError_1.NexmoApiError(error));\n                }\n            }\n        };\n        return imageRequest;\n    }\n    /**\n     * Cancel uploading or sending an Image message to the conversation.\n     *\n     * @param {XMLHttpRequest} imageRequest\n     *\n     * @returns void\n     *\n     * @example <caption>cancel sending an image</caption>\n     * conversation.sendImage(fileInput.files[0]).then((imageRequest) => {\n     *    conversation.abortSendImage(imageRequest);\n   * }).catch((error) => {\n   *    console.error(\"error sending the image \", error);\n     * });\n   *\n   * @example <caption>cancel uploading an image</caption>\n     * conversation.uploadImage(fileInput.files[0]).then((imageRequest) => {\n     *    conversation.abortSendImage(imageRequest);\n   * }).catch((error) => {\n   *    console.error(\"error uploading the image \", error);\n     * });\n    */\n    abortSendImage(imageRequest) {\n        if (imageRequest instanceof XMLHttpRequest) {\n            return imageRequest.abort();\n        }\n        else {\n            return new nexmoClientError_1.NexmoClientError('error:invalid:param:type');\n        }\n    }\n    /**\n      * Send a message event to the conversation, which will be relayed to every other member of the conversation\n      *\n      * @param {object} params the content of the message you want sent\n      * @param {string} params.message_type the type of the message. It should be one of 'text', 'image', 'audio', 'video', 'file'\n      * @param {string} [params.text] the text content when message type is 'text\n      * @param {object} [params.image]\n      * @param {string} params.image.url the image url when message type is 'image'\n      * @param {object} [params.audio]\n      * @param {string} params.audio.url the audio url when message type is 'audio'\n      * @param {object} [params.video]\n      * @param {string} params.video.url the video url when message type is 'video'\n      * @param {object} [params.file]\n      * @param {string} params.file.url the file url when message type is 'file'\n      *\n      * @returns {Promise<MessageEvent>} - the message that was sent\n      *\n      * @example <caption> sending a message </caption>\n      * conversation.sendMessage({ \"message_type\": \"text\", \"text\": \"Hi Vonage!\" }).then((event) => {\n      *  console.log(\"message was sent\", event);\n      * }).catch((error)=>{\n      *  console.error(\"error sending the message \", error);\n      * });\n      *\n    */\n    async sendMessage(params) {\n        if (this.me === null) {\n            throw new nexmoClientError_1.NexmoClientError('error:self');\n        }\n        else if (!(params === null || params === void 0 ? void 0 : params.message_type)) {\n            throw new nexmoClientError_1.NexmoClientError('error:message-event:invalid');\n        }\n        try {\n            const msg = {\n                type: 'message',\n                cid: this.id,\n                from: this.me.id,\n                body: {\n                    ...params\n                }\n            };\n            const { id, timestamp } = await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data: msg\n            });\n            msg.id = id;\n            msg.body.timestamp = timestamp;\n            return new message_event_1.default(this, msg);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    async _typing(state) {\n        const params = {\n            activity: (state === 'on') ? 1 : 0\n        };\n        const data = {\n            type: 'text:typing:' + state,\n            cid: this.id,\n            from: this.me.id,\n            body: params\n        };\n        try {\n            await this.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data\n            });\n            return `text:typing:${state}:success`;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send start typing indication\n     *\n     * @returns {Promise} - resolves the promise on successful sent\n     *\n     * @example <caption>send start typing event when key is pressed</caption>\n     * messageTextarea.addEventListener('keypress', (event) => {\n     *    conversation.startTyping();\n     * });\n    */\n    startTyping() {\n        return this._typing('on');\n    }\n    /**\n     * Send stop typing indication\n     *\n     * @returns {Promise} - resolves the promise on successful sent\n     *\n     * @example <caption>send stop typing event when a key has not been pressed for half a second</caption>\n     * let timeout = null;\n     * messageTextarea.addEventListener('keyup', (event) => {\n     *    clearTimeout(timeout);\n     *    timeout = setTimeout(() => {\n     *      conversation.stopTyping();\n     *    }, 500);\n     * });\n    */\n    stopTyping() {\n        return this._typing('off');\n    }\n    /**\n      * Query the service to get a list of events in this conversation.\n      *\n      * @param {object} params configure defaults for paginated events query\n      * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n      * @param {number} params.page_size the number of resources returned in a single request list\n      * @param {string} [params.cursor] string to access the starting point of a dataset\n      * @param {string} [params.event_type] the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*'\n      *\n      * @returns {Promise<EventsPage<Map<Events>>>} - Populate Conversations.events.\n      * @example <caption>Get Events</caption>\n      * conversation.getEvents({ event_type: 'member:*' }).then((events_page) => {\n      *   events_page.items.forEach(event => {\n      *     render(event)\n      *   })\n      * }).catch((error) => {\n      *  console.error(\"error getting the events \", error);\n      * });\n    */\n    async getEvents(params = {}) {\n        const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/events`;\n        // Create pageConfig if given params otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token);\n            response.application = this.application;\n            response.conversation = this;\n            const events_page = new events_page_1.default(response);\n            this.events_page_last = events_page;\n            return events_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Query the service to get a list of members in this conversation.\n      *\n      * @param {object} params configure defaults for paginated events query\n      * @param {string} params.order 'asc' or 'desc' ordering of resources based on creation time\n      * @param {number} params.page_size the number of resources returned in a single request list\n      * @param {string} [params.cursor] string to access the starting point of a dataset\n      *\n      * @returns {Promise<MembersPage<Map<Member>>>}\n      * @example <caption>Get Members</caption>\n      * const params = {\n      *   order: \"desc\",\n      *   page_size: 100\n      * }\n      * conversation.getMembers(params).then((members_page) => {\n      *   members_page.items.forEach(member => {\n      *     render(member)\n      *   })\n      * }).catch((error) => {\n      *  console.error(\"error getting the members \", error);\n      * });\n    */\n    async getMembers(params = {}) {\n        const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.id}/members`;\n        // Create pageConfig if given params otherwise use default\n        let pageConfig = Object.keys(params).length === 0 ? this.pageConfig : new page_config_1.default(params);\n        try {\n            const response = await utils_1.default.paginationRequest(url, pageConfig, this.application.session.config.token);\n            response.application = this.application;\n            response.conversation = this;\n            const members_page = new members_page_1.default(response);\n            this.members_page_last = members_page;\n            return members_page;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Query the service to get my member in this conversation.\n      *\n      * @returns {Promise<Member>}\n      * @example <caption>Get My Member</caption>\n      * conversation.getMyMember().then((member) => {\n      *   render(member)\n      * }).catch((error) => {\n      *  console.error(\"error getting my member\", error);\n      * });\n    */\n    async getMyMember() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'GET',\n                path: `conversations/${this.id}/members/me`,\n                version: 'v0.3'\n            });\n            const member = new member_1.default(this, response);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n      * Query the service to get a member in this conversation.\n      *\n      * @param {string} member_id the id of the member to return\n      *\n      * @returns {Promise<Member>}\n      * @example <caption>Get Member</caption>\n      * conversation.getMember(\"MEM-id\").then((member) => {\n      *   render(member)\n      * }).catch((error) => {\n      *  console.error(\"error getting member\", error);\n      * });\n    */\n    async getMember(member_id) {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: 'GET',\n                path: `conversations/${this.id}/members/${member_id}`,\n                version: 'v0.3'\n            });\n            const member = new member_1.default(this, response);\n            return member;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Handle and event from the cloud.\n     * using conversationEventHandler\n     * @param {object} event\n     * @private\n    */\n    _handleEvent(event) {\n        var _a, _b;\n        if (event.type.startsWith('rtc')) {\n            // keep the rtc events going to the application layer, we use them in media module\n            this.emit(event.type, event);\n            return Promise.resolve(event);\n        }\n        this.sequence_number++;\n        // make sure the event_id is not a string\n        if (event.body && event.body.event_id && typeof event.body.event_id === 'string') {\n            event.body.event_id = parseInt(event.body.event_id);\n        }\n        let memberInfo = { memberId: event.from };\n        if ((_a = event === null || event === void 0 ? void 0 : event.body) === null || _a === void 0 ? void 0 : _a.user) {\n            const { id, name, display_name, image_url, custom_data } = event.body.user;\n            memberInfo = { ...memberInfo, ...{\n                    ...(id && { userId: id }),\n                    ...(name && { userName: name }),\n                    ...(display_name && { displayName: display_name }),\n                    ...(image_url && { imageUrl: image_url }),\n                    ...(custom_data && { customData: custom_data })\n                } };\n        }\n        else if ((_b = event === null || event === void 0 ? void 0 : event._embedded) === null || _b === void 0 ? void 0 : _b.from_user) {\n            const { id, name, display_name, image_url, custom_data } = event._embedded.from_user;\n            memberInfo = { ...memberInfo, ...{\n                    ...(id && { userId: id }),\n                    ...(name && { userName: name }),\n                    ...(display_name && { displayName: display_name }),\n                    ...(image_url && { imageUrl: image_url }),\n                    ...(custom_data && { customData: custom_data })\n                } };\n        }\n        let constructed_event = this.conversationEventHandler.handleEvent(event);\n        // Unless they are typing events, add the event to the conversation.events map\n        if (!['text:typing:on', 'text:typing:off'].includes(event.type)) {\n            this.events.set(constructed_event.id, constructed_event);\n        }\n        // For custom events remove the custom: prefix before emitting event\n        if (event.type.startsWith('custom:')) {\n            this.emit(constructed_event.type, memberInfo, constructed_event);\n            return Promise.resolve(event);\n        }\n        this.emit(event.type, memberInfo, constructed_event);\n        return Promise.resolve(event);\n    }\n}\nexports.default = Conversation;\nmodule.exports = Conversation;\n\n},{\"./application\":1,\"./events/message_event\":4,\"./events/nxmEvent\":5,\"./events/text_event\":6,\"./handlers/conversation_events\":8,\"./member\":13,\"./modules/media\":15,\"./nexmoClientError\":20,\"./pages/events_page\":23,\"./pages/members_page\":24,\"./pages/page_config\":26,\"./utils\":31,\"loglevel\":63,\"wildemitter\":107}],3:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  ImageEvent Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst loglevel_1 = require(\"loglevel\");\nconst nxmEvent_1 = __importDefault(require(\"./nxmEvent\"));\n/**\n * An image event\n *\n * @class ImageEvent\n * @extends NXMEvent\n*/\nclass ImageEvent extends nxmEvent_1.default {\n    constructor(conversation, params) {\n        super(conversation, params);\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.type = 'image';\n        this.conversation = conversation;\n        this.state = {\n            seen_by: {},\n            delivered_to: {}\n        };\n        if (params && params.body && params.body.timestamp) {\n            this.timestamp = params.body.timestamp;\n        }\n        Object.assign(this, params);\n    }\n    /**\n     * Set the imageEvent status to 'seen'\n     * @returns {Promise}\n     * @example <caption>Set the imageEvent status to 'seen'</caption>\n     *  imageEvent.seen().then(() => {\n     *    console.log(\"image event status set to seen\");\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error setting image event status to seen \", error);\n     *  });\n     */\n    seen() {\n        return super.seen();\n    }\n    /**\n     * Set the imageEvent status to 'delivered'\n     * @returns {Promise}\n     * @example <caption>Set the imageEvent status to 'delivered'</caption>\n     *  imageEvent.delivered().then(() => {\n     *    console.log(\"image event status set to delivered\");\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error setting image event status to delivered  \", error);\n     *  });\n     */\n    delivered() {\n        return super.delivered();\n    }\n    /**\n     * Delete the image event, all 3 representations of it\n     * passing only the one of the three URLs\n     * @returns {Promise}\n     * @example <caption>Delete the imageEvent</caption>\n     *  imageEvent.del().then(() => {\n     *    console.log(\"image event deleted\");\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error deleting image event  \", error);\n     *  });\n     */\n    async del() {\n        await utils_1.default.networkRequest({\n            type: 'DELETE',\n            url: this.body.representations.original.url,\n            token: this.conversation.application.session.config.token\n        });\n        return super.del();\n    }\n    /**\n     * Download an Image from Media service //3 representations\n     * @param {string} [type=\"thumbnail\"] original, medium, or thumbnail\n     * @param {string} [representations=this.body.representations]  the ImageEvent.body for the image to download\n     * @returns {string} the dataUrl \"data:image/jpeg;base64...\"\n     * @example <caption>Downloading an image from the imageEvent</caption>\n     *  imageEvent.fetchImage(\"medium\").then((imageData) => {\n     *    const img = new Image();\n     *    img.src = imageData;\n     *    document.body.appendChild(img);\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error getting image \", error);\n     *  });\n    */\n    async fetchImage(type = 'thumbnail', imageRepresentations = this.body.representations) {\n        try {\n            return utils_1.default._fetchImage(imageRepresentations[type].url, this.conversation.application.session.config.token);\n        }\n        catch (error) {\n            this.log.error(error);\n            throw error;\n        }\n    }\n}\nexports.default = ImageEvent;\nmodule.exports = ImageEvent;\n\n},{\"../utils\":31,\"./nxmEvent\":5,\"loglevel\":63}],4:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Message NXMEvent Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst loglevel_1 = require(\"loglevel\");\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst nxmEvent_1 = __importDefault(require(\"./nxmEvent\"));\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\n/**\n * A message event\n *\n * @class MessageEvent\n * @extends NXMEvent\n*/\nclass MessageEvent extends nxmEvent_1.default {\n    constructor(conversation, params) {\n        super(conversation, params);\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.type = 'message';\n        this.conversation = conversation;\n        this.state = {\n            seen_by: {},\n            delivered_to: {},\n            submitted_to: {},\n            rejected_by: {},\n            undeliverable_to: {}\n        };\n        if (params && params.body && params.body.timestamp) {\n            this.timestamp = params.body.timestamp;\n        }\n        Object.assign(this, params);\n    }\n    /**\n     * Set the messageEvent status to 'seen'\n     * @returns {Promise}\n     * @example <caption>Set the messageEvent status to 'seen'</caption>\n     *  messageEvent.seen().then(() => {\n     *    console.log(\"message event status set to seen\");\n     *  }).catch((error)=>{\n     *\t  console.log(\"error setting message event status to seen \", error);\n     *  });\n     */\n    seen() {\n        return super.seen();\n    }\n    /**\n     * Set the messageEvent status to 'delivered'.\n     * handled by the SDK\n     * @returns {Promise}\n     * @example <caption>Set the messageEvent status to 'delivered'</caption>\n     *  messageEvent.delivered().then(() => {\n     *    console.log(\"message event status set to delivered\");\n     *  }).catch((error)=>{\n     *\t  console.log(\"error setting message event status to delivered  \", error);\n     *  });\n     */\n    delivered() {\n        return super.delivered();\n    }\n    /**\n     * Delete the messageEvent\n     * @returns {Promise}\n     * @example <caption>Delete the messageEvent</caption>\n     *  messageEvent.del().then(() => {\n     *    console.log(\"message event deleted\");\n     *  }).catch((error)=>{\n     *\t  console.log(\"error deleting message event  \", error);\n     *  });\n     */\n    del() {\n        return super.del();\n    }\n    /**\n     * Download an Image from Media service\n     * @returns {string} the dataUrl \"data:image/jpeg;base64...\"\n     * @example <caption>Downloading an image from the messageEvent</caption>\n     *  messageEvent.fetchImage().then((imageData) => {\n     *    const img = new Image();\n     *    img.src = imageData;\n     *    document.body.appendChild(img);\n     *  }).catch((error) => {\n     *    console.log(\"error getting image \", error);\n     *  });\n    */\n    async fetchImage() {\n        if (this.body.message_type !== \"image\") {\n            throw new nexmoClientError_1.NexmoClientError('error:message-event:invalid');\n        }\n        try {\n            return utils_1.default._fetchImage(this.body.image.url, this.conversation.application.session.config.token);\n        }\n        catch (error) {\n            this.log.error(error);\n            throw error;\n        }\n    }\n}\nexports.default = MessageEvent;\nmodule.exports = MessageEvent;\n\n},{\"../nexmoClientError\":20,\"../utils\":31,\"./nxmEvent\":5,\"loglevel\":63}],5:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  NXMEvent Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\n/**\n * Conversation NXMEvent Object.\n * The super class that holds the base events that apply to\n * common event objects.\n * @class NXMEvent\n */\nclass NXMEvent {\n    constructor(conversation, params) {\n        var _a, _b, _c, _d;\n        this.conversation = conversation;\n        if (params) {\n            for (const key in params) {\n                switch (key) {\n                    case 'type':\n                        if (params.type.startsWith('custom:')) {\n                            this.type = params.type.replace('custom:', '');\n                        }\n                        else {\n                            this.type = params.type;\n                        }\n                        break;\n                    case 'application_id':\n                        this.application_id = params.application_id;\n                        break;\n                    case 'cid':\n                        this.cid = params.cid;\n                        break;\n                    case 'from':\n                        if (['member:invited', 'member:joined', 'member:left'].indexOf(params.type) > -1) {\n                            if ((_b = (_a = params._embedded) === null || _a === void 0 ? void 0 : _a.from_member) === null || _b === void 0 ? void 0 : _b.id) {\n                                this.from = (_d = (_c = params._embedded) === null || _c === void 0 ? void 0 : _c.from_member) === null || _d === void 0 ? void 0 : _d.id;\n                            }\n                        }\n                        else {\n                            this.from = params.from;\n                        }\n                        break;\n                    case 'timestamp':\n                        this.timestamp = params.timestamp;\n                        break;\n                    case 'id':\n                        this.id = params.id;\n                        break;\n                    case 'state':\n                        this.state = params.state;\n                        break;\n                    case 'index':\n                        this.index = params.index;\n                        break;\n                    case 'streamIndex':\n                        this.streamIndex = params.streamIndex;\n                        break;\n                    case 'body':\n                        this.body = params.body;\n                        if (this.body.user && this.body.user.user_id) {\n                            this.body.user.id = this.body.user.user_id;\n                            delete this.body.user.user_id;\n                        }\n                        if (this.body.digit) {\n                            this.digit = this.body.digit;\n                            delete this.body.digit;\n                        }\n                        if (this.body.digits) {\n                            this.digit = this.body.digits;\n                            delete this.body.digits;\n                        }\n                        break;\n                }\n            }\n        }\n        WildEmitter.mixin(NXMEvent);\n    }\n    /**\n     * Delete the event\n     * @param {number} [event_id=this.event_id] if the event id param is not present, \"this\" event will be default\n     * @returns {Promise}\n     * @private\n    */\n    async del(event_id = this.id) {\n        try {\n            await this.conversation.application.session.sendNetworkRequest({\n                type: 'DELETE',\n                path: `conversations/${this.conversation.id}/events/${event_id}?from=${this.conversation.me.id}`,\n                version: 'beta2'\n            });\n            return;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Mark as Delivered the event\n     * @param {number} [event_id=this.event_id] if the event id is not provided, the this event will be used\n     * @returns {Promise}\n     * @private\n     */\n    async delivered(event_id = this.id) {\n        if (this.type !== 'text' && this.type !== 'image' && this.type !== 'message') {\n            this.type = 'event';\n        }\n        if (this.conversation.me.id === this.from) {\n            throw new nexmoClientError_1.NexmoClientError('error:delivered:own-message');\n        }\n        else if (this.state && this.state.delivered_to && this.state.delivered_to[this.conversation.me.id]) {\n            throw new nexmoClientError_1.NexmoClientError('error:already-delivered');\n        }\n        else {\n            try {\n                await this.conversation.application.session.sendNetworkRequest({\n                    type: 'POST',\n                    path: `conversations/${this.conversation.id}/events`,\n                    data: {\n                        type: `${this.type}:delivered`,\n                        from: this.conversation.me.id,\n                        body: {\n                            event_id\n                        }\n                    }\n                });\n                return;\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n        }\n    }\n    /**\n     * Mark as Seen the event\n     * @param {number} [event_id=this.event_id] if the event id is not provided, the this event will be used\n     * @returns {Promise}\n     * @private\n    */\n    async seen(event_id = this.id) {\n        if (this.type !== 'text' && this.type !== 'image' && this.type !== 'message') {\n            this.type = 'event';\n        }\n        if (this.conversation.me.id === this.from) {\n            throw new nexmoClientError_1.NexmoClientError('error:seen:own-message');\n        }\n        else if (this.state && this.state.seen_by && this.state.seen_by[this.conversation.me.id]) {\n            throw new nexmoClientError_1.NexmoClientError('error:already-seen');\n        }\n        else {\n            try {\n                await this.conversation.application.session.sendNetworkRequest({\n                    type: 'POST',\n                    path: `conversations/${this.conversation.id}/events`,\n                    data: {\n                        type: `${this.type}:seen`,\n                        from: this.conversation.me.id,\n                        body: {\n                            event_id\n                        }\n                    }\n                });\n                return;\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n        }\n    }\n}\nexports.default = NXMEvent;\nmodule.exports = NXMEvent;\n\n},{\"../nexmoClientError\":20,\"wildemitter\":107}],6:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Text NXMEvent Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst nxmEvent_1 = __importDefault(require(\"./nxmEvent\"));\n/**\n * A text event\n *\n * @class TextEvent\n * @extends NXMEvent\n*/\nclass TextEvent extends nxmEvent_1.default {\n    constructor(conversation, params) {\n        super(conversation, params);\n        this.type = 'text';\n        this.conversation = conversation;\n        this.state = {\n            seen_by: {},\n            delivered_to: {}\n        };\n        if (params && params.body && params.body.timestamp) {\n            this.timestamp = params.body.timestamp;\n        }\n        Object.assign(this, params);\n    }\n    /**\n     * Set the textEvent status to 'seen'\n     * @returns {Promise}\n     * @example <caption>Set the textEvent status to 'seen'</caption>\n     *  textEvent.seen().then(() => {\n     *    console.log(\"text event status set to seen\");\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error setting text event status to seen \", error);\n     *  });\n     */\n    seen() {\n        return super.seen();\n    }\n    /**\n     * Set the textEvent status to 'delivered'.\n     * handled by the SDK\n     * @returns {Promise}\n     * @example <caption>Set the textEvent status to 'delivered'</caption>\n     *  textEvent.delivered().then(() => {\n     *    console.log(\"text event status set to delivered\");\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error setting text event status to delivered  \", error);\n     *  });\n     */\n    delivered() {\n        return super.delivered();\n    }\n    /**\n     * Delete the textEvent\n     * @returns {Promise}\n     * @example <caption>Delete the textEvent</caption>\n     *  textEvent.del().then(() => {\n     *    console.log(\"text event deleted\");\n     *  }).catch((error)=>{\n     *\tconsole.log(\"error deleting text event  \", error);\n     *  });\n     */\n    del() {\n        return super.del();\n    }\n}\nexports.default = TextEvent;\nmodule.exports = TextEvent;\n\n},{\"./nxmEvent\":5}],7:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Application Events Handler\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\nconst nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\"));\nconst nxmCall_1 = __importDefault(require(\"../modules/nxmCall\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst rtc_helper_1 = __importDefault(require(\"../modules/rtc_helper\"));\n/**\n * Handle Application Events\n *\n * @class ApplicationEventsHandler\n * @param {Application} application\n * @param {Conversation} conversation\n * @private\n*/\nclass ApplicationEventsHandler {\n    constructor(application) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this._handleApplicationEventMap = {\n            'member:joined': this._processMemberJoined,\n            'member:invited': this._processMemberInvited\n        };\n    }\n    /**\n      * Handle and event.\n      *\n      * Update the event to map local generated events\n      * in case we need a more specific event to pass in the application listener\n      * or f/w the event as it comes\n      * @param {object} event\n      * @private\n    */\n    handleEvent(event) {\n        const conversation = this.application.conversations.get(event.cid);\n        const copied_event = Object.assign({}, event);\n        if (this._handleApplicationEventMap.hasOwnProperty(event.type)) {\n            return this._handleApplicationEventMap[event.type].call(this, conversation, new nxmEvent_1.default(conversation, copied_event), event);\n        }\n        return new nxmEvent_1.default(conversation, copied_event);\n    }\n    /**\n      * case: call to PSTN, after knocking event we receive joined\n      * @private\n    */\n    _processMemberJoined(conversation, event, raw_event) {\n        try {\n            if (event.body.channel && this.application._call_draft_list.has(event.body.channel.id)) {\n                this.log.debug(\"_processMemberJoined: outbound serverCall from sdk\", { event });\n                const nxmCall = this.application._call_draft_list.get(event.body.channel.id);\n                let pc = ((nxmCall.rtcObjects || {})[event.body.channel.id] || {}).pc;\n                nxmCall._setFrom(conversation.me);\n                nxmCall._setupConversationObject(conversation, event.body.channel.id);\n                // add the media objects to new conversation from placeholder in call\n                conversation.media._attachEndingEventHandlers();\n                // Checking to see if placeholder NxmCall has rtcObject, pc or activeStreams while new conversation does not and if so add\n                // to new conversation the missing rtcObject, pc or activeStream\n                if (Object.entries(conversation.media.rtcObjects).length === 0 && Object.entries(nxmCall.rtcObjects).length !== 0) {\n                    Object.assign(conversation.media.rtcObjects, nxmCall.rtcObjects);\n                }\n                if (!conversation.media.pc && pc) {\n                    Object.assign(conversation.media.pc = pc);\n                }\n                if (conversation.application.activeStreams.length === 0 && nxmCall.application.activeStreams.length > 0) {\n                    conversation.application.activeStreams = nxmCall.application.activeStreams;\n                }\n                delete nxmCall.client_ref;\n                delete nxmCall.knocking_id;\n                // if rtcStats on call object place on media object as well\n                if (nxmCall.rtcStats) {\n                    conversation.media.rtcStats = nxmCall.rtcStats;\n                }\n                // remove the leg_id from the call_draft_list\n                this.application._call_draft_list.delete(event.body.channel.id);\n                this.application.calls.set(conversation.id, nxmCall);\n                nxmCall._handleStatusChange(event);\n                this.log.debug(\"_processMemberJoined: processedCall \", { nxmCall });\n                if (conversation.members && event.body.member_id) {\n                    const member = conversation.members.get(event.body.member_id);\n                    if (member)\n                        this.application.emit('member:call', member, nxmCall);\n                }\n                // Supports old way of listening for the media stream after the conversation is set up even though its already there\n                setTimeout(() => {\n                    if (conversation === null || conversation === void 0 ? void 0 : conversation.me)\n                        rtc_helper_1.default.emitMediaStream(conversation.me, pc, nxmCall.stream);\n                }, 200);\n            }\n            this.log.debug(\"_processMemberJoined: default member joined: \", { event });\n            return event;\n        }\n        catch (e) {\n            this.log.error(\"_processMemberJoined: \", { e });\n        }\n    }\n    _processMemberInvited(conversation, event) {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            if (!conversation) {\n                this.log.warn(`no conversation object for ${event.type}`);\n                return event;\n            }\n            // no need to process the event if it's not media related invite, or the member is us\n            if ((((_a = conversation.me) === null || _a === void 0 ? void 0 : _a.user.id) === event.body.invited_by) || !((_c = (_b = event.body.user.media) === null || _b === void 0 ? void 0 : _b.audio_settings) === null || _c === void 0 ? void 0 : _c.enabled)) {\n                return event;\n            }\n            const caller = utils_1.default.getMemberNumberFromEventOrNull(event.body.channel) ||\n                utils_1.default.getMemberFromNameOrNull(conversation, event.body.invited_by) || 'unknown';\n            const nxmCall = new nxmCall_1.default(this.application, conversation, caller);\n            this.application.calls.set(conversation.id, nxmCall);\n            if (((_d = event.body) === null || _d === void 0 ? void 0 : _d.sdp) && this.application.session.config.enableInboundOffer) {\n                nxmCall._setOffer({ sdp: event.body.sdp, leg_id: event.body.channel.id });\n            }\n            // (VAPI call)\n            if (!((_e = conversation.display_name) === null || _e === void 0 ? void 0 : _e.startsWith('CALL_'))) {\n                nxmCall._handleStatusChange(event);\n            }\n            this.application.emit('member:call', this.application.conversations.get(event.cid).members.get((_f = event.body) === null || _f === void 0 ? void 0 : _f.member_id), nxmCall);\n            return event;\n        }\n        catch (e) {\n            this.log.error(\"_processMemberInvited: \", { e });\n        }\n    }\n}\nexports.default = ApplicationEventsHandler;\nmodule.exports = ApplicationEventsHandler;\n\n},{\"../events/nxmEvent\":5,\"../modules/nxmCall\":16,\"../modules/rtc_helper\":18,\"../utils\":31,\"loglevel\":63}],8:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Conversation Events Handler\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\nconst nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\"));\nconst text_event_1 = __importDefault(require(\"../events/text_event\"));\nconst image_event_1 = __importDefault(require(\"../events/image_event\"));\nconst message_event_1 = __importDefault(require(\"../events/message_event\"));\n/**\n * Handle Conversation Events\n *\n * @class ConversationEventsHandler\n * @param {Application} application\n * @param {Conversation} conversation\n * @private\n*/\nclass ConversationEventHandler {\n    constructor(application, conversation) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this.conversation = conversation;\n        this.constructed_event = null;\n        this._handleEventMap = {\n            'event:delete': this._processDelete,\n            'image': this._processImage,\n            'image:delivered': this._processDelivered,\n            'image:seen': this._processSeen,\n            'member:invited': this._processMember,\n            'member:joined': this._processMember,\n            'member:left': this._processMember,\n            'audio:ringing:start': this._processMember,\n            'leg:status:update': this._processLegStatus,\n            'member:media': this._processMedia,\n            'text': this._processText,\n            'text:delivered': this._processDelivered,\n            'text:seen': this._processSeen,\n            'audio:mute:on': this._processMuteForMedia,\n            'audio:mute:off': this._processMuteForMedia,\n            'message': this._processMessage,\n            'message:delivered': this._processDelivered,\n            'message:seen': this._processSeen,\n            'message:submitted': this._processSubmitted,\n            'message:rejected': this._processRejected,\n            'message:undeliverable': this._processUndeliverable\n        };\n    }\n    /**\n      * Handle and event.\n      *\n      * Identify the type of the event,\n      * create the corresponding Class instance\n      * emit to the corresponding Objects\n      * @param {object} event\n      * @private\n    */\n    handleEvent(event) {\n        if (this._handleEventMap.hasOwnProperty(event.type)) {\n            return this._handleEventMap[event.type].call(this, event) || new nxmEvent_1.default(this.conversation, event);\n        }\n        return new nxmEvent_1.default(this.conversation, event);\n    }\n    /**\n      * Mark the requested event as delivered\n      * use that event as constructed to update the local events' map\n        * @param {object} event\n      * @returns the NXMEvent that is marked as delivered\n      * @private\n    */\n    _processDelivered(event) {\n        let event_to_mark = this.conversation.events.get(event.body.event_id);\n        if (event_to_mark) {\n            event_to_mark.state = event_to_mark.state || {};\n            event_to_mark.state.delivered_to = event_to_mark.state.delivered_to || {};\n            event_to_mark.state.delivered_to[event.from] = event.timestamp;\n            return event_to_mark;\n        }\n        else {\n            this.log.warn('NXMEvent not found');\n            return null;\n        }\n    }\n    /**\n      * Delete the requested event\n      * empty the payload of the event (text, image or message)\n      * use that event as constructed to update the local events map\n      * @param {object} event\n      * @returns the deleted events\n      * @private\n    */\n    _processDelete(event) {\n        var _a;\n        let event_to_delete = this.conversation.events.get((_a = event === null || event === void 0 ? void 0 : event.body) === null || _a === void 0 ? void 0 : _a.event_id);\n        if (event_to_delete) {\n            if (event_to_delete.body.text)\n                event_to_delete.body.text = '';\n            if (event_to_delete.body.representations)\n                event_to_delete.body.representations = '';\n            event_to_delete.body.timestamp = {\n                deleted: event.timestamp\n            };\n            return event_to_delete;\n        }\n        else {\n            this.log.warn('NXMEvent not found');\n            return null;\n        }\n    }\n    /**\n      * Return an ImageEvent with the corresponding image data\n      * @param {object} event\n      * @returns {ImageEvent}\n    */\n    _processImage(event) {\n        var _a;\n        const imageEvent = new image_event_1.default(this.conversation, event);\n        // Automatically send a delivery\n        // avoid sending delivered to our own events\n        if (((_a = this.conversation.me) === null || _a === void 0 ? void 0 : _a.id) !== imageEvent.from) {\n            imageEvent.delivered();\n        }\n        return imageEvent;\n    }\n    /**\n      * Handle events for member state changes (joined, invited, left)\n      * in conversation level.\n      * Other members are going through here too.\n      * For .me member initial event (join, invite) use the application listener\n        * @param {object} event\n      * @returns {NXMEvent}\n      * @private\n    */\n    _processMember(event) {\n        // needs to first process the call state and then alter the member\n        if (this.application.calls.has(this.conversation.id)) {\n            let call = this.application.calls.get(this.conversation.id);\n            call._handleStatusChange(event);\n        }\n        if (this.conversation.members.has(event.from))\n            this.conversation.members.get(event.from)._handleEvent(event);\n        return new nxmEvent_1.default(this.conversation, event);\n    }\n    /**\n     * Handle events for leg status updates in conversation level.\n     * Other member's legs are going through here too.\n     * @param {object} event\n     * @returns {NXMEvent}\n     * @private\n    */\n    _processLegStatus(event) {\n        if (this.conversation.members.has(event.from))\n            this.conversation.members.get(event.from)._handleEvent(event);\n        return new nxmEvent_1.default(this.conversation, event);\n    }\n    /**\n      * Handle member:media events\n      * use a call object if and the member object\n        * @param {object} event\n      * @private\n    */\n    _processMedia(event) {\n        if (this.conversation.members.has(event.from))\n            this.conversation.members.get(event.from)._handleEvent(event);\n        return null;\n    }\n    /**\n      * Handle *:mute:* events\n        * @param {object} event\n      * @private\n    */\n    _processMuteForMedia(event) {\n        if (this.conversation.media.rtcObjects[event.body.rtc_id]) {\n            event.streamIndex = this.conversation.media.rtcObjects[event.body.rtc_id].streamIndex;\n        }\n        else {\n            this.log.warn('No audio stream was found');\n        }\n        return null;\n    }\n    /**\n      * Mark the requested event as seen\n      * use that event as constructed to update the local Events map\n        * @param {object} event\n      * @private\n    */\n    _processSeen(event) {\n        let event_to_mark = this.conversation.events.get(event.body.event_id);\n        if (event_to_mark) {\n            event_to_mark.state = event_to_mark.state || {};\n            event_to_mark.state.seen_by = event_to_mark.state.seen_by || {};\n            event_to_mark.state.seen_by[event.from] = event.timestamp;\n            return event_to_mark;\n        }\n        else {\n            this.log.warn('NXMEvent not found');\n            return null;\n        }\n    }\n    /**\n      * Create the TextEvent object and trigger .delivered()\n        * @param {object} event\n      * @private\n    */\n    _processText(event) {\n        var _a, _b;\n        const textEvent = new text_event_1.default(this.conversation, event);\n        // Automatically send a delivery\n        // avoid sending delivered to our own events\n        if (((_b = (_a = this.conversation) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) !== textEvent.from) {\n            textEvent.delivered();\n        }\n        return textEvent;\n    }\n    /**\n      * Create the MessageEvent object and trigger .delivered()\n        * @param {object} event\n      * @private\n    */\n    _processMessage(event) {\n        var _a, _b;\n        const messageEvent = new message_event_1.default(this.conversation, event);\n        // Automatically send a delivery\n        // avoid sending delivered to our own events\n        if (((_b = (_a = this.conversation) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) !== messageEvent.from) {\n            messageEvent.delivered();\n        }\n        return messageEvent;\n    }\n    /**\n      * Mark the requested event as submitted\n      * use that event as constructed to update the local Events map\n        * @param {object} event\n      * @private\n    */\n    _processSubmitted(event) {\n        let event_to_mark = this.conversation.events.get(event.body.event_id);\n        if (event_to_mark) {\n            event_to_mark.state = event_to_mark.state || {};\n            event_to_mark.state.submitted_to = event_to_mark.state.submitted_to || {};\n            event_to_mark.state.submitted_to[event.from] = event.timestamp;\n            return event_to_mark;\n        }\n        else {\n            this.log.warn('NXMEvent not found');\n            return null;\n        }\n    }\n    /**\n      * Mark the requested event as rejected\n      * use that event as constructed to update the local Events map\n        * @param {object} event\n      * @private\n    */\n    _processRejected(event) {\n        let event_to_mark = this.conversation.events.get(event.body.event_id);\n        if (event_to_mark) {\n            event_to_mark.state = event_to_mark.state || {};\n            event_to_mark.state.rejected_by = event_to_mark.state.rejected_by || {};\n            event_to_mark.state.rejected_by[event.from] = event.timestamp;\n            return event_to_mark;\n        }\n        else {\n            this.log.warn('NXMEvent not found');\n            return null;\n        }\n    }\n    /**\n      * Mark the requested event as undeliverable\n      * use that event as constructed to update the local Events map\n        * @param {object} event\n      * @private\n    */\n    _processUndeliverable(event) {\n        let event_to_mark = this.conversation.events.get(event.body.event_id);\n        if (event_to_mark) {\n            event_to_mark.state = event_to_mark.state || {};\n            event_to_mark.state.undeliverable_to = event_to_mark.state.undeliverable_to || {};\n            event_to_mark.state.undeliverable_to[event.from] = event.timestamp;\n            return event_to_mark;\n        }\n        else {\n            this.log.warn('NXMEvent not found');\n            return null;\n        }\n    }\n}\nexports.default = ConversationEventHandler;\nmodule.exports = ConversationEventHandler;\n\n},{\"../events/image_event\":3,\"../events/message_event\":4,\"../events/nxmEvent\":5,\"../events/text_event\":6,\"loglevel\":63}],9:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConversationEventsProcessor = exports.EventsQueue = void 0;\n/*\n * Nexmo Client SDK\n * Events Queue\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle Mapping of Conversation Ids to ConversationEventsProcessor\n *\n * @class EventsQueue\n * @private\n */\nclass EventsQueue {\n    constructor(callback) {\n        this.callback = callback;\n        this.cidMap = new Map();\n        this.log = loglevel_1.getLogger(this.constructor.name);\n    }\n    // enqueue(item)\n    async enqueue(event, application) {\n        var _a, _b, _c, _d;\n        //Check if cid or event id and if not just send to application to be processed\n        const { cid, id } = event;\n        const eventId = Number(id);\n        if (!cid || isNaN(eventId))\n            return this.callback(event);\n        // Check if Conversation Events Queue for CID and if not create one\n        if (!this.cidMap.get(cid)) {\n            this.log.debug(`enqueue: create new ConversationEventsProcessor for ${cid}`);\n            const newConversationEventsProcessor = new ConversationEventsProcessor(cid, eventId - 1, application);\n            this.cidMap.set(cid, newConversationEventsProcessor);\n            // edge case for member:media or member:joined event before transfer or member:joined && channel.id\n            if (event.type == 'member:media' && ((_b = (_a = event.body) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.audio) || event.type == 'member:joined' && ((_d = (_c = event.body) === null || _c === void 0 ? void 0 : _c.channel) === null || _d === void 0 ? void 0 : _d.id)) {\n                // fetch last 20 events of conversation & if there is a transfer to this converstaion\n                const startingFetchEventId = eventId - 20 < 1 ? 1 : eventId - 20;\n                const events = await newConversationEventsProcessor.fetchConversationEvents(startingFetchEventId, 20);\n                let transferEventFound = false;\n                events.forEach(fetchedEvent => {\n                    if (fetchedEvent.type === 'rtc:transfer' && fetchedEvent.from === event.from) {\n                        transferEventFound = true;\n                        // reset the events processor to process transfer event next\n                        newConversationEventsProcessor.lastEventIdProcessed = Number(fetchedEvent.id) - 1;\n                    }\n                    if (transferEventFound) {\n                        //Enqueue all events after rtc:transfer event found\n                        newConversationEventsProcessor.enqueue(Number(fetchedEvent.id), fetchedEvent);\n                    }\n                });\n            }\n        }\n        const conversationEventsProcessor = this.cidMap.get(cid);\n        // Add new event to conversation events queue\n        conversationEventsProcessor.enqueue(eventId, event);\n        // If not currently processing events in queue begin processing\n        if (!conversationEventsProcessor.processing) {\n            conversationEventsProcessor.processing = true;\n            await conversationEventsProcessor.processEvents();\n        }\n        return;\n    }\n}\nexports.EventsQueue = EventsQueue;\n/**\n * Handle Ordering of Conversation Events for Processing\n *\n * @class ConversationEventsProcessor\n * @private\n */\nclass ConversationEventsProcessor {\n    constructor(cid, lastEventIdProcessed, application) {\n        this.cid = cid;\n        this.eventsMap = new Map();\n        this.callback = (event) => application._handleEvent(event);\n        this.lastEventIdProcessed = lastEventIdProcessed;\n        this.largestEventIdInQueue = lastEventIdProcessed;\n        this.processing = false;\n        this.application = application;\n        this.eventsFetchRange = 9;\n        this.log = loglevel_1.getLogger(this.constructor.name);\n    }\n    enqueue(eventId, event) {\n        if (eventId > this.largestEventIdInQueue)\n            this.largestEventIdInQueue = eventId;\n        if (eventId > this.lastEventIdProcessed)\n            this.eventsMap.set(eventId, event);\n        return event;\n    }\n    dequeue(eventId) {\n        const event = this.eventsMap.get(eventId);\n        this.eventsMap.delete(eventId);\n        return event;\n    }\n    async processEvents() {\n        const doneProcessing = () => {\n            this.eventsMap.clear();\n            this.log.debug(`processEvents: Done Processing`);\n            return this.processing = false;\n        };\n        if (this.eventsMap.size < 1)\n            return doneProcessing();\n        const nextEventToProcess = this.lastEventIdProcessed + 1;\n        const processedEvent = await this.processNextEvent(nextEventToProcess);\n        if (processedEvent) {\n            this.lastEventIdProcessed = Number(processedEvent.id);\n            return this.processEvents();\n        }\n        else {\n            return doneProcessing();\n        }\n    }\n    async processNextEvent(eventId) {\n        this.log.debug(`processNextEvent: processing event number ${eventId}`);\n        const event = this.dequeue(eventId);\n        try {\n            if (event) {\n                await this.callback(event);\n                return event;\n            }\n            else {\n                // The next event in the sequence was not in the map, if larger event id in queue (gap)\n                // make a request to CS to get all conversation events and add any missed\n                if (this.largestEventIdInQueue > eventId) {\n                    this.log.debug(`processNextEvent: largestEventIdInQueue-${this.largestEventIdInQueue} > eventId-${eventId}`);\n                    const foundEvent = await this.fetchEventsAndProcess(eventId);\n                    if (foundEvent) {\n                        this.log.debug(\"processNextEvent: foundEvent \", { foundEvent });\n                        await this.callback(foundEvent);\n                        return foundEvent;\n                    }\n                    else {\n                        this.log.debug(`processNextEvent: not found process next ${eventId + 1}`);\n                        return this.processNextEvent(eventId + 1);\n                    }\n                }\n                return;\n            }\n        }\n        catch (e) {\n            return;\n        }\n    }\n    async fetchEventsAndProcess(missingEvent) {\n        //fetch conversation events\n        try {\n            const eventsList = await this.fetchConversationEvents(missingEvent, this.eventsFetchRange);\n            this.log.debug(\"fetchEventsAndProcess: fetched events list \", { eventsList });\n            //check for next event id\n            let foundEvent;\n            eventsList.forEach((event) => {\n                //add cid back to fetched event\n                event.cid = this.cid;\n                const eventId = Number(event.id);\n                if (isNaN(eventId) || eventId < missingEvent)\n                    return;\n                if (eventId > missingEvent) {\n                    this.log.debug(`fetchEventsAndProcess: event > missingEvent ${eventId} `, { missingEvent });\n                    this.enqueue(eventId, event);\n                }\n                else {\n                    this.log.debug(\"fetchEventsAndProcess: foundEvent \", { event });\n                    foundEvent = event;\n                }\n            });\n            return foundEvent;\n        }\n        catch (e) {\n            this.log.debug(\"fetchEventsAndProcess: error \", { e });\n            return;\n        }\n    }\n    async fetchConversationEvents(start_id, range) {\n        this.log.debug(\"fetchConversationEvents: \", this.cid, start_id);\n        // from & to by event id to restrict\n        const end_id = this.largestEventIdInQueue > start_id ? this.largestEventIdInQueue + range : start_id + range;\n        const url = `${this.application.session.config.nexmo_api_url}/beta2/conversations/${this.cid}/events`;\n        try {\n            const response = await utils_1.default.paginationRequest(url, { start_id, end_id }, this.application.session.config.token);\n            const eventsList = response.items;\n            return eventsList;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n}\nexports.ConversationEventsProcessor = ConversationEventsProcessor;\nmodule.exports = {\n    EventsQueue: EventsQueue,\n    ConversationEventsProcessor: ConversationEventsProcessor\n};\n\n},{\"../nexmoClientError\":20,\"../utils\":31,\"loglevel\":63}],10:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  RTC Events Handler\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle rtc Events\n *\n * @class RtcEventHandler\n * @private\n */\nclass RtcEventHandler {\n    constructor(application) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this._handleRtcEventMap = {\n            'rtc:transfer': this._processRtcTransfer,\n            'rtc:answer': this._processRtcAnswer,\n            'rtc:hangup': this._processRtcHangup\n        };\n    }\n    /**\n     * Entry point for rtc events\n     * @param {object} event\n     * @private\n     */\n    _handleRtcEvent(event) {\n        if (this._handleRtcEventMap.hasOwnProperty(event.type)) {\n            return this._handleRtcEventMap[event.type].call(this, event);\n        }\n    }\n    /**\n      * on transfer event\n      * update the conversation object in the NXMCall,\n      * update the media object in the new conversation\n      * set `transferred_to` <Conversation> on the member that is transferred\n      * @param {object} event\n      * @private\n    */\n    _processRtcTransfer(event) {\n        this.log.debug('_processRtcTransfer: ', { event });\n        const old_conversation = this.application.conversations.get(event.body.transferred_from);\n        const new_conversation = this.application.conversations.get(event.cid);\n        const nxmCall = this.application.calls.get(event.body.transferred_from);\n        if (!nxmCall) {\n            this.log.warn('NXMCall transfer for unknown nxmCall');\n            return;\n        }\n        // mark the transferred member in the old conversation\n        nxmCall.conversation.members.get(event.body.was_member).transferred_to = new_conversation;\n        nxmCall._setupConversationObject(new_conversation);\n        nxmCall.transferred = true;\n        this.application.calls.set(event.cid, nxmCall);\n        this.application.calls.delete(event.body.transferred_from);\n        // in case we joined in the middle of a transfer and we don't have the\n        // previous conversation in our list yet\n        if (old_conversation) {\n            new_conversation.members.get(event.from).transferred_from = old_conversation;\n            new_conversation.media._attachEndingEventHandlers();\n            // Checking to see if old conversation has rtcObject, pc or activeStreams while new conversation does not and if so add\n            // to new conversation the missing rtcObject, pc or activeStream\n            if (Object.entries(new_conversation.media.rtcObjects).length === 0 && Object.entries(old_conversation.media.rtcObjects).length !== 0) {\n                Object.assign(new_conversation.media.rtcObjects, old_conversation.media.rtcObjects);\n            }\n            if (!new_conversation.media.pc && old_conversation.media.pc) {\n                Object.assign(new_conversation.media.pc = old_conversation.media.pc);\n            }\n            if (new_conversation.application.activeStreams.length === 0 && old_conversation.application.activeStreams.length > 0) {\n                new_conversation.application.activeStreams = old_conversation.application.activeStreams;\n            }\n        }\n    }\n    /**\n     * Handle rtc:answer event\n     *\n     * @param {object} event\n     * @private\n     */\n    _processRtcAnswer(event) {\n        this.log.debug('_processRtcAnswer: ', { event });\n        if (this.application.calls.has(event.cid)) {\n            this.application.calls.get(event.cid).id = event.body.rtc_id;\n        }\n    }\n    /**\n     * Handle rtc:hangup event\n     *\n     * @param {object} event\n     * @private\n     */\n    _processRtcHangup(event) {\n        this.log.debug('_processRtcHangup: ', { event });\n        if (this.application.calls.has(event.cid)) {\n            let call = this.application.calls.get(event.cid);\n            call._handleStatusChange(event);\n        }\n    }\n}\nexports.default = RtcEventHandler;\nmodule.exports = RtcEventHandler;\n\n},{\"loglevel\":63}],11:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  SIP Events Handler\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\n/**\n * Handle sip Events\n *\n * @class SipEventHandler\n * @private\n  */\nclass SipEventHandler {\n    constructor(application) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.application = application;\n        this._handleSipCallEventMap = {\n            'sip:hangup': this._processSipHangup,\n            'sip:ringing': this._processSipRinging\n        };\n    }\n    /**\n     * Entry point for sip events\n     * The event belongs to a call Object\n     * @private\n    */\n    _handleSipCallEvent(event) {\n        this.log.debug(\"_handleSipCallEvent: \", { event });\n        if (!this.application.calls.has(event.cid)) {\n            this.log.warn('There is no call object for this Conversation id.');\n            return;\n        }\n        const event_call = this.application.calls.get(event.cid);\n        if (this._handleSipCallEventMap.hasOwnProperty(event.type)) {\n            return this._handleSipCallEventMap[event.type].call(this, event_call, event);\n        }\n    }\n    /**\n     * Handle sip:hangup event\n     *\n     * @param {object} event_call\n     * @private\n     */\n    _processSipHangup(event_call, event) {\n        this.log.debug(\"_processSipHangup: \", event);\n        event_call._handleStatusChange(event);\n    }\n    /**\n     * Handle sip:ringing event\n     *\n     * @param {object} event_call\n     * @private\n     */\n    _processSipRinging(event_call, event) {\n        this.log.debug(\"_processSipRinging: \", event);\n        event_call._handleStatusChange(event);\n    }\n}\nexports.default = SipEventHandler;\nmodule.exports = SipEventHandler;\n\n},{\"loglevel\":63}],12:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\nlet NexmoClient = global.NexmoClient || {};\nNexmoClient = require('./sdk');\nglobal.NexmoClient = NexmoClient;\n\n}).call(this)}).call(this,typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./sdk\":28}],13:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Member Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst nxmEvent_1 = __importDefault(require(\"./events/nxmEvent\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\n/**\n * An individual user (i.e. conversation member).\n * @class Member\n * @param {Conversation} conversation\n * @param {object} params\n*/\nclass Member {\n    constructor(conversation, params) {\n        this.conversation = conversation;\n        this.callStatus = null;\n        this._normalise(params);\n        WildEmitter.mixin(Member);\n    }\n    /**\n     * Update object instance and align attribute names\n     *\n     * Handle params input to keep consistent the member object\n     * @param {object} params member attributes\n     * @private\n    */\n    _normalise(params) {\n        if (params) {\n            this.user = this.user || {};\n            this.channel = params.channel || {\n                type: 'app'\n            };\n            let key;\n            for (key in params) {\n                switch (key) {\n                    case 'member_id':\n                        this.id = params.member_id;\n                        break;\n                    case 'timestamp':\n                        this.timestamp = params.timestamp;\n                        break;\n                    case 'state':\n                        this.state = params.state;\n                        break;\n                    case 'from':\n                        this.id = params.from; // special case for member events\n                        break;\n                    case 'user_id':\n                        this.user.id = params.user_id;\n                        break;\n                    case 'name':\n                        this.user.name = params.name;\n                        break;\n                    case 'user':\n                        this.user = {\n                            name: params.user.name,\n                            id: params.user.user_id || params.user.id\n                        };\n                        this.display_name = this.display_name || params.user.display_name;\n                        break;\n                    case 'invited_by':\n                        this.invited_by = params.invited_by;\n                        break;\n                    case 'display_name':\n                        this.display_name = this.display_name || params.display_name;\n                        break;\n                    case '_embedded':\n                        if (params._embedded.user) {\n                            this.user = {\n                                id: params._embedded.user.id || this.user.id,\n                                name: params._embedded.user.name || this.user.name\n                            };\n                            this.display_name = this.display_name || params._embedded.user.display_name;\n                        }\n                    case 'conversation':\n                        break;\n                    default:\n                        if (!params.type) {\n                            this[key] = params[key];\n                        }\n                }\n            }\n            // join conversation returns our member with only id,\n            // compare it for now and use the username we have in the application object\n            if (this.conversation.application.me && params.user_id === this.conversation.application.me.id) {\n                this.user.name = this.conversation.application.me.name;\n            }\n            // make sure we don't keep a member.user_id, name in any flow\n            delete this.user_id;\n            delete this.name;\n            delete this.user.user_id;\n        }\n    }\n    /**\n     * Play the given stream only to this member within the conversation\n     *\n     * @param {string} [params]\n     *\n     * @returns {Promise<NXMEvent>}\n     * @private\n    */\n    async playStream(params) {\n        try {\n            const response = await this.conversation.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data: {\n                    type: 'audio:play',\n                    to: this.id,\n                    body: params\n                }\n            });\n            return new nxmEvent_1.default(this.conversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Speak the given text only to this member within the Conversation.\n     *\n     * @param {string} [params]\n     *\n     * @returns {Promise<NXMEvent>}\n     * @private\n    */\n    async sayText(params) {\n        try {\n            const response = await this.conversation.application.session.sendNetworkRequest({\n                type: 'POST',\n                path: `conversations/${this.id}/events`,\n                data: {\n                    type: 'audio:say',\n                    cid: this.id,\n                    from: this.conversation.me.id,\n                    to: this.id,\n                    body: {\n                        text: params.text,\n                        voice_name: params.voice_name || 'Amy',\n                        level: params.level || 1,\n                        queue: params.queue || true,\n                        loop: params.loop || 1,\n                        ssml: params.ssml || false\n                    }\n                }\n            });\n            return new nxmEvent_1.default(this.conversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Kick a Member from the Conversation.\n     *\n     * @param {object} [reason] the reason for kicking out a member\n     * @param {string} [reason.reason_code] the code of the reason\n     * @param {string} [reason.reason_text] the description of the reason\n     * @example <caption>Remove a member from the Conversation.</caption>\n     * // Remove a member\n     * member.kick({reason_code: \"Reason Code\", reason_text: \"Reason Text\"})\n     * .then(() => {\n     *     console.log(\"Successfully removed member.\");\n     * }).catch((error) => {\n     *     console.error(\"Error removing member: \", error);\n     * });\n     *\n     * // Remove yourself\n     * conversation.me.kick({reason_code: \"Reason Code\", reason_text: \"Reason Text\"})\n     * .then(() => {\n     *     console.log(\"Successfully removed yourself.\");\n     * }).catch((error) => {\n     *     console.error(\"Error removing yourself: \", error);\n     * });\n     *\n     * @returns {Promise}\n    */\n    async kick(reason) {\n        var _a, _b;\n        let path = `conversations/${this.conversation.id}/members/${this.id}`;\n        let params = new URLSearchParams();\n        // add member_id of from\n        if ((_b = (_a = this === null || this === void 0 ? void 0 : this.conversation) === null || _a === void 0 ? void 0 : _a.me) === null || _b === void 0 ? void 0 : _b.id) {\n            params.append('from', this.conversation.me.id);\n        }\n        if (reason) {\n            Object.keys(reason).forEach((key) => {\n                params.append(key, reason[key]);\n            });\n        }\n        path += `?${params.toString()}`;\n        try {\n            return await this.conversation.application.session.sendNetworkRequest({\n                type: 'DELETE',\n                path\n            });\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Mute your stream.\n     *\n     * @param {boolean} [mute] true for mute, false for unmute\n     * @param {number} [streamIndex] stream index of the stream\n     * @example <caption>Mute audio stream of your Member.</caption>\n     * // Mute yourself\n     * conversation.me.mute(true);\n     *\n     * // Unmute yourself\n     * conversation.me.mute(false);\n     *\n     * @returns {Promise}\n    */\n    mute(mute, streamIndex = null) {\n        return this.conversation.media.mute(mute, streamIndex);\n    }\n    /**\n     * Earmuff yourself in the Conversation.\n     *\n     * @param {boolean} earmuff true or false\n     * @example <caption>Disables your Member from hearing other Members in the Conversation.</caption>\n     * // Earmuff yourself\n     * conversation.me.earmuff(true);\n     *\n     * // Unearmuff yourself\n     * conversation.me.earmuff(false);\n     *\n     * @returns {Promise}\n     *\n    */\n    earmuff(earmuff) {\n        return this.conversation.media.earmuff(earmuff);\n    }\n    /**\n     * Handle member object events\n     *\n     * Handle events that are modifying this member instance\n     * @param {NXMEvent} event invited, joined, left, media events\n     * @private\n    */\n    _handleEvent(event) {\n        switch (event.type) {\n            case 'member:invited':\n                this._normalise(event.body); // take care of misaligned objects.\n                this.state = 'INVITED';\n                this.timestamp.invited = event.body.timestamp.invited;\n                if (!event.body.invited_by && event.body.user.media && event.body.user.media.audio_settings\n                    && event.body.user.media.audio_settings.enabled) {\n                    this._setCallStatusAndEmit('started');\n                }\n                break;\n            case 'member:joined':\n                this._normalise(event.body); // take care of misaligned objects.\n                this.state = 'JOINED';\n                this.timestamp.joined = event.body.timestamp.joined;\n                if (event.body.channel && event.body.channel.knocking_id) {\n                    this._setCallStatusAndEmit('started');\n                }\n                break;\n            case 'member:left':\n                this._normalise(event.body); // take care of misaligned objects.\n                this.state = 'LEFT';\n                this.timestamp.left = event.body.timestamp.left;\n                if (event.body.reason && event.body.reason.text) {\n                    this._setCallStatusAndEmit(event.body.reason.text);\n                }\n                break;\n            case 'member:media':\n                this.media = event.body.media;\n                break;\n            case 'leg:status:update':\n                this.channel.legs = utils_1.default.updateMemberLegs(this.channel.legs, event);\n                this._setCallStatusAndEmit(event.body.status);\n                break;\n            case 'audio:ringing:start':\n                if (!this.callStatus || this.callStatus === 'started') {\n                    this._setCallStatusAndEmit('ringing');\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n       * Set the member.callStatus and emit a member:call:status event\n       *\n       * @param {Member.callStatus} this.callStatus the call status to set\n       * @private\n      */\n    _setCallStatusAndEmit(callStatus) {\n        if (this.callStatus !== String(callStatus)) {\n            this.callStatus = callStatus;\n            this.conversation.emit('member:call:status', this);\n        }\n    }\n}\nexports.default = Member;\nmodule.exports = Member;\n\n},{\"./events/nxmEvent\":5,\"./nexmoClientError\":20,\"./utils\":31,\"wildemitter\":107}],14:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Errors Emitter\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\n/**\n * Class that can emit errors via any emitter passed to it.\n * @class ErrorsEmitter\n * @param {Emitter} emitter - Any event emitter that implements \"emit\" and \"releaseGroup\". Basically object that is mixed with Wildemitter.\n * @property {string} LISTENER_GROUP='NXM-errors' - the group this emitter will register\n * @emits Emitter#NXM-errors\n * @private\n*/\n/**\n * Application listening for client and expired-token errors events.\n *\n * @event Application#NXM-errors\n *\n * @property {NexmoClientError} error\n *\n * @example <caption>listen for client error events on Application level</caption>\n * application.on('*', 'NXM-errors', (error) => {\n *    console.log('Error thrown with type ' + error.type);\n *  });\n * @example <caption>listen for expired-token error events and then update the token on Application level</caption>\n * application.on('system:error:expired-token', 'NXM-errors', (error) => {\n * \tconsole.log('token expired');\n * \tapplication.updateToken(token);\n * });\n*/\nclass ErrorsEmitter {\n    constructor(emitter) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        if (!emitter) {\n            throw new nexmoClientError_1.NexmoClientError('no emitter object passed for the Error Emitter');\n        }\n        this.emitter = emitter;\n        this.LISTENER_GROUP = 'NXM-errors';\n    }\n    /**\n     * Detect if the param.type includes error and emit that payload in the LISTENER_GROUP\n     * @param param - the payload to forward in the LISTENER_GROUP\n     * @param param.type - the type of the event to check if it's an error\n    */\n    emitResponseIfError(param) {\n        if (this._isTypeError(param.type)) {\n            return this.emitter.emit(param.type, this.LISTENER_GROUP, param);\n        }\n        return;\n    }\n    /**\n     * Release Group on the registered emitter (using the namespace LISTENER_GROUP that is set)\n    */\n    cleanup() {\n        return this.emitter.releaseGroup(this.LISTENER_GROUP);\n    }\n    /**\n     * Returns true if the param includes 'error'\n     * @param {string} type - the error type to check\n    */\n    _isTypeError(param) {\n        return param.indexOf('error') !== -1;\n    }\n}\nexports.default = ErrorsEmitter;\nmodule.exports = ErrorsEmitter;\n\n},{\"../nexmoClientError\":20,\"loglevel\":63}],15:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Media Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtc_helper_1 = __importDefault(require(\"./rtc_helper\"));\nconst utils_1 = __importDefault(require(\"../utils\"));\nconst nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\"));\nconst conversation_1 = __importDefault(require(\"../conversation\"));\nconst application_1 = __importDefault(require(\"../application\"));\n/**\n * Member listening for audio stream on.\n *\n * @event Member#media:stream:on\n *\n * @property {number} payload.streamIndex the index number of this stream\n * @property {number} [payload.rtc_id] the rtc_id / leg_id\n * @property {string} [payload.remote_member_id] the id of the Member the stream belongs to\n * @property {string} [payload.name] the stream's display name\n * @property {MediaStream} payload.stream the stream that is activated\n * @property {boolean} [payload.audio_mute] if the audio is muted\n */\n/**\n * WebRTC Media class\n * @class Media\n * @property {Application} application The parent application object\n * @property {Conversation} parentConversation the conversation object this media instance belongs to\n * @property {number} parentConversation.streamIndex the latest index of the streams, updated in each new peer offer\n * @property {object[]} rtcObjects data related to the rtc connection\n * @property {string} rtcObjects.rtc_id the rtc_id\n * @property {PeerConnection} rtcObjects.pc the current PeerConnection object\n * @property {Stream} rtcObjects.stream the stream of the specific rtc_id\n * @property {string} [rtcObjects.type] audio the type of the stream\n * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)\n * @property {RTCStatsConfig} rtcstats_conf the config needed to controll rtcstats analytics behavior\n * @property {RTCStatsAnalytics} rtcstats an instance to collect analytics from a peer connection\n * @emits Application#rtcstats:report\n * @emits Application#rtcstats:analytics\n * @emits Member#media:stream:on\n */\nclass Media {\n    constructor(conversationOrApplication) {\n        var _a, _b, _c;\n        const conversation = conversationOrApplication instanceof conversation_1.default\n            ? conversationOrApplication\n            : null;\n        const application = conversationOrApplication instanceof application_1.default\n            ? conversationOrApplication\n            : null;\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        if (conversation) {\n            this.rtcHelper = new rtc_helper_1.default();\n            this.application = conversation.application;\n            this.application.activeStreams = this.application.activeStreams || [];\n            this.parentConversation = conversation;\n            this.rtcObjects = {};\n            this.streamIndex = 0;\n            this.rtcstats_conf = ((_c = (_b = (_a = this.application) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.rtcStats) || {};\n            this.rtcStats = null;\n        }\n        else if (application) {\n            this.rtcHelper = new rtc_helper_1.default();\n            this.application = application;\n        }\n        else {\n            this.log.warn(\"No conversation object in Media\");\n        }\n    }\n    _attachEndingEventHandlers() {\n        if (!this.parentConversation) {\n            return;\n        }\n        this.log.debug(\"attaching leave listeners in media for \" + this.parentConversation.id);\n        this.parentConversation.on(\"rtc:hangup\", async (event) => {\n            let member;\n            if (this.parentConversation.members.has(event.from)) {\n                member = this.parentConversation.members.get(event.from);\n            }\n            else {\n                try {\n                    member = await this.parentConversation.getMember(event.from);\n                }\n                catch (error) {\n                    this.log.warn(`There is an error getting the member ${error}`);\n                }\n            }\n            if (member.user.id === this.application.me.id &&\n                this.application.activeStreams.length) {\n                this._cleanMediaProperties();\n            }\n            // terminate peer connection stream in case of a transfer\n            if (member.user.id === this.application.me.id &&\n                member.transferred_from) {\n                member.transferred_from.media._cleanMediaProperties();\n            }\n            if (member.user.id === this.application.me.id) {\n                this.parentConversation.off(\"rtc:hangup\");\n            }\n        });\n    }\n    /**\n     * Switch on the rtc stats emit events\n     * @private\n     */\n    _enableStatsEvents() {\n        this.rtcstats_conf.emit_rtc_analytics = true;\n        this.rtcstats_conf.remote_collection = true;\n        const rtcObject = this._findRtcObjectByType(\"audio\");\n        if (!this.rtcStats && rtcObject) {\n            this.log.debug(`enabling stats events for ${rtcObject.rtc_id}`);\n            this.rtcStats = rtc_helper_1.default._initStatsEvents({\n                application: this.application,\n                rtc_id: rtcObject.rtc_id,\n                pc: this.pc,\n                conversation: this.parentConversation,\n            });\n        }\n    }\n    /**\n     * Switch off the rtcStat events\n     * @private\n     */\n    _disableStatsEvents() {\n        this.rtcstats_conf.emit_events = false;\n        this.rtcstats_conf.emit_rtc_analytics = false;\n        this.rtcstats_conf.remote_collection = false;\n        this.rtcStats.removeIntervals();\n        delete this.rtcStats;\n    }\n    /**\n     * Function used to init the media stream\n     * @private\n     */\n    _audioInitHandler(params = {}, onIceCandidateHandler) {\n        return new Promise(async (resolve, reject) => {\n            const streamIndex = this.streamIndex;\n            this.streamIndex++;\n            const { audioConstraints } = params;\n            try {\n                const localStream = await rtc_helper_1.default.getUserAudio(audioConstraints);\n                const pc = rtc_helper_1.default.createPeerConnection(this.application);\n                this.pc = pc;\n                const { application, log, parentConversation: conversation, rtcObjects } = this;\n                const context = {\n                    pc,\n                    streamIndex,\n                    localStream,\n                    application,\n                    conversation,\n                    log,\n                    rtcObjects\n                };\n                onIceCandidateHandler({ ...context, resolve, reject });\n                rtc_helper_1.default.attachConversationEventHandlers(context);\n                this._attachEndingEventHandlers();\n            }\n            catch (error) {\n                reject(new nexmoClientError_1.NexmoClientError(error));\n            }\n        });\n    }\n    /**\n     * Handles the enabling of audio when an offer is available\n     * @private\n     */\n    _execAnswer(params = {}) {\n        const { offer: { sdp, leg_id } } = params;\n        return this._audioInitHandler(params, (context) => rtc_helper_1.default.doAnswer(context, sdp, leg_id));\n    }\n    /**\n     * Handles the enabling of audio only stream with rtc:new\n     * @private\n     */\n    _handleAudio(params = {}) {\n        const { reconnectRtcId } = params;\n        return this._audioInitHandler(params, (context) => rtc_helper_1.default.attachPeerConnectionEventHandlers({ ...context, reconnectRtcId }));\n    }\n    _findRtcObjectByType(type) {\n        return Object.values(this.rtcObjects).find((rtcObject) => rtcObject.type === type);\n    }\n    async _cleanConversationProperties() {\n        if (this.pc) {\n            this.pc.close();\n        }\n        // stop active stream\n        delete this.pc;\n        this.rtcStats = null;\n        this.application.activeStreams = [];\n        this.listeningToRtcEvent = false;\n        await Promise.resolve();\n    }\n    /**\n     * Cleans up the user's media before leaving the conversation\n     * @private\n     */\n    _cleanMediaProperties() {\n        if (this.pc) {\n            this.pc.close();\n        }\n        if (this.rtcObjects) {\n            for (const leg_id in this.rtcObjects) {\n                rtc_helper_1.default.closeStream(this.rtcObjects[leg_id].stream);\n            }\n        }\n        delete this.pc;\n        this.rtcStats = null;\n        this.application.activeStreams = [];\n        this.rtcObjects = {};\n        this.listeningToRtcEvent = false;\n    }\n    async _disableLeg(leg_id) {\n        const csRequestPromise = new Promise(async (resolve, reject) => {\n            try {\n                await this.application.session.sendNetworkRequest({\n                    type: \"DELETE\",\n                    path: `conversations/${this.parentConversation.id}/rtc/${leg_id}?from=${this.parentConversation.me.id}&originating_session=${this.application.session.session_id}`,\n                    version: \"beta2\",\n                });\n                resolve(\"rtc:terminate:success\");\n            }\n            catch (error) {\n                reject(new nexmoClientError_1.NexmoApiError(error));\n            }\n        });\n        const closeResourcesPromise = new Promise((resolve) => {\n            if (this.rtcObjects[leg_id].pc) {\n                this.rtcObjects[leg_id].pc.close();\n            }\n            if (this.rtcObjects[leg_id].stream) {\n                rtc_helper_1.default.closeStream(this.rtcObjects[leg_id].stream);\n            }\n            resolve();\n        });\n        try {\n            await Promise.all([csRequestPromise, closeResourcesPromise]);\n            this.parentConversation.me.emit(\"media:stream:off\", this.rtcObjects[leg_id].streamIndex);\n            delete this.rtcObjects[leg_id];\n            return \"rtc:terminate:success\";\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    _enableMediaTracks(tracks, enabled) {\n        tracks.forEach((mediaTrack) => {\n            mediaTrack.enabled = enabled;\n        });\n    }\n    /**\n     * Send a mute request with the rtc_id and enable/disable the tracks\n     * If the mute request fails revert the changes in the tracks\n     * @private\n     */\n    async _setMediaTracksAndMute(rtc_id, tracks, mute, mediaType) {\n        this._enableMediaTracks(tracks, !mute);\n        try {\n            return await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: mediaType,\n                    to: this.parentConversation.me.id,\n                    from: this.parentConversation.me.id,\n                    body: {\n                        rtc_id,\n                    },\n                },\n            });\n        }\n        catch (error) {\n            this._enableMediaTracks(tracks, mute);\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Replaces the stream's audio tracks currently being used as the sender's sources with a new one\n     * @param {object} constraints - audio constraints - { deviceId: { exact: selectedAudioDeviceId } }\n     * @param {string} type - rtc object type - audio\n     * @returns {Promise<MediaStream>} - Returns the new stream.\n     * @example <caption>Update the stream currently being used with a new audio source</caption>\n     * conversation.media.updateAudioConstraints({ deviceId: { exact: selectedAudioDeviceId } }, \"audio\")\n     * .then((response) => {\n     *   console.log(response);\n     * }).catch((error) => {\n     *   console.error(error);\n     * });\n     *\n     *\n     */\n    async updateAudioConstraints(constraints = {}) {\n        let rtcObjectByType = this._findRtcObjectByType('audio');\n        if (rtcObjectByType && rtcObjectByType.pc) {\n            try {\n                const localStream = await rtc_helper_1.default.getUserAudio(constraints);\n                localStream.getTracks().forEach((track) => {\n                    const sender = rtcObjectByType.pc\n                        .getSenders()\n                        .find((s) => s.track.kind === track.kind);\n                    if (sender) {\n                        track.enabled = sender.track.enabled;\n                        sender.replaceTrack(track);\n                    }\n                });\n                rtc_helper_1.default.closeStream(rtcObjectByType.stream);\n                rtcObjectByType.stream = localStream;\n                return localStream;\n            }\n            catch (error) {\n                return error;\n            }\n        }\n        else {\n            throw new nexmoClientError_1.NexmoApiError(\"error:media:stream:not-found\");\n        }\n    }\n    /**\n     * Mute your Member\n     *\n     * @param {boolean} [mute=false] true for mute, false for unmute\n     * @param {number} [streamIndex] stream id to set - if it's not set all streams will be muted\n     * @example <caption>Mute your audio stream in the Conversation</caption>\n     * // Mute your Member\n     * conversation.media.mute(true);\n     *\n     * // Unmute your Member\n     * conversation.media.mute(false);\n     */\n    mute(mute = false, streamIndex = null) {\n        const state = mute ? \"on\" : \"off\";\n        const audioType = \"audio:mute:\" + state;\n        let promises = [];\n        let muteObjects = {};\n        if (streamIndex !== null) {\n            muteObjects[0] = Object.values(this.rtcObjects).find((rtcObj) => rtcObj.streamIndex === streamIndex);\n            if (!muteObjects[0]) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:media:stream:not-found\");\n            }\n        }\n        else {\n            muteObjects = this.rtcObjects;\n        }\n        Object.values(muteObjects).forEach((rtcObject) => {\n            const audioTracks = rtcObject.stream.getAudioTracks();\n            const audioPromise = this._setMediaTracksAndMute(rtcObject.rtc_id, audioTracks, mute, audioType);\n            promises.push(audioPromise);\n        });\n        return Promise.all(promises);\n    }\n    /**\n     * Earmuff our member\n     *\n     * @param {boolean} [params]\n     *\n     * @returns {Promise}\n     * @private\n     */\n    async earmuff(earmuff) {\n        try {\n            if (this.me === null) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:self\");\n            }\n            else {\n                let type = \"audio:earmuff:off\";\n                if (earmuff) {\n                    type = \"audio:earmuff:on\";\n                }\n                const { response, } = await this.application.session.sendNetworkRequest({\n                    type: \"POST\",\n                    path: `conversations/${this.parentConversation.id}/events`,\n                    data: {\n                        type,\n                        to: this.parentConversation.me.id,\n                    },\n                });\n                return response;\n            }\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Enable media participation in the conversation for this application (requires WebRTC)\n     * @param {object} [params] - rtc params\n     * @param {string} [params.label] - label is an application defined tag, eg. ‘fullscreen’\n     * @param {string} [params.reconnectRtcId] - the rtc_id / leg_id of the call to reconnect to\n     * @param {object} [params.audio=true] - audio enablement mode. possible values \"both\", \"send_only\", \"receive_only\", \"none\", true or false\n     * @param {object} [params.autoPlayAudio=false] - attach the audio stream automatically to start playing after enable media (default false)\n     * @param {object} [params.audioConstraints] - audio constraints to use\n     * @param {boolean} [params.audioConstraints.autoGainControl] - a boolean which specifies whether automatic gain control is preferred and/or required\n     * @param {boolean} [params.audioConstraints.echoCancellation] - a boolean specifying whether or not echo cancellation is preferred and/or required\n     * @param {boolean} [params.audioConstraints.noiseSuppression] - a boolean which specifies whether noise suppression is preferred and/or required\n     * @param {string | Array} [params.audioConstraints.deviceId] - object specifying a device ID or an array of device IDs which are acceptable and/or required\n     * @returns {Promise<MediaStream>}\n     * @example <caption>Enable media in the Conversation</caption>\n     *\n     * conversation.media.enable()\n     * .then((stream) => {\n     *    const media = document.createElement(\"audio\");\n     *    const source = document.createElement(\"source\");\n     *    const media_div = document.createElement(\"div\");\n     *    media.appendChild(source);\n     *    media_div.appendChild(media);\n     *    document.insertBefore(media_div);\n     *    // Older browsers may not have srcObject\n     *    if (\"srcObject\" in media) {\n     *      media.srcObject = stream;\n     *    } else {\n     *      // Avoid using this in new browsers, as it is going away.\n     *      media.src = window.URL.createObjectURL(stream);\n     *    }\n     *    media.onloadedmetadata = (e) => {\n     *      media.play();\n     *    };\n     * }).catch((error) => {\n     *    console.error(error);\n     * });\n     *\n     **/\n    async enable(params) {\n        try {\n            if (this.parentConversation.me === null) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:self\");\n            }\n            else {\n                const { offer } = params !== null && params !== void 0 ? params : {};\n                let remoteStream = await (offer !== undefined ? this._execAnswer(params) : this._handleAudio(params));\n                // attach the audio stream automatically to start playing\n                let autoPlayAudio = params &&\n                    (params.autoPlayAudio || params.autoPlayAudio === undefined);\n                if (!params || autoPlayAudio) {\n                    rtc_helper_1.default.playAudioStream(remoteStream);\n                }\n                return remoteStream;\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    /**\n     * Disable media participation in the conversation for this application\n     * if RtcStats MOS is enabled, a final report will be available in\n     * NexmoClient#rtcstats:report\n     * @returns {Promise}\n     * @example <caption>Disable media in the Conversation</caption>\n     *\n     * conversation.media.disable()\n     * .then((response) => {\n     *   console.log(response);\n     * }).catch((error) => {\n     *   console.error(error);\n     * });\n     *\n     **/\n    disable() {\n        let promises = [];\n        promises.push(this._cleanConversationProperties());\n        for (const leg_id in this.rtcObjects) {\n            promises.push(this._disableLeg(leg_id));\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * Play a voice text in the Conversation\n     * @param {object} params\n     * @param {string} params.text - The text to say in the Conversation.\n     * @param {string} [params.voice_name=\"Amy\"] - Name of the voice to use for speech to text.\n     * @param {number} [params.level=1] - Set the audio level of the audio stream: min=-1 max=1 increment=0.1.\n     * @param {boolean} [params.queue=true] - ?\n     * @param {boolean} [params.loop=1] - The number of times to repeat audio. Set to 0 to loop infinitely.\n     * @param {boolean} [params.ssml=false] - Customize the spoken text with <a href=\"https://developer.nexmo.com/voice/voice-api/guides/customizing-tts\">Speech Synthesis Markup Language (SSML)</a> specification\n     *\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Play speech to text in the Conversation</caption>\n     * conversation.media.sayText({text:\"hi\"})\n     * .then((response) => {\n     *    console.log(response);\n     * })\n     * .catch((error) => {\n     *     console.error(error);\n     * });\n     *\n     **/\n    async sayText(params) {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:say\",\n                    cid: this.parentConversation.id,\n                    from: this.parentConversation.me.id,\n                    body: {\n                        text: params.text,\n                        voice_name: params.voice_name || \"Amy\",\n                        level: params.level || 1,\n                        queue: params.queue || true,\n                        loop: params.loop || 1,\n                        ssml: params.ssml || false,\n                    },\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send DTMF in the Conversation\n     * @param {string} digit - the DTMF digit(s) to send\n     *\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Send DTMF in the Conversation</caption>\n     * conversation.media.sendDTMF(\"digit\");\n     * .then((response) => {\n     *    console.log(response);\n     * })\n     * .catch((error) => {\n     *     console.error(error);\n     * });\n     **/\n    async sendDTMF(digit) {\n        try {\n            if (!utils_1.default.validateDTMF(digit)) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:audio:dtmf:invalid-digit\");\n            }\n            const rtc_id = (this._findRtcObjectByType('audio') || {}).rtc_id;\n            if (!rtc_id) {\n                throw new nexmoClientError_1.NexmoClientError(\"error:audio:dtmf:audio-disabled\");\n            }\n            const { id, timestamp, } = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:dtmf\",\n                    from: this.parentConversation.me.id,\n                    body: {\n                        digit,\n                        channel: {\n                            type: \"app\",\n                            id: this._findRtcObjectByType('audio').rtc_id\n                        }\n                    },\n                },\n            });\n            const placeholder_event = {\n                body: {\n                    digit,\n                    dtmf_id: \"\",\n                },\n                cid: this.parentConversation.id,\n                from: this.parentConversation.me.id,\n                id,\n                timestamp,\n                type: \"audio:dtmf\",\n            };\n            const dtmfEvent = new nxmEvent_1.default(this.parentConversation, placeholder_event);\n            this.parentConversation.events.set(placeholder_event.id, dtmfEvent);\n            return dtmfEvent;\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Play an audio stream in the Conversation\n     * @param {object} params\n     * @param {number} params.level - Set the audio level of the audio stream: min=-1 max=1 increment=0.1.\n     * @param {array} params.stream_url - Link to the audio file.\n     * @param {number} params.loop - The number of times to repeat audio. Set to 0 to loop infinitely.\n     *\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Play an audio stream in the Conversation</caption>\n     * conversation.media.playStream({ level: 0.5, stream_url: [\"https://nexmo-community.github.io/ncco-examples/assets/voice_api_audio_streaming.mp3\"], loop: 1 })\n     * .then((response) => {\n     *   console.log(\"response: \", response);\n     * })\n     * .catch((error) => {\n     *   console.error(\"error: \", error);\n     * });\n     *\n     */\n    async playStream(params) {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:play\",\n                    body: params,\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send start ringing event\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Send start ringing event in the Conversation</caption>\n     *\n     * conversation.media.startRinging()\n     * .then((response) => {\n     *    console.log(response);\n     * }).catch((error) => {\n     *    console.error(error);\n     * });\n     *\n     * // Listen for start ringing event\n     * conversation.on('audio:ringing:start', (data) => {\n     *    console.log(\"ringing started: \", data);\n     * });\n     *\n     */\n    async startRinging() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:ringing:start\",\n                    from: this.parentConversation.me.id,\n                    body: {},\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n    /**\n     * Send stop ringing event\n     * @returns {Promise<NXMEvent>}\n     * @example <caption>Send stop ringing event in the Conversation</caption>\n     *\n     * conversation.media.stopRinging()\n     * .then((response) => {\n     *    console.log(response);\n     * }).catch((error) => {\n     *    console.error(error);\n     * });\n     *\n     * // Listen for stop ringing event\n     * conversation.on('audio:ringing:stop', (data) => {\n     *    console.log(\"ringing stopped: \", data);\n     * });\n     *\n     */\n    async stopRinging() {\n        try {\n            const response = await this.application.session.sendNetworkRequest({\n                type: \"POST\",\n                path: `conversations/${this.parentConversation.id}/events`,\n                data: {\n                    type: \"audio:ringing:stop\",\n                    from: this.parentConversation.me.id,\n                    body: {},\n                },\n            });\n            return new nxmEvent_1.default(this.parentConversation, response);\n        }\n        catch (error) {\n            throw new nexmoClientError_1.NexmoApiError(error);\n        }\n    }\n}\nexports.default = Media;\nmodule.exports = Media;\n\n},{\"../application\":1,\"../conversation\":2,\"../events/nxmEvent\":5,\"../nexmoClientError\":20,\"../utils\":31,\"./rtc_helper\":18,\"loglevel\":63}],16:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  NXMCall Object Model\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_1 = require(\"loglevel\");\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtc_helper_1 = __importDefault(require(\"./rtc_helper\"));\n/**\n * Conversation NXMCall Object.\n * @class NXMCall\n * @param {Application} application - The Application object.\n * @param {Conversation} conversation - The Conversation object that belongs to this nxmCall.\n * @param {Member} from - The member that initiated the nxmCall.\n * @property {Application} application -  The Application object that the nxmCall belongs to.\n * @property {Conversation} conversation -  The Conversation object that belongs to this nxmCall.\n * @property {Member} from - The caller. The member object of the caller (not a reference to the one in conversation.members)\n * @property {Map<string, Member>} to - The callees keyed by a member's id. The members that receive the nxmCall (not a reference to conversation.members)\n * @property {String} id - The nxmCall id (our member's leg_id, comes from rtc:answer event, or member:media)\n * @property {NXMCall.CALL_STATUS} CALL_STATUS=\"started\" - the available nxmCall statuses\n * @property {NXMCall.CALL_DIRECTION} direction - the Direction of the nxmCall, Outbound, Inbound\n * @property {NXMCall.STATUS_PERMITTED_FLOW} STATUS_PERMITTED_FLOW - the permitted nxmCall status transition map, describes the \"from\" and allowed \"to\" transitions\n * @property {object[]} rtcObjects data related to the rtc connection\n * @property {string} rtcObjects.rtc_id the rtc_id\n * @property {PeerConnection} rtcObjects.pc the current PeerConnection object\n * @property {Stream} rtcObjects.stream the stream of the specific rtc_id\n * @property {string} [rtcObjects.type] audio the type of the stream\n * @property {number} rtcObjects.streamIndex the index number of the stream (e.g. use to mute)\n * @property {Stream} stream the remote stream\n * @emits Application#member:call\n * @emits Application#call:status:changed\n*/\n/**\n * Application listening for member call events.\n *\n * @event Application#member:call\n *\n * @property {Member} member - the member that initiated the nxmCall\n * @property {NXMCall} nxmCall -  resolves the nxmCall object\n *\n * @example <caption>listen for member call events on Application level</caption>\n *  application.on(\"member:call\", (member, nxmCall) => {\n *    console.log(\"NXMCall \", nxmCall);\n *  });\n*/\n/**\n * Application listening for nxmCall status changed events.\n *\n * @event Application#call:status:changed\n * @property {NXMCall} nxmCall -  the actual event\n * @example <caption>listen for nxmCall status changed events on Application level</caption>\n *  application.on(\"call:status:changed\",(nxmCall) => {\n *    console.log(\"call: \" + nxmCall.status);\n *  });\n*/\nclass NXMCall {\n    constructor(application, conversation, from) {\n        this.application = application;\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.from = from;\n        this.conversation = null;\n        this.rtcObjects = {};\n        /**\n         * Enum for NXMCall status.\n         * @readonly\n         * @enum {string}\n         * @alias NXMCall.CALL_STATUS\n        */\n        this.CALL_STATUS = {\n            /** The NXMCall is in started status */\n            STARTED: 'started',\n            /** The NXMCall is in ringing status */\n            RINGING: 'ringing',\n            /** The NXMCall is in answered status */\n            ANSWERED: 'answered',\n            /** The NXMCall is in completed status */\n            COMPLETED: 'completed',\n            /** The NXMCall is in busy status */\n            BUSY: 'busy',\n            /** The NXMCall is in timeout status */\n            TIMEOUT: 'timeout',\n            /** The NXMCall is in unanswered status */\n            UNANSWERED: 'unanswered',\n            /** The NXMCall is in rejected status */\n            REJECTED: 'rejected',\n            /** The NXMCall is in failed status */\n            FAILED: 'failed'\n        };\n        /**\n         * Enum for NXMCall direction.\n         * @readonly\n         * @enum {string}\n         * @alias NXMCall.CALL_DIRECTION\n        */\n        this.CALL_DIRECTION = {\n            /** The NXMCall started from another end */\n            INBOUND: 'inbound',\n            /** The NXMCall started from this client */\n            OUTBOUND: 'outbound'\n        };\n        Object.freeze(this.CALL_DIRECTION);\n        /**\n         * Enum for the permitted call status transition.\n         * @readonly\n         * @alias NXMCall.STATUS_PERMITTED_FLOW\n         * @enum {Map<string, Set<NXMCall.CALL_STATUS>>}\n        */\n        this.STATUS_PERMITTED_FLOW = new Map([\n            /** Permitted transition array from STARTED  */\n            ['STARTED', new Set([\n                    this.CALL_STATUS.RINGING,\n                    this.CALL_STATUS.ANSWERED,\n                    this.CALL_STATUS.FAILED,\n                    this.CALL_STATUS.TIMEOUT,\n                    this.CALL_STATUS.UNANSWERED,\n                    this.CALL_STATUS.REJECTED,\n                    this.CALL_STATUS.BUSY\n                ])],\n            /** Permitted transition array from RINGING  */\n            ['RINGING', new Set([\n                    this.CALL_STATUS.ANSWERED,\n                    this.CALL_STATUS.FAILED,\n                    this.CALL_STATUS.TIMEOUT,\n                    this.CALL_STATUS.UNANSWERED,\n                    this.CALL_STATUS.REJECTED,\n                    this.CALL_STATUS.BUSY\n                ])],\n            /** Permitted transition set from ANSWERED  */\n            ['ANSWERED', new Set([\n                    this.CALL_STATUS.COMPLETED,\n                    this.CALL_STATUS.FAILED\n                ])]\n        ]);\n        Object.freeze(this.STATUS_PERMITTED_FLOW);\n        this.status = null;\n        this.call_disconnect_timeout = null;\n        this.direction = this.CALL_DIRECTION.INBOUND;\n        this._setupConversationObject(conversation);\n        WildEmitter.mixin(NXMCall);\n    }\n    /**\n     * Enable NXMCall stats to be emitted in\n   * - application.inAppCall.on('rtcstats:report')\n   * - application.inAppCall.on('rtcstats:analytics')\n     * @private\n    */\n    _enableStatsEvents() {\n        this.conversation.media._enableStatsEvents();\n    }\n    /**\n     * Attach member event listeners from the conversation\n     * @private\n    */\n    _attachCallListeners() {\n        // Conversation level listeners\n        this.log.debug(\"_attachCallListeners : \", { nxmCall: this });\n        try {\n            this.conversation.releaseGroup('call_module');\n            this.conversation.on('member:media', 'call_module', (from, event) => {\n                if (this.application.calls && this.application.calls.has(this.conversation.id)) {\n                    this.application.calls.get(this.conversation.id)._handleStatusChange(event);\n                }\n            });\n        }\n        catch (e) {\n            this.log.error(\"_attachCallListeners_error: \", { e });\n        }\n    }\n    /**\n     * Validate the current nxmCall status transition\n     * If a transition is not defined, return false\n     * @param {string} status the status to validate\n     * @returns {boolean} false if the transition is not permitted\n     * @private\n    */\n    _isValidStatusTransition(status) {\n        if (!status) {\n            throw new nexmoClientError_1.NexmoClientError(`Provide the status to validate the transition from '${this.status}'`);\n        }\n        // if the nxmCall object is just initialised allow any state\n        if (!this.status) {\n            return true;\n        }\n        const current_status = this.status.toUpperCase();\n        if (!this.STATUS_PERMITTED_FLOW.has(current_status)) {\n            return false;\n        }\n        if (this.status === status) {\n            return false;\n        }\n        return (this.STATUS_PERMITTED_FLOW.get(current_status).has(status));\n    }\n    /**\n     * Go through the members of the conversation and if .me is the only one (JOINED or INVITED)\n     * nxmCall nxmCall.hangUp().\n     * @returns {Promise} - empty promise or the nxmCall.hangUp promise chain\n    */\n    hangUpIfAllLeft() {\n        this.log.debug(\"hangUpIfAllLeft: \", { nxmCall: this });\n        if (!this.conversation.me || this.conversation.me.state === 'LEFT' || this.conversation.members.size <= 1) {\n            return Promise.resolve();\n        }\n        for (let member of this.conversation.members.values()) {\n            if (member.state !== 'LEFT' && (this.conversation.me.user.id !== member.user.id)) {\n                return Promise.resolve();\n            }\n        }\n        return this.hangUp();\n    }\n    /**\n     * Set the conversation object of the NXMCall\n     * update nxmCall.from, and nxmCall.to attributes based on the conversation members\n     * @private\n    */\n    _setupConversationObject(conversation, rtc_id) {\n        if (!conversation)\n            return;\n        this.conversation = conversation;\n        if (!conversation.me) {\n            this.log.warn('missing own member object');\n        }\n        else {\n            this.to = new Map(conversation.members);\n            if (this.from) {\n                this.to.delete(this.from.id);\n            }\n        }\n        // Attch Conversation Listeners\n        this._attachCallListeners();\n    }\n    /**\n     * Set the from object of the NXMCall\n     * @private\n    */\n    _setFrom(from) {\n        this.from = from;\n    }\n    /**\n     * Set the from object of the NXMCall\n     * @private\n    */\n    _setOffer(offer) {\n        this.offer = offer;\n    }\n    /**\n     * Process raw events to figure out the nxmCall status\n     * @private\n    */\n    _handleStatusChange(event) {\n        var _a;\n        // for knocking case the conversation object is not yet set in the nxmCall. We know the action is initiated from us\n        const _isEventFromMe = (this.conversation) ? ((_a = this.conversation.me) === null || _a === void 0 ? void 0 : _a.id) === event.from : true;\n        const _isOutbound = this.direction === this.CALL_DIRECTION.OUTBOUND;\n        this.log.debug(\"_handleStatusChange: \", { event }, `_isEventFromMe: ${_isEventFromMe} _isOutbound: ${_isOutbound}`);\n        let _handleStatusChangeMap = new Map();\n        _handleStatusChangeMap.set('member:joined', async () => {\n            if (event.body.channel && event.body.channel.id) {\n                try {\n                    this._setStatusAndEmit(this.CALL_STATUS.STARTED);\n                    return;\n                }\n                catch (error) {\n                    this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n                    this.log.error(error);\n                    throw error;\n                }\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('member:invited', () => {\n            if (event.body.invited_by === null &&\n                event.body.user.media &&\n                event.body.user.media.audio_settings) {\n                this._setStatusAndEmit(this.CALL_STATUS.STARTED);\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('rtc:hangup', () => {\n            if (this.status === this.CALL_STATUS.ANSWERED) {\n                this._setStatusAndEmit(this.CALL_STATUS.COMPLETED);\n                return Promise.resolve();\n            }\n            else {\n                if (_isEventFromMe && _isOutbound || !_isEventFromMe && !_isOutbound) {\n                    this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n                    return Promise.resolve();\n                }\n                else {\n                    this._setStatusAndEmit(this.CALL_STATUS.REJECTED);\n                    return Promise.resolve();\n                }\n            }\n        });\n        _handleStatusChangeMap.set('member:left', () => {\n            if (!event.body.timestamp.hasOwnProperty('joined') && this.status !== this.CALL_STATUS.ANSWERED) {\n                if (_isEventFromMe && _isOutbound || !_isEventFromMe && !_isOutbound) {\n                    this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n                    return Promise.resolve();\n                }\n                else {\n                    this._setStatusAndEmit(this.CALL_STATUS.REJECTED);\n                    return Promise.resolve();\n                }\n            }\n        });\n        _handleStatusChangeMap.set('member:media', () => {\n            if (this.status !== this.CALL_STATUS.ANSWERED && event.body.audio) {\n                if (_isEventFromMe && event.body.channel) {\n                    this.id = event.body.channel.id;\n                }\n                if ((!_isEventFromMe || !_isOutbound) && this.id) {\n                    this._setStatusAndEmit(this.CALL_STATUS.ANSWERED);\n                }\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('sip:ringing', () => {\n            if (this.status !== this.CALL_STATUS.RINGING) {\n                this._setStatusAndEmit(this.CALL_STATUS.RINGING);\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('sip:hangup', () => {\n            switch (event.body.reason.sip_code) {\n                case 486:\n                    this._setStatusAndEmit(this.CALL_STATUS.BUSY);\n                    break;\n                case 487:\n                    this._setStatusAndEmit(this.CALL_STATUS.TIMEOUT);\n                    break;\n                case 403:\n                    this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n                    break;\n            }\n            return Promise.resolve();\n        });\n        _handleStatusChangeMap.set('knocking:delete:success', () => {\n            this._setStatusAndEmit(this.CALL_STATUS.UNANSWERED);\n            return Promise.resolve();\n        });\n        if (_handleStatusChangeMap.has(event.type)) {\n            return _handleStatusChangeMap.get(event.type).call(this);\n        }\n    }\n    /**\n     * Set the nxmCall.status and emit a call:status:changed event\n     *\n     * @param {NXMCall.CALL_STATUS} this.CALL_STATUS the canxmCallll status to set\n     * @emits Application#call:status:changed\n     * @private\n    */\n    _setStatusAndEmit(status) {\n        if (!this._isValidStatusTransition(status)) {\n            return;\n        }\n        this.status = status;\n        this.log.debug(`_setStatusAndEmit: ${status}`, { nxmCall: this });\n        this.application.emit('call:status:changed', this);\n    }\n    /**\n     * Answers an incoming nxmCall\n     * Join the conversation that you are invited\n     * Create autoplay Audio object\n     *\n   * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true)\n     * @returns {Promise<Audio>}\n    */\n    async answer(autoPlayAudio = true) {\n        this.log.debug(`answer: { autoPlayAudio: ${autoPlayAudio}`);\n        if (this.conversation) {\n            try {\n                await this.conversation.join();\n                const stream = await this.conversation.media.enable({ autoPlayAudio, offer: this.offer });\n                this.offer = undefined;\n                return stream;\n            }\n            catch (error) {\n                this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n                this.log.error(error);\n                throw error;\n            }\n        }\n        else {\n            throw new nexmoClientError_1.NexmoClientError('error:call:answer');\n        }\n    }\n    /**\n     * Trigger the nxmCall flow for the input users.\n     * Create a conversation with prefix name \"CALL_\"\n     * and invite all the users.\n     * If at least one user is successfully invited, enable the audio.\n     *\n     * @param {string[]} usernames the usernames of the users to call\n   * @param {boolean} [autoPlayAudio=true] attach the audio stream automatically to start playing (default true)\n     * @returns {Promise[]} an array of the invite promises for the provided usernames\n     * @private\n    */\n    async createCall(usernames, autoPlayAudio = true) {\n        this.log.debug(`createCall: { usernames: ${usernames}, autoPlayAudio: ${autoPlayAudio} }`);\n        if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:application:call:params'));\n        }\n        try {\n            const conversation = await this.application.newConversationAndJoin({ display_name: 'CALL_' + this.application.me.name + '_' + usernames.join('_').replace(' ', '') });\n            conversation.members.set(conversation.me.id, conversation.me);\n            this.from = conversation.me;\n            this.successful_invited_members = new Map();\n            const invites = usernames.map(async (username) => {\n                // check all invites, if at least one is resolved enable audio\n                // we need to catch rejections to allow all the chain to go through (all invites)\n                // we then catch-reject a promise so that the errors are passing through the end of the chain\n                try {\n                    const member = await conversation.inviteWithAudio({ user_name: username });\n                    conversation.members.set(member.id, member);\n                    this.successful_invited_members.set(member.id, member);\n                    return member;\n                }\n                catch (error) {\n                    this.log.error(error);\n                    // resolve the error to allow the promise.all to collect\n                    // and return all the promises\n                    return error;\n                }\n            });\n            // helper function to process in Promise.all() the failed invites too\n            const process_invites = async () => {\n                if (this.successful_invited_members.size > 0) {\n                    await conversation.media.enable({\n                        audio: {\n                            muted: false,\n                            earmuffed: false\n                        },\n                        autoPlayAudio\n                    });\n                    this.application.calls.set(conversation.id, this);\n                    return invites;\n                }\n                else {\n                    throw invites;\n                }\n            };\n            // we need to continue the invites even if one fails,\n            // in process_invites we do the check if at least one was successful\n            await Promise.all(invites);\n            this._setupConversationObject(conversation);\n            return await process_invites();\n        }\n        catch (error) {\n            this.log.error(error);\n            this._setStatusAndEmit(this.CALL_STATUS.FAILED);\n            throw error;\n        }\n    }\n    /**\n     * Trigger the nxmCall flow for the phone call.\n     * Create a knocking event\n     *\n     * @param {string} user the phone number or the username to call\n   * @param {string} type the type of the call you want to have. possible values \"phone\" or \"app\" (default is \"phone\")\n     * @returns {Promise}\n     * @private\n    */\n    async createServerCall(user, type, custom_data) {\n        this.log.debug(`createServerCall: { user: ${user}, type: ${type}, custom_data: `, { custom_data });\n        const to = {\n            type\n        };\n        if (type === 'phone') {\n            to.number = user;\n        }\n        else {\n            to.user = user;\n        }\n        try {\n            // PrewarmLeg\n            const { stream, legId, rtcObjects } = await rtc_helper_1.default.prewarmLeg(this);\n            this.log.debug(\"createServerCall: \", { stream }, { legId }, { rtcObjects });\n            // Add Media to the Call Object\n            this.rtcObjects = rtcObjects;\n            this.stream = stream;\n            this.id = legId;\n            // Add leg_id to the call draft list\n            this.application._call_draft_list.set(legId, this);\n            rtc_helper_1.default.playAudioStream(stream);\n            const params = {\n                type: 'POST',\n                path: 'knocking',\n                data: {\n                    channel: {\n                        type: 'app',\n                        from: { type: 'app' },\n                        to,\n                        id: legId || null\n                    },\n                    ...(custom_data && Object.keys(custom_data).length && { properties: { custom_data } })\n                }\n            };\n            try {\n                const knockingResponse = await this.application.session.sendNetworkRequest(params);\n                this.knocking_id = knockingResponse.id;\n            }\n            catch (error) {\n                throw new nexmoClientError_1.NexmoApiError(error);\n            }\n            // If knocking request doesn't result in member:joined after set time disable audio, cleanup media\n            rtc_helper_1.default.cleanCallMediaIfFailed(this);\n            return stream;\n        }\n        catch (error) {\n            // If knocking request fails disable audio, cleanup media\n            rtc_helper_1.default.cleanMediaProperties(this);\n            throw error;\n        }\n    }\n    /**\n     * Hangs up the nxmCall\n     *\n     * If there is a knocking active, do a knocking:delete\n     * otherwise\n     * Leave from the conversation\n     * Disable the audio\n     *\n   * @param {object} [reason] the reason for hanging up the nxmCall\n   * @param {string} [reason.reason_code] the code of the reason\n   * @param {string} [reason.reason_text] the description of the reason\n     * @returns {Promise}\n    */\n    async hangUp(reason) {\n        this.log.debug(`hangUp: { reason: ${reason} }`);\n        if (this.conversation) {\n            await this.conversation.media.disable();\n        }\n        if (!this.knocking_id && this.conversation) {\n            return this.conversation.leave(reason).catch(error => {\n                if (error.type !== \"conversation:error:invalid-member-state\") {\n                    return Promise.reject(error);\n                }\n                return;\n            });\n        }\n        else {\n            let path = `knocking/${this.knocking_id}`;\n            if (reason) {\n                let params = new URLSearchParams();\n                Object.keys(reason).forEach((key) => {\n                    params.append(key, reason[key]);\n                });\n                path += `?${params.toString()}`;\n            }\n            try {\n                const response = await this.application.session.sendNetworkRequest({\n                    type: 'DELETE',\n                    path\n                });\n                const nxmCall = this.application._call_draft_list.get(this.client_ref);\n                nxmCall._handleStatusChange(response);\n                this.application._call_draft_list.delete(this.client_ref);\n                return response;\n            }\n            catch (error) {\n                // Don't switch yet to fail status, it could be an expected race between knocking:delete and conversation.leave\n                if (!this.conversation) {\n                    this.log.debug('hangup: Problem cancelling the call. Knocking cancel failed and Conversation. Leave not available', error);\n                    return;\n                }\n                else {\n                    this.log.error(new nexmoClientError_1.NexmoApiError(error));\n                    return this.conversation.leave(reason).catch(error => {\n                        if (error.type !== \"conversation:error:invalid-member-state\") {\n                            return Promise.reject(error);\n                        }\n                        return;\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Rejects an incoming nxmCall\n     * Leave from the conversation that you are invited\n     *\n   * @param {object} [reason] the reason for rejecting the nxmCall\n   * @param {string} [reason.reason_code] the code of the reason\n   * @param {string} [reason.reason_text] the description of the reason\n     * @returns {Promise}\n    */\n    reject(reason) {\n        this.log.debug(`reject: { reason: ${reason} }`);\n        if (this.conversation) {\n            return this.conversation.leave(reason);\n        }\n        else {\n            return Promise.reject(new nexmoClientError_1.NexmoClientError('error:call:reject'));\n        }\n    }\n}\nexports.default = NXMCall;\nmodule.exports = NXMCall;\n\n},{\"../nexmoClientError\":20,\"./rtc_helper\":18,\"loglevel\":63,\"wildemitter\":107}],17:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_ip_1 = __importDefault(require(\"is-ip\"));\nclass CancelError extends Error {\n    constructor() {\n        super('Request was cancelled');\n        this.name = 'CancelError';\n    }\n    get isCanceled() {\n        return true;\n    }\n}\nconst defaults = {\n    timeout: 5000\n};\nconst urls = {\n    v4: [\n        'https://ipv4.icanhazip.com/',\n        'https://api.ipify.org/'\n    ],\n    v6: [\n        'https://ipv6.icanhazip.com/',\n        'https://api6.ipify.org/'\n    ]\n};\nconst sendXhr = (url, options, version) => {\n    const xhr = new XMLHttpRequest();\n    let _reject;\n    const promise = new Promise((resolve, reject) => {\n        _reject = reject;\n        xhr.addEventListener('error', reject, { once: true });\n        xhr.addEventListener('timeout', reject, { once: true });\n        xhr.addEventListener('load', () => {\n            const ip = xhr.responseText.trim();\n            if (!ip || version === 'v4' ? !is_ip_1.default.v4(ip) : !is_ip_1.default.v6(ip)) {\n                reject();\n                return;\n            }\n            resolve(ip);\n        }, { once: true });\n        xhr.open('GET', url);\n        xhr.timeout = options.timeout;\n        xhr.send();\n    });\n    // promise.cancel = () => {\n    // \txhr.abort();\n    // \t_reject(new CancelError());\n    // };\n    return promise;\n};\nconst queryHttps = (version, options) => {\n    let request;\n    const promise = (async function () {\n        const urls_ = [].concat.apply(urls[version], options.fallbackUrls || []);\n        for (const url of urls_) {\n            try {\n                request = sendXhr(url, options, version);\n                const ip = await request;\n                return ip;\n            }\n            catch (error) {\n                if (error instanceof CancelError) {\n                    throw error;\n                }\n            }\n        }\n        throw new Error('Couldn\\'t find your IP');\n    })();\n    // promise.cancel = () => {\n    // \trequest.cancel();\n    // };\n    return promise;\n};\nclass PublicIp {\n}\nexports.default = PublicIp;\nPublicIp.v4 = (options) => queryHttps('v4', { ...defaults, ...options });\nPublicIp.v6 = (options) => queryHttps('v6', { ...defaults, ...options });\nmodule.exports = PublicIp;\n\n},{\"is-ip\":61}],18:[function(require,module,exports){\n'use strict';\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n */\nrequire('webrtc-adapter');\nconst sdptransform = require('sdp-transform');\nconst loglevel_1 = require(\"loglevel\");\nconst browserDetect = __importStar(require(\"detect-browser\"));\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\nconst rtcstats_analytics_1 = __importDefault(require(\"./rtcstats_analytics\"));\nconst clearingTimeout = 20000;\n/**\n * RTC helper object for accessing webRTC API.\n * @class RtcHelper\n * @private\n*/\nclass RtcHelper {\n    constructor() {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n    }\n    static getUserAudio(audioConstraints = true) {\n        let constraintsToUse = {\n            video: false,\n            audio: audioConstraints\n        };\n        return navigator.mediaDevices.getUserMedia(constraintsToUse);\n    }\n    createRTCPeerConnection(config) {\n        const pc = new RTCPeerConnection(config);\n        // attaching the .trace to make easier the stats reporting implementation\n        pc.trace = () => {\n            return;\n        };\n        return pc;\n    }\n    _getWindowLocationProtocol() {\n        return window.location.protocol;\n    }\n    static _getBrowserName() {\n        return browserDetect.detect().name;\n    }\n    static isNode() {\n        return this._getBrowserName() === 'node';\n    }\n    /**\n      * Check if the keys in an object are found in another object\n    */\n    checkValidKeys(object, defaultObject) {\n        let valid = true;\n        Object.keys(object).forEach((key) => {\n            if (!defaultObject.hasOwnProperty(key)) {\n                valid = false;\n            }\n            ;\n        });\n        return valid;\n    }\n    ;\n    static cleanCallMediaIfFailed(call) {\n        setTimeout(() => {\n            if (!call.conversation) {\n                this.cleanMediaProperties(call);\n                call.status = call.CALL_STATUS.FAILED;\n                call.application.emit('call:status:changed', call);\n            }\n        }, 5000);\n    }\n    static callDisconnectHandler(call, pc) {\n        const callStatus = [call.CALL_STATUS.ANSWERED, call.CALL_STATUS.STARTED, call.CALL_STATUS.RINGING];\n        if (pc.connectionState !== 'disconnected' || !call || !call.conversation)\n            return;\n        // Timeout and wait for FS 20 seconds on backend until normal clearing\n        return setTimeout(() => {\n            if (pc.connectionState === 'connected' || callStatus.indexOf(call.status) == -1)\n                return;\n            this.cleanMediaProperties(call);\n            call.status = call.CALL_STATUS.COMPLETED;\n            call.application.emit('call:status:changed', call);\n        }, clearingTimeout);\n    }\n    static cleanMediaProperties(call) {\n        if (call.rtcObjects) {\n            for (const leg_id in call.rtcObjects) {\n                call.rtcObjects[leg_id].pc.close();\n                delete call.rtcObjects[leg_id].pc;\n                RtcHelper.closeStream(call.rtcObjects[leg_id].stream);\n            }\n        }\n        call.application.activeStreams = [];\n        call.rtcObjects = {};\n        if (call.conversation && call.conversation.media)\n            call.conversation.media.rtcStats = null;\n    }\n    static playAudioStream(stream) {\n        const audio = new Audio();\n        audio.srcObject = stream;\n        audio.autoplay = true;\n        return audio;\n    }\n    // Media methods\n    static createDummyCandidateSDP(pc) {\n        const candidate = {\n            foundation: 1176891032,\n            component: 1,\n            transport: 'udp',\n            priority: 2122260223,\n            ip: '0.0.0.0',\n            port: 9,\n            type: 'host',\n            generation: 0,\n            'network-id': 1,\n            'network-cost': 50\n        };\n        const sdpNewObj = sdptransform.parse(pc.localDescription.sdp);\n        sdpNewObj.media[0].candidates = [candidate];\n        return sdptransform.write(sdpNewObj);\n    }\n    static createRTCPeerConnectionConfig(application) {\n        return {\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'balanced',\n            rtcpMuxPolicy: 'require',\n            iceCandidatePoolSize: '0',\n            ...(application.session.config &&\n                application.session.config.iceServers && {\n                iceServers: application.session.config.iceServers\n            })\n        };\n    }\n    static createPeerConnection(application) {\n        const pc_config = this.createRTCPeerConnectionConfig(application);\n        const pc = new RTCPeerConnection(pc_config);\n        return pc;\n    }\n    static sendOffer(application, pc, conversation, reconnectRtcId) {\n        const sdp = this.createDummyCandidateSDP(pc);\n        const offer = { sdp };\n        let data = {\n            from: conversation.me.id,\n            body: { offer }\n        };\n        let path = `conversations/${conversation.id}/rtc`;\n        if (reconnectRtcId) {\n            path += `/${reconnectRtcId}/offer`;\n        }\n        return application.session.sendNetworkRequest({\n            type: 'POST',\n            path,\n            data\n        });\n    }\n    ;\n    static sendAnswer(application, pc, conversation, leg_id) {\n        const answer = this.createDummyCandidateSDP(pc);\n        let data = {\n            from: conversation.me.id,\n            body: { answer }\n        };\n        let path = `conversations/${conversation.id}/rtc/${leg_id}/answer`;\n        return application.session.sendNetworkRequest({\n            type: 'POST',\n            path,\n            data\n        });\n    }\n    ;\n    static createLeg(application, pc) {\n        const sdpOfferNew = this.createDummyCandidateSDP(pc);\n        const offer = { sdp: sdpOfferNew, type: \"offer\" };\n        return application.session.sendNetworkRequest({\n            type: 'POST',\n            path: `legs`,\n            version: `beta`,\n            data: {\n                body: {\n                    offer\n                }\n            }\n        });\n    }\n    static closeStream(stream) {\n        stream.getTracks().forEach((track) => {\n            track.stop();\n        });\n    }\n    static emitMediaStream(member, pc, stream) {\n        member.emit(\"media:stream:on\", {\n            pc,\n            stream,\n            type: \"audio\",\n            streamIndex: 0\n        });\n    }\n    static _initStatsEvents(context) {\n        var _a, _b, _c;\n        if (RtcHelper.isNode())\n            return;\n        if ((_c = (_b = (_a = context === null || context === void 0 ? void 0 : context.application) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.rtcstats) {\n            const config = context.application.session.config.rtcstats;\n            const { emit_events, remote_collection, emit_rtc_analytics, } = config;\n            if (emit_events || remote_collection || emit_rtc_analytics) {\n                const params = { ...context, config: { ...config } };\n                return new rtcstats_analytics_1.default(params);\n            }\n        }\n    }\n    static attachConversationEventHandlers(context) {\n        const { conversation, pc, log } = context;\n        // We want to be able to handle these events, for this  member, before they get propagated out\n        conversation.once(\"rtc:answer\", (event) => {\n            if (!pc) {\n                log.warn(\"RTC: received an answer too late\");\n                return;\n            }\n            pc.setRemoteDescription(new RTCSessionDescription({\n                type: \"answer\",\n                sdp: event.body.answer,\n            }));\n        });\n    }\n    static doAnswer(context, offer, leg_id) {\n        const { application, conversation, pc, reject, localStream } = context;\n        this.addPeerConnectionListeners(context, () => RtcHelper.sendAnswer(application, pc, conversation, leg_id).then(() => ({ rtc_id: leg_id })));\n        pc.setRemoteDescription(new RTCSessionDescription({ type: \"offer\", sdp: offer }))\n            .then(() => pc.createAnswer())\n            .then((sessionDescription) => pc.setLocalDescription(sessionDescription))\n            .catch((err) => {\n            if (localStream)\n                this.closeStream(localStream);\n            reject(err);\n        });\n    }\n    static attachPeerConnectionEventHandlers(context) {\n        const { application, conversation, pc, reconnectRtcId } = context;\n        this.addPeerConnectionListeners(context, () => RtcHelper.sendOffer(application, pc, conversation, reconnectRtcId));\n    }\n    static addPeerConnectionListeners(context, description_handler) {\n        const { application, conversation, pc, streamIndex, localStream, log, rtcObjects, resolve, reject } = context;\n        let stream;\n        let stop_ice_gathering = false;\n        let nxmCall;\n        if (conversation.id) {\n            nxmCall = application.calls.get(conversation.id);\n        }\n        pc.ontrack = (evt) => {\n            stream = evt.streams[0];\n            application.activeStreams.push(stream);\n            RtcHelper.emitMediaStream(conversation.me, pc, stream);\n        };\n        pc.onconnectionstatechange = (_) => this.onconnectionstatechangeHandler(pc, log, nxmCall, () => resolve(stream), () => reject());\n        pc.onnegotiationneeded = () => this.onnegotiationneededHandler(pc, (nexmoError) => reject(nexmoError));\n        pc.oniceconnectionstatechange = (connection_event) => this.oniceconnectionstatechange(connection_event, pc, log, (nexmoError) => reject(nexmoError));\n        pc.onicecandidate = async (event) => {\n            if (event.candidate && !stop_ice_gathering && pc) {\n                stop_ice_gathering = true;\n                try {\n                    const { rtc_id } = await description_handler();\n                    RtcHelper._initStatsEvents({\n                        application,\n                        rtc_id,\n                        pc,\n                        conversation\n                    });\n                    //attach rtc stats with rtc_id\n                    if (pc.trace)\n                        pc.trace(\"rtc_id\", rtc_id);\n                    rtcObjects[rtc_id] = {\n                        rtc_id,\n                        pc,\n                        stream: localStream,\n                        type: \"audio\",\n                        streamIndex: streamIndex,\n                    };\n                }\n                catch (error) {\n                    if (localStream)\n                        this.closeStream(localStream);\n                    reject(new nexmoClientError_1.NexmoClientError(error));\n                }\n            }\n        };\n        localStream.getTracks().forEach((track) => pc.addTrack(track));\n    }\n    static prewarmLeg(nxmCall) {\n        const application = nxmCall.application;\n        return new Promise(async (resolve, reject) => {\n            let offer_sent = false;\n            let stream;\n            let legId;\n            let rtcObjects = {};\n            const log = loglevel_1.getLogger(this.constructor.name);\n            try {\n                let localStream = await this.getUserAudio();\n                const pc = this.createPeerConnection(application);\n                // create call\n                pc.ontrack = (evt) => {\n                    stream = evt.streams[0];\n                    application.activeStreams.push(stream);\n                };\n                pc.onconnectionstatechange = (event) => this.onconnectionstatechangeHandler(pc, log, nxmCall, () => resolve({ stream, legId, rtcObjects }), () => reject());\n                pc.onnegotiationneeded = () => this.onnegotiationneededHandler(pc, (nexmoError) => reject(nexmoError));\n                pc.oniceconnectionstatechange = (connection_event) => this.oniceconnectionstatechange(connection_event, pc, log, (nexmoError) => reject(nexmoError));\n                pc.onicecandidate = async (event) => {\n                    if (event.candidate && !offer_sent && pc) {\n                        offer_sent = true;\n                        const { rtc_id, sdp } = await this.createLeg(application, pc);\n                        RtcHelper._initStatsEvents({\n                            application,\n                            rtc_id,\n                            pc,\n                        });\n                        legId = rtc_id;\n                        rtcObjects[legId] = {\n                            rtc_id,\n                            pc,\n                            stream: localStream,\n                            type: \"audio\",\n                            streamIndex: 1,\n                        };\n                        return pc.setRemoteDescription(new RTCSessionDescription({\n                            type: \"answer\",\n                            sdp,\n                        }));\n                    }\n                };\n                localStream.getTracks().forEach((track) => pc.addTrack(track));\n            }\n            catch (error) {\n                reject(new nexmoClientError_1.NexmoClientError(error));\n            }\n        });\n    }\n}\nexports.default = RtcHelper;\nRtcHelper.onconnectionstatechangeHandler = (pc, log, nxmCall, resolveCallback, rejectCallback) => {\n    switch (pc.connectionState) {\n        case \"connected\":\n            log.info(\"The connection has become fully connected\");\n            resolveCallback();\n            break;\n        case \"disconnected\":\n            if (!nxmCall)\n                break;\n            if (nxmCall.call_disconnect_timeout) {\n                clearTimeout(nxmCall.call_disconnect_timeout);\n            }\n            nxmCall.call_disconnect_timeout = RtcHelper.callDisconnectHandler(nxmCall, pc);\n            break;\n        case \"failed\":\n            rejectCallback();\n            log.info(\"One or more transports has terminated unexpectedly or in an error\");\n            break;\n        case \"closed\":\n            log.info(\"The connection has been closed\");\n            break;\n    }\n};\nRtcHelper.oniceconnectionstatechange = (connection_event, pc, log, rejectCallback) => {\n    switch (pc.iceConnectionState) {\n        // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState\n        case \"disconnected\":\n            log.warn(\"One or more transports is disconnected\", pc.iceConnectionState);\n            break;\n        case \"failed\":\n            rejectCallback(new nexmoClientError_1.NexmoClientError(connection_event));\n            log.warn(\"One or more transports has terminated unexpectedly or in an error\", connection_event);\n            break;\n        default:\n            log.info(\"The ice connection status changed\", pc.iceConnectionState);\n    }\n};\nRtcHelper.onnegotiationneededHandler = async (pc, rejectCallback) => {\n    try {\n        const offer = await pc.createOffer();\n        return pc.setLocalDescription(offer);\n    }\n    catch (error) {\n        rejectCallback(new nexmoClientError_1.NexmoClientError(error));\n    }\n};\nmodule.exports = RtcHelper;\n\n},{\"../nexmoClientError\":20,\"./rtcstats_analytics\":19,\"detect-browser\":38,\"loglevel\":63,\"sdp-transform\":72,\"webrtc-adapter\":92}],19:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rtcStatsAdapterParser = require(\"rtc-stats-adapter\");\nconst calculateMos = require('rtc-stats-adapter/calculate-mos');\nconst utils_1 = __importDefault(require(\"../utils\"));\n/**\n * Collect WebRTC Report data\n * Removes credential information from the STUN.TURN server configuration.\n * performs Delta compression\n *\n * if isCallback is true the report includes a MOS score : trace('mos', mos, report);\n *\n * @param {object} context\n * @param {Application} context.application\n * @param {Conversation} context.conversation\n * @param {RTCPeerConnection} context.pc peer connection object\n * @param {string} context.rtc_id id of a leg\n * @param {RTCStatsConfig} context.config config settings for ananlytics\n * @property {MosReport} mos_report the final mos report to be sent when the stream is closed\n * @property {number} _reportsCount the number of reports taken for mos average\n * @property {number} _mosSum the summary of mos scores\n * @private\n */\nclass RTCStatsAnalytics {\n    constructor(context) {\n        this.mos_report = { min: 5, max: 0 };\n        this._reportsCount = 0;\n        this._mosSum = 0;\n        this.intervals = [];\n        this._deprecationWarningSent = false;\n        if (!context || !context.application || !context.rtc_id || !context.pc) {\n            return;\n        }\n        this.conversation = null;\n        this.application_id = null;\n        this.attachHandlers(context);\n        this.startSendingStats(context);\n        this.startEmittingStats(context);\n    }\n    attachHandlers(context) {\n        const { pc } = context;\n        const onConnectionStateChange = pc.onconnectionstatechange\n            ? pc.onconnectionstatechange\n            : () => { };\n        pc.onconnectionstatechange = (event) => {\n            onConnectionStateChange.call(pc, event);\n            switch (pc.connectionState) {\n                case \"disconnected\":\n                case \"failed\":\n                case \"closed\":\n                    this.removeIntervals();\n                    this.emitLastReport(context);\n            }\n        };\n        if (!context.conversation) {\n            const application = context.application;\n            application.on(\"member:joined\", (member, event) => {\n                if ((!this.conversation || !this.application_id) && (context === null || context === void 0 ? void 0 : context.rtc_id) === event.body.channel.id) {\n                    this.conversation = member.conversation;\n                    this.application_id = event.application_id;\n                }\n            });\n        }\n        else {\n            const conversation = context.conversation;\n            conversation.on(\"member:media\", (member, event) => {\n                if (!this.application_id && (context === null || context === void 0 ? void 0 : context.rtc_id) === event.body.channel.id) {\n                    this.application_id = event.application_id;\n                }\n            });\n        }\n    }\n    emitLastReport(context) {\n        const { application, conversation = null, rtc_id, config: { emit_events, emit_rtc_analytics }, } = context;\n        const mos_report = this.getMOSReport();\n        const mos = mos_report.last;\n        if (mos) {\n            if (emit_rtc_analytics) {\n                application.emit(\"rtcstats:analytics\", {\n                    type: \"mos_report\",\n                    mos,\n                    rtc_id,\n                    mos_report,\n                    api_key: application.session.apiKey,\n                    ...(this.application_id && { application_id: this.application_id }),\n                    ...(conversation && {\n                        conversation_id: conversation.id,\n                        conversation_name: conversation.name\n                    })\n                });\n            }\n            if (emit_events) {\n                if (!this._deprecationWarningSent) {\n                    this._deprecationWarningSent = true;\n                    console.warn('\"rtcstats:report\" event is deprecated. Use \"rtcstats:analytics\" instead');\n                }\n                /**\n                 * @deprecated Use \"rtcstats:analytics instead\"\n                 */\n                application.emit(\"rtcstats:report\", mos, null, conversation, mos_report);\n            }\n        }\n    }\n    startSendingStats(context) {\n        const { application, conversation = null, pc, rtc_id, config: { remote_collection, remote_collection_url, remote_collection_interval, }, } = context;\n        if (!remote_collection)\n            return;\n        const remote_collection_interval_id = setInterval(() => {\n            pc.getStats(null).then((report) => {\n                var _a;\n                const conv = (_a = conversation !== null && conversation !== void 0 ? conversation : this.conversation) !== null && _a !== void 0 ? _a : null;\n                utils_1.default.networkRequest({\n                    url: remote_collection_url,\n                    type: \"POST\",\n                    data: {\n                        ...rtcStatsAdapterParser(report),\n                        legId: rtc_id,\n                        apiKey: application.session.apiKey,\n                        ...(this.application_id && { applicationId: this.application_id }),\n                        ...(conv && {\n                            conversationId: conv.id,\n                            conversationName: conv.name\n                        })\n                    }\n                }).catch(() => { });\n            }).catch(() => { });\n            if (pc.connectionState === \"closed\" || pc.signalingState === 'closed') {\n                this.removeIntervals();\n            }\n        }, remote_collection_interval);\n        this.intervals.push(remote_collection_interval_id);\n    }\n    startEmittingStats(context) {\n        const { application, conversation = null, pc, rtc_id, config: { emit_events, emit_rtc_analytics, emit_interval }, } = context;\n        if (!emit_events && !emit_rtc_analytics)\n            return;\n        const emit_stats_interval_id = setInterval(() => {\n            var _a;\n            pc.getStats(null).then((stats) => {\n                var _a;\n                const mos = this.getMos(stats);\n                if (!mos)\n                    return;\n                const conv = (_a = conversation !== null && conversation !== void 0 ? conversation : this.conversation) !== null && _a !== void 0 ? _a : null;\n                if (emit_rtc_analytics) {\n                    application.emit(\"rtcstats:analytics\", {\n                        type: \"mos\",\n                        mos,\n                        report: stats,\n                        rtc_id,\n                        api_key: application.session.apiKey,\n                        ...(this.application_id && { application_id: this.application_id }),\n                        ...(conv && {\n                            conversation_id: conv.id,\n                            conversation_name: conv.name\n                        })\n                    });\n                }\n                if (emit_events) {\n                    if (!this._deprecationWarningSent) {\n                        this._deprecationWarningSent = true;\n                        console.warn('\"rtcstats:report\" event is deprecated. Use \"rtcstats:analytics\" instead');\n                    }\n                    /**\n                     * @deprecated Use \"rtcstats:analytics instead\"\n                     */\n                    application.emit(\"rtcstats:report\", mos, stats, conversation);\n                }\n            }).catch(() => { });\n            if (pc.connectionState === \"closed\" || pc.signalingState === 'closed') {\n                this.removeIntervals();\n                this.emitLastReport({\n                    ...context,\n                    conversation: (_a = conversation !== null && conversation !== void 0 ? conversation : this.conversation) !== null && _a !== void 0 ? _a : null\n                });\n            }\n        }, emit_interval);\n        this.intervals.push(emit_stats_interval_id);\n    }\n    removeIntervals() {\n        this.intervals.forEach((interval) => clearInterval(interval));\n        this.intervals = [];\n    }\n    getMos(stats) {\n        const mos = calculateMos(stats);\n        this.updateMOSReport(parseInt(mos));\n        return mos;\n    }\n    /**\n     * Update the mos_report object\n     * @param {number} mos the MOS score\n     * @returns {object} the report object\n     */\n    updateMOSReport(mos) {\n        this._reportsCount++;\n        this._mosSum += mos;\n        this.mos_report.last = mos;\n        this.mos_report.min = mos < this.mos_report.min ? mos : this.mos_report.min;\n        this.mos_report.max = mos > this.mos_report.max ? mos : this.mos_report.max;\n        this.mos_report.average = this._mosSum / this._reportsCount;\n    }\n    /**\n     * Update the MOS report object\n     * mos_report.min - the minimum MOS value during the stream\n     * mos_report.max - the maximum MOS value during the stream\n     * mos_report.last - the last MOS value during the stream\n     * mos_report.average - the average MOS value during the stream\n     * @returns {MosReport} mos_report - a report for the MOS values\n     *\n     */\n    getMOSReport() {\n        this.mos_report.min = RTCStatsAnalytics.normaliseFloat(this.mos_report.min);\n        this.mos_report.max = RTCStatsAnalytics.normaliseFloat(this.mos_report.max);\n        this.mos_report.last = RTCStatsAnalytics.normaliseFloat(this.mos_report.last);\n        this.mos_report.average = RTCStatsAnalytics.normaliseFloat(this.mos_report.average);\n        return this.mos_report;\n    }\n    static normaliseFloat(value) {\n        return parseFloat(value).toFixed(6);\n    }\n}\nexports.default = RTCStatsAnalytics;\nmodule.exports = RTCStatsAnalytics;\n\n},{\"../utils\":31,\"rtc-stats-adapter\":67,\"rtc-stats-adapter/calculate-mos\":66}],20:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NexmoApiError = exports.NexmoClientError = void 0;\n/*\n * Nexmo Client SDK\n *  Nexmo Client - API Error wrapper\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst NexmoClientErrorTypes = require('./nexmoClientErrorTypes');\nconst loglevel_1 = require(\"loglevel\");\nfunction decorateError(instance, error) {\n    if (error && error.code) {\n        error.type = error.code;\n        delete error['code'];\n    }\n    Object.assign(instance, error);\n    instance.message = 'type: ' + instance.type + ', description: ' + (instance.description ? instance.description : '');\n}\n/**\n * Error constructor of an NexmoClient-error\n * @param {string} errorInput String client error\n*/\nclass NexmoClientError {\n    constructor(errorInput) {\n        const error = NexmoClientErrorTypes[errorInput];\n        // for other errors (libs/browser APIs) re-use the Client error\n        // to forward it but don't throw it away\n        if (error) {\n            // if error type exists in our list keep consistency\n            decorateError(this, error);\n        }\n        else {\n            // if the structure is not as expected, f/w as much as we can get\n            this.message = errorInput && errorInput.message ? errorInput.message : errorInput;\n            this.stack = errorInput.stack;\n        }\n        // log error\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.log.error(this);\n        // make sure the error.name matches the class name\n        this.name = 'NexmoClientError';\n        if (typeof global.NXMbugsnagClient !== 'undefined') {\n            global.NXMbugsnagClient.notify(this, {\n                severity: 'info'\n            });\n        }\n    }\n}\nexports.NexmoClientError = NexmoClientError;\n/**\n * Error constructor of an API-error\n * @param {object} error API error, always containing {type: <string>}\n*/\nclass NexmoApiError {\n    constructor(errorInput) {\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        if (errorInput) {\n            decorateError(this, errorInput);\n        }\n        else {\n            // if the structure is not as expected, f/w as much as we can get\n            this.message = errorInput && errorInput.message ? errorInput.message : errorInput;\n            this.stack = errorInput && errorInput.stack ? errorInput.stack : new Error().stack;\n        }\n        this.name = 'NexmoApiError';\n        // log error\n        this.log = loglevel_1.getLogger(this.constructor.name);\n        this.log.error(this);\n        if (typeof global.NXMbugsnagClient !== 'undefined') {\n            global.NXMbugsnagClient.notify(this, {\n                severity: 'info'\n            });\n        }\n    }\n}\nexports.NexmoApiError = NexmoApiError;\nmodule.exports = {\n    NexmoClientError: NexmoClientError,\n    NexmoApiError: NexmoApiError\n};\n\n}).call(this)}).call(this,typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./nexmoClientErrorTypes\":21,\"loglevel\":63}],21:[function(require,module,exports){\n'use strict';\n/*\n *  Nexmo Client SDK\n *  Nexmo Client Error Types\n *\n * Copyright (c) Nexmo Inc.\n */\nmodule.exports = {\n    'error:application:call:params': {\n        type: 'error:application:call:params',\n        description: 'not a valid String[] of usernames param'\n    },\n    'error:application:callServer:params': {\n        type: 'error:application:call:params',\n        description: 'not a valid String of phone number'\n    },\n    'error:call:reject': {\n        type: 'error:call:reject',\n        description: 'failed to reject the call'\n    },\n    'error:getUserMedia:permissions': {\n        type: 'error:getUserMedia:permissions',\n        description: 'missing getUserMedia permissions'\n    },\n    'error:media:params': {\n        type: 'error:media:params',\n        description: 'currently supported params media type= {audio:{muted:false, earmuffed:false}}'\n    },\n    'error:media:reenable': {\n        type: 'error:media:reenable',\n        description: 'missing reconnectRtcId required to reenable media'\n    },\n    'error:self': {\n        type: 'error:self',\n        description: 'Conversation Object is missing self (me)'\n    },\n    'error:user:relogin': {\n        type: 'error:user:relogin',\n        description: 'please relogin'\n    },\n    'error:seen:own-message': {\n        type: 'error:seen:own-message',\n        description: 'attempt to send seen for own message'\n    },\n    'error:already-seen': {\n        type: 'error:already-seen',\n        description: 'already marked as seen'\n    },\n    'error:delivered:own-message': {\n        type: 'error:delivered:own-message',\n        description: 'attempt to send delivered for own message'\n    },\n    'error:already-delivered': {\n        type: 'error:already-delivered',\n        description: 'already marked as delivered'\n    },\n    'error:fetch-image': {\n        type: 'error:fetch-image',\n        description: 'xhr.status received other than 200'\n    },\n    'error:delete-image': {\n        type: 'error:delete-image',\n        description: 'xhr.status received other than 204'\n    },\n    'error:missing:params': {\n        type: 'error:missing:params',\n        description: 'missing parameters'\n    },\n    'error:invite:missing:params': {\n        type: 'error:missing:params',\n        description: 'This invite cannot be sent to empty username and user_id'\n    },\n    'error:invalid:param:type': {\n        type: 'error:invalid:param:type',\n        description: 'Invalid Object type, passed in the parameters'\n    },\n    'error:audio:already-connecting': {\n        type: 'error:audio:already-connecting',\n        description: 'Audio call already in progress'\n    },\n    'error:audio:not-enabled': {\n        type: 'error:audio:not-enabled',\n        description: 'Audio is not enabled'\n    },\n    'error:media:already-connecting': {\n        type: 'error:media:already-connecting',\n        description: 'Media is already in progress'\n    },\n    'error:media:unsupported-browser': {\n        type: 'error:media:unsupported-browser',\n        description: 'This action is not supported on this browser'\n    },\n    'error:media:extension': {\n        type: 'error:media:extension',\n        description: 'Chrome extension has thrown an error'\n    },\n    'error:media:extension-not-installed': {\n        type: 'error:media:extension-not-installed',\n        description: 'Chrome extension should be installed'\n    },\n    'error:media:update:streams': {\n        type: 'error:media:update:streams',\n        description: 'cant update more than one stream'\n    },\n    'error:media:update:invalid': {\n        type: 'error:media:update:invalid',\n        description: 'state of media is not supported for this update'\n    },\n    'error:media:stream:not-found': {\n        type: 'error:media:stream:not-found',\n        description: 'A stream with the given index was not found'\n    },\n    'error:audio:dtmf:invalid-digit': {\n        type: 'error:audio:dtmf:invalid-digit',\n        description: 'not a valid string of dtmf digits (0-9,a-d,A-D,p,P,*,#)'\n    },\n    'error:audio:dtmf:audio-disabled': {\n        type: 'error:audio:dtmf:audio-disabled',\n        description: 'Audio must be enabled to send DTMF'\n    },\n    'error:invalid-order': {\n        type: 'error:invalid-order',\n        description: 'params not valid. Order must be asc or desc'\n    },\n    'error:custom-event:invalid': {\n        type: 'error:custom-event:invalid',\n        description: 'Custom event type not valid'\n    },\n    'error:message-event:invalid': {\n        type: 'error:message-event:invalid',\n        description: 'message_type is missing or is invalid'\n    },\n    'error:invalid-cursor': {\n        type: 'error:invalid-cursor',\n        description: 'page does not exist'\n    },\n    'error:client:reconnection_failed': {\n        type: 'error:client:reconnection_failed',\n        description: 'websocket failed to reconnect'\n    },\n    'error:conversation-service:version': {\n        type: 'error:conversation:version',\n        description: 'Wrong version of Conversation Service API. It should be one of \"v1\" or \"v3\"'\n    },\n    'error:no-media-offer': {\n        type: 'error:no-media-offer',\n        description: 'Media preload attempt without having an offer available'\n    }\n};\n\n},{}],22:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst page_1 = __importDefault(require(\"./page\"));\n/**\n * A Conversations Page\n *\n * @class ConversationsPage\n * @param {Map} items map of conversations fetched in the paginated query\n * @extends Page\n*/\nclass ConversationsPage extends page_1.default {\n    constructor(params) {\n        super(params);\n        this.items = new Map();\n        // Iterate and create the conversations if not existent\n        params.items.forEach((c) => {\n            const conversation = this.application.updateOrCreateConversation(c);\n            this.items.set(conversation.id, conversation);\n        });\n    }\n    /**\n     * Fetch the previous page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the previous page if exists</caption>\n     *  currentConvPage.getPrev().then((prevConvPage) => {\n     *    console.log(\"previous conversation page \", prevConvPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting previous conversation page \", error);\n     *  });\n    */\n    getPrev() {\n        if (!this.hasPrev())\n            return this._getError();\n        return this.application.getConversations(this._getConfig(this.cursor.prev));\n    }\n    /**\n     * Fetch the next page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the next page if exists</caption>\n     *  currentConvPage.getNext().then((nextConvPage) => {\n     *    console.log(\"next conversation page \", nextConvPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting next conversation page \", error);\n     *  });\n    */\n    getNext() {\n        if (!this.hasNext())\n            return this._getError();\n        return this.application.getConversations(this._getConfig(this.cursor.next));\n    }\n}\nexports.default = ConversationsPage;\nmodule.exports = ConversationsPage;\n\n},{\"./page\":25}],23:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst page_1 = __importDefault(require(\"./page\"));\nconst nxmEvent_1 = __importDefault(require(\"../events/nxmEvent\"));\nconst text_event_1 = __importDefault(require(\"../events/text_event\"));\nconst image_event_1 = __importDefault(require(\"../events/image_event\"));\nconst message_event_1 = __importDefault(require(\"../events/message_event\"));\n/**\n * A Events Page\n *\n * @class EventsPage\n * @param {Map} items map of events fetched in the paginated query\n * @extends Page\n*/\nclass EventsPage extends page_1.default {\n    constructor(params) {\n        super(params);\n        this.items = new Map();\n        this.conversation = params.conversation;\n        // Iterate and create the event objects\n        params.items.forEach((event) => {\n            switch (event.type) {\n                // NXMEvent types with corresponding classes\n                case 'text':\n                    this.items.set(event.id, new text_event_1.default(this.conversation, event));\n                    break;\n                case 'image':\n                    this.items.set(event.id, new image_event_1.default(this.conversation, event));\n                    break;\n                case 'message':\n                    this.items.set(event.id, new message_event_1.default(this.conversation, event));\n                    break;\n                default:\n                    this.items.set(event.id, new nxmEvent_1.default(this.conversation, event));\n                    break;\n            }\n        });\n        // update the events Map on the conversation\n        this.conversation.events = new Map([...this.conversation.events, ...this.items]);\n    }\n    /**\n     * Fetch the previous page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the previous page if exists</caption>\n     *  currentEventsPage.getPrev().then((prevEventsPage) => {\n     *    console.log(\"previous events page \", prevEventsPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting previous events page \", error);\n     *  });\n    */\n    getPrev() {\n        if (!this.hasPrev())\n            return this._getError();\n        return this.conversation.getEvents(this._getConfig(this.cursor.prev));\n    }\n    /**\n     * Fetch the next page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the next page if exists</caption>\n     *  currentEventsPage.getNext().then((nextEventsPage) => {\n     *    console.log(\"next events page \", nextEventsPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting next events page \", error);\n     *  });\n    */\n    getNext() {\n        if (!this.hasNext())\n            return this._getError();\n        return this.conversation.getEvents(this._getConfig(this.cursor.next));\n    }\n}\nexports.default = EventsPage;\nmodule.exports = EventsPage;\n\n},{\"../events/image_event\":3,\"../events/message_event\":4,\"../events/nxmEvent\":5,\"../events/text_event\":6,\"./page\":25}],24:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst page_1 = __importDefault(require(\"./page\"));\nconst member_1 = __importDefault(require(\"../member\"));\n/**\n * A Members Page\n *\n * @class MembersPage\n * @param {Map} items map of members fetched in the paginated query\n * @extends Page\n*/\nclass MembersPage extends page_1.default {\n    constructor(params) {\n        super(params);\n        this.conversation = params.conversation;\n        this.items = new Map();\n        // Iterate and create the conversations if not existent\n        params.items.forEach((member) => {\n            this.items.set(member.id, new member_1.default(this.conversation, member));\n        });\n    }\n    /**\n     * Fetch the previous page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the previous page if exists</caption>\n     *  currentMembersPage.getPrev().then((prevMembersPage) => {\n     *    console.log(\"previous members page \", prevMembersPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting previous members page \", error);\n     *  });\n    */\n    getPrev() {\n        if (!this.hasPrev())\n            return this._getError();\n        return this.conversation.getMembers(this._getConfig(this.cursor.prev));\n    }\n    /**\n     * Fetch the next page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the next page if exists</caption>\n     *  currentMembersPage.getNext().then((nextMembersPage) => {\n     *    console.log(\"next members page \", nextMembersPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting next members page \", error);\n     *  });\n    */\n    getNext() {\n        if (!this.hasNext())\n            return this._getError();\n        return this.conversation.getMembers(this._getConfig(this.cursor.next));\n    }\n}\nexports.default = MembersPage;\nmodule.exports = MembersPage;\n\n},{\"../member\":13,\"./page\":25}],25:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst nexmoClientError_1 = require(\"../nexmoClientError\");\n/** Page Class for Paginated Results\n *\n * @class Page\n * @param {number} page_size the number of resources returned in a single request list\n * @param {string} order 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} cursor cursor parameter to access the next or previous page of a data set\n * @param {Application} application - the parent Application\n * @param {string} [event_type] the type of event used to filter event requests\n *\n * @private\n*/\nclass Page {\n    constructor(params = {}) {\n        this.page_size = params.page_size;\n        this.order = params.order;\n        this.cursor = params.cursor;\n        this.application = params.application;\n        if (params.event_type && params.event_type.length > 0) {\n            this.event_type = params.event_type;\n        }\n    }\n    /**\n     * Check if previous page exists\n     * @returns {Boolean}\n     * @example <caption>Check if previous page exists</caption>\n     * // currentPage is the current Conversations or Events Page\n     * currentPage.hasPrev() // true or false\n    */\n    hasPrev() {\n        return this.cursor.prev ? this.cursor.prev.length > 0 : false;\n    }\n    /**\n     * Check if next page exists\n     * @returns {Boolean}\n     * @example <caption>Check if next page exists</caption>\n     * // currentPage is the current Conversations or Events Page\n     * currentPage.hasNext() // true or false\n    */\n    hasNext() {\n        return this.cursor.next ? this.cursor.next.length > 0 : false;\n    }\n    /**\n      * Create config params for paginationRequest\n      * @param {string} cursor cursor parameter to access the next or previous page of a data set\n      * @returns {Object}\n     * @private\n    */\n    _getConfig(cursor) {\n        const config = {\n            page_size: this.page_size,\n            order: this.order,\n            cursor,\n            ...(this.event_type && { event_type: this.event_type })\n        };\n        return config;\n    }\n    /**\n     * Create a nexmoClientError when page does not exist\n     * @private\n    */\n    _getError() {\n        return Promise.reject(new nexmoClientError_1.NexmoClientError('error:invalid-cursor'));\n    }\n}\nexports.default = Page;\nmodule.exports = Page;\n\n},{\"../nexmoClientError\":20}],26:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n*/\n/** Config Class for Paginated Requests\n *\n * @class PageConfig\n * @param {number} page_size=10 the number of resources returned in a single request list\n * @param {string} order=asc the asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} cursor='' cursor parameter to access the next or previous page of a data set\n * @param {string} [event_type] the type of event used to filter event requests\n * @param {string} state='' the INVITED, JOINED, or LEFT state of your membership in the conversation\n * @private\n*/\nclass PageConfig {\n    constructor(params = {}) {\n        this.page_size = params.page_size || 10;\n        this.order = params.order || 'asc';\n        this.cursor = params.cursor || '';\n        this.state = params.state || '';\n        if (params.event_type) {\n            this.event_type = params.event_type;\n        }\n    }\n}\nexports.default = PageConfig;\nmodule.exports = PageConfig;\n\n},{}],27:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst page_1 = __importDefault(require(\"./page\"));\nconst user_session_1 = __importDefault(require(\"../user_session\"));\n/**\n * A UserSessions Page\n *\n * @class UserSessionsPage\n * @param {Map} items map of UserSessions fetched in the paginated query\n * @extends Page\n*/\nclass UserSessionsPage extends page_1.default {\n    constructor(params) {\n        super(params);\n        this.items = new Map();\n        // Iterate through the UserSessions\n        params.items.forEach((userSession) => {\n            this.items.set(userSession.id, new user_session_1.default(this.application, userSession));\n        });\n    }\n    /**\n     * Fetch the previous page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the previous page if exists</caption>\n     *  currentUserSessionsPage.getPrev().then((prevUserSessionsPage) => {\n     *    console.log(\"previous user sessions page \", prevUserSessionsPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting previous user sessions page \", error);\n     *  });\n    */\n    getPrev() {\n        if (!this.hasPrev())\n            return this._getError();\n        return this.application.getUserSessions(this._getConfig(this.cursor.prev));\n    }\n    /**\n     * Fetch the next page if exists\n     * @returns {Promise<Page>}\n     * @example <caption>Fetch the next page if exists</caption>\n     *  currentUserSessionsPage.getNext().then((nextUserSessionsPage) => {\n     *    console.log(\"next user sessions page \", nextUserSessionsPage);\n     *  }).catch((error) => {\n     *    console.error(\"error getting next user sessions page \", error);\n     *  });\n    */\n    getNext() {\n        if (!this.hasNext())\n            return this._getError();\n        return this.application.getUserSessions(this._getConfig(this.cursor.next));\n    }\n}\nexports.default = UserSessionsPage;\nmodule.exports = UserSessionsPage;\n\n},{\"../user_session\":30,\"./page\":25}],28:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Main wrapper\n *\n * Copyright (c) Nexmo Inc.\n*/\nconst WildEmitter = require('wildemitter');\nconst loglevel_plugin_prefix_1 = __importDefault(require(\"loglevel-plugin-prefix\"));\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst nexmoClientError_1 = require(\"./nexmoClientError\");\nconst socket_io_client_1 = __importDefault(require(\"socket.io-client\"));\nconst js_1 = __importDefault(require(\"@bugsnag/js\"));\nconst publicip_1 = __importDefault(require(\"./modules/publicip\"));\nconst utils_1 = __importDefault(require(\"./utils\"));\nconst application_1 = __importDefault(require(\"./application\"));\nconst errors_emitter_1 = __importDefault(require(\"./modules/errors_emitter\"));\nconst user_1 = __importDefault(require(\"./user\"));\nconst rtc_helper_1 = __importDefault(require(\"./modules/rtc_helper\"));\nloglevel_plugin_prefix_1.default.reg(loglevel_1.default);\nloglevel_plugin_prefix_1.default.apply(loglevel_1.default, {\n    template: '[%t] %l (NXM-%n):',\n    timestampFormatter: (date) => {\n        return date.toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, '$1');\n    },\n    levelFormatter: (level) => {\n        return level.toUpperCase();\n    },\n    nameFormatter: (name) => {\n        return name || 'SDK';\n    }\n});\n/**\n * The parent NexmoClient class.\n *\n * @class NexmoClient\n *\n * @param {object} params the settings to initialise the SDK\n * @param {string} params.debug='silent' set mode to 'debug', 'info', 'warn', or 'error' for customized logging levels in the console\n * @param {string} params.url='nexmo_ws_url' Nexmo Conversation Websocket url, default is wss://ws.nexmo.com (wss://ws-us-1.nexmo.com for WDC, wss://ws-us-2.nexmo.com for DAL, wss://ws-eu-1.nexmo.com for LON, wss://ws-sg-1.nexmo.com for SNG)\n * @param {string} params.nexmo_api_url=Nexmo Conversation Api url, default is https://api.nexmo.com (https://api-us-1.nexmo.com for WDC, https://api-us-2.nexmo.com for DAL, https://api-eu-1.nexmo.com for LON, https://api-sg-1.nexmo.com for SNG)\n * @param {string} params.ips_url='ips_url' Nexmo IPS url for image upload, default is https://api.nexmo.com/v1/image (https://api-us-1.nexmo.com/v1/image for WDC, https://api-us-2.nexmo.com/v1/image for DAL, https://api-eu-1.nexmo.com/v1/image for LON, https://api-sg-1.nexmo.com/v1/image for SNG)\n * @param {string} params.path='/v2/rtc' Nexmo Conversation Websocket url path suffix\n * @param {RTCStatsConfig} params.rtcstats set reporting for stream statistics (Internal event emit)\n * @param {Boolean} params.rtcstats.emit_events=false receive rtcstats:report event (deprecated)\n * @param {Boolean} params.rtcstats.emit_rtc_analytics=false receive rtcstats:analytics event\n * @param {number} params.rtcstats.emit_interval=1000 interval in ms for rtcstats:report and rtcstats:analytics\n * @param {Boolean} params.rtcstats.remote_collection=true collect client logs internally\n * @param {Boolean} params.rtcstats.remote_collection_url='gollum_url' url for collecting client logs internally\n * @param {number} params.rtcstats.remote_collection_interval=5000 interval in ms to collect client logs internally\n * @param {object} params.socket_io configure socket.io\n * @param {Boolean} params.socket_io.forceNew=true configure socket.io forceNew attribute\n * @param {Boolean} params.socket_io.autoConnect=true socket.io autoConnect attribute\n * @param {Boolean} params.socket_io.reconnection=true socket.io reconnection attribute\n * @param {number} params.socket_io.reconnectionAttempts=5 socket.io reconnectionAttempts attribute\n * @param {string[]} params.socket_io.transports='websocket' socket.io transports protocols\n * @param {string} params.sync='none' {'none' || 'lite' || 'full'} after a successful session creation, synchronise conversations, include events or nothing\n * @param {string} params.environment='production' development / production environment\n * @param {object[]} [params.iceServers=[]] configure iceServers for RTCPeerConnection\n * @param {object} params.log_reporter configure log reports for bugsnag tool\n * @param {Boolean} params.log_reporter.enabled=true\n * @param {string} params.log_reporter.bugsnag_key your bugsnag api key / defaults to Nexmo api key\n * @param {object} params.conversations_page_config configure paginated requests for conversations\n * @param {number} params.conversations_page_config.page_size=10 the number of resources returned in a single request list\n * @param {string} params.conversations_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} params.conversations_page_config.cursor cursor parameter to access the next or previous page of a data set\n * @param {object} params.events_page_config configure paginated requests for events\n * @param {number} params.events_page_config.page_size=10 the number of resources returned in a single request list\n * @param {string} params.events_page_config.order=asc 'asc' or 'desc' ordering of resources (usually based on creation time)\n * @param {string} params.events_page_config.event_type the type of event used to filter event requests. Supports wildcard options with :* eg. 'members:*'\n * @param {Boolean} params.enableEventsQueue=true mechanism to guarantee order of events received during a session\n * @param {Boolean} params.enableInboundOffer=false configure receiving offer for faster inbound call setup\n * @param {Boolean} params.acknowledgeEvents=true send acknowledgment over websocket to server for received events\n * @param {string} params.token the jwt token for network requests\n *\n * @emits NexmoClient#disconnect\n * @emits NexmoClient#error\n * @emits NexmoClient#ready\n * @emits NexmoClient#reconnect\n * @emits NexmoClient#reconnecting\n*/\nclass NexmoClient {\n    constructor(params = {}) {\n        // save an array of instances\n        const inputParams = params;\n        this.config = {\n            debug: 'silent',\n            log_reporter: {\n                enabled: false,\n                bugsnag_key: null\n            },\n            environment: 'production',\n            ips_url: 'https://api-us.vonage.com/v1/image',\n            nexmo_api_url: 'https://api-us.vonage.com',\n            path: '/v2/rtc',\n            repository: 'https://github.com/Nexmo/conversation-js-sdk',\n            SDK_version: '9.3.0',\n            socket_io: {\n                reconnection: true,\n                reconnectionAttempts: 5,\n                reconnectionDelay: 2000,\n                randomizationFactor: 0.75,\n                reconnectionDelayMax: 15000,\n                forceNew: true,\n                autoConnect: true,\n                transports: ['websocket'],\n            },\n            sync: 'none',\n            url: 'https://ws-us.vonage.com',\n            iceServers: [],\n            rtcstats: {\n                remote_collection: true,\n                remote_collection_url: 'https://hlg.tokbox.com/prod/logging/nexmo_client_js_stats',\n                remote_collection_interval: 5000,\n                emit_events: false,\n                emit_rtc_analytics: false,\n                emit_interval: 1000,\n            },\n            conversations_page_config: {\n                page_size: 10,\n                order: 'asc',\n                cursor: ''\n            },\n            events_page_config: {\n                page_size: 10,\n                order: 'asc',\n                event_type: ''\n            },\n            enableEventsQueue: true,\n            enableInboundOffer: false,\n            acknowledgeEvents: true,\n            token: null\n        };\n        this.config.socket_io.query = {\n            token: '',\n            SDK_version: this.config.SDK_version,\n            session_version: params.enableInboundOffer ? '0.0.2' : '0.0.1',\n            acknowledge_events: this.config.acknowledgeEvents,\n            OS_family: 'js',\n            OS_revision: (typeof navigator !== 'undefined') ? navigator.userAgent : (typeof window !== 'undefined') ? window.navigator.userAgent : 'Generic JS navigator'\n        };\n        this.sessionReady = false;\n        this.disconnectTimestamp = null;\n        this.session_id = null;\n        this.apiKey = null;\n        this.requests = {};\n        this.application = null;\n        /*\n          Definitions of log levels\n          error: major error messages, some lost functionality\n          warn: error messages which do not cause a functional failure\n          info: informational messages, showing completion, progress, etc.\n          debug: messages to help in diagnosing a problem\n        */\n        if (['debug', 'info', 'warn', 'error'].includes(inputParams.debug)) {\n            loglevel_1.default.setLevel(inputParams.debug);\n        }\n        else if (inputParams.debug === true) {\n            loglevel_1.default.setLevel('debug');\n        }\n        else {\n            loglevel_1.default.setLevel('silent');\n        }\n        this.log = loglevel_1.default.noConflict();\n        // set our config from the inputParams\n        this.config = utils_1.default.deepMergeObj(this.config, this._sanitizeConfig(inputParams));\n        // inject bug reporting tool\n        if (this.config.log_reporter.enabled) {\n            const bugsnagConfig = {\n                apiKey: this.config.log_reporter.bugsnag_key || utils_1.default._getBugsnagKey(),\n                appVersion: this.config.socket_io.query.SDK_version,\n                releaseStage: this.config.environment\n            };\n            global.NXMbugsnagClient = js_1.default(bugsnagConfig);\n        }\n        WildEmitter.mixin(NexmoClient);\n    }\n    /**\n     * Creates and sets the socket_io connection\n     *\n     * @private\n    */\n    _createAndSetConnection() {\n        let connection;\n        // Create the socket.io connection and allow multiple instances\n        let socket_io_config = Object.assign({ path: this.config.path }, this.config.socket_io);\n        connection = socket_io_client_1.default.connect(this.config.url, socket_io_config);\n        this.connection = connection;\n        // Listen to socket.io events\n        /**\n         * Client listening for ready event.\n         *\n         * @event NexmoClient#ready\n         * @example <caption>Listen for websocket ready event </caption>\n         *     rtc.on(\"ready\", () => {\n         *      console.log(\"connection ready\");\n         *     });\n        */\n        connection.on('connect', () => {\n            this.emit('ready');\n            this.sessionReady = true;\n            this.log.info('websocket ready');\n        });\n        /**\n         * Client listening for disconnect event.\n         *\n         * @event NexmoClient#disconnect\n         * @example <caption>Listen for websocket disconnect event </caption>\n         *     rtc.on(\"disconnect\", (reason) => {\n         *      console.log(\"disconnect\", reason);\n         *     });\n        */\n        connection.on('disconnect', (reason, details) => {\n            this.emit('disconnect', (reason === \"io client disconnect\")\n                ? NexmoClient.DISCONNECT_REASON.ClientDisconnected\n                : (reason === \"io server disconnect\" && this.session_id) ? NexmoClient.DISCONNECT_REASON.TokenExpired\n                    : NexmoClient.DISCONNECT_REASON.ConnectionError);\n            this.disconnectTimestamp = Date.now();\n            this.log.info('websocket disconnected', reason, details);\n        });\n        /**\n         * Client listening for reconnect event.\n         *\n         * @event NexmoClient#reconnect\n         * @example <caption>Listen for websocket reconnect event </caption>\n         *     rtc.on(\"reconnect\", (retry_number) => {\n         *      console.log(\"reconnect\", retry_number);\n         *     });\n        */\n        connection.io.on('reconnect', (retry_number) => {\n            this.emit('reconnect', retry_number);\n            this.log.info('websocket reconnect', retry_number);\n            utils_1.default.networkRequest({\n                url: `${this.config.url.replace('wss://', 'https://')}/v2/rtc/metrics`,\n                type: 'POST',\n                token: this.config.token,\n                data: {\n                    sessionId: this.session_id,\n                    metrics: [\n                        {\n                            name: 'TIME_TO_RECONNECT_SUCCESS',\n                            time: this.disconnectTimestamp ? Date.now() - this.disconnectTimestamp : undefined,\n                            attempt: retry_number\n                        }\n                    ]\n                }\n            }).catch((err) => {\n                this.log.warn('Failed to publish socket reconnection metrics', err);\n            });\n        });\n        /**\n         * Client listening for reconnecting event.\n         *\n         * @event NexmoClient#reconnecting\n         * @example <caption>Listen for websocket reconnecting event </caption>\n         *     rtc.on(\"reconnecting\", (retry_number): void => {\n         *      console.log(\"reconnecting\", retry_number);\n         *     });\n        */\n        connection.io.on('reconnect_attempt', (retry_number) => {\n            this.emit('reconnecting', retry_number);\n            this.log.info('websocket reconnecting', retry_number);\n        });\n        /**\n         * Client listening for error event.\n         *\n         * @event NexmoClient#error\n         * @example <caption>Listen for websocket error event </caption>\n         *     rtc.on(\"error\", (error) => {\n         *      console.log(\"error\", error);\n         *     });\n        */\n        connection.on('connect_error', (error) => {\n            this.emit('error', new nexmoClientError_1.NexmoClientError(error));\n            this.log.error('Socket.io reported a generic error', error);\n        });\n        connection.io.on(\"reconnect_failed\", () => {\n            this.emit('error', new nexmoClientError_1.NexmoClientError(\"error:client:reconnection_failed\"));\n            this.log.error('websocket reconnection error');\n        });\n        connection.io.on('packet', (packet) => {\n            if (packet.type !== 2)\n                return;\n            if (packet.data[0] === 'echo')\n                return; // ignore echo events\n            const callbackAck = packet.data[2];\n            if (callbackAck && typeof (callbackAck) === \"function\") {\n                callbackAck();\n            }\n            const response = packet.data[1];\n            // Set the type of the response\n            response.type = packet.data[0];\n            this.log.debug('<--', response.type, response);\n            if (this.requests['session:login']) {\n                const callback = this.requests['session:login'].callback;\n                delete this.requests['session:login'];\n                callback(response);\n            }\n            else if (response.rid in this.requests) {\n                const callback = this.requests[response.rid].callback;\n                delete this.requests[response.rid];\n                delete response.delay;\n                if (this.errorsEmitter) {\n                    this.errorsEmitter.emitResponseIfError(response);\n                }\n                callback(response);\n            }\n            else {\n                // This is an unsolicited event we emit it in application level\n                // Excluding session:* events from being processed and check if event type is a system:error:* one\n                if (this.errorsEmitter && response.type.startsWith('system:error:')) {\n                    this.errorsEmitter.emitResponseIfError(response);\n                }\n                else if (response.type.startsWith('session:')) {\n                    // Handle Events emitted from Reconnection\n                    this.updateSession(response);\n                }\n                else if (this.application) {\n                    this.application._enqueueEvent(response);\n                }\n            }\n        });\n        return connection;\n    }\n    /**\n     * Revert any invalid params to our default\n     *\n     * @param {object} config the object to sanitize\n     * @private\n    */\n    _sanitizeConfig(incomingConfig) {\n        // make sure we allow specific values for the params\n        // Sync\n        let sanitizedConfig = incomingConfig;\n        if (incomingConfig.sync && ['none', 'lite', 'full'].indexOf(incomingConfig.sync) === -1) {\n            this.log.warn(`invalid param '${incomingConfig.sync}' for sync, reverting to ${this.config.sync}`);\n            sanitizedConfig.sync = this.config.sync;\n        }\n        return sanitizedConfig;\n    }\n    /**\n     * Conversation listening for text events.\n     *\n     * @event Conversation#text\n     *\n     * @property {Member} sender - The sender of the text\n     * @property {TextEvent} text - The text message received\n     * @example <caption>listen for text events</caption>\n     *  conversation.on(\"text\",(sender, message) => {\n     *    console.log(sender, message);\n     *    // Identify your own message.\n     *    if (message.from === conversation.me.id){\n     *        renderMyMessages(message)\n     *    } else {\n     *        renderOtherMessages(message)\n     *    }\n     *  });\n     */\n    /**\n     *\n     * Conversation listening for image events.\n     *\n     * @event Conversation#image\n     *\n     * @property {Member} sender - The sender of the image\n     * @property {ImageEvent} image - The image message received\n     * @example <caption>listen for image events</caption>\n     *  conversation.on(\"image\", (sender, image) => {\n     *    console.log(sender,image);\n     *    // Identify if your own imageEvent or someone else's.\n     *    if (image.from !== conversation.me.id){\n     *        displayImages(image);\n     *    }\n     *  });\n     */\n    /**\n     * Conversation listening for deleted events.\n     *\n     * @event Conversation#event:delete\n     *\n     * @property {Member} member - the Member who deleted an event\n     * @property {NXMEvent} event - deleted event: event.id\n     * @example <caption>get details about the deleted event</caption>\n     * conversation.on(\"event:delete\", (member, event) => {\n     *  console.log(event.id);\n     *  console.log(event.body.timestamp.deleted);\n     * });\n     */\n    /**\n     * Conversation listening for new Members.\n     *\n     * @event Conversation#member:joined\n     *\n     * @property {Member} member - the Member that joined\n     * @property {NXMEvent} event - the join event\n     * @example <caption>get the name of the new Member</caption>\n     * conversation.on(\"member:joined\", (member, event) => {\n     *  console.log(event.id)\n     *  console.log(member.userName+ \" joined the conversation\");\n     * });\n     */\n    /**\n     * Conversation listening for Members being invited.\n     *\n     * @event Conversation#member:invited\n     *\n     * @property {Member} member - the Member that is invited\n     * @property {NXMEvent} event - data regarding the receiver of the invitation\n     * @example <caption>get the name of the invited Member</caption>\n     * conversation.on(\"member:invited\", (member, event) => {\n     *  console.log(member.userName + \" invited to the conversation\");\n     * });\n     */\n    /**\n     * Conversation listening for Members callStatus changes.\n     *\n     * @event Conversation#member:call:status\n     *\n     * @property {Member} member - the Member that has left\n     * @example <caption>get the callStatus of the member that changed call status</caption>\n     * conversation.on(\"member:call:status\", (member) => {\n     *  console.log(member.callStatus);\n     * });\n     */\n    /**\n     * Conversation listening for Members leaving (kicked or left).\n     *\n     * @event Conversation#member:left\n     *\n     * @property {Member} member - the Member that has left\n     * @property {NXMEvent} event - data regarding the receiver of the invitation\n     * @example <caption>get the username of the Member that left</caption>\n     * conversation.on(\"member:left\", (member , event) => {\n     *  console.log(member.userName + \" left\");\n     *  console.log(event.body.reason);\n     * });\n     */\n    /**\n     * Conversation listening for Members typing.\n     *\n     * @event Conversation#text:typing:on\n     *\n     * @property {Member} member - the member that started typing\n     * @property {NXMEvent} event - the start typing event\n     * @example <caption>get the display name of the Member that is typing</caption>\n     * conversation.on(\"text:typing:on\", (member, event) => {\n     *  console.log(member.displayName + \" is typing...\");\n     * });\n     */\n    /**\n     * Conversation listening for Members stopped typing.\n     *\n     * @event Conversation#text:typing:off\n     *\n     * @property {Member} member - the member that stopped typing\n     * @property {NXMEvent} event - the stop typing event\n     * @example <caption>get the display name of the Member that stopped typing</caption>\n     * conversation.on(\"text:typing:off\", (member, event) => {\n     *  console.log(member.displayName + \" stopped typing...\");\n     * });\n     */\n    /**\n     * Conversation listening for Members' seen texts.\n     *\n     * @event Conversation#text:seen\n     *\n     * @property {Member} member - the Member that saw the text\n     * @property {TextEvent} text - the text that was seen\n     * @example <caption>listen for seen text events</caption>\n     * conversation.on(\"text:seen\", (member, text) => {\n     *  console.log(text);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  }\n     * });\n     */\n    /**\n     * Conversation listening for Members' seen images.\n     * @event Conversation#image:seen\n     *\n     * @property {Member} member - the member that saw the image\n     * @property {ImageEvent} image - the image that was seen\n     * @example <caption>listen for seen image events</caption>\n     * conversation.on(\"image:seen\", (member, image) => {\n     *  console.log(image);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members submitted messages.\n     * @event Conversation#message:submitted\n     *\n     * @property {Member} member - the member that message was submitted to\n     * @property {MessageEvent} message - the message that was submitted\n     * @example <caption>listen for submitted message events</caption>\n     * conversation.on(\"message:submitted\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members rejected messages.\n     * @event Conversation#message:rejected\n     *\n     * @property {Member} member - the member that message was rejected by\n     * @property {MessageEvent} message - the message that was rejected\n     * @example <caption>listen for rejected message events</caption>\n     * conversation.on(\"message:rejected\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members undeliverable messages.\n     * @event Conversation#message:undeliverable\n     *\n     * @property {Member} member - the member that message was undeliverable to\n     * @property {MessageEvent} message - the message that was undeliverable\n     * @example <caption>listen for undeliverable message events</caption>\n     * conversation.on(\"message:undeliverable\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members delivered messages.\n     * @event Conversation#message:delivered\n     *\n     * @property {Member} member - the member that message was delivered to\n     * @property {MessageEvent} message - the message that was delivered\n     * @example <caption>listen for delivered message events</caption>\n     * conversation.on(\"message:delivered\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members seen messages.\n     * @event Conversation#message:seen\n     *\n     * @property {Member} member - the member that message was seen by\n     * @property {MessageEvent} message - the message that was seen\n     * @example <caption>listen for seen message events</caption>\n     * conversation.on(\"message:seen\", (member, message) => {\n     *  console.log(message);\n     *  if (conversation.me.id !== member.memberId) {\n     *    console.log(member);\n     *  };\n     * });\n     */\n    /**\n     * Conversation listening for Members media changes (audio,text)\n     *\n     * Change in media presence state. They are in the Conversation with text or audio.\n     *\n     * @event Conversation#member:media\n     *\n     * @property {Member} member - the Member object linked to this event\n     * @property {NXMEvent} event - information about media presence state\n     * @property {boolean} event.body.audio  - is audio enabled\n     * @example <caption>get every Member's media change events </caption>\n     * conversation.on(\"member:media\", (member, event) => {\n     *  console.log(event.body.media); //{\"audio\": true, \"audio_settings\": {\"enabled\": true, \"muted\": false, \"earmuffed\": false}}\n     * });\n     */\n    /**\n     * Conversation listening for mute on events\n     * A Member has muted their audio\n     *\n     * @event Conversation#audio:mute:on\n     *\n     * @property {Member} member - the Member object linked to this event\n     * @property {NXMEvent} event - information about the mute event\n     * @example <caption>listen for audio mute on events </caption>\n     * conversation.on(\"audio:mute:on\", (member, event) => {\n     *  console.log(\"member that is muted \", member);\n     *  console.log(event);\n     * });\n     */\n    /**\n     * Conversation listening for mute off events\n     * A member has unmuted their audio\n     *\n     * @event Conversation#audio:mute:off\n     *\n     * @property {Member} member - the member object linked to this event\n     * @property {NXMEvent} event - information about the mute event\n     * @example <caption>listen for audio mute off events </caption>\n     * conversation.on(\"audio:mute:off\", (member, event) => {\n     *  console.log(\"member that is unmuted \", member);\n     *  console.log(event);\n     * });\n     */\n    sendRequest(request, callback) {\n        // Add a message ID to the request and set up a listener for the reply (or error)\n        request.tid = utils_1.default.allocateUUID();\n        const type = request.type;\n        delete request.type;\n        this.log.debug('-->', type, request);\n        this.log.info('-->', type, request.tid);\n        this.connection.emit(type, request);\n        this.requests[request.tid] = {\n            type: type,\n            request,\n            callback\n        };\n    }\n    async sendNetworkRequest(params) {\n        const version = params.version || 'beta';\n        const url = `${this.config.nexmo_api_url}/${version}/${params.path}`;\n        if (!(params.type === 'GET' || params.type === 'DELETE')) {\n            if (params.data) {\n                params.data.originating_session = this.session_id;\n            }\n            else {\n                params.data = {\n                    originating_session: this.session_id\n                };\n            }\n        }\n        try {\n            const request = {\n                type: params.type,\n                url,\n                data: (params.data) ? params.data : null,\n                token: (params.data || {}).token ? params.data.token : this.config.token || null\n            };\n            this.log.debug('sendNetworkRequest: ', { request });\n            const { response } = await utils_1.default.networkRequest(request);\n            return response;\n        }\n        catch ({ response }) {\n            throw response;\n        }\n    }\n    /**\n     * Create a new Session.\n     * @param {string} token - the user JSON Web Token (JWT)\n     * @returns  {Promise<Application>} - the application logged in to\n     * @example <caption>Create a session and return the Application</caption>\n     *  rtc.createSession(token).then((application) => {\n     *    console.log(application);\n     *  }).catch((error) => {\n     *    console.log(error);\n     *  });\n    */\n    createSession(token) {\n        this.config.socket_io.query.token = token;\n        this._createAndSetConnection();\n        // return a promise for the application\n        return new Promise((resolve, reject) => {\n            this.log.info(`Client-SDK Version: ${this.config.SDK_version}`);\n            this.config.token = null;\n            this.requests['session:login'] = {\n                type: 'session:login',\n                callback: async (response) => {\n                    if (response.type === 'session:success') {\n                        this.session_id = response.body.id;\n                        this.apiKey = response.body.api_key;\n                        // Store token in config\n                        this.config.token = token;\n                        // adds the session id as a query parameter in order to\n                        // connect to the same session in case of a reconnection\n                        this.connection.io.opts.query = {\n                            session_id: this.session_id,\n                            token: this.config.token\n                        };\n                        if (!this.application || (this.application.me && this.application.me.id !== response.body.user_id)) {\n                            this.application = new application_1.default(this, {});\n                        }\n                        if (!this.application.me) {\n                            this.application.me = new user_1.default(this.application, {\n                                id: response.body.user_id,\n                                name: response.body.name\n                            });\n                        }\n                        if (!this.errorsEmitter) {\n                            this.errorsEmitter = new errors_emitter_1.default(this.application);\n                        }\n                        // Set Bugsnag user to application.me.id\n                        if (this.config.log_reporter.enabled) {\n                            global.NXMbugsnagClient.user = {\n                                id: this.application.me.id,\n                                name: this.application.me.name,\n                                session_id: response.body.id\n                            };\n                        }\n                        if (this.config.sync !== 'none') {\n                            // Retrieve the existing conversation data for this user\n                            try {\n                                await this.application.getConversations();\n                                resolve(this.application);\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        }\n                        else {\n                            resolve(this.application);\n                        }\n                    }\n                    else {\n                        reject(new nexmoClientError_1.NexmoApiError(response));\n                    }\n                }\n            };\n        });\n    }\n    /**\n     * Delete existing Session.\n     * @returns  {Promise<CAPIResponse>} - response with rid and type\n     * @example <caption>Delete existing session</caption>\n     *  rtc.deleteSession().then((response) => {\n     *    console.log(response);\n     *  }).catch((error) => {\n     *    console.log(error);\n     *  });\n    */\n    deleteSession() {\n        return new Promise(async (resolve, reject) => {\n            const logoutRequest = () => {\n                return this.sendRequest({\n                    type: 'session:logout',\n                    body: {}\n                }, (response) => {\n                    if (response.type === 'session:logged-out' || response.type === 'session:terminated') {\n                        this.disconnect();\n                        delete this.errorsEmitter;\n                        delete this.application;\n                        delete this.connection;\n                        this.requests = {};\n                        this.sessionReady = false;\n                        resolve(response);\n                    }\n                    else {\n                        reject(response);\n                    }\n                });\n            };\n            // prepare for deleteSession\n            if (this.application) {\n                let disablePromises = [];\n                if (this.application.conversations.size) {\n                    for (let conversation of this.application.conversations.values()) {\n                        disablePromises.push(conversation.media.disable());\n                    }\n                }\n                try {\n                    await Promise.all(disablePromises);\n                }\n                catch (error) {\n                    this.log.error(\"deleteSession: \", error);\n                }\n                return logoutRequest();\n            }\n            else {\n                return logoutRequest();\n            }\n        });\n    }\n    updateSession(event) {\n        if (event.type === 'session:success') {\n            this.session_id = event.body.id;\n            this.connection.io.opts.query.session_id = event.body.id;\n        }\n    }\n    /**\n     * Disconnect from the cloud.\n     *\n    */\n    disconnect() {\n        return this.connection.disconnect();\n    }\n    /**\n     * Connect to the cloud.\n     *\n    */\n    connect() {\n        return this.connection.connect();\n    }\n    /**\n       * Get a connectivity report for all Vonage DCs and Media Servers.\n     * @param {string} token - the JSON Web Token (JWT)\n     * @param {object} options - configure the connectivityReport\n     * @param {Function} options.dcListCallback - a callback function to edit the list of datacenters before connectivity checks\n       * @returns  {Promise<Report>}\n       * @example <caption>Get a connectivity report</caption>\n     *\n       *  rtc.connectivityReport(token, {\n     *    dcListCallback: (dcList) => {...dcList, additionalDc}\n     *  }).then((report) => {\n     *    console.log(report);\n     *  }).catch((error) => {\n     *    console.log(error);\n     *  });\n    */\n    async connectivityReport(token, options) {\n        const ip = !rtc_helper_1.default.isNode() ? await publicip_1.default.v4() : undefined;\n        const report = {\n            machineInfo: { ip },\n            connectivityReport: []\n        };\n        try {\n            const { response } = await utils_1.default.networkRequest({\n                type: 'GET',\n                url: `${this.config.nexmo_api_url}/v0.3/discovery/api`,\n                token\n            });\n            let dcList = response;\n            if (options === null || options === void 0 ? void 0 : options.dcListCallback) {\n                dcList = options.dcListCallback(dcList);\n            }\n            for (const dc in dcList) {\n                const endpoint = dcList[dc].endpoint;\n                const apiUrl = dcList[dc].https;\n                const wsUrl = dcList[dc].ws;\n                try {\n                    const httpRes = await utils_1.default._checkHttpConnectivity(apiUrl);\n                    const wsRes = await utils_1.default._checkWsConnectivity(wsUrl, this.config.path, this.config.socket_io);\n                    const mediaConnectionReport = await utils_1.default._checkMediaServers(token, endpoint, dc);\n                    const rep = {\n                        name: dc,\n                        signalConnectionReport: {\n                            https: httpRes,\n                            ws: wsRes,\n                        },\n                        mediaConnectionReport\n                    };\n                    report.connectivityReport.push(rep);\n                }\n                catch (error) {\n                    this.log.error(`Error generating report for ${dc}`, error);\n                }\n            }\n        }\n        catch (error) {\n            this.log.error(`Error fetching nexmo servers information`, error);\n        }\n        return report;\n    }\n    /**\n      * Return a list with the connection health of the media servers for a specific datacenter.\n      * @returns  {Promise<MediaConnectionReport[]>}\n    * @param {string} token - the JSON Web Token (JWT)\n    * @param {string} nexmo_api_url - url of the nexmo api to be called\n    * @param {string} datacenter - datacenter of interest\n      * @example <caption>Return a list with the connection health of the media servers</caption>\n    *\n      *  rtc.checkMediaServers('nexmo-api-url','dc').then((responseArray) => {\n      *    console.log(responseArray);\n      *  }).catch((error) => {\n      *    console.log(error);\n      *  });\n     */\n    async checkMediaServers(token, nexmo_api_url, datacenter) {\n        return await utils_1.default._checkMediaServers(token, nexmo_api_url, datacenter);\n    }\n    /**\n    * Return the connection health of a single media server including possible connectionTime in ms.\n    * @returns  {Promise<MediaConnectionReport>}\n    * @param {string} ip - ip address of the Media Server\n    * @param {string} port - port number of the Media Server\n    * @example <caption>Return the connection health of a single media server</caption>\n    *\n    *  rtc.checkMediaConnectivity('ip-address','1').then((response) => {\n    *    console.log(`IP Address of media server: ${response.ip}`);\n    *    console.log(`Able to connect: ${response.canConnect}`);\n    *    console.log(`ConnectionTime in ms: ${resonse.connectionTime}`);\n    *  }).catch((error) => {\n    *    console.log(error);\n    *  });\n   */\n    async checkMediaConnectivity(ip, port) {\n        return await utils_1.default._checkMediaConnectivity(ip, port);\n    }\n}\nexports.default = NexmoClient;\n/**\n * Enum for NexmoClient disconnection reason.\n * @readonly\n * @enum {string}\n * @alias NexmoClient.DISCONNECT_REASON\n*/\nNexmoClient.DISCONNECT_REASON = {\n    ClientDisconnected: 'ClientDisconnected',\n    TokenExpired: 'TokenExpired',\n    ConnectionError: 'ConnectionError'\n};\nmodule.exports = NexmoClient;\n\n}).call(this)}).call(this,typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./application\":1,\"./modules/errors_emitter\":14,\"./modules/publicip\":17,\"./modules/rtc_helper\":18,\"./nexmoClientError\":20,\"./user\":29,\"./utils\":31,\"@bugsnag/js\":33,\"loglevel\":63,\"loglevel-plugin-prefix\":62,\"socket.io-client\":77,\"wildemitter\":107}],29:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  User Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst WildEmitter = require('wildemitter');\nclass User {\n    constructor(application, params) {\n        this.application = application;\n        Object.assign(this, params);\n        WildEmitter.mixin(User);\n    }\n}\nexports.default = User;\nmodule.exports = User;\n\n},{\"wildemitter\":107}],30:[function(require,module,exports){\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  UserSession Object Model\n *\n * Copyright (c) Nexmo Inc.\n */\nconst WildEmitter = require('wildemitter');\nclass UserSession {\n    constructor(application, params) {\n        var _a, _b;\n        this.application = application;\n        this.id = (_a = params === null || params === void 0 ? void 0 : params.id) !== null && _a !== void 0 ? _a : null;\n        this._embedded = (_b = params === null || params === void 0 ? void 0 : params._embedded) !== null && _b !== void 0 ? _b : null;\n        WildEmitter.mixin(UserSession);\n    }\n}\nexports.default = UserSession;\nmodule.exports = UserSession;\n\n},{\"wildemitter\":107}],31:[function(require,module,exports){\n'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Nexmo Client SDK\n *  Utility functions\n *\n * Copyright (c) Nexmo Inc.\n */\nconst uuid_1 = __importDefault(require(\"uuid\"));\nconst socket_io_client_1 = __importDefault(require(\"socket.io-client\"));\nconst application_1 = __importDefault(require(\"./application\"));\nconst MEDIA_CONNECTIVITY_TIMEOUT = 40000; // 40s is the default timeout for ice candidates gathering\nconst WS_CONNECTIVITY_TIMEOUT = 20000; // 20s is the default timeout for ws connection\n/**\n * Utilities class for the SDK.\n *\n * @class Utils\n * @private\n */\nclass Utils {\n    /**\n     * Get the Member from the username of a conversation\n     *\n     * @param {string} username the username of the member to get\n     * @param {Conversation} conversation the Conversation to search in\n     * @returns {Member} the requested Member\n     * @static\n     */\n    static getMemberFromNameOrNull(conversation, username) {\n        if (!conversation || !username)\n            return null;\n        for (let member of conversation.members.values()) {\n            if (member.user.name === username) {\n                return member;\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the Member's number or uri from the event's channel field\n     *\n     * @param {object} channel the event's channel field\n     * @returns {string} the requested Member number or uri\n     * @static\n     */\n    static getMemberNumberFromEventOrNull(channel) {\n        const from = channel && channel.from;\n        if (from && (from.number || from.uri)) {\n            return from.number || from.uri;\n        }\n        return null;\n    }\n    /**\n     * Perform a network request to the given url\n     *\n     * @param {object} reqObject the object that has all the information for the request\n     * @param {string} url the request url\n     * @param {string} type=GET|POST|PUT|DELETE the types of the network request\n     * @param {object} [data] the data that are going to be sent\n     * @param {string} [responseType] the response type of the request\n     * @param {string} token the jwt token for the network request\n     * @returns {Promise<NetworkRequestResponse>} the NetworkRequestResponse\n     * @static\n     */\n    static networkRequest(reqObject) {\n        return new Promise((resolve, reject) => {\n            if (!reqObject.token &&\n                !reqObject.url.includes('logging') &&\n                !reqObject.url.includes('ping')) {\n                // eslint-disable-next-line prefer-promise-reject-errors\n                reject({\n                    response: {\n                        type: 'error:user:token',\n                        description: 'network error on request. Please create a new session.'\n                    }\n                });\n            }\n            const xhr = new XMLHttpRequest();\n            let data;\n            xhr.open(reqObject.type, reqObject.url, true);\n            if (reqObject.token) {\n                xhr.setRequestHeader('Authorization', 'Bearer ' + reqObject.token);\n            }\n            if (reqObject && reqObject.url.includes('image')) {\n                xhr.responseType = '';\n                data = reqObject.data;\n                xhr.onloadstart = () => {\n                    resolve(xhr);\n                };\n            }\n            else {\n                xhr.responseType = reqObject.responseType || 'json';\n                data = JSON.stringify(reqObject.data) || null;\n                xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n            }\n            xhr.onload = () => {\n                if (xhr.status === 200 || xhr.status === 201 || xhr.status === 204) {\n                    resolve(xhr);\n                }\n                else {\n                    reject(xhr);\n                }\n            };\n            xhr.onerror = (error) => {\n                reject(error);\n            };\n            xhr.send(data);\n        });\n    }\n    /**\n     * Perform a GET network request for fetching paginated conversations and events\n     *\n     * @param {string} url the request url\n     * @param {object} [params] network request params\n     * @param {string} [params.cursor] cursor parameter to access the next or previous page of a data set\n     * @param {number} [params.page_size] the number of resources returned in a single request list\n     * @param {string} [params.order] 'asc' or 'desc' ordering of resources (usually based on creation time)\n     * @param {string} [params.event_type] the type of event used to filter event requests ('member:joined', 'audio:dtmf', etc)\n     * @param {string} token the jwt token for the network request\n     * @param {string} [version=Application.CONVERSATION_API_VERSION.v1] version of conversation service that is used for the request (one of v1 and v3)\n     *\n     * @returns {Promise<XMLHttpRequest.response>} the XMLHttpRequest\n     * @static\n     * @example <caption>Sending a nexmo GET request</caption>\n     *    paginationRequest(url, params).then((response) => {\n     *      response.items: {},\n     *      response.cursor: {\n     *          prev: '',\n     *          next: '',\n     *          self: ''\n     *      },\n     *      response.page_size: 10,\n     *      response.order: 'asc',\n     *   });\n     */\n    static async paginationRequest(url, params, token, version = application_1.default.CONVERSATION_API_VERSION.v1) {\n        try {\n            const xhr = await Utils.networkRequest({\n                type: 'GET',\n                url: Utils.addUrlSearchParams(url, params),\n                token\n            });\n            const { page_size, _embedded, _links } = xhr.response;\n            const resource = url.split('/').pop().trim();\n            return {\n                items: (version === application_1.default.CONVERSATION_API_VERSION.v1) ? _embedded.data[resource] : _embedded[resource],\n                cursor: {\n                    prev: _links.prev ? new URLSearchParams(_links.prev.href).get('cursor') : '',\n                    next: _links.next ? new URLSearchParams(_links.next.href).get('cursor') : '',\n                    self: _links.self ? new URLSearchParams(_links.self.href).get('cursor') : ''\n                },\n                page_size: page_size,\n                order: params.order || 'asc',\n                event_type: params.event_type || null\n            };\n        }\n        catch ({ response }) {\n            const parsed_error = response ?\n                response : { type: 'error:network:get-request', description: 'network error on nexmo get request' };\n            if (parsed_error.validation) {\n                parsed_error.description = parsed_error.validation[Object.keys(parsed_error.validation)[0]];\n            }\n            throw parsed_error;\n        }\n    }\n    /**\n     * Update the Search Params of a url\n     * @returns {string} the appended url\n     * @static\n     */\n    static addUrlSearchParams(url, params = {}) {\n        let appended_url = new URL(url);\n        Object.keys(params).forEach((key) => {\n            if (params[key] && !(typeof params[key] === 'string' && params[key].length < 1) && params[key] !== null) {\n                appended_url.searchParams.set(key, params[key]);\n            }\n        });\n        return appended_url.href;\n    }\n    /**\n     * Deep merges two objects\n     * @returns {Object} the new merged object\n     * @static\n     */\n    static deepMergeObj(obj1, obj2) {\n        const mergedObj = JSON.parse(JSON.stringify(obj1));\n        // Merge the object into the new mergedObject\n        for (let prop in obj2) {\n            // If the property is an object then merge properties\n            if (Object.prototype.toString.call(obj2[prop]) === '[object Object]') {\n                mergedObj[prop] = Utils.deepMergeObj(mergedObj[prop], obj2[prop]);\n            }\n            else {\n                mergedObj[prop] = obj2[prop];\n            }\n        }\n        return mergedObj;\n    }\n    /**\n     * Inject a script into the document\n     *\n     * @param {string} s script being executed\n     * @param {requestCallback} c the callback fired after script executed\n     * @static\n     */\n    static injectScript(u, c) {\n        if (typeof document !== 'undefined') {\n            let h = document.getElementsByTagName('head')[0];\n            let s = document.createElement('script');\n            s.async = true;\n            s.src = u;\n            s.onload = s.onreadystatechange = () => {\n                if (!s.readyState || /loaded|complete/.test(s.readyState)) {\n                    s.onload = s.onreadystatechange = null;\n                    s = null;\n                    if (c) {\n                        c();\n                    }\n                }\n            };\n            h.insertBefore(s, h.firstChild);\n        }\n    }\n    static allocateUUID() {\n        return uuid_1.default.v4();\n    }\n    /**\n     * Validate dtmf digit\n     * @static\n     */\n    static validateDTMF(digit) {\n        return typeof digit === 'string' ? /^[\\da-dA-D#*pP]{1,45}$$/.test(digit) : false;\n    }\n    /**\n     * Get the nexmo bugsnag api key\n     * @private\n     */\n    static _getBugsnagKey() {\n        return '76498fc1ca8d9b0a173a44e2b873d7ed';\n    }\n    /**\n     * Update the member legs array with the new one received in the event\n     *\n     * @param {Array} legs the member legs array\n     * @param {NXMEvent} event the member event holding the new legs array\n     * @static\n     */\n    static updateMemberLegs(legs, event) {\n        if (legs) {\n            // find the leg in the legs array if exists\n            const leg = legs.find((leg) => leg.leg_id === event.body.leg_id);\n            if (!leg) {\n                legs.push({\n                    leg_id: event.body.leg_id,\n                    status: event.body.status\n                });\n            }\n            else if (leg.status !== event.body.status) {\n                // if the status of the leg is different from the event status\n                // update the leg object with the new leg status\n                let index = legs.indexOf(leg);\n                legs.fill(leg.status = event.body.status, index, index++);\n            }\n        }\n        else {\n            legs = [{\n                    leg_id: event.body.leg_id,\n                    status: event.body.status\n                }];\n        }\n        return legs;\n    }\n    /**\n     * Check if the event is referenced to a call or simple conversation\n     * @private\n     */\n    static _isCallEvent(event) {\n        const { channel, media } = event.body;\n        // in case we have a transfer we should fetch the conversation\n        // including the new membership\n        if (event.type === \"rtc:transfer\")\n            return true;\n        // this check differentiates the call flow with the non call\n        // IP-PSTN (member:joined) should have an knocking_id inside the channel\n        // PSTN-IP and IP-IP (member:invited) should have audio_settings.enabled = true\n        if (channel && ((media && media.audio_settings && media.audio_settings.enabled) ||\n            (media && media.audio && media.audio.enabled) || channel.knocking_id)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fetch an image from Media Service\n     * @private\n     */\n    static async _fetchImage(url, token) {\n        const { response } = await Utils.networkRequest({\n            type: 'GET',\n            url,\n            responseType: 'arraybuffer',\n            token\n        });\n        const responseArray = new Uint8Array(response);\n        // Convert the int array to a binary String\n        // We have to use apply() as we are converting an *array*\n        // and String.fromCharCode() takes one or more single values, not\n        // an array.\n        // support large image files (Chunking)\n        let res = '';\n        const chunk = 8 * 1024;\n        let i;\n        for (i = 0; i < responseArray.length / chunk; i++) {\n            res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk, (i + 1) * chunk));\n        }\n        res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk));\n        return 'data:image/jpeg;base64,' + btoa(res);\n    }\n    /**\n     * Check if HTTP URL is reachable\n     * @private\n     */\n    static async _checkHttpConnectivity(url) {\n        const timeBeforeConnecting = Date.now();\n        try {\n            await Utils.networkRequest({\n                type: 'GET',\n                url\n            });\n            const connectionTime = Date.now() - timeBeforeConnecting;\n            return { url, canConnect: true, connectionTime };\n        }\n        catch (error) {\n            return { url, canConnect: false, error };\n        }\n    }\n    /**\n     * Check if websocket URL is reachable\n     * @private\n     */\n    static _checkWsConnectivity(ws_url, path, config) {\n        return new Promise((resolve, reject) => {\n            const socket_io_config = Object.assign({ path }, config);\n            const timeBeforeConnecting = Date.now();\n            const connection = socket_io_client_1.default.connect(ws_url, socket_io_config);\n            const timeout = setTimeout(() => resolve({ url: ws_url, canConnect: false }), WS_CONNECTIVITY_TIMEOUT);\n            connection.on('connect', () => {\n                const connectionTime = Date.now() - timeBeforeConnecting;\n                connection.disconnect();\n                clearTimeout(timeout);\n                resolve({ url: ws_url, canConnect: true, connectionTime });\n            });\n            connection.on('error', (error) => {\n                connection.disconnect();\n                clearTimeout(timeout);\n                resolve({ url: ws_url, canConnect: false, error });\n            });\n        });\n    }\n    /**\n     * Return a list with the connection health of the Media Servers\n     * @private\n     */\n    static async _checkMediaServers(token, nexmo_api_url, datacenter) {\n        try {\n            const { response } = await Utils.networkRequest({\n                type: 'GET',\n                url: `${nexmo_api_url}/v0.3/discovery/media/${datacenter}`,\n                token\n            });\n            const reqList = response.map((host) => Utils._checkMediaConnectivity(host.ip, host.port));\n            return await Promise.all(reqList);\n        }\n        catch (error) {\n            return [];\n        }\n    }\n    /**\n     * Check if we can establish a peer connection with a specific Media Server\n     * @private\n     */\n    static async _checkMediaConnectivity(ip, port) {\n        return new Promise(async (resolve, reject) => {\n            const configuration = { iceServers: [{ urls: `stun:${ip}:${port}` }] };\n            const pc = new RTCPeerConnection(configuration);\n            const timeBeforeConnecting = Date.now();\n            const offer = await pc.createOffer({ offerToReceiveAudio: true });\n            pc.setLocalDescription(offer);\n            const timeout = setTimeout(() => {\n                pc.close();\n                resolve({ ip, canConnect: false });\n            }, MEDIA_CONNECTIVITY_TIMEOUT);\n            pc.onicecandidate = ({ candidate }) => {\n                if ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === \"srflx\") {\n                    const connectionTime = Date.now() - timeBeforeConnecting;\n                    // Connection established successfully\n                    clearTimeout(timeout);\n                    pc.close();\n                    resolve({ ip, canConnect: true, connectionTime });\n                }\n            };\n            pc.onicecandidateerror = (event) => {\n                if (event.errorCode) {\n                    pc.close();\n                    clearTimeout(timeout);\n                    resolve({ ip, canConnect: false, error: event });\n                }\n            };\n        });\n    }\n    /**\n     * Check if the user is re invited to an existing conversation\n     * @private\n     */\n    static _checkIfUserIsReInvited(conversations, event) {\n        var _a;\n        if (!conversations.has(event.cid))\n            return false;\n        if (!(event.type === 'member:invited' || event.type === 'member:joined'))\n            return false;\n        const me = (_a = conversations.get(event.cid)) === null || _a === void 0 ? void 0 : _a.me;\n        if (!me)\n            return false;\n        if (me.user.name === event.body.user.name && me.state === 'LEFT')\n            return true;\n        return false;\n    }\n}\nexports.default = Utils;\nmodule.exports = Utils;\n\n},{\"./application\":1,\"socket.io-client\":77,\"uuid\":87}],32:[function(require,module,exports){\n(function (global){(function (){\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else{ var g; }})(function(){var define,module,exports;\n// minimal implementations of useful ES functionality\n// all we really need for arrays is reduce – everything else is just sugar!\n// Array#reduce\nvar reduce = function (arr, fn, accum) {\n  var val = accum;\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    val = fn(val, arr[i], i, arr);\n  }\n\n  return val;\n}; // Array#filter\n\n\nvar filter = function (arr, fn) {\n  return reduce(arr, function (accum, item, i, arr) {\n    return !fn(item, i, arr) ? accum : accum.concat(item);\n  }, []);\n}; // Array#map\n\n\nvar map = function (arr, fn) {\n  return reduce(arr, function (accum, item, i, arr) {\n    return accum.concat(fn(item, i, arr));\n  }, []);\n}; // Array#includes\n\n\nvar includes = function (arr, x) {\n  return reduce(arr, function (accum, item, i, arr) {\n    return accum === true || item === x;\n  }, false);\n};\n\nvar _hasDontEnumBug = !{\n  toString: null\n}.propertyIsEnumerable('toString');\n\nvar _dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor']; // Object#keys\n\nvar keys = function (obj) {\n  // stripped down version of\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/Keys\n  var result = [];\n  var prop;\n\n  for (prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) result.push(prop);\n  }\n\n  if (!_hasDontEnumBug) return result;\n\n  for (var i = 0, len = _dontEnums.length; i < len; i++) {\n    if (Object.prototype.hasOwnProperty.call(obj, _dontEnums[i])) result.push(_dontEnums[i]);\n  }\n\n  return result;\n}; // Array#isArray\n\n\nvar isArray = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar _pad = function (n) {\n  return n < 10 ? \"0\" + n : n;\n}; // Date#toISOString\n\n\nvar isoDate = function () {\n  // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\n  var d = new Date();\n  return d.getUTCFullYear() + '-' + _pad(d.getUTCMonth() + 1) + '-' + _pad(d.getUTCDate()) + 'T' + _pad(d.getUTCHours()) + ':' + _pad(d.getUTCMinutes()) + ':' + _pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';\n};\n\nvar _$esUtils_8 = {\n  map: map,\n  reduce: reduce,\n  filter: filter,\n  includes: includes,\n  keys: keys,\n  isArray: isArray,\n  isoDate: isoDate\n};\n\nvar _$validators_15 = {};\n_$validators_15.intRange = function (min, max) {\n  if (min === void 0) {\n    min = 1;\n  }\n\n  if (max === void 0) {\n    max = Infinity;\n  }\n\n  return function (value) {\n    return typeof value === 'number' && parseInt('' + value, 10) === value && value >= min && value <= max;\n  };\n};\n\n_$validators_15.stringWithLength = function (value) {\n  return typeof value === 'string' && !!value.length;\n};\n\nvar _$config_5 = {};\nvar __filter_5 = _$esUtils_8.filter,\n    __reduce_5 = _$esUtils_8.reduce,\n    __keys_5 = _$esUtils_8.keys,\n    __isArray_5 = _$esUtils_8.isArray,\n    __includes_5 = _$esUtils_8.includes;\n\nvar intRange = _$validators_15.intRange,\n    stringWithLength = _$validators_15.stringWithLength;\n\n_$config_5.schema = {\n  apiKey: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'is required',\n    validate: stringWithLength\n  },\n  appVersion: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return value === null || stringWithLength(value);\n    }\n  },\n  appType: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return value === null || stringWithLength(value);\n    }\n  },\n  autoNotify: {\n    defaultValue: function () {\n      return true;\n    },\n    message: 'should be true|false',\n    validate: function (value) {\n      return value === true || value === false;\n    }\n  },\n  beforeSend: {\n    defaultValue: function () {\n      return [];\n    },\n    message: 'should be a function or array of functions',\n    validate: function (value) {\n      return typeof value === 'function' || __isArray_5(value) && __filter_5(value, function (f) {\n        return typeof f === 'function';\n      }).length === value.length;\n    }\n  },\n  endpoints: {\n    defaultValue: function () {\n      return {\n        notify: 'https://notify.bugsnag.com',\n        sessions: 'https://sessions.bugsnag.com'\n      };\n    },\n    message: 'should be an object containing endpoint URLs { notify, sessions }. sessions is optional if autoCaptureSessions=false',\n    validate: function (val, obj) {\n      return (// first, ensure it's an object\n        val && typeof val === 'object' && // endpoints.notify must always be set\n        stringWithLength(val.notify) && ( // endpoints.sessions must be set unless session tracking is explicitly off\n        obj.autoCaptureSessions === false || stringWithLength(val.sessions)) && // ensure no keys other than notify/session are set on endpoints object\n        __filter_5(__keys_5(val), function (k) {\n          return !__includes_5(['notify', 'sessions'], k);\n        }).length === 0\n      );\n    }\n  },\n  autoCaptureSessions: {\n    defaultValue: function (val, opts) {\n      return opts.endpoints === undefined || !!opts.endpoints && !!opts.endpoints.sessions;\n    },\n    message: 'should be true|false',\n    validate: function (val) {\n      return val === true || val === false;\n    }\n  },\n  notifyReleaseStages: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'should be an array of strings',\n    validate: function (value) {\n      return value === null || __isArray_5(value) && __filter_5(value, function (f) {\n        return typeof f === 'string';\n      }).length === value.length;\n    }\n  },\n  releaseStage: {\n    defaultValue: function () {\n      return 'production';\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return typeof value === 'string' && value.length;\n    }\n  },\n  maxBreadcrumbs: {\n    defaultValue: function () {\n      return 20;\n    },\n    message: 'should be a number ≤40',\n    validate: function (value) {\n      return intRange(0, 40)(value);\n    }\n  },\n  autoBreadcrumbs: {\n    defaultValue: function () {\n      return true;\n    },\n    message: 'should be true|false',\n    validate: function (value) {\n      return typeof value === 'boolean';\n    }\n  },\n  user: {\n    defaultValue: function () {\n      return null;\n    },\n    message: '(object) user should be an object',\n    validate: function (value) {\n      return typeof value === 'object';\n    }\n  },\n  metaData: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'should be an object',\n    validate: function (value) {\n      return typeof value === 'object';\n    }\n  },\n  logger: {\n    defaultValue: function () {\n      return undefined;\n    },\n    message: 'should be null or an object with methods { debug, info, warn, error }',\n    validate: function (value) {\n      return !value || value && __reduce_5(['debug', 'info', 'warn', 'error'], function (accum, method) {\n        return accum && typeof value[method] === 'function';\n      }, true);\n    }\n  },\n  filters: {\n    defaultValue: function () {\n      return ['password'];\n    },\n    message: 'should be an array of strings|regexes',\n    validate: function (value) {\n      return __isArray_5(value) && value.length === __filter_5(value, function (s) {\n        return typeof s === 'string' || s && typeof s.test === 'function';\n      }).length;\n    }\n  }\n};\n\n_$config_5.mergeDefaults = function (opts, schema) {\n  if (!opts || !schema) throw new Error('opts and schema objects are required');\n  return __reduce_5(__keys_5(schema), function (accum, key) {\n    accum[key] = opts[key] !== undefined ? opts[key] : schema[key].defaultValue(opts[key], opts);\n    return accum;\n  }, {});\n};\n\n_$config_5.validate = function (opts, schema) {\n  if (!opts || !schema) throw new Error('opts and schema objects are required');\n  var errors = __reduce_5(__keys_5(schema), function (accum, key) {\n    if (schema[key].validate(opts[key], opts)) return accum;\n    return accum.concat({\n      key: key,\n      message: schema[key].message,\n      value: opts[key]\n    });\n  }, []);\n  return {\n    valid: !errors.length,\n    errors: errors\n  };\n};\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar schema = _$config_5.schema;\n\nvar __map_1 = _$esUtils_8.map;\n\nvar __stringWithLength_1 = _$validators_15.stringWithLength;\n\nvar _$config_1 = {\n  releaseStage: {\n    defaultValue: function () {\n      if (/^localhost(:\\d+)?$/.test(window.location.host)) return 'development';\n      return 'production';\n    },\n    message: 'should be set',\n    validate: __stringWithLength_1\n  },\n  logger: _extends({}, schema.logger, {\n    defaultValue: function () {\n      return (// set logger based on browser capability\n        typeof console !== 'undefined' && typeof console.debug === 'function' ? getPrefixedConsole() : undefined\n      );\n    }\n  })\n};\n\nvar getPrefixedConsole = function () {\n  var logger = {};\n  var consoleLog = console['log'];\n  __map_1(['debug', 'info', 'warn', 'error'], function (method) {\n    var consoleMethod = console[method];\n    logger[method] = typeof consoleMethod === 'function' ? consoleMethod.bind(console, '[bugsnag]') : consoleLog.bind(console, '[bugsnag]');\n  });\n  return logger;\n};\n\nvar __isoDate_3 = _$esUtils_8.isoDate;\n\nvar BugsnagBreadcrumb =\n/*#__PURE__*/\nfunction () {\n  function BugsnagBreadcrumb(name, metaData, type, timestamp) {\n    if (name === void 0) {\n      name = '[anonymous]';\n    }\n\n    if (metaData === void 0) {\n      metaData = {};\n    }\n\n    if (type === void 0) {\n      type = 'manual';\n    }\n\n    if (timestamp === void 0) {\n      timestamp = __isoDate_3();\n    }\n\n    this.type = type;\n    this.name = name;\n    this.metaData = metaData;\n    this.timestamp = timestamp;\n  }\n\n  var _proto = BugsnagBreadcrumb.prototype;\n\n  _proto.toJSON = function toJSON() {\n    return {\n      type: this.type,\n      name: this.name,\n      timestamp: this.timestamp,\n      metaData: this.metaData\n    };\n  };\n\n  return BugsnagBreadcrumb;\n}();\n\nvar _$BugsnagBreadcrumb_3 = BugsnagBreadcrumb;\n\n// This is a heavily modified/simplified version of\n//   https://github.com/othiym23/async-some\n//\n// We can't use that because:\n//   a) it inflates the bundle size to over 10kB\n//   b) it depends on a module that uses Object.keys()\n//      (which we can't use due to ie8 support)\n// run the asynchronous test function (fn) over each item in the array (arr)\n// in series until:\n//   - fn(item, cb) => calls cb(null, true)\n//   - or the end of the array is reached\n// the callback (cb) will be passed true if any of the items resulted in a true\n// callback, otherwise false\nvar _$asyncSome_6 = function (arr, fn, cb) {\n  var length = arr.length;\n  var index = 0;\n\n  var next = function () {\n    if (index >= length) return cb(null, false);\n    fn(arr[index], function (err, result) {\n      if (err) return cb(err, false);\n      if (result === true) return cb(null, true);\n      index++;\n      next();\n    });\n  };\n\n  next();\n};\n\nvar _$inferReleaseStage_10 = function (client) {\n  return client.app && typeof client.app.releaseStage === 'string' ? client.app.releaseStage : client.config.releaseStage;\n};\n\n/**\n * Expose `isError`.\n */\nvar _$isError_21 = isError;\n/**\n * Test whether `value` is error object.\n *\n * @param {*} value\n * @returns {boolean}\n */\n\nfunction isError(value) {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n      return true;\n\n    case '[object Exception]':\n      return true;\n\n    case '[object DOMException]':\n      return true;\n\n    default:\n      return value instanceof Error;\n  }\n}\n\nvar _$iserror_11 = _$isError_21;\n\nvar _$runBeforeSend_14 = function (report, onError) {\n  return function (fn, cb) {\n    if (typeof fn !== 'function') return cb(null, false);\n\n    try {\n      // if function appears sync…\n      if (fn.length !== 2) {\n        var ret = fn(report); // check if it returned a \"thenable\" (promise)\n\n        if (ret && typeof ret.then === 'function') {\n          return ret.then( // resolve\n          function (val) {\n            return setTimeout(function () {\n              return cb(null, shouldPreventSend(report, val));\n            }, 0);\n          }, // reject\n          function (err) {\n            setTimeout(function () {\n              onError(err);\n              return cb(null, false);\n            });\n          });\n        }\n\n        return cb(null, shouldPreventSend(report, ret));\n      } // if function is async…\n\n\n      fn(report, function (err, result) {\n        if (err) {\n          onError(err);\n          return cb(null, false);\n        }\n\n        cb(null, shouldPreventSend(report, result));\n      });\n    } catch (e) {\n      onError(e);\n      cb(null, false);\n    }\n  };\n};\n\nvar shouldPreventSend = function (report, value) {\n  return report.isIgnored() || value === false;\n};\n\nvar _$stackframe_23 = {};\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('stackframe', [], factory);\n  } else if (typeof _$stackframe_23 === 'object') {\n    _$stackframe_23 = factory();\n  } else {\n    root.StackFrame = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n  function _getter(p) {\n    return function () {\n      return this[p];\n    };\n  }\n\n  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n  var numericProps = ['columnNumber', 'lineNumber'];\n  var stringProps = ['fileName', 'functionName', 'source'];\n  var arrayProps = ['args'];\n  var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n  function StackFrame(obj) {\n    if (obj instanceof Object) {\n      for (var i = 0; i < props.length; i++) {\n        if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n          this['set' + _capitalize(props[i])](obj[props[i]]);\n        }\n      }\n    }\n  }\n\n  StackFrame.prototype = {\n    getArgs: function () {\n      return this.args;\n    },\n    setArgs: function (v) {\n      if (Object.prototype.toString.call(v) !== '[object Array]') {\n        throw new TypeError('Args must be an Array');\n      }\n\n      this.args = v;\n    },\n    getEvalOrigin: function () {\n      return this.evalOrigin;\n    },\n    setEvalOrigin: function (v) {\n      if (v instanceof StackFrame) {\n        this.evalOrigin = v;\n      } else if (v instanceof Object) {\n        this.evalOrigin = new StackFrame(v);\n      } else {\n        throw new TypeError('Eval Origin must be an Object or StackFrame');\n      }\n    },\n    toString: function () {\n      var functionName = this.getFunctionName() || '{anonymous}';\n      var args = '(' + (this.getArgs() || []).join(',') + ')';\n      var fileName = this.getFileName() ? '@' + this.getFileName() : '';\n      var lineNumber = _isNumber(this.getLineNumber()) ? ':' + this.getLineNumber() : '';\n      var columnNumber = _isNumber(this.getColumnNumber()) ? ':' + this.getColumnNumber() : '';\n      return functionName + args + fileName + lineNumber + columnNumber;\n    }\n  };\n\n  for (var i = 0; i < booleanProps.length; i++) {\n    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n      return function (v) {\n        this[p] = Boolean(v);\n      };\n    }(booleanProps[i]);\n  }\n\n  for (var j = 0; j < numericProps.length; j++) {\n    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n      return function (v) {\n        if (!_isNumber(v)) {\n          throw new TypeError(p + ' must be a Number');\n        }\n\n        this[p] = Number(v);\n      };\n    }(numericProps[j]);\n  }\n\n  for (var k = 0; k < stringProps.length; k++) {\n    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n      return function (v) {\n        this[p] = String(v);\n      };\n    }(stringProps[k]);\n  }\n\n  return StackFrame;\n});\n\nvar _$errorStackParser_20 = {};\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('error-stack-parser', ['stackframe'], factory);\n  } else if (typeof _$errorStackParser_20 === 'object') {\n    _$errorStackParser_20 = factory(_$stackframe_23);\n  } else {\n    root.ErrorStackParser = factory(root.StackFrame);\n  }\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^\\)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});\n\nvar _$errorStackParser_7 = _$errorStackParser_20;\n\n// Given `err` which may be an error, does it have a stack property which is a string?\nvar _$hasStack_9 = function (err) {\n  return !!err && (!!err.stack || !!err.stacktrace || !!err['opera#sourceloc']) && typeof (err.stack || err.stacktrace || err['opera#sourceloc']) === 'string' && err.stack !== err.name + \": \" + err.message;\n};\n\nvar _$jsRuntime_12 =  true ? 'browserjs' : 0;\n\nvar _$stackGenerator_22 = {};\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('stack-generator', ['stackframe'], factory);\n  } else if (typeof _$stackGenerator_22 === 'object') {\n    _$stackGenerator_22 = factory(_$stackframe_23);\n  } else {\n    root.StackGenerator = factory(root.StackFrame);\n  }\n})(this, function (StackFrame) {\n  return {\n    backtrace: function StackGenerator$$backtrace(opts) {\n      var stack = [];\n      var maxStackSize = 10;\n\n      if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n        maxStackSize = opts.maxStackSize;\n      }\n\n      var curr = arguments.callee;\n\n      while (curr && stack.length < maxStackSize && curr['arguments']) {\n        // Allow V8 optimizations\n        var args = new Array(curr['arguments'].length);\n\n        for (var i = 0; i < args.length; ++i) {\n          args[i] = curr['arguments'][i];\n        }\n\n        if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n          stack.push(new StackFrame({\n            functionName: RegExp.$1 || undefined,\n            args: args\n          }));\n        } else {\n          stack.push(new StackFrame({\n            args: args\n          }));\n        }\n\n        try {\n          curr = curr.caller;\n        } catch (e) {\n          break;\n        }\n      }\n\n      return stack;\n    }\n  };\n});\n\nfunction ___extends_24() { ___extends_24 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_24.apply(this, arguments); }\n\n/* removed: var _$errorStackParser_7 = require('./lib/error-stack-parser'); */;\n\n/* removed: var _$stackGenerator_22 = require('stack-generator'); */;\n\n/* removed: var _$hasStack_9 = require('./lib/has-stack'); */;\n\nvar __reduce_24 = _$esUtils_8.reduce,\n    __filter_24 = _$esUtils_8.filter;\n\n/* removed: var _$jsRuntime_12 = require('./lib/js-runtime'); */;\n\nvar BugsnagReport =\n/*#__PURE__*/\nfunction () {\n  function BugsnagReport(errorClass, errorMessage, stacktrace, handledState, originalError) {\n    if (stacktrace === void 0) {\n      stacktrace = [];\n    }\n\n    if (handledState === void 0) {\n      handledState = defaultHandledState();\n    }\n\n    // duck-typing ftw >_<\n    this.__isBugsnagReport = true;\n    this._ignored = false; // private (un)handled state\n\n    this._handledState = handledState; // setable props\n\n    this.app = undefined;\n    this.apiKey = undefined;\n    this.breadcrumbs = [];\n    this.context = undefined;\n    this.device = undefined;\n    this.errorClass = stringOrFallback(errorClass, '[no error class]');\n    this.errorMessage = stringOrFallback(errorMessage, '[no error message]');\n    this.groupingHash = undefined;\n    this.metaData = {};\n    this.request = undefined;\n    this.severity = this._handledState.severity;\n    this.stacktrace = __reduce_24(stacktrace, function (accum, frame) {\n      var f = formatStackframe(frame); // don't include a stackframe if none of its properties are defined\n\n      try {\n        if (JSON.stringify(f) === '{}') return accum;\n        return accum.concat(f);\n      } catch (e) {\n        return accum;\n      }\n    }, []);\n    this.user = undefined;\n    this.session = undefined;\n    this.originalError = originalError; // Flags.\n    // Note these are not initialised unless they are used\n    // to save unnecessary bytes in the browser bundle\n\n    /* this.attemptImmediateDelivery, default: true */\n  }\n\n  var _proto = BugsnagReport.prototype;\n\n  _proto.ignore = function ignore() {\n    this._ignored = true;\n  };\n\n  _proto.isIgnored = function isIgnored() {\n    return this._ignored;\n  };\n\n  _proto.updateMetaData = function updateMetaData(section) {\n    var _updates;\n\n    if (!section) return this;\n    var updates; // updateMetaData(\"section\", null) -> removes section\n\n    if ((arguments.length <= 1 ? undefined : arguments[1]) === null) return this.removeMetaData(section); // updateMetaData(\"section\", \"property\", null) -> removes property from section\n\n    if ((arguments.length <= 2 ? undefined : arguments[2]) === null) return this.removeMetaData(section, arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]); // normalise the two supported input types into object form\n\n    if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'object') updates = arguments.length <= 1 ? undefined : arguments[1];\n    if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'string') updates = (_updates = {}, _updates[arguments.length <= 1 ? undefined : arguments[1]] = arguments.length <= 2 ? undefined : arguments[2], _updates); // exit if we don't have an updates object at this point\n\n    if (!updates) return this; // ensure a section with this name exists\n\n    if (!this.metaData[section]) this.metaData[section] = {}; // merge the updates with the existing section\n\n    this.metaData[section] = ___extends_24({}, this.metaData[section], updates);\n    return this;\n  };\n\n  _proto.removeMetaData = function removeMetaData(section, property) {\n    if (typeof section !== 'string') return this; // remove an entire section\n\n    if (!property) {\n      delete this.metaData[section];\n      return this;\n    } // remove a single property from a section\n\n\n    if (this.metaData[section]) {\n      delete this.metaData[section][property];\n      return this;\n    }\n\n    return this;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return {\n      payloadVersion: '4',\n      exceptions: [{\n        errorClass: this.errorClass,\n        message: this.errorMessage,\n        stacktrace: this.stacktrace,\n        type: _$jsRuntime_12\n      }],\n      severity: this.severity,\n      unhandled: this._handledState.unhandled,\n      severityReason: this._handledState.severityReason,\n      app: this.app,\n      device: this.device,\n      breadcrumbs: this.breadcrumbs,\n      context: this.context,\n      user: this.user,\n      metaData: this.metaData,\n      groupingHash: this.groupingHash,\n      request: this.request,\n      session: this.session\n    };\n  };\n\n  return BugsnagReport;\n}(); // takes a stacktrace.js style stackframe (https://github.com/stacktracejs/stackframe)\n// and returns a Bugsnag compatible stackframe (https://docs.bugsnag.com/api/error-reporting/#json-payload)\n\n\nvar formatStackframe = function (frame) {\n  var f = {\n    file: frame.fileName,\n    method: normaliseFunctionName(frame.functionName),\n    lineNumber: frame.lineNumber,\n    columnNumber: frame.columnNumber,\n    code: undefined,\n    inProject: undefined // Some instances result in no file:\n    // - calling notify() from chrome's terminal results in no file/method.\n    // - non-error exception thrown from global code in FF\n    // This adds one.\n\n  };\n\n  if (f.lineNumber > -1 && !f.file && !f.method) {\n    f.file = 'global code';\n  }\n\n  return f;\n};\n\nvar normaliseFunctionName = function (name) {\n  return /^global code$/i.test(name) ? 'global code' : name;\n};\n\nvar defaultHandledState = function () {\n  return {\n    unhandled: false,\n    severity: 'warning',\n    severityReason: {\n      type: 'handledException'\n    }\n  };\n};\n\nvar stringOrFallback = function (str, fallback) {\n  return typeof str === 'string' && str ? str : fallback;\n}; // Helpers\n\n\nBugsnagReport.getStacktrace = function (error, errorFramesToSkip, generatedFramesToSkip) {\n  if (errorFramesToSkip === void 0) {\n    errorFramesToSkip = 0;\n  }\n\n  if (generatedFramesToSkip === void 0) {\n    generatedFramesToSkip = 0;\n  }\n\n  if (_$hasStack_9(error)) return _$errorStackParser_7.parse(error).slice(errorFramesToSkip); // in IE11 a new Error() doesn't have a stacktrace until you throw it, so try that here\n\n  try {\n    throw error;\n  } catch (e) {\n    if (_$hasStack_9(e)) return _$errorStackParser_7.parse(error).slice(1 + generatedFramesToSkip); // error wasn't provided or didn't have a stacktrace so try to walk the callstack\n\n    try {\n      return __filter_24(_$stackGenerator_22.backtrace(), function (frame) {\n        return (frame.functionName || '').indexOf('StackGenerator$$') === -1;\n      }).slice(1 + generatedFramesToSkip);\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\nBugsnagReport.ensureReport = function (reportOrError, errorFramesToSkip, generatedFramesToSkip) {\n  if (errorFramesToSkip === void 0) {\n    errorFramesToSkip = 0;\n  }\n\n  if (generatedFramesToSkip === void 0) {\n    generatedFramesToSkip = 0;\n  }\n\n  // notify() can be called with a Report object. In this case no action is required\n  if (reportOrError.__isBugsnagReport) return reportOrError;\n\n  try {\n    var stacktrace = BugsnagReport.getStacktrace(reportOrError, errorFramesToSkip, 1 + generatedFramesToSkip);\n    return new BugsnagReport(reportOrError.name, reportOrError.message, stacktrace, undefined, reportOrError);\n  } catch (e) {\n    return new BugsnagReport(reportOrError.name, reportOrError.message, [], undefined, reportOrError);\n  }\n};\n\nvar _$BugsnagReport_24 = BugsnagReport;\n\nvar _$pad_18 = function pad(num, size) {\n  var s = '000000000' + num;\n  return s.substr(s.length - size);\n};\n\n/* removed: var _$pad_18 = require('./pad.js'); */;\n\nvar env = typeof window === 'object' ? window : self;\nvar globalCount = 0;\n\nfor (var prop in env) {\n  if (Object.hasOwnProperty.call(env, prop)) globalCount++;\n}\n\nvar mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;\nvar clientId = _$pad_18((mimeTypesLength + navigator.userAgent.length).toString(36) + globalCount.toString(36), 4);\n\nvar _$fingerprint_17 = function fingerprint() {\n  return clientId;\n};\n\n/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n/* removed: var _$fingerprint_17 = require('./lib/fingerprint.js'); */;\n\n/* removed: var _$pad_18 = require('./lib/pad.js'); */;\n\nvar c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize);\n\nfunction randomBlock() {\n  return _$pad_18((Math.random() * discreteValues << 0).toString(base), blockSize);\n}\n\nfunction safeCounter() {\n  c = c < discreteValues ? c : 0;\n  c++; // this is not subliminal\n\n  return c - 1;\n}\n\nfunction cuid() {\n  // Starting with a lowercase letter makes\n  // it HTML element ID friendly.\n  var letter = 'c',\n      // hard-coded allows for sequential access\n  // timestamp\n  // warning: this exposes the exact date and time\n  // that the uid was created.\n  timestamp = new Date().getTime().toString(base),\n      // Prevent same-machine collisions.\n  counter = _$pad_18(safeCounter().toString(base), blockSize),\n      // A few chars to generate distinct ids for different\n  // clients (so different computers are far less\n  // likely to generate the same id)\n  print = _$fingerprint_17(),\n      // Grab some more chars from Math.random()\n  random = randomBlock() + randomBlock();\n  return letter + timestamp + counter + print + random;\n}\n\ncuid.fingerprint = _$fingerprint_17;\nvar _$cuid_16 = cuid;\n\nvar __isoDate_25 = _$esUtils_8.isoDate;\n\n/* removed: var _$cuid_16 = require('@bugsnag/cuid'); */;\n\nvar Session =\n/*#__PURE__*/\nfunction () {\n  function Session() {\n    this.id = _$cuid_16();\n    this.startedAt = __isoDate_25();\n    this._handled = 0;\n    this._unhandled = 0;\n  }\n\n  var _proto = Session.prototype;\n\n  _proto.toJSON = function toJSON() {\n    return {\n      id: this.id,\n      startedAt: this.startedAt,\n      events: {\n        handled: this._handled,\n        unhandled: this._unhandled\n      }\n    };\n  };\n\n  _proto.trackError = function trackError(report) {\n    this[report._handledState.unhandled ? '_unhandled' : '_handled'] += 1;\n  };\n\n  return Session;\n}();\n\nvar _$Session_25 = Session;\n\nfunction ___extends_4() { ___extends_4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_4.apply(this, arguments); }\n\n/* removed: var _$config_5 = require('./config'); */;\n\n/* removed: var _$BugsnagReport_24 = require('./report'); */;\n\n/* removed: var _$BugsnagBreadcrumb_3 = require('./breadcrumb'); */;\n\n/* removed: var _$Session_25 = require('./session'); */;\n\nvar __map_4 = _$esUtils_8.map,\n    __includes_4 = _$esUtils_8.includes,\n    __isArray_4 = _$esUtils_8.isArray;\n\n/* removed: var _$inferReleaseStage_10 = require('./lib/infer-release-stage'); */;\n\n/* removed: var _$iserror_11 = require('./lib/iserror'); */;\n\n/* removed: var _$asyncSome_6 = require('./lib/async-some'); */;\n\n/* removed: var _$runBeforeSend_14 = require('./lib/run-before-send'); */;\n\nvar LOG_USAGE_ERR_PREFIX = \"Usage error.\";\nvar REPORT_USAGE_ERR_PREFIX = \"Bugsnag usage error.\";\n\nvar BugsnagClient =\n/*#__PURE__*/\nfunction () {\n  function BugsnagClient(notifier) {\n    if (!notifier || !notifier.name || !notifier.version || !notifier.url) {\n      throw new Error('`notifier` argument is required');\n    } // notifier id\n\n\n    this.notifier = notifier; // configure() should be called before notify()\n\n    this._configured = false; // intialise opts and config\n\n    this._opts = {};\n    this.config = {}; // // i/o\n\n    this._delivery = {\n      sendSession: function () {},\n      sendReport: function () {}\n    };\n    this._logger = {\n      debug: function () {},\n      info: function () {},\n      warn: function () {},\n      error: function () {} // plugins\n\n    };\n    this._plugins = {};\n    this._session = null;\n    this.breadcrumbs = []; // setable props\n\n    this.app = {};\n    this.context = undefined;\n    this.device = undefined;\n    this.metaData = undefined;\n    this.request = undefined;\n    this.user = {}; // expose internal constructors\n\n    this.BugsnagClient = BugsnagClient;\n    this.BugsnagReport = _$BugsnagReport_24;\n    this.BugsnagBreadcrumb = _$BugsnagBreadcrumb_3;\n    this.BugsnagSession = _$Session_25;\n    var self = this;\n    var notify = this.notify;\n\n    this.notify = function () {\n      return notify.apply(self, arguments);\n    };\n  }\n\n  var _proto = BugsnagClient.prototype;\n\n  _proto.setOptions = function setOptions(opts) {\n    this._opts = ___extends_4({}, this._opts, opts);\n  };\n\n  _proto.configure = function configure(partialSchema) {\n    if (partialSchema === void 0) {\n      partialSchema = _$config_5.schema;\n    }\n\n    var conf = _$config_5.mergeDefaults(this._opts, partialSchema);\n    var validity = _$config_5.validate(conf, partialSchema);\n    if (!validity.valid === true) throw new Error(generateConfigErrorMessage(validity.errors)); // update and elevate some special options if they were passed in at this point\n\n    if (typeof conf.beforeSend === 'function') conf.beforeSend = [conf.beforeSend];\n    if (conf.appVersion) this.app.version = conf.appVersion;\n    if (conf.appType) this.app.type = conf.appType;\n    if (conf.metaData) this.metaData = conf.metaData;\n    if (conf.user) this.user = conf.user;\n    if (conf.logger) this.logger(conf.logger); // merge with existing config\n\n    this.config = ___extends_4({}, this.config, conf);\n    this._configured = true;\n    return this;\n  };\n\n  _proto.use = function use(plugin) {\n    if (!this._configured) throw new Error('client not configured');\n    if (plugin.configSchema) this.configure(plugin.configSchema);\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var result = plugin.init.apply(plugin, [this].concat(args)); // JS objects are not the safest way to store arbitrarily keyed values,\n    // so bookend the key with some characters that prevent tampering with\n    // stuff like __proto__ etc. (only store the result if the plugin had a\n    // name)\n\n    if (plugin.name) this._plugins[\"~\" + plugin.name + \"~\"] = result;\n    return this;\n  };\n\n  _proto.getPlugin = function getPlugin(name) {\n    return this._plugins[\"~\" + name + \"~\"];\n  };\n\n  _proto.delivery = function delivery(d) {\n    this._delivery = d(this);\n    return this;\n  };\n\n  _proto.logger = function logger(l, sid) {\n    this._logger = l;\n    return this;\n  };\n\n  _proto.sessionDelegate = function sessionDelegate(s) {\n    this._sessionDelegate = s;\n    return this;\n  };\n\n  _proto.startSession = function startSession() {\n    if (!this._sessionDelegate) {\n      this._logger.warn('No session implementation is installed');\n\n      return this;\n    }\n\n    return this._sessionDelegate.startSession(this);\n  };\n\n  _proto.leaveBreadcrumb = function leaveBreadcrumb(name, metaData, type, timestamp) {\n    if (!this._configured) throw new Error('client not configured'); // coerce bad values so that the defaults get set\n\n    name = name || undefined;\n    type = typeof type === 'string' ? type : undefined;\n    timestamp = typeof timestamp === 'string' ? timestamp : undefined;\n    metaData = typeof metaData === 'object' && metaData !== null ? metaData : undefined; // if no name and no metaData, usefulness of this crumb is questionable at best so discard\n\n    if (typeof name !== 'string' && !metaData) return;\n    var crumb = new _$BugsnagBreadcrumb_3(name, metaData, type, timestamp); // push the valid crumb onto the queue and maintain the length\n\n    this.breadcrumbs.push(crumb);\n\n    if (this.breadcrumbs.length > this.config.maxBreadcrumbs) {\n      this.breadcrumbs = this.breadcrumbs.slice(this.breadcrumbs.length - this.config.maxBreadcrumbs);\n    }\n\n    return this;\n  };\n\n  _proto.notify = function notify(error, opts, cb) {\n    var _this = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (cb === void 0) {\n      cb = function () {};\n    }\n\n    if (!this._configured) throw new Error('client not configured'); // releaseStage can be set via config.releaseStage or client.app.releaseStage\n\n    var releaseStage = _$inferReleaseStage_10(this); // ensure we have an error (or a reasonable object representation of an error)\n\n    var _normaliseError = normaliseError(error, opts, this._logger),\n        err = _normaliseError.err,\n        errorFramesToSkip = _normaliseError.errorFramesToSkip,\n        _opts = _normaliseError._opts;\n\n    if (_opts) opts = _opts; // ensure opts is an object\n\n    if (typeof opts !== 'object' || opts === null) opts = {}; // create a report from the error, if it isn't one already\n\n    var report = _$BugsnagReport_24.ensureReport(err, errorFramesToSkip, 2);\n    report.app = ___extends_4({}, {\n      releaseStage: releaseStage\n    }, report.app, this.app);\n    report.context = report.context || opts.context || this.context || undefined;\n    report.device = ___extends_4({}, report.device, this.device, opts.device);\n    report.request = ___extends_4({}, report.request, this.request, opts.request);\n    report.user = ___extends_4({}, report.user, this.user, opts.user);\n    report.metaData = ___extends_4({}, report.metaData, this.metaData, opts.metaData);\n    report.breadcrumbs = this.breadcrumbs.slice(0);\n\n    if (this._session) {\n      this._session.trackError(report);\n\n      report.session = this._session;\n    } // set severity if supplied\n\n\n    if (opts.severity !== undefined) {\n      report.severity = opts.severity;\n      report._handledState.severityReason = {\n        type: 'userSpecifiedSeverity'\n      };\n    } // exit early if the reports should not be sent on the current releaseStage\n\n\n    if (__isArray_4(this.config.notifyReleaseStages) && !__includes_4(this.config.notifyReleaseStages, releaseStage)) {\n      this._logger.warn(\"Report not sent due to releaseStage/notifyReleaseStages configuration\");\n\n      return cb(null, report);\n    }\n\n    var originalSeverity = report.severity;\n    var beforeSend = [].concat(opts.beforeSend).concat(this.config.beforeSend);\n\n    var onBeforeSendErr = function (err) {\n      _this._logger.error(\"Error occurred in beforeSend callback, continuing anyway\\u2026\");\n\n      _this._logger.error(err);\n    };\n\n    _$asyncSome_6(beforeSend, _$runBeforeSend_14(report, onBeforeSendErr), function (err, preventSend) {\n      if (err) onBeforeSendErr(err);\n\n      if (preventSend) {\n        _this._logger.debug(\"Report not sent due to beforeSend callback\");\n\n        return cb(null, report);\n      } // only leave a crumb for the error if actually got sent\n\n\n      if (_this.config.autoBreadcrumbs) {\n        _this.leaveBreadcrumb(report.errorClass, {\n          errorClass: report.errorClass,\n          errorMessage: report.errorMessage,\n          severity: report.severity\n        }, 'error');\n      }\n\n      if (originalSeverity !== report.severity) {\n        report._handledState.severityReason = {\n          type: 'userCallbackSetSeverity'\n        };\n      }\n\n      _this._delivery.sendReport({\n        apiKey: report.apiKey || _this.config.apiKey,\n        notifier: _this.notifier,\n        events: [report]\n      }, function (err) {\n        return cb(err, report);\n      });\n    });\n  };\n\n  return BugsnagClient;\n}();\n\nvar normaliseError = function (error, opts, logger) {\n  var synthesizedErrorFramesToSkip = 3;\n\n  var createAndLogUsageError = function (reason) {\n    var msg = generateNotifyUsageMessage(reason);\n    logger.warn(LOG_USAGE_ERR_PREFIX + \" \" + msg);\n    return new Error(REPORT_USAGE_ERR_PREFIX + \" \" + msg);\n  };\n\n  var err;\n  var errorFramesToSkip = 0;\n\n  var _opts;\n\n  switch (typeof error) {\n    case 'string':\n      if (typeof opts === 'string') {\n        // ≤v3 used to have a notify('ErrorName', 'Error message') interface\n        // report usage/deprecation errors if this function is called like that\n        err = createAndLogUsageError('string/string');\n        _opts = {\n          metaData: {\n            notifier: {\n              notifyArgs: [error, opts]\n            }\n          }\n        };\n      } else {\n        err = new Error(String(error));\n        errorFramesToSkip = synthesizedErrorFramesToSkip;\n      }\n\n      break;\n\n    case 'number':\n    case 'boolean':\n      err = new Error(String(error));\n      break;\n\n    case 'function':\n      err = createAndLogUsageError('function');\n      break;\n\n    case 'object':\n      if (error !== null && (_$iserror_11(error) || error.__isBugsnagReport)) {\n        err = error;\n      } else if (error !== null && hasNecessaryFields(error)) {\n        err = new Error(error.message || error.errorMessage);\n        err.name = error.name || error.errorClass;\n        errorFramesToSkip = synthesizedErrorFramesToSkip;\n      } else {\n        err = createAndLogUsageError(error === null ? 'null' : 'unsupported object');\n      }\n\n      break;\n\n    default:\n      err = createAndLogUsageError('nothing');\n  }\n\n  return {\n    err: err,\n    errorFramesToSkip: errorFramesToSkip,\n    _opts: _opts\n  };\n};\n\nvar hasNecessaryFields = function (error) {\n  return (typeof error.name === 'string' || typeof error.errorClass === 'string') && (typeof error.message === 'string' || typeof error.errorMessage === 'string');\n};\n\nvar generateConfigErrorMessage = function (errors) {\n  return \"Bugsnag configuration error\\n\" + __map_4(errors, function (err) {\n    return \"\\\"\" + err.key + \"\\\" \" + err.message + \" \\n    got \" + stringify(err.value);\n  }).join('\\n\\n');\n};\n\nvar generateNotifyUsageMessage = function (actual) {\n  return \"notify() expected error/opts parameters, got \" + actual;\n};\n\nvar stringify = function (val) {\n  return typeof val === 'object' ? JSON.stringify(val) : String(val);\n};\n\nvar _$BugsnagClient_4 = BugsnagClient;\n\nvar _$safeJsonStringify_19 = function (data, replacer, space, opts) {\n  var filterKeys = opts && opts.filterKeys ? opts.filterKeys : [];\n  var filterPaths = opts && opts.filterPaths ? opts.filterPaths : [];\n  return JSON.stringify(prepareObjForSerialization(data, filterKeys, filterPaths), replacer, space);\n};\n\nvar MAX_DEPTH = 20;\nvar MAX_EDGES = 25000;\nvar MIN_PRESERVED_DEPTH = 8;\nvar REPLACEMENT_NODE = '...';\n\nfunction __isError_19(o) {\n  return o instanceof Error || /^\\[object (Error|(Dom)?Exception)\\]$/.test(Object.prototype.toString.call(o));\n}\n\nfunction throwsMessage(err) {\n  return '[Throws: ' + (err ? err.message : '?') + ']';\n}\n\nfunction find(haystack, needle) {\n  for (var i = 0, len = haystack.length; i < len; i++) {\n    if (haystack[i] === needle) return true;\n  }\n\n  return false;\n} // returns true if the string `path` starts with any of the provided `paths`\n\n\nfunction isDescendent(paths, path) {\n  for (var i = 0, len = paths.length; i < len; i++) {\n    if (path.indexOf(paths[i]) === 0) return true;\n  }\n\n  return false;\n}\n\nfunction shouldFilter(patterns, key) {\n  for (var i = 0, len = patterns.length; i < len; i++) {\n    if (typeof patterns[i] === 'string' && patterns[i] === key) return true;\n    if (patterns[i] && typeof patterns[i].test === 'function' && patterns[i].test(key)) return true;\n  }\n\n  return false;\n}\n\nfunction __isArray_19(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction safelyGetProp(obj, prop) {\n  try {\n    return obj[prop];\n  } catch (err) {\n    return throwsMessage(err);\n  }\n}\n\nfunction prepareObjForSerialization(obj, filterKeys, filterPaths) {\n  var seen = []; // store references to objects we have seen before\n\n  var edges = 0;\n\n  function visit(obj, path) {\n    function edgesExceeded() {\n      return path.length > MIN_PRESERVED_DEPTH && edges > MAX_EDGES;\n    }\n\n    edges++;\n    if (path.length > MAX_DEPTH) return REPLACEMENT_NODE;\n    if (edgesExceeded()) return REPLACEMENT_NODE;\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (find(seen, obj)) return '[Circular]';\n    seen.push(obj);\n\n    if (typeof obj.toJSON === 'function') {\n      try {\n        // we're not going to count this as an edge because it\n        // replaces the value of the currently visited object\n        edges--;\n        var fResult = visit(obj.toJSON(), path);\n        seen.pop();\n        return fResult;\n      } catch (err) {\n        return throwsMessage(err);\n      }\n    }\n\n    var er = __isError_19(obj);\n\n    if (er) {\n      edges--;\n      var eResult = visit({\n        name: obj.name,\n        message: obj.message\n      }, path);\n      seen.pop();\n      return eResult;\n    }\n\n    if (__isArray_19(obj)) {\n      var aResult = [];\n\n      for (var i = 0, len = obj.length; i < len; i++) {\n        if (edgesExceeded()) {\n          aResult.push(REPLACEMENT_NODE);\n          break;\n        }\n\n        aResult.push(visit(obj[i], path.concat('[]')));\n      }\n\n      seen.pop();\n      return aResult;\n    }\n\n    var result = {};\n\n    try {\n      for (var prop in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, prop)) continue;\n\n        if (isDescendent(filterPaths, path.join('.')) && shouldFilter(filterKeys, prop)) {\n          result[prop] = '[Filtered]';\n          continue;\n        }\n\n        if (edgesExceeded()) {\n          result[prop] = REPLACEMENT_NODE;\n          break;\n        }\n\n        result[prop] = visit(safelyGetProp(obj, prop), path.concat(prop));\n      }\n    } catch (e) {}\n\n    seen.pop();\n    return result;\n  }\n\n  return visit(obj, []);\n}\n\nvar _$jsonPayload_13 = {};\n/* removed: var _$safeJsonStringify_19 = require('@bugsnag/safe-json-stringify'); */;\n\nvar REPORT_FILTER_PATHS = ['events.[].app', 'events.[].metaData', 'events.[].user', 'events.[].breadcrumbs', 'events.[].request', 'events.[].device'];\nvar SESSION_FILTER_PATHS = ['device', 'app', 'user'];\n\n_$jsonPayload_13.report = function (report, filterKeys) {\n  var payload = _$safeJsonStringify_19(report, null, null, {\n    filterPaths: REPORT_FILTER_PATHS,\n    filterKeys: filterKeys\n  });\n\n  if (payload.length > 10e5) {\n    delete report.events[0].metaData;\n    report.events[0].metaData = {\n      notifier: \"WARNING!\\nSerialized payload was \" + payload.length / 10e5 + \"MB (limit = 1MB)\\nmetaData was removed\"\n    };\n    payload = _$safeJsonStringify_19(report, null, null, {\n      filterPaths: REPORT_FILTER_PATHS,\n      filterKeys: filterKeys\n    });\n    if (payload.length > 10e5) throw new Error('payload exceeded 1MB limit');\n  }\n\n  return payload;\n};\n\n_$jsonPayload_13.session = function (report, filterKeys) {\n  var payload = _$safeJsonStringify_19(report, null, null, {\n    filterPaths: SESSION_FILTER_PATHS,\n    filterKeys: filterKeys\n  });\n  if (payload.length > 10e5) throw new Error('payload exceeded 1MB limit');\n  return payload;\n};\n\nvar _$delivery_26 = {};\nvar _this = this;\n\n/* removed: var _$jsonPayload_13 = require('@bugsnag/core/lib/json-payload'); */;\n\nvar __isoDate_26 = _$esUtils_8.isoDate;\n\n_$delivery_26 = function (client, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    sendReport: function (report, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      var url = getApiUrl(client.config, 'notify', '4', win);\n      var req = new win.XDomainRequest();\n\n      req.onload = function () {\n        cb(null);\n      };\n\n      req.open('POST', url);\n      setTimeout(function () {\n        try {\n          req.send(_$jsonPayload_13.report(report, client.config.filters));\n        } catch (e) {\n          client._logger.error(e);\n\n          cb(e);\n        }\n      }, 0);\n    },\n    sendSession: function (session, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      var url = getApiUrl(client.config, 'sessions', '1', win);\n      var req = new win.XDomainRequest();\n\n      req.onload = function () {\n        cb(null);\n      };\n\n      req.open('POST', url);\n      setTimeout(function () {\n        try {\n          req.send(_$jsonPayload_13.session(session, client.config.filters));\n        } catch (e) {\n          _this._logger.error(e);\n\n          cb(e);\n        }\n      }, 0);\n    }\n  };\n};\n\nvar getApiUrl = function (config, endpoint, version, win) {\n  return matchPageProtocol(config.endpoints[endpoint], win.location.protocol) + \"?apiKey=\" + encodeURIComponent(config.apiKey) + \"&payloadVersion=\" + version + \"&sentAt=\" + encodeURIComponent(__isoDate_26());\n};\n\nvar matchPageProtocol = _$delivery_26._matchPageProtocol = function (endpoint, pageProtocol) {\n  return pageProtocol === 'http:' ? endpoint.replace(/^https:/, 'http:') : endpoint;\n};\n\n/* removed: var _$jsonPayload_13 = require('@bugsnag/core/lib/json-payload'); */;\n\nvar __isoDate_27 = _$esUtils_8.isoDate;\n\nvar _$delivery_27 = function (client, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    sendReport: function (report, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      try {\n        var url = client.config.endpoints.notify;\n        var req = new win.XMLHttpRequest();\n\n        req.onreadystatechange = function () {\n          if (req.readyState === win.XMLHttpRequest.DONE) cb(null);\n        };\n\n        req.open('POST', url);\n        req.setRequestHeader('Content-Type', 'application/json');\n        req.setRequestHeader('Bugsnag-Api-Key', report.apiKey || client.config.apiKey);\n        req.setRequestHeader('Bugsnag-Payload-Version', '4');\n        req.setRequestHeader('Bugsnag-Sent-At', __isoDate_27());\n        req.send(_$jsonPayload_13.report(report, client.config.filters));\n      } catch (e) {\n        client._logger.error(e);\n      }\n    },\n    sendSession: function (session, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      try {\n        var url = client.config.endpoints.sessions;\n        var req = new win.XMLHttpRequest();\n\n        req.onreadystatechange = function () {\n          if (req.readyState === win.XMLHttpRequest.DONE) cb(null);\n        };\n\n        req.open('POST', url);\n        req.setRequestHeader('Content-Type', 'application/json');\n        req.setRequestHeader('Bugsnag-Api-Key', client.config.apiKey);\n        req.setRequestHeader('Bugsnag-Payload-Version', '1');\n        req.setRequestHeader('Bugsnag-Sent-At', __isoDate_27());\n        req.send(_$jsonPayload_13.session(session, client.config.filters));\n      } catch (e) {\n        client._logger.error(e);\n      }\n    }\n  };\n};\n\n/*\n * Sets the default context to be the current URL\n */\nvar _$context_28 = {\n  init: function (client, win) {\n    if (win === void 0) {\n      win = window;\n    }\n\n    client.config.beforeSend.unshift(function (report) {\n      if (report.context) return;\n      report.context = win.location.pathname;\n    });\n  }\n};\n\nfunction ___extends_29() { ___extends_29 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_29.apply(this, arguments); }\n\nvar __isoDate_29 = _$esUtils_8.isoDate;\n/*\n * Automatically detects browser device details\n */\n\n\nvar _$device_29 = {\n  init: function (client, nav) {\n    if (nav === void 0) {\n      nav = navigator;\n    }\n\n    var device = {\n      locale: nav.browserLanguage || nav.systemLanguage || nav.userLanguage || nav.language,\n      userAgent: nav.userAgent // merge with anything already set on the client\n\n    };\n    client.device = ___extends_29({}, device, client.device); // add time just as the report is sent\n\n    client.config.beforeSend.unshift(function (report) {\n      report.device = ___extends_29({}, report.device, {\n        time: __isoDate_29()\n      });\n    });\n  }\n};\n\nfunction ___extends_30() { ___extends_30 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_30.apply(this, arguments); }\n\n/*\n * Sets the report request: { url } to be the current href\n */\nvar _$request_30 = {\n  init: function (client, win) {\n    if (win === void 0) {\n      win = window;\n    }\n\n    client.config.beforeSend.unshift(function (report) {\n      if (report.request && report.request.url) return;\n      report.request = ___extends_30({}, report.request, {\n        url: win.location.href\n      });\n    });\n  }\n};\n\nfunction ___extends_31() { ___extends_31 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_31.apply(this, arguments); }\n\nvar __isArray_31 = _$esUtils_8.isArray,\n    __includes_31 = _$esUtils_8.includes;\n\n/* removed: var _$inferReleaseStage_10 = require('@bugsnag/core/lib/infer-release-stage'); */;\n\nvar _$session_31 = {\n  init: function (client) {\n    return client.sessionDelegate(sessionDelegate);\n  }\n};\nvar sessionDelegate = {\n  startSession: function (client) {\n    var sessionClient = client;\n    sessionClient._session = new client.BugsnagSession();\n    var releaseStage = _$inferReleaseStage_10(sessionClient); // exit early if the reports should not be sent on the current releaseStage\n\n    if (__isArray_31(sessionClient.config.notifyReleaseStages) && !__includes_31(sessionClient.config.notifyReleaseStages, releaseStage)) {\n      sessionClient._logger.warn(\"Session not sent due to releaseStage/notifyReleaseStages configuration\");\n\n      return sessionClient;\n    }\n\n    if (!sessionClient.config.endpoints.sessions) {\n      sessionClient._logger.warn(\"Session not sent due to missing endpoints.sessions configuration\");\n\n      return sessionClient;\n    }\n\n    sessionClient._delivery.sendSession({\n      notifier: sessionClient.notifier,\n      device: sessionClient.device,\n      app: ___extends_31({}, {\n        releaseStage: releaseStage\n      }, sessionClient.app),\n      sessions: [{\n        id: sessionClient._session.id,\n        startedAt: sessionClient._session.startedAt,\n        user: sessionClient.user\n      }]\n    });\n\n    return sessionClient;\n  }\n};\n\nfunction ___extends_32() { ___extends_32 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_32.apply(this, arguments); }\n\n/*\n * Prevent collection of user IPs\n */\nvar _$clientIp_32 = {\n  init: function (client) {\n    if (client.config.collectUserIp) return;\n    client.config.beforeSend.push(function (report) {\n      // If user.id is explicitly undefined, it will be missing from the payload. It needs\n      // removing so that the following line replaces it\n      if (report.user && typeof report.user.id === 'undefined') delete report.user.id;\n      report.user = ___extends_32({\n        id: '[NOT COLLECTED]'\n      }, report.user);\n      report.request = ___extends_32({\n        clientIp: '[NOT COLLECTED]'\n      }, report.request);\n    });\n  },\n  configSchema: {\n    collectUserIp: {\n      defaultValue: function () {\n        return true;\n      },\n      message: 'should be true|false',\n      validate: function (value) {\n        return value === true || value === false;\n      }\n    }\n  }\n};\n\nvar _$consoleBreadcrumbs_33 = {};\nvar __map_33 = _$esUtils_8.map,\n    __reduce_33 = _$esUtils_8.reduce,\n    __filter_33 = _$esUtils_8.filter;\n/*\n * Leaves breadcrumbs when console log methods are called\n */\n\n\n_$consoleBreadcrumbs_33.init = function (client) {\n  var isDev = /^dev(elopment)?$/.test(client.config.releaseStage);\n  var explicitlyDisabled = client.config.consoleBreadcrumbsEnabled === false;\n  var implicitlyDisabled = (client.config.autoBreadcrumbs === false || isDev) && client.config.consoleBreadcrumbsEnabled !== true;\n  if (explicitlyDisabled || implicitlyDisabled) return;\n  __map_33(CONSOLE_LOG_METHODS, function (method) {\n    var original = console[method];\n\n    console[method] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      client.leaveBreadcrumb('Console output', __reduce_33(args, function (accum, arg, i) {\n        // do the best/simplest stringification of each argument\n        var stringified = '[Unknown value]'; // this may fail if the input is:\n        // - an object whose [[Prototype]] is null (no toString)\n        // - an object with a broken toString or @@toPrimitive implementation\n\n        try {\n          stringified = String(arg);\n        } catch (e) {} // if it stringifies to [object Object] attempt to JSON stringify\n\n\n        if (stringified === '[object Object]') {\n          // catch stringify errors and fallback to [object Object]\n          try {\n            stringified = JSON.stringify(arg);\n          } catch (e) {}\n        }\n\n        accum[\"[\" + i + \"]\"] = stringified;\n        return accum;\n      }, {\n        severity: method.indexOf('group') === 0 ? 'log' : method\n      }), 'log');\n      original.apply(console, args);\n    };\n\n    console[method]._restore = function () {\n      console[method] = original;\n    };\n  });\n};\n\n_$consoleBreadcrumbs_33.configSchema = {\n  consoleBreadcrumbsEnabled: {\n    defaultValue: function () {\n      return undefined;\n    },\n    validate: function (value) {\n      return value === true || value === false || value === undefined;\n    },\n    message: 'should be true|false'\n  }\n};\n\nif (false) {}\n\nvar CONSOLE_LOG_METHODS = __filter_33(['log', 'debug', 'info', 'warn', 'error'], function (method) {\n  return typeof console !== 'undefined' && typeof console[method] === 'function';\n});\n\nvar __map_34 = _$esUtils_8.map,\n    __reduce_34 = _$esUtils_8.reduce,\n    __filter_34 = _$esUtils_8.filter;\n\nvar MAX_LINE_LENGTH = 200;\nvar MAX_SCRIPT_LENGTH = 500000;\nvar _$inlineScriptContent_34 = {\n  init: function (client, doc, win) {\n    if (doc === void 0) {\n      doc = document;\n    }\n\n    if (win === void 0) {\n      win = window;\n    }\n\n    if (!client.config.trackInlineScripts) return;\n    var originalLocation = win.location.href;\n    var html = '';\n    var DOMContentLoaded = false;\n\n    var getHtml = function () {\n      return doc.documentElement.outerHTML;\n    }; // get whatever HTML exists at this point in time\n\n\n    html = getHtml();\n    var prev = doc.onreadystatechange; // then update it when the DOM content has loaded\n\n    doc.onreadystatechange = function () {\n      // IE8 compatible alternative to document#DOMContentLoaded\n      if (doc.readyState === 'interactive') {\n        html = getHtml();\n        DOMContentLoaded = true;\n      }\n\n      try {\n        prev.apply(this, arguments);\n      } catch (e) {}\n    };\n\n    var _lastScript = null;\n\n    var updateLastScript = function (script) {\n      _lastScript = script;\n    };\n\n    var getCurrentScript = function () {\n      var script = doc.currentScript || _lastScript;\n\n      if (!script && !DOMContentLoaded) {\n        var scripts = doc.scripts || doc.getElementsByTagName('script');\n        script = scripts[scripts.length - 1];\n      }\n\n      return script;\n    };\n\n    var addSurroundingCode = function (lineNumber) {\n      // get whatever html has rendered at this point\n      if (!DOMContentLoaded || !html) html = getHtml(); // simulate the raw html\n\n      var htmlLines = ['<!-- DOC START -->'].concat(html.split('\\n'));\n      var zeroBasedLine = lineNumber - 1;\n      var start = Math.max(zeroBasedLine - 3, 0);\n      var end = Math.min(zeroBasedLine + 3, htmlLines.length);\n      return __reduce_34(htmlLines.slice(start, end), function (accum, line, i) {\n        accum[start + 1 + i] = line.length <= MAX_LINE_LENGTH ? line : line.substr(0, MAX_LINE_LENGTH);\n        return accum;\n      }, {});\n    };\n\n    client.config.beforeSend.unshift(function (report) {\n      // remove any of our own frames that may be part the stack this\n      // happens before the inline script check as it happens for all errors\n      report.stacktrace = __filter_34(report.stacktrace, function (f) {\n        return !/__trace__$/.test(f.method);\n      });\n      var frame = report.stacktrace[0]; // if frame.file exists and is not the original location of the page, this can't be an inline script\n\n      if (frame && frame.file && frame.file.replace(/#.*$/, '') !== originalLocation.replace(/#.*$/, '')) return; // grab the last script known to have run\n\n      var currentScript = getCurrentScript();\n\n      if (currentScript) {\n        var content = currentScript.innerHTML;\n        report.updateMetaData('script', 'content', content.length <= MAX_SCRIPT_LENGTH ? content : content.substr(0, MAX_SCRIPT_LENGTH));\n      } // only attempt to grab some surrounding code if we have a line number\n\n\n      if (!frame || !frame.lineNumber) return;\n      frame.code = addSurroundingCode(frame.lineNumber);\n    }); // Proxy all the timer functions whose callback is their 0th argument.\n    // Keep a reference to the original setTimeout because we need it later\n\n    var _map = __map_34(['setTimeout', 'setInterval', 'setImmediate', 'requestAnimationFrame'], function (fn) {\n      return __proxy(win, fn, function (original) {\n        return __traceOriginalScript(original, function (args) {\n          return {\n            get: function () {\n              return args[0];\n            },\n            replace: function (fn) {\n              args[0] = fn;\n            }\n          };\n        });\n      });\n    }),\n        _setTimeout = _map[0]; // Proxy all the host objects whose prototypes have an addEventListener function\n\n\n    __map_34(['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'], function (o) {\n      if (!win[o] || !win[o].prototype || !win[o].prototype.hasOwnProperty || !win[o].prototype.hasOwnProperty('addEventListener')) return;\n\n      __proxy(win[o].prototype, 'addEventListener', function (original) {\n        return __traceOriginalScript(original, eventTargetCallbackAccessor);\n      });\n\n      __proxy(win[o].prototype, 'removeEventListener', function (original) {\n        return __traceOriginalScript(original, eventTargetCallbackAccessor, true);\n      });\n    });\n\n    function __traceOriginalScript(fn, callbackAccessor, alsoCallOriginal) {\n      if (alsoCallOriginal === void 0) {\n        alsoCallOriginal = false;\n      }\n\n      return function () {\n        // this is required for removeEventListener to remove anything added with\n        // addEventListener before the functions started being wrapped by Bugsnag\n        var args = Array.prototype.slice.call(arguments);\n\n        try {\n          var cba = callbackAccessor(args);\n          var cb = cba.get();\n          if (alsoCallOriginal) fn.apply(this, args);\n          if (typeof cb !== 'function') return fn.apply(this, args);\n\n          if (cb.__trace__) {\n            cba.replace(cb.__trace__);\n          } else {\n            var script = getCurrentScript(); // this function mustn't be annonymous due to a bug in the stack\n            // generation logic, meaning it gets tripped up\n            // see: https://github.com/stacktracejs/stack-generator/issues/6\n\n            cb.__trace__ = function __trace__() {\n              // set the script that called this function\n              updateLastScript(script); // immediately unset the currentScript synchronously below, however\n              // if this cb throws an error the line after will not get run so schedule\n              // an almost-immediate aysnc update too\n\n              _setTimeout(function () {\n                updateLastScript(null);\n              }, 0);\n\n              var ret = cb.apply(this, arguments);\n              updateLastScript(null);\n              return ret;\n            };\n\n            cb.__trace__.__trace__ = cb.__trace__;\n            cba.replace(cb.__trace__);\n          }\n        } catch (e) {} // swallow these errors on Selenium:\n        // Permission denied to access property '__trace__'\n        // WebDriverException: Message: Permission denied to access property \"handleEvent\"\n        // IE8 doesn't let you call .apply() on setTimeout/setInterval\n\n\n        if (fn.apply) return fn.apply(this, args);\n\n        switch (args.length) {\n          case 1:\n            return fn(args[0]);\n\n          case 2:\n            return fn(args[0], args[1]);\n\n          default:\n            return fn();\n        }\n      };\n    }\n  },\n  configSchema: {\n    trackInlineScripts: {\n      validate: function (value) {\n        return value === true || value === false;\n      },\n      defaultValue: function () {\n        return true;\n      },\n      message: 'should be true|false'\n    }\n  }\n};\n\nfunction __proxy(host, name, replacer) {\n  var original = host[name];\n  if (!original) return original;\n  var replacement = replacer(original);\n  host[name] = replacement;\n  return original;\n}\n\nfunction eventTargetCallbackAccessor(args) {\n  var isEventHandlerObj = !!args[1] && typeof args[1].handleEvent === 'function';\n  return {\n    get: function () {\n      return isEventHandlerObj ? args[1].handleEvent : args[1];\n    },\n    replace: function (fn) {\n      if (isEventHandlerObj) {\n        args[1].handleEvent = fn;\n      } else {\n        args[1] = fn;\n      }\n    }\n  };\n}\n\n/*\n * Leaves breadcrumbs when the user interacts with the DOM\n */\nvar _$interactionBreadcrumbs_35 = {\n  init: function (client, win) {\n    if (win === void 0) {\n      win = window;\n    }\n\n    if (!('addEventListener' in win)) return;\n    var explicitlyDisabled = client.config.interactionBreadcrumbsEnabled === false;\n    var implicitlyDisabled = client.config.autoBreadcrumbs === false && client.config.interactionBreadcrumbsEnabled !== true;\n    if (explicitlyDisabled || implicitlyDisabled) return;\n    win.addEventListener('click', function (event) {\n      var targetText, targetSelector;\n\n      try {\n        targetText = getNodeText(event.target);\n        targetSelector = getNodeSelector(event.target, win);\n      } catch (e) {\n        targetText = '[hidden]';\n        targetSelector = '[hidden]';\n\n        client._logger.error('Cross domain error when tracking click event. See docs: https://tinyurl.com/yy3rn63z');\n      }\n\n      client.leaveBreadcrumb('UI click', {\n        targetText: targetText,\n        targetSelector: targetSelector\n      }, 'user');\n    }, true);\n  },\n  configSchema: {\n    interactionBreadcrumbsEnabled: {\n      defaultValue: function () {\n        return undefined;\n      },\n      validate: function (value) {\n        return value === true || value === false || value === undefined;\n      },\n      message: 'should be true|false'\n    }\n  } // extract text content from a element\n\n};\n\nvar getNodeText = function (el) {\n  var text = el.textContent || el.innerText || '';\n  if (!text && (el.type === 'submit' || el.type === 'button')) text = el.value;\n  text = text.replace(/^\\s+|\\s+$/g, ''); // trim whitespace\n\n  return truncate(text, 140);\n}; // Create a label from tagname, id and css class of the element\n\n\nfunction getNodeSelector(el, win) {\n  var parts = [el.tagName];\n  if (el.id) parts.push('#' + el.id);\n  if (el.className && el.className.length) parts.push(\".\" + el.className.split(' ').join('.')); // Can't get much more advanced with the current browser\n\n  if (!win.document.querySelectorAll || !Array.prototype.indexOf) return parts.join('');\n\n  try {\n    if (win.document.querySelectorAll(parts.join('')).length === 1) return parts.join('');\n  } catch (e) {\n    // Sometimes the query selector can be invalid just return it as-is\n    return parts.join('');\n  } // try to get a more specific selector if this one matches more than one element\n\n\n  if (el.parentNode.childNodes.length > 1) {\n    var index = Array.prototype.indexOf.call(el.parentNode.childNodes, el) + 1;\n    parts.push(\":nth-child(\" + index + \")\");\n  }\n\n  if (win.document.querySelectorAll(parts.join('')).length === 1) return parts.join(''); // try prepending the parent node selector\n\n  if (el.parentNode) return getNodeSelector(el.parentNode, win) + \" > \" + parts.join('');\n  return parts.join('');\n}\n\nfunction truncate(value, length) {\n  var ommision = '(...)';\n  if (value && value.length <= length) return value;\n  return value.slice(0, length - ommision.length) + ommision;\n}\n\nvar _$navigationBreadcrumbs_36 = {};\n/*\n * Leaves breadcrumbs when navigation methods are called or events are emitted\n */\n_$navigationBreadcrumbs_36.init = function (client, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  if (!('addEventListener' in win)) return;\n  var explicitlyDisabled = client.config.navigationBreadcrumbsEnabled === false;\n  var implicitlyDisabled = client.config.autoBreadcrumbs === false && client.config.navigationBreadcrumbsEnabled !== true;\n  if (explicitlyDisabled || implicitlyDisabled) return; // returns a function that will drop a breadcrumb with a given name\n\n  var drop = function (name) {\n    return function () {\n      return client.leaveBreadcrumb(name, {}, 'navigation');\n    };\n  }; // simple drops – just names, no meta\n\n\n  win.addEventListener('pagehide', drop('Page hidden'), true);\n  win.addEventListener('pageshow', drop('Page shown'), true);\n  win.addEventListener('load', drop('Page loaded'), true);\n  win.document.addEventListener('DOMContentLoaded', drop('DOMContentLoaded'), true); // some browsers like to emit popstate when the page loads, so only add the popstate listener after that\n\n  win.addEventListener('load', function () {\n    return win.addEventListener('popstate', drop('Navigated back'), true);\n  }); // hashchange has some metaData that we care about\n\n  win.addEventListener('hashchange', function (event) {\n    var metaData = event.oldURL ? {\n      from: relativeLocation(event.oldURL, win),\n      to: relativeLocation(event.newURL, win),\n      state: getCurrentState(win)\n    } : {\n      to: relativeLocation(win.location.href, win)\n    };\n    client.leaveBreadcrumb('Hash changed', metaData, 'navigation');\n  }, true); // the only way to know about replaceState/pushState is to wrap them… >_<\n\n  if (win.history.replaceState) wrapHistoryFn(client, win.history, 'replaceState', win);\n  if (win.history.pushState) wrapHistoryFn(client, win.history, 'pushState', win);\n  client.leaveBreadcrumb('Bugsnag loaded', {}, 'navigation');\n};\n\n_$navigationBreadcrumbs_36.configSchema = {\n  navigationBreadcrumbsEnabled: {\n    defaultValue: function () {\n      return undefined;\n    },\n    validate: function (value) {\n      return value === true || value === false || value === undefined;\n    },\n    message: 'should be true|false'\n  }\n};\n\nif (false) {} // takes a full url like http://foo.com:1234/pages/01.html?yes=no#section-2 and returns\n// just the path and hash parts, e.g. /pages/01.html?yes=no#section-2\n\n\nvar relativeLocation = function (url, win) {\n  var a = win.document.createElement('A');\n  a.href = url;\n  return \"\" + a.pathname + a.search + a.hash;\n};\n\nvar stateChangeToMetaData = function (win, state, title, url) {\n  var currentPath = relativeLocation(win.location.href, win);\n  return {\n    title: title,\n    state: state,\n    prevState: getCurrentState(win),\n    to: url || currentPath,\n    from: currentPath\n  };\n};\n\nvar wrapHistoryFn = function (client, target, fn, win) {\n  var orig = target[fn];\n\n  target[fn] = function (state, title, url) {\n    client.leaveBreadcrumb(\"History \" + fn, stateChangeToMetaData(win, state, title, url), 'navigation'); // if throttle plugin is in use, refresh the event sent count\n\n    if (typeof client.refresh === 'function') client.refresh(); // if the client is operating in auto session-mode, a new route should trigger a new session\n\n    if (client.config.autoCaptureSessions) client.startSession(); // Internet Explorer will convert `undefined` to a string when passed, causing an unintended redirect\n    // to '/undefined'. therefore we only pass the url if it's not undefined.\n\n    orig.apply(target, [state, title].concat(url !== undefined ? url : []));\n  };\n\n  if (false) {}\n};\n\nvar getCurrentState = function (win) {\n  try {\n    return win.history.state;\n  } catch (e) {}\n};\n\nvar _$networkBreadcrumbs_37 = {};\nvar BREADCRUMB_TYPE = 'request'; // keys to safely store metadata on the request object\n\nvar REQUEST_SETUP_KEY = 'BS~~S';\nvar REQUEST_URL_KEY = 'BS~~U';\nvar REQUEST_METHOD_KEY = 'BS~~M';\n\nvar __includes_37 = _$esUtils_8.includes;\n\nvar restoreFunctions = [];\nvar client;\nvar win;\nvar getIgnoredUrls;\n\nvar defaultIgnoredUrls = function () {\n  return [client.config.endpoints.notify, client.config.endpoints.sessions];\n};\n/*\n * Leaves breadcrumbs when network requests occur\n */\n\n\n_$networkBreadcrumbs_37.name = 'networkBreadcrumbs';\n\n_$networkBreadcrumbs_37.init = function (_client, _getIgnoredUrls, _win) {\n  if (_getIgnoredUrls === void 0) {\n    _getIgnoredUrls = defaultIgnoredUrls;\n  }\n\n  if (_win === void 0) {\n    _win = window;\n  }\n\n  var explicitlyDisabled = _client.config.networkBreadcrumbsEnabled === false;\n  var implicitlyDisabled = _client.config.autoBreadcrumbs === false && _client.config.networkBreadcrumbsEnabled !== true;\n  if (explicitlyDisabled || implicitlyDisabled) return;\n  client = _client;\n  win = _win;\n  getIgnoredUrls = _getIgnoredUrls;\n  monkeyPatchXMLHttpRequest();\n  monkeyPatchFetch();\n};\n\n_$networkBreadcrumbs_37.configSchema = {\n  networkBreadcrumbsEnabled: {\n    defaultValue: function () {\n      return undefined;\n    },\n    validate: function (value) {\n      return value === true || value === false || value === undefined;\n    },\n    message: 'should be true|false'\n  }\n};\n\nif (false) {} // XMLHttpRequest monkey patch\n\n\nvar monkeyPatchXMLHttpRequest = function () {\n  if (!('addEventListener' in win.XMLHttpRequest.prototype)) return;\n  var nativeOpen = win.XMLHttpRequest.prototype.open; // override native open()\n\n  win.XMLHttpRequest.prototype.open = function open(method, url) {\n    // store url and HTTP method for later\n    this[REQUEST_URL_KEY] = url;\n    this[REQUEST_METHOD_KEY] = method; // if we have already setup listeners, it means open() was called twice, we need to remove\n    // the listeners and recreate them\n\n    if (this[REQUEST_SETUP_KEY]) {\n      this.removeEventListener('load', handleXHRLoad);\n      this.removeEventListener('error', handleXHRError);\n    } // attach load event listener\n\n\n    this.addEventListener('load', handleXHRLoad); // attach error event listener\n\n    this.addEventListener('error', handleXHRError);\n    this[REQUEST_SETUP_KEY] = true;\n    nativeOpen.apply(this, arguments);\n  };\n\n  if (false) {}\n};\n\nfunction handleXHRLoad() {\n  if (__includes_37(getIgnoredUrls(), this[REQUEST_URL_KEY])) {\n    // don't leave a network breadcrumb from bugsnag notify calls\n    return;\n  }\n\n  var metaData = {\n    status: this.status,\n    request: this[REQUEST_METHOD_KEY] + \" \" + this[REQUEST_URL_KEY]\n  };\n\n  if (this.status >= 400) {\n    // contacted server but got an error response\n    client.leaveBreadcrumb('XMLHttpRequest failed', metaData, BREADCRUMB_TYPE);\n  } else {\n    client.leaveBreadcrumb('XMLHttpRequest succeeded', metaData, BREADCRUMB_TYPE);\n  }\n}\n\nfunction handleXHRError() {\n  if (__includes_37(getIgnoredUrls, this[REQUEST_URL_KEY])) {\n    // don't leave a network breadcrumb from bugsnag notify calls\n    return;\n  } // failed to contact server\n\n\n  client.leaveBreadcrumb('XMLHttpRequest error', {\n    request: this[REQUEST_METHOD_KEY] + \" \" + this[REQUEST_URL_KEY]\n  }, BREADCRUMB_TYPE);\n} // window.fetch monkey patch\n\n\nvar monkeyPatchFetch = function () {\n  // only patch it if it exists and if it is not a polyfill (patching a polyfilled\n  // fetch() results in duplicate breadcrumbs for the same request because the\n  // implementation uses XMLHttpRequest which is also patched)\n  if (!('fetch' in win) || win.fetch.polyfill) return;\n  var oldFetch = win.fetch;\n\n  win.fetch = function fetch() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var url = args[0],\n        options = args[1];\n    var method = 'GET';\n\n    if (options && options.method) {\n      method = options.method;\n    }\n\n    return new Promise(function (resolve, reject) {\n      // pass through to native fetch\n      oldFetch.apply(void 0, args).then(function (response) {\n        handleFetchSuccess(response, method, url);\n        resolve(response);\n      })[\"catch\"](function (error) {\n        handleFetchError(method, url);\n        reject(error);\n      });\n    });\n  };\n\n  if (false) {}\n};\n\nvar handleFetchSuccess = function (response, method, url) {\n  var metaData = {\n    status: response.status,\n    request: method + \" \" + url\n  };\n\n  if (response.status >= 400) {\n    // when the request comes back with a 4xx or 5xx status it does not reject the fetch promise,\n    client.leaveBreadcrumb('fetch() failed', metaData, BREADCRUMB_TYPE);\n  } else {\n    client.leaveBreadcrumb('fetch() succeeded', metaData, BREADCRUMB_TYPE);\n  }\n};\n\nvar handleFetchError = function (method, url) {\n  client.leaveBreadcrumb('fetch() error', {\n    request: method + \" \" + url\n  }, BREADCRUMB_TYPE);\n};\n\nvar __intRange_38 = _$validators_15.intRange;\n/*\n * Throttles and dedupes error reports\n */\n\n\nvar _$throttle_38 = {\n  init: function (client) {\n    // track sent events for each init of the plugin\n    var n = 0; // add beforeSend hook\n\n    client.config.beforeSend.push(function (report) {\n      // have max events been sent already?\n      if (n >= client.config.maxEvents) return report.ignore();\n      n++;\n    });\n\n    client.refresh = function () {\n      n = 0;\n    };\n  },\n  configSchema: {\n    maxEvents: {\n      defaultValue: function () {\n        return 10;\n      },\n      message: 'should be a positive integer ≤100',\n      validate: function (val) {\n        return __intRange_38(1, 100)(val);\n      }\n    }\n  }\n};\n\nvar _$stripQueryString_39 = {};\nfunction ___extends_39() { ___extends_39 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_39.apply(this, arguments); }\n\n/*\n * Remove query strings (and fragments) from stacktraces\n */\nvar __map_39 = _$esUtils_8.map;\n\n_$stripQueryString_39 = {\n  init: function (client) {\n    client.config.beforeSend.push(function (report) {\n      report.stacktrace = __map_39(report.stacktrace, function (frame) {\n        return ___extends_39({}, frame, {\n          file: strip(frame.file)\n        });\n      });\n    });\n  }\n};\n\nvar strip = _$stripQueryString_39._strip = function (str) {\n  return typeof str === 'string' ? str.replace(/\\?.*$/, '').replace(/#.*$/, '') : str;\n};\n\n/*\n * Automatically notifies Bugsnag when window.onerror is called\n */\nvar _$onerror_40 = {\n  init: function (client, win) {\n    if (win === void 0) {\n      win = window;\n    }\n\n    function onerror(messageOrEvent, url, lineNo, charNo, error) {\n      // Ignore errors with no info due to CORS settings\n      if (lineNo === 0 && /Script error\\.?/.test(messageOrEvent)) {\n        client._logger.warn('Ignoring cross-domain or eval script error. See docs: https://tinyurl.com/yy3rn63z');\n      } else {\n        // any error sent to window.onerror is unhandled and has severity=error\n        var handledState = {\n          severity: 'error',\n          unhandled: true,\n          severityReason: {\n            type: 'unhandledException'\n          }\n        };\n        var report; // window.onerror can be called in a number of ways. This big if-else is how we\n        // figure out which arguments were supplied, and what kind of values it received.\n\n        if (error) {\n          // if the last parameter (error) was supplied, this is a modern browser's\n          // way of saying \"this value was thrown and not caught\"\n          if (error.name && error.message) {\n            // if it looks like an error, construct a report object using its stack\n            report = new client.BugsnagReport(error.name, error.message, decorateStack(client.BugsnagReport.getStacktrace(error), url, lineNo, charNo), handledState, error);\n          } else {\n            // otherwise, for non error values that were thrown, stringify it for\n            // use as the error message and get/generate a stacktrace\n            report = new client.BugsnagReport('window.onerror', String(error), decorateStack(client.BugsnagReport.getStacktrace(error, 1), url, lineNo, charNo), handledState, error); // include the raw input as metadata\n\n            report.updateMetaData('window onerror', {\n              error: error\n            });\n          }\n        } else if ( // This complex case detects \"error\" events that are typically synthesised\n        // by jquery's trigger method (although can be created in other ways). In\n        // order to detect this:\n        // - the first argument (message) must exist and be an object (most likely it's a jQuery event)\n        // - the second argument (url) must either not exist or be something other than a string (if it\n        //    exists and is not a string, it'll be the extraParameters argument from jQuery's trigger()\n        //    function)\n        // - the third, fourth and fifth arguments must not exist (lineNo, charNo and error)\n        typeof messageOrEvent === 'object' && messageOrEvent !== null && (!url || typeof url !== 'string') && !lineNo && !charNo && !error) {\n          // The jQuery event may have a \"type\" property, if so use it as part of the error message\n          var name = messageOrEvent.type ? \"Event: \" + messageOrEvent.type : 'window.onerror'; // attempt to find a message from one of the conventional properties, but\n          // default to empty string (the report will fill it with a placeholder)\n\n          var message = messageOrEvent.message || messageOrEvent.detail || '';\n          report = new client.BugsnagReport(name, message, client.BugsnagReport.getStacktrace(new Error(), 1).slice(1), handledState, messageOrEvent); // include the raw input as metadata – it might contain more info than we extracted\n\n          report.updateMetaData('window onerror', {\n            event: messageOrEvent,\n            extraParameters: url\n          });\n        } else {\n          // Lastly, if there was no \"error\" parameter this event was probably from an old\n          // browser that doesn't support that. Instead we need to generate a stacktrace.\n          report = new client.BugsnagReport('window.onerror', String(messageOrEvent), decorateStack(client.BugsnagReport.getStacktrace(error, 1), url, lineNo, charNo), handledState, messageOrEvent); // include the raw input as metadata – it might contain more info than we extracted\n\n          report.updateMetaData('window onerror', {\n            event: messageOrEvent\n          });\n        }\n\n        client.notify(report);\n      }\n\n      if (typeof prevOnError === 'function') prevOnError.apply(this, arguments);\n    }\n\n    var prevOnError = win.onerror;\n    win.onerror = onerror;\n  } // Sometimes the stacktrace has less information than was passed to window.onerror.\n  // This function will augment the first stackframe with any useful info that was\n  // received as arguments to the onerror callback.\n\n};\n\nvar decorateStack = function (stack, url, lineNo, charNo) {\n  var culprit = stack[0];\n  if (!culprit) return stack;\n  if (!culprit.fileName && typeof url === 'string') culprit.setFileName(url);\n  if (!culprit.lineNumber && isActualNumber(lineNo)) culprit.setLineNumber(lineNo);\n\n  if (!culprit.columnNumber) {\n    if (isActualNumber(charNo)) {\n      culprit.setColumnNumber(charNo);\n    } else if (window.event && isActualNumber(window.event.errorCharacter)) {\n      culprit.setColumnNumber(window.event.errorCharacter);\n    }\n  }\n\n  return stack;\n};\n\nvar isActualNumber = function (n) {\n  return typeof n === 'number' && String.call(n) !== 'NaN';\n};\n\nvar _$unhandledRejection_41 = {};\n/* removed: var _$hasStack_9 = require('@bugsnag/core/lib/has-stack'); */;\n\nvar __reduce_41 = _$esUtils_8.reduce;\n\n/* removed: var _$errorStackParser_7 = require('@bugsnag/core/lib/error-stack-parser'); */;\n\n/* removed: var _$iserror_11 = require('@bugsnag/core/lib/iserror'); */;\n/*\n * Automatically notifies Bugsnag when window.onunhandledrejection is called\n */\n\n\nvar _listener;\n\n_$unhandledRejection_41.init = function (client, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var listener = function (event) {\n    var error = event.reason;\n    var isBluebird = false; // accessing properties on event.detail can throw errors (see #394)\n\n    try {\n      if (event.detail && event.detail.reason) {\n        error = event.detail.reason;\n        isBluebird = true;\n      }\n    } catch (e) {}\n\n    var handledState = {\n      severity: 'error',\n      unhandled: true,\n      severityReason: {\n        type: 'unhandledPromiseRejection'\n      }\n    };\n    var report;\n\n    if (error && _$hasStack_9(error)) {\n      // if it quacks like an Error…\n      report = new client.BugsnagReport(error.name, error.message, _$errorStackParser_7.parse(error), handledState, error);\n\n      if (isBluebird) {\n        report.stacktrace = __reduce_41(report.stacktrace, fixBluebirdStacktrace(error), []);\n      }\n    } else {\n      // if it doesn't…\n      var msg = 'Rejection reason was not an Error. See \"Promise\" tab for more detail.';\n      report = new client.BugsnagReport(error && error.name ? error.name : 'UnhandledRejection', error && error.message ? error.message : msg, [], handledState, error); // stuff the rejection reason into metaData, it could be useful\n\n      report.updateMetaData('promise', 'rejection reason', serializableReason(error));\n    }\n\n    client.notify(report);\n  };\n\n  if ('addEventListener' in win) {\n    win.addEventListener('unhandledrejection', listener);\n  } else {\n    win.onunhandledrejection = function (reason, promise) {\n      listener({\n        detail: {\n          reason: reason,\n          promise: promise\n        }\n      });\n    };\n  }\n\n  _listener = listener;\n};\n\nif (false) {}\n\nvar serializableReason = function (err) {\n  if (err === null || err === undefined) {\n    return 'undefined (or null)';\n  } else if (_$iserror_11(err)) {\n    var _ref;\n\n    return _ref = {}, _ref[Object.prototype.toString.call(err)] = {\n      name: err.name,\n      message: err.message,\n      code: err.code,\n      stack: err.stack\n    }, _ref;\n  } else {\n    return err;\n  }\n}; // The stack parser on bluebird stacks in FF get a suprious first frame:\n//\n// Error: derp\n//   b@http://localhost:5000/bluebird.html:22:24\n//   a@http://localhost:5000/bluebird.html:18:9\n//   @http://localhost:5000/bluebird.html:14:9\n//\n// results in\n//   […]\n//     0: Object { file: \"Error: derp\", method: undefined, lineNumber: undefined, … }\n//     1: Object { file: \"http://localhost:5000/bluebird.html\", method: \"b\", lineNumber: 22, … }\n//     2: Object { file: \"http://localhost:5000/bluebird.html\", method: \"a\", lineNumber: 18, … }\n//     3: Object { file: \"http://localhost:5000/bluebird.html\", lineNumber: 14, columnNumber: 9, … }\n//\n// so the following reduce/accumulator function removes such frames\n//\n// Bluebird pads method names with spaces so trim that too…\n// https://github.com/petkaantonov/bluebird/blob/b7f21399816d02f979fe434585334ce901dcaf44/src/debuggability.js#L568-L571\n\n\nvar fixBluebirdStacktrace = function (error) {\n  return function (accum, frame) {\n    if (frame.file === error.toString()) return accum;\n\n    if (frame.method) {\n      frame.method = frame.method.replace(/^\\s+/, '');\n    }\n\n    return accum.concat(frame);\n  };\n};\n\nvar _$notifier_2 = {};\nfunction ___extends_2() { ___extends_2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ___extends_2.apply(this, arguments); }\n\nvar name = 'Bugsnag JavaScript';\nvar version = '6.4.3';\nvar url = 'https://github.com/bugsnag/bugsnag-js';\n\n/* removed: var _$BugsnagClient_4 = require('@bugsnag/core/client'); */;\n\n/* removed: var _$BugsnagReport_24 = require('@bugsnag/core/report'); */;\n\n/* removed: var _$Session_25 = require('@bugsnag/core/session'); */;\n\n/* removed: var _$BugsnagBreadcrumb_3 = require('@bugsnag/core/breadcrumb'); */; // extend the base config schema with some browser-specific options\n\n\nvar __schema_2 = ___extends_2({}, _$config_5.schema, _$config_1);\n\n/* removed: var _$onerror_40 = require('@bugsnag/plugin-window-onerror'); */;\n\n/* removed: var _$unhandledRejection_41 = require('@bugsnag/plugin-window-unhandled-rejection'); */;\n\n/* removed: var _$device_29 = require('@bugsnag/plugin-browser-device'); */;\n\n/* removed: var _$context_28 = require('@bugsnag/plugin-browser-context'); */;\n\n/* removed: var _$request_30 = require('@bugsnag/plugin-browser-request'); */;\n\n/* removed: var _$throttle_38 = require('@bugsnag/plugin-simple-throttle'); */;\n\n/* removed: var _$consoleBreadcrumbs_33 = require('@bugsnag/plugin-console-breadcrumbs'); */;\n\n/* removed: var _$networkBreadcrumbs_37 = require('@bugsnag/plugin-network-breadcrumbs'); */;\n\n/* removed: var _$navigationBreadcrumbs_36 = require('@bugsnag/plugin-navigation-breadcrumbs'); */;\n\n/* removed: var _$interactionBreadcrumbs_35 = require('@bugsnag/plugin-interaction-breadcrumbs'); */;\n\n/* removed: var _$inlineScriptContent_34 = require('@bugsnag/plugin-inline-script-content'); */;\n\n/* removed: var _$session_31 = require('@bugsnag/plugin-browser-session'); */;\n\n/* removed: var _$clientIp_32 = require('@bugsnag/plugin-client-ip'); */;\n\n/* removed: var _$stripQueryString_39 = require('@bugsnag/plugin-strip-query-string'); */; // delivery mechanisms\n\n\n/* removed: var _$delivery_26 = require('@bugsnag/delivery-x-domain-request'); */;\n\n/* removed: var _$delivery_27 = require('@bugsnag/delivery-xml-http-request'); */;\n\n_$notifier_2 = function (opts) {\n  // handle very simple use case where user supplies just the api key as a string\n  if (typeof opts === 'string') opts = {\n    apiKey: opts // support renamed/deprecated options\n\n  };\n  var warningMessage = '';\n\n  if (opts.endpoints && opts.endpoints.notify && !opts.endpoints.sessions) {\n    warningMessage += 'notify endpoint is set but sessions endpoint is not. No sessions will be sent.';\n  }\n\n  var bugsnag = new _$BugsnagClient_4({\n    name: name,\n    version: version,\n    url: url\n  });\n  bugsnag.setOptions(opts); // set delivery based on browser capability (IE 8+9 have an XDomainRequest object)\n\n  bugsnag.delivery(window.XDomainRequest ? _$delivery_26 : _$delivery_27); // configure with user supplied options\n  // errors can be thrown here that prevent the lib from being in a useable state\n\n  bugsnag.configure(__schema_2);\n  if (warningMessage) bugsnag._logger.warn(warningMessage); // always-on browser-specific plugins\n\n  bugsnag.use(_$device_29);\n  bugsnag.use(_$context_28);\n  bugsnag.use(_$request_30);\n  bugsnag.use(_$throttle_38);\n  bugsnag.use(_$session_31);\n  bugsnag.use(_$clientIp_32);\n  bugsnag.use(_$stripQueryString_39); // optional browser-specific plugins\n\n  if (bugsnag.config.autoNotify !== false) {\n    bugsnag.use(_$onerror_40);\n    bugsnag.use(_$unhandledRejection_41);\n  }\n\n  bugsnag.use(_$navigationBreadcrumbs_36);\n  bugsnag.use(_$interactionBreadcrumbs_35);\n  bugsnag.use(_$networkBreadcrumbs_37);\n  bugsnag.use(_$consoleBreadcrumbs_33); // this one added last to avoid wrapping functionality before bugsnag uses it\n\n  bugsnag.use(_$inlineScriptContent_34);\n\n  bugsnag._logger.debug(\"Loaded!\");\n\n  return bugsnag.config.autoCaptureSessions ? bugsnag.startSession() : bugsnag;\n}; // Angular's DI system needs this interface to match what is exposed\n// in the type definition file (types/bugsnag.d.ts)\n\n\n_$notifier_2.Bugsnag = {\n  Client: _$BugsnagClient_4,\n  Report: _$BugsnagReport_24,\n  Session: _$Session_25,\n  Breadcrumb: _$BugsnagBreadcrumb_3 // Export a \"default\" property for compatibility with ESM imports\n\n};\n_$notifier_2['default'] = _$notifier_2;\n\nreturn _$notifier_2;\n\n});\n\n\n}).call(this)}).call(this,typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],33:[function(require,module,exports){\nmodule.exports = require('@bugsnag/browser')\n\n},{\"@bugsnag/browser\":32}],34:[function(require,module,exports){\n\n/**\n * Expose `Emitter`.\n */\n\nexports.Emitter = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n},{}],35:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n},{}],36:[function(require,module,exports){\n(function (process){(function (){\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"./common\":37,\"_process\":65}],37:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n},{\"ms\":64}],38:[function(require,module,exports){\n(function (process){(function (){\n\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BrowserInfo = /** @class */ (function () {\n    function BrowserInfo(name, version, os) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n    }\n    return BrowserInfo;\n}());\nexports.BrowserInfo = BrowserInfo;\nvar NodeInfo = /** @class */ (function () {\n    function NodeInfo(version) {\n        this.version = version;\n        this.name = 'node';\n        this.os = process.platform;\n    }\n    return NodeInfo;\n}());\nexports.NodeInfo = NodeInfo;\nvar BotInfo = /** @class */ (function () {\n    function BotInfo() {\n        this.bot = true; // NOTE: deprecated test name instead\n        this.name = 'bot';\n        this.version = null;\n        this.os = null;\n    }\n    return BotInfo;\n}());\nexports.BotInfo = BotInfo;\n// tslint:disable-next-line:max-line-length\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\\/Teoma)|(ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [\n    ['aol', /AOLShield\\/([0-9\\._]+)/],\n    ['edge', /Edge\\/([0-9\\._]+)/],\n    ['edge-ios', /EdgiOS\\/([0-9\\._]+)/],\n    ['yandexbrowser', /YaBrowser\\/([0-9\\._]+)/],\n    ['vivaldi', /Vivaldi\\/([0-9\\.]+)/],\n    ['kakaotalk', /KAKAOTALK\\s([0-9\\.]+)/],\n    ['samsung', /SamsungBrowser\\/([0-9\\.]+)/],\n    ['silk', /\\bSilk\\/([0-9._-]+)\\b/],\n    ['miui', /MiuiBrowser\\/([0-9\\.]+)$/],\n    ['beaker', /BeakerBrowser\\/([0-9\\.]+)/],\n    ['edge-chromium', /Edg\\/([0-9\\.]+)/],\n    [\n        'chromium-webview',\n        /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/,\n    ],\n    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n    ['phantomjs', /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['crios', /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n    ['fxios', /FxiOS\\/([0-9\\.]+)/],\n    ['opera-mini', /Opera Mini.*Version\\/([0-9\\.]+)/],\n    ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n    ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n    ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n    ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n    ['ie', /MSIE\\s(7\\.0)/],\n    ['bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n    ['android', /Android\\s([0-9\\.]+)/],\n    ['ios', /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n    ['safari', /Version\\/([0-9\\._]+).*Safari/],\n    ['facebook', /FBAV\\/([0-9\\.]+)/],\n    ['instagram', /Instagram\\s([0-9\\.]+)/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n    ['searchbot', SEARCHBOX_UA_REGEX],\n];\nvar operatingSystemRules = [\n    ['iOS', /iP(hone|od|ad)/],\n    ['Android OS', /Android/],\n    ['BlackBerry OS', /BlackBerry|BB10/],\n    ['Windows Mobile', /IEMobile/],\n    ['Amazon OS', /Kindle/],\n    ['Windows 3.11', /Win16/],\n    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],\n    ['Windows 98', /(Windows 98)|(Win98)/],\n    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],\n    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],\n    ['Windows Server 2003', /(Windows NT 5.2)/],\n    ['Windows Vista', /(Windows NT 6.0)/],\n    ['Windows 7', /(Windows NT 6.1)/],\n    ['Windows 8', /(Windows NT 6.2)/],\n    ['Windows 8.1', /(Windows NT 6.3)/],\n    ['Windows 10', /(Windows NT 10.0)/],\n    ['Windows ME', /Windows ME/],\n    ['Open BSD', /OpenBSD/],\n    ['Sun OS', /SunOS/],\n    ['Chrome OS', /CrOS/],\n    ['Linux', /(Linux)|(X11)/],\n    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],\n    ['QNX', /QNX/],\n    ['BeOS', /BeOS/],\n    ['OS/2', /OS\\/2/],\n    ['Search Bot', SEARCHBOT_OS_REGEX],\n];\nfunction detect(userAgent) {\n    if (!!userAgent) {\n        return parseUserAgent(userAgent);\n    }\n    if (typeof navigator !== 'undefined') {\n        return parseUserAgent(navigator.userAgent);\n    }\n    return getNodeVersion();\n}\nexports.detect = detect;\nfunction parseUserAgent(ua) {\n    // opted for using reduce here rather than Array#first with a regex.test call\n    // this is primarily because using the reduce we only perform the regex\n    // execution once rather than once for the test and for the exec again below\n    // probably something that needs to be benchmarked though\n    var matchedRule = ua !== '' &&\n        userAgentRules.reduce(function (matched, _a) {\n            var browser = _a[0], regex = _a[1];\n            if (matched) {\n                return matched;\n            }\n            var uaMatch = regex.exec(ua);\n            return !!uaMatch && [browser, uaMatch];\n        }, false);\n    if (!matchedRule) {\n        return null;\n    }\n    var name = matchedRule[0], match = matchedRule[1];\n    if (name === 'searchbot') {\n        return new BotInfo();\n    }\n    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);\n    if (versionParts) {\n        if (versionParts.length < REQUIRED_VERSION_PARTS) {\n            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));\n        }\n    }\n    else {\n        versionParts = [];\n    }\n    return new BrowserInfo(name, versionParts.join('.'), detectOS(ua));\n}\nexports.parseUserAgent = parseUserAgent;\nfunction detectOS(ua) {\n    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];\n        var match = regex.test(ua);\n        if (match) {\n            return os;\n        }\n    }\n    return null;\n}\nexports.detectOS = detectOS;\nfunction getNodeVersion() {\n    var isNode = typeof process !== 'undefined' && process.version;\n    return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\nexports.getNodeVersion = getNodeVersion;\nfunction createVersionParts(count) {\n    var output = [];\n    for (var ii = 0; ii < count; ii++) {\n        output.push('0');\n    }\n    return output;\n}\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":65}],39:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasCORS = void 0;\n// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nexports.hasCORS = value;\n\n},{}],40:[function(require,module,exports){\n\"use strict\";\n// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = void 0;\nfunction encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\nexports.encode = encode;\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nfunction decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\nexports.decode = decode;\n\n},{}],41:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = void 0;\n// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nfunction parse(str) {\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nexports.parse = parse;\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n\n},{}],42:[function(require,module,exports){\n// imported from https://github.com/unshiftio/yeast\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.yeast = exports.decode = exports.encode = void 0;\nconst alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n    let encoded = '';\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\nexports.encode = encode;\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\nexports.decode = decode;\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return seed = 0, prev = now;\n    return now + '.' + encode(seed++);\n}\nexports.yeast = yeast;\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n\n},{}],43:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globalThisShim = void 0;\nexports.globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n\n},{}],44:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.Transport = exports.protocol = exports.Socket = void 0;\nconst socket_js_1 = require(\"./socket.js\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_js_1.Socket; } });\nexports.protocol = socket_js_1.Socket.protocol;\nvar transport_js_1 = require(\"./transport.js\");\nObject.defineProperty(exports, \"Transport\", { enumerable: true, get: function () { return transport_js_1.Transport; } });\nvar index_js_1 = require(\"./transports/index.js\");\nObject.defineProperty(exports, \"transports\", { enumerable: true, get: function () { return index_js_1.transports; } });\nvar util_js_1 = require(\"./util.js\");\nObject.defineProperty(exports, \"installTimerFunctions\", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });\nvar parseuri_js_1 = require(\"./contrib/parseuri.js\");\nObject.defineProperty(exports, \"parse\", { enumerable: true, get: function () { return parseuri_js_1.parse; } });\nvar websocket_constructor_js_1 = require(\"./transports/websocket-constructor.js\");\nObject.defineProperty(exports, \"nextTick\", { enumerable: true, get: function () { return websocket_constructor_js_1.nextTick; } });\n\n},{\"./contrib/parseuri.js\":41,\"./socket.js\":45,\"./transport.js\":46,\"./transports/index.js\":47,\"./transports/websocket-constructor.js\":49,\"./util.js\":52}],45:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst index_js_1 = require(\"./transports/index.js\");\nconst util_js_1 = require(\"./util.js\");\nconst parseqs_js_1 = require(\"./contrib/parseqs.js\");\nconst parseuri_js_1 = require(\"./contrib/parseuri.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:socket\"); // debug()\nclass Socket extends component_emitter_1.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts = {}) {\n        super();\n        this.writeBuffer = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = (0, parseuri_js_1.parse)(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;\n        }\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        debug('creating transport \"%s\"', name);\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser_1.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        });\n        debug(\"options: %j\", opts);\n        return new index_js_1.transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            debug(\"error while creating transport: %s\", e);\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        debug(\"setting transport %s\", transport.name);\n        if (this.transport) {\n            debug(\"clearing existing transport %s\", this.transport.name);\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    probe(name) {\n        debug('probing transport \"%s\"', name);\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            debug('probe transport \"%s\" opened', name);\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    debug('probe transport \"%s\" pong', name);\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    debug('pausing current transport \"%s\"', this.transport.name);\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        debug(\"changing transport and sending upgrade packet\");\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    debug('probe transport \"%s\" failed', name);\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            debug('probe transport \"%s\" failed because of error: %s', name, err);\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        debug(\"socket open\");\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            debug(\"starting upgrade probes\");\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n            debug('packet received with socket readyState \"%s\"', this.readyState);\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this.getWritablePackets();\n            debug(\"flushing %d packets in socket\", packets.length);\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    getWritablePackets() {\n        const shouldCheckPayloadSize = this.maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += (0, util_js_1.byteLength)(data);\n            }\n            if (i > 0 && payloadSize > this.maxPayload) {\n                debug(\"only send %d out of %d packets\", i, this.writeBuffer.length);\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        debug(\"payload size is %d (max: %d)\", payloadSize, this.maxPayload);\n        return this.writeBuffer;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            debug(\"socket closing - telling transport to close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    onError(err) {\n        debug(\"socket error %j\", err);\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            debug('socket close with reason: \"%s\"', reason);\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nexports.Socket = Socket;\nSocket.protocol = engine_io_parser_1.protocol;\n\n},{\"./contrib/parseqs.js\":40,\"./contrib/parseuri.js\":41,\"./transports/index.js\":47,\"./util.js\":52,\"@socket.io/component-emitter\":34,\"debug\":36,\"engine.io-parser\":57}],46:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst util_js_1 = require(\"./util.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = (0, debug_1.default)(\"engine.io-client:transport\"); // debug()\nclass TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nclass Transport extends component_emitter_1.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n            debug(\"transport is not open, discarding packets\");\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n}\nexports.Transport = Transport;\n\n},{\"./util.js\":52,\"@socket.io/component-emitter\":34,\"debug\":36,\"engine.io-parser\":57}],47:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transports = void 0;\nconst polling_js_1 = require(\"./polling.js\");\nconst websocket_js_1 = require(\"./websocket.js\");\nexports.transports = {\n    websocket: websocket_js_1.WS,\n    polling: polling_js_1.Polling,\n};\n\n},{\"./polling.js\":48,\"./websocket.js\":50}],48:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Request = exports.Polling = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst yeast_js_1 = require(\"../contrib/yeast.js\");\nconst parseqs_js_1 = require(\"../contrib/parseqs.js\");\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst xmlhttprequest_js_1 = require(\"./xmlhttprequest.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst util_js_1 = require(\"../util.js\");\nconst globalThis_js_1 = require(\"../globalThis.js\");\nconst debug = (0, debug_1.default)(\"engine.io-client:polling\"); // debug()\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new xmlhttprequest_js_1.XHR({\n        xdomain: false,\n    });\n    return null != xhr.responseType;\n})();\nclass Polling extends transport_js_1.Transport {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        this.polling = false;\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            debug(\"paused\");\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                debug(\"we are currently polling - waiting to pause\");\n                total++;\n                this.once(\"pollComplete\", function () {\n                    debug(\"pre-pause polling complete\");\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                debug(\"we are currently writing - waiting to pause\");\n                total++;\n                this.once(\"drain\", function () {\n                    debug(\"pre-pause writing complete\");\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    poll() {\n        debug(\"polling\");\n        this.polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        debug(\"polling got data %s\", data);\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n                debug('ignoring poll - transport state \"%s\"', this.readyState);\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            debug(\"writing close packet\");\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            debug(\"transport open - closing\");\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            debug(\"transport not open - deferring close\");\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        (0, engine_io_parser_1.encodePayload)(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = (0, parseqs_js_1.encode)(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        debug(\"xhr poll\");\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nexports.Polling = Polling;\nclass Request extends component_emitter_1.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(uri, opts) {\n        super();\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    create() {\n        const opts = (0, util_js_1.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new xmlhttprequest_js_1.XHR(opts));\n        try {\n            debug(\"xhr open %s: %s\", this.method, this.uri);\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            debug(\"xhr data %s\", this.data);\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    onError(err) {\n        this.emitReserved(\"error\", err, this.xhr);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this.cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nexports.Request = Request;\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis_js_1.globalThisShim ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n\n},{\"../contrib/parseqs.js\":40,\"../contrib/yeast.js\":42,\"../globalThis.js\":43,\"../transport.js\":46,\"../util.js\":52,\"./xmlhttprequest.js\":51,\"@socket.io/component-emitter\":34,\"debug\":36,\"engine.io-parser\":57}],49:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;\nconst globalThis_js_1 = require(\"../globalThis.js\");\nexports.nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexports.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;\nexports.usingBrowserWebSocket = true;\nexports.defaultBinaryType = \"arraybuffer\";\n\n},{\"../globalThis.js\":43}],50:[function(require,module,exports){\n(function (Buffer){(function (){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WS = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst parseqs_js_1 = require(\"../contrib/parseqs.js\");\nconst yeast_js_1 = require(\"../contrib/yeast.js\");\nconst util_js_1 = require(\"../util.js\");\nconst websocket_constructor_js_1 = require(\"./websocket-constructor.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:websocket\"); // debug()\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends transport_js_1.Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : (0, util_js_1.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new websocket_constructor_js_1.WebSocket(uri, protocols)\n                        : new websocket_constructor_js_1.WebSocket(uri)\n                    : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!websocket_constructor_js_1.usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \n                        // @ts-ignore\n                        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (websocket_constructor_js_1.usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                    debug(\"websocket closed before onclose event\");\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0, websocket_constructor_js_1.nextTick)(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = (0, parseqs_js_1.encode)(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @private\n     */\n    check() {\n        return !!websocket_constructor_js_1.WebSocket;\n    }\n}\nexports.WS = WS;\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"../contrib/parseqs.js\":40,\"../contrib/yeast.js\":42,\"../transport.js\":46,\"../util.js\":52,\"./websocket-constructor.js\":49,\"buffer\":58,\"debug\":36,\"engine.io-parser\":57}],51:[function(require,module,exports){\n\"use strict\";\n// browser shim for xmlhttprequest module\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XHR = void 0;\nconst has_cors_js_1 = require(\"../contrib/has-cors.js\");\nconst globalThis_js_1 = require(\"../globalThis.js\");\nfunction XHR(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis_js_1.globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\nexports.XHR = XHR;\n\n},{\"../contrib/has-cors.js\":39,\"../globalThis.js\":43}],52:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.byteLength = exports.installTimerFunctions = exports.pick = void 0;\nconst globalThis_js_1 = require(\"./globalThis.js\");\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\nexports.pick = pick;\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = globalThis_js_1.globalThisShim.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = globalThis_js_1.globalThisShim.clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);\n    }\n    else {\n        obj.setTimeoutFn = globalThis_js_1.globalThisShim.setTimeout.bind(globalThis_js_1.globalThisShim);\n        obj.clearTimeoutFn = globalThis_js_1.globalThisShim.clearTimeout.bind(globalThis_js_1.globalThisShim);\n    }\n}\nexports.installTimerFunctions = installTimerFunctions;\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nfunction byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nexports.byteLength = byteLength;\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n\n},{\"./globalThis.js\":43}],53:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nexports.PACKET_TYPES = PACKET_TYPES;\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nexports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexports.ERROR_PACKET = ERROR_PACKET;\n\n},{}],54:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = void 0;\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nconst encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexports.encode = encode;\nconst decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\nexports.decode = decode;\n\n},{}],55:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst base64_arraybuffer_js_1 = require(\"./contrib/base64-arraybuffer.js\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return commons_js_1.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0, base64_arraybuffer_js_1.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\nexports.default = decodePacket;\n\n},{\"./commons.js\":53,\"./contrib/base64-arraybuffer.js\":54}],56:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(commons_js_1.PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + content);\n    };\n    return fileReader.readAsDataURL(data);\n};\nexports.default = encodePacket;\n\n},{\"./commons.js\":53}],57:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;\nconst encodePacket_js_1 = require(\"./encodePacket.js\");\nexports.encodePacket = encodePacket_js_1.default;\nconst decodePacket_js_1 = require(\"./decodePacket.js\");\nexports.decodePacket = decodePacket_js_1.default;\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        (0, encodePacket_js_1.default)(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nexports.encodePayload = encodePayload;\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexports.decodePayload = decodePayload;\nexports.protocol = 4;\n\n},{\"./decodePacket.js\":55,\"./encodePacket.js\":56}],58:[function(require,module,exports){\n(function (Buffer){(function (){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"base64-js\":35,\"buffer\":58,\"ieee754\":59}],59:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],60:[function(require,module,exports){\n'use strict';\n\nconst word = '[a-fA-F\\\\d:]';\nconst b = options => options && options.includeBoundaries ?\n\t`(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))` :\n\t'';\n\nconst v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\nconst v6seg = '[a-fA-F\\\\d]{1,4}';\nconst v6 = `\n(?:\n(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`.replace(/\\s*\\/\\/.*$/gm, '').replace(/\\n/g, '').trim();\n\n// Pre-compile only the exact regexes because adding a global flag make regexes stateful\nconst v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\nconst v4exact = new RegExp(`^${v4}$`);\nconst v6exact = new RegExp(`^${v6}$`);\n\nconst ip = options => options && options.exact ?\n\tv46Exact :\n\tnew RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, 'g');\n\nip.v4 = options => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');\nip.v6 = options => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');\n\nmodule.exports = ip;\n\n},{}],61:[function(require,module,exports){\n'use strict';\nconst ipRegex = require('ip-regex');\n\nconst isIp = string => ipRegex({exact: true}).test(string);\nisIp.v4 = string => ipRegex.v4({exact: true}).test(string);\nisIp.v6 = string => ipRegex.v6({exact: true}).test(string);\nisIp.version = string => isIp(string) ? (isIp.v4(string) ? 4 : 6) : undefined;\n\nmodule.exports = isIp;\n\n},{\"ip-regex\":60}],62:[function(require,module,exports){\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function (root) {\n  'use strict';\n\n  var merge = function (target) {\n    var i = 1;\n    var length = arguments.length;\n    var key;\n    for (; i < length; i++) {\n      for (key in arguments[i]) {\n        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n          target[key] = arguments[i][key];\n        }\n      }\n    }\n    return target;\n  };\n\n  var defaults = {\n    template: '[%t] %l:',\n    levelFormatter: function (level) {\n      return level.toUpperCase();\n    },\n    nameFormatter: function (name) {\n      return name || 'root';\n    },\n    timestampFormatter: function (date) {\n      return date.toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, '$1');\n    },\n    format: undefined\n  };\n\n  var loglevel;\n  var configs = {};\n\n  var reg = function (rootLogger) {\n    if (!rootLogger || !rootLogger.getLogger) {\n      throw new TypeError('Argument is not a root logger');\n    }\n    loglevel = rootLogger;\n  };\n\n  var apply = function (logger, config) {\n    if (!logger || !logger.setLevel) {\n      throw new TypeError('Argument is not a logger');\n    }\n\n    /* eslint-disable vars-on-top */\n    var originalFactory = logger.methodFactory;\n    var name = logger.name || '';\n    var parent = configs[name] || configs[''] || defaults;\n    /* eslint-enable vars-on-top */\n\n    function methodFactory(methodName, logLevel, loggerName) {\n      var originalMethod = originalFactory(methodName, logLevel, loggerName);\n      var options = configs[loggerName] || configs[''];\n\n      var hasTimestamp = options.template.indexOf('%t') !== -1;\n      var hasLevel = options.template.indexOf('%l') !== -1;\n      var hasName = options.template.indexOf('%n') !== -1;\n\n      return function () {\n        var content = '';\n\n        var length = arguments.length;\n        var args = Array(length);\n        var key = 0;\n        for (; key < length; key++) {\n          args[key] = arguments[key];\n        }\n\n        // skip the root method for child loggers to prevent duplicate logic\n        if (name || !configs[loggerName]) {\n          /* eslint-disable vars-on-top */\n          var timestamp = options.timestampFormatter(new Date());\n          var level = options.levelFormatter(methodName);\n          var lname = options.nameFormatter(loggerName);\n          /* eslint-enable vars-on-top */\n\n          if (options.format) {\n            content += options.format(level, lname, timestamp);\n          } else {\n            content += options.template;\n            if (hasTimestamp) {\n              content = content.replace(/%t/, timestamp);\n            }\n            if (hasLevel) content = content.replace(/%l/, level);\n            if (hasName) content = content.replace(/%n/, lname);\n          }\n\n          if (args.length && typeof args[0] === 'string') {\n            // concat prefix with first argument to support string substitutions\n            args[0] = content + ' ' + args[0];\n          } else {\n            args.unshift(content);\n          }\n        }\n\n        originalMethod.apply(undefined, args);\n      };\n    }\n\n    if (!configs[name]) {\n      logger.methodFactory = methodFactory;\n    }\n\n    // for remove inherited format option if template option preset\n    config = config || {};\n    if (config.template) config.format = undefined;\n\n    configs[name] = merge({}, parent, config);\n\n    logger.setLevel(logger.getLevel());\n\n    if (!loglevel) {\n      logger.warn(\n        'It is necessary to call the function reg() of loglevel-plugin-prefix before calling apply. From the next release, it will throw an error. See more: https://github.com/kutuluk/loglevel-plugin-prefix/blob/master/README.md'\n      );\n    }\n\n    return logger;\n  };\n\n  var api = {\n    reg: reg,\n    apply: apply\n  };\n\n  var save;\n\n  if (root) {\n    save = root.prefix;\n    api.noConflict = function () {\n      if (root.prefix === api) {\n        root.prefix = save;\n      }\n      return api;\n    };\n  }\n\n  return api;\n}));\n\n},{}],63:[function(require,module,exports){\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n\n},{}],64:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n},{}],65:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],66:[function(require,module,exports){\nconst { iterateReports } = require(\"./utils\");\n\nfunction calculateMos(reports) {\n  let jitter_time = 0;\n  let recv_pkts = 0;\n  let lost_pkts = 0;\n  let average = 100.0;\n  let packet_loss = 0.0;\n  let effective_latency;\n  let r_value;\n  let mos;\n\n  iterateReports(reports, (report) => {\n    if (report.type === \"inbound-rtp\") {\n      jitter_time = report.jitter;\n      lost_pkts = report.packetsLost;\n      recv_pkts = report.packetsReceived;\n    }\n  })\n\n  if (recv_pkts + lost_pkts > 0) {\n    packet_loss = 100.0 * (lost_pkts / (recv_pkts + lost_pkts));\n  }\n  effective_latency = average + jitter_time * 2 + 10;\n  if (effective_latency < 160) {\n    r_value = 93.2 - effective_latency / 40;\n  } else {\n    r_value = 93.2 - (effective_latency - 120) / 10;\n  }\n  r_value = r_value - packet_loss * 2.5;\n\n  if (r_value < 1) {\n    r_value = 1;\n  }\n  mos =\n    1 + 0.035 * r_value + 0.000007 * r_value * (r_value - 60) * (100 - r_value);\n\n  return parseFloat(mos).toFixed(6);\n}\n\nmodule.exports = calculateMos;\n\n},{\"./utils\":69}],67:[function(require,module,exports){\nconst { iterateReports } = require(\"./utils\");\nconst { parsers } = require(\"./parsers/new-api\");\nconst calculateMos = require(\"./calculate-mos\");\n\nfunction parse(reports) {\n  const result = {};\n\n  iterateReports(reports, (report) => {\n    if (report.type in parsers) {\n      const mappedReport = parsers[report.type](report);\n\n      Object.assign(result, mappedReport);\n    }\n  });\n\n  result.networkMos = parseFloat(calculateMos(reports));\n\n  return result;\n}\n\nmodule.exports = parse;\n\n},{\"./calculate-mos\":66,\"./parsers/new-api\":68,\"./utils\":69}],68:[function(require,module,exports){\n/**\n * Rules to map different types of reports combined by report name\n * On the left - name of the field in a report\n * On the rirgh - new name\n */\nconst rules = {\n  \"outbound-rtp\": {\n    packetsSent: \"audioSentPackets\",\n    bytesSent: \"audioSentBytes\",\n  },\n  \"inbound-rtp\": {\n    packetsReceived: \"audioRecvPackets\",\n    packetsLost: \"audioRecvPacketsLost\",\n    bytesReceived: \"audioRecvBytes\",\n    jitter: \"audioRecvJitter\"\n  },\n  \"remote-inbound-rtp\": {\n    packetsLost: \"audioSentPacketsLost\",\n    roundTripTime: \"audioRtt\",\n    jitter: \"audioSentJitter\"\n  },\n};\n\n// Additional logic to parse values can be done here\nconst parsers = {\n  \"remote-candidate\": function (report) {\n    return mapKeys(report);\n  },\n  \"inbound-rtp\": function (report) {\n    return mapKeys(report);\n  },\n  \"outbound-rtp\": function (report) {\n    return mapKeys(report);\n  },\n  \"remote-inbound-rtp\": function (report) {\n    return mapKeys(report);\n  },\n};\n\nconst mapKeys = (report) => {\n  const { type } = report;\n  const mapping = rules[type];\n  const result = {};\n\n  for (let field in mapping) {\n    if (field in report) {\n      let mappedName;\n\n      if (typeof mapping[field] === \"function\") {\n        mappedName = mapping[field](report);\n      } else {\n        mappedName = mapping[field];\n      }\n      result[mappedName] = report[field];\n    } else {\n      result[mapping[field]] = null;\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = {\n  rules,\n  parsers,\n};\n\n},{}],69:[function(require,module,exports){\nfunction iterateReports(stats, fn) {\n  if (typeof stats[Symbol.iterator] === \"function\") {\n    for (const el of stats) {\n      const report = Array.isArray(el) ? el[1] : el;\n      fn(report);\n    }\n  } else {\n    for (const key in stats) {\n      if (stats.hasOwnProperty(key)) {\n        const report = stats[key];\n        fn(report);\n      }\n    }\n  }\n}\n\nmodule.exports = {\n    iterateReports\n}\n},{}],70:[function(require,module,exports){\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nvar SDPUtils = require('sdp');\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all fieldѕ are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this._localDescription = null;\n    this._remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {\n    configurable: true,\n    get: function() {\n      return this._localDescription;\n    }\n  });\n  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {\n    configurable: true,\n    get: function() {\n      return this._remoteDescription;\n    }\n  });\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // ѕdpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete‥\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc._localDescription.sdp =\n          SDPUtils.getDescription(pc._localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc._localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||\n          protocol === 'UDP/DTLS/SCTP'))) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          protocol: protocol,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        // If the offer contained RTX but the answer did not,\n        // remove RTX from sendEncodingParameters.\n        var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n        var hasRtx = commonCapabilities.codecs.filter(function(c) {\n          return c.name.toLowerCase() === 'rtx';\n        }).length;\n        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n          delete transceiver.sendEncodingParameters[0].rtx;\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc._remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n      }\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && transceiver.dtlsTransport &&\n          !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n        states[transceiver.dtlsTransport.state]++;\n      }\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc._remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt\n            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n          } else {\n            sdp += 'm=application 0 ' + transceiver.protocol +\n                ' webrtc-datachannel\\r\\n';\n          }\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc._remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function(selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function(transceiver) {\n        if (transceiver.rtpSender &&\n            transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver &&\n            transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    return Promise.all(promises).then(function(allStats) {\n      var results = new Map();\n      allStats.forEach(function(stats) {\n        stats.forEach(function(stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',\n    'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function(ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function() {\n        return nativeGetstats.apply(this)\n        .then(function(nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function(id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n},{\"sdp\":75}],71:[function(require,module,exports){\nvar grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push:'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name:'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += (o.id != null ? 'id=%s %s' : '%v%s');\n        str += (o.mediaClockValue != null ? '=%s' : '');\n        str += (o.rateNumerator != null ? ' rate=%s' : '');\n        str += (o.rateDenominator != null ? '/%s' : '');\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n},{}],72:[function(require,module,exports){\nvar parser = require('./parser');\nvar writer = require('./writer');\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n},{\"./parser\":73,\"./writer\":74}],73:[function(require,module,exports){\nvar toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = require('./grammar');\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n},{\"./grammar\":71}],74:[function(require,module,exports){\nvar grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n},{\"./grammar\":71}],75:[function(require,module,exports){\n/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\nSDPUtils.parseSsrcGroup = function(line) {\n  var parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(function(ssrc) {\n      return parseInt(ssrc, 10);\n    })\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  var parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES paramters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(parts) {\n      return parts.attribute === 'cname';\n    });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(function(line) {\n      var parts = line.substr(17).split(' ');\n      return parts.map(function(part) {\n        return parseInt(part, 10);\n      });\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  // Gets the first SSRC. Note tha with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(obj) {\n      return obj.attribute === 'cname';\n    })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(msidParts) {\n      return msidParts.attribute === 'msid';\n    });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  var mline = SDPUtils.parseMLine(mediaSection);\n  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  var maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize: maxMessageSize\n    };\n  }\n  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize: maxMessageSize\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  var output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n'\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  var user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n    transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n    transceiver.dtlsTransport.getLocalParameters(),\n    type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  var lines = SDPUtils.splitLines(blob);\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n\n},{}],76:[function(require,module,exports){\n\"use strict\";\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Backoff = void 0;\nfunction Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\nexports.Backoff = Backoff;\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n\n},{}],77:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;\nconst url_js_1 = require(\"./url.js\");\nconst manager_js_1 = require(\"./manager.js\");\nObject.defineProperty(exports, \"Manager\", { enumerable: true, get: function () { return manager_js_1.Manager; } });\nconst socket_js_1 = require(\"./socket.js\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_js_1.Socket; } });\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client\"); // debug()\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url_js_1.url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        debug(\"ignoring socket cache for %s\", source);\n        io = new manager_js_1.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            debug(\"new io instance for %s\", source);\n            cache[id] = new manager_js_1.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\nexports.io = lookup;\nexports.connect = lookup;\nexports.default = lookup;\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: manager_js_1.Manager,\n    Socket: socket_js_1.Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nvar socket_io_parser_1 = require(\"socket.io-parser\");\nObject.defineProperty(exports, \"protocol\", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });\n\nmodule.exports = lookup;\n\n},{\"./manager.js\":78,\"./socket.js\":80,\"./url.js\":81,\"debug\":82,\"socket.io-parser\":85}],78:[function(require,module,exports){\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Manager = void 0;\nconst engine_io_client_1 = require(\"engine.io-client\");\nconst socket_js_1 = require(\"./socket.js\");\nconst parser = __importStar(require(\"socket.io-parser\"));\nconst on_js_1 = require(\"./on.js\");\nconst backo2_js_1 = require(\"./contrib/backo2.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:manager\"); // debug()\nclass Manager extends component_emitter_1.Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        engine_io_client_1.installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new backo2_js_1.Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        debug(\"readyState %s\", this._readyState);\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        debug(\"opening %s\", this.uri);\n        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on_js_1.on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on_js_1.on(socket, \"error\", (err) => {\n            debug(\"error\");\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            debug(\"connect attempt will timeout after %d\", timeout);\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                debug(\"connect attempt timed out after %d\", timeout);\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"open\");\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on_js_1.on(socket, \"ping\", this.onping.bind(this)), on_js_1.on(socket, \"data\", this.ondata.bind(this)), on_js_1.on(socket, \"error\", this.onerror.bind(this)), on_js_1.on(socket, \"close\", this.onclose.bind(this)), on_js_1.on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        engine_io_client_1.nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        debug(\"error\", err);\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new socket_js_1.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                debug(\"socket %s is still active, skipping close\", nsp);\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        debug(\"writing packet %j\", packet);\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        debug(\"cleanup\");\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        debug(\"disconnect\");\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        debug(\"closed due to %s\", reason);\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            debug(\"reconnect failed\");\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            debug(\"will wait %dms before reconnect attempt\", delay);\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                debug(\"attempting reconnect\");\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        debug(\"reconnect attempt error\");\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        debug(\"reconnect success\");\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\nexports.Manager = Manager;\n\n},{\"./contrib/backo2.js\":76,\"./on.js\":79,\"./socket.js\":80,\"@socket.io/component-emitter\":34,\"debug\":82,\"engine.io-client\":44,\"socket.io-parser\":85}],79:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.on = void 0;\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\nexports.on = on;\n\n},{}],80:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst on_js_1 = require(\"./on.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:socket\"); // debug()\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nclass Socket extends component_emitter_1.Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on_js_1.on(io, \"open\", this.onopen.bind(this)),\n            on_js_1.on(io, \"packet\", this.onpacket.bind(this)),\n            on_js_1.on(io, \"error\", this.onerror.bind(this)),\n            on_js_1.on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n            debug(\"discard packet as the transport is not currently writable\");\n        }\n        else if (this.connected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    debug(\"removing packet with ack id %d from the buffer\", id);\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks[id] = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, [null, ...args]);\n        };\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    debug(\"packet [%d] is discarded after %d tries\", packet.id, packet.tryCount);\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                debug(\"packet [%d] was successfully sent\", packet.id);\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        debug(\"draining queue\");\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            debug(\"packet [%d] has already been sent and is waiting for an ack\", packet.id);\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        debug(\"sending packet [%d] (try n°%d)\", packet.id, packet.tryCount);\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"transport is open - connecting\");\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: socket_io_parser_1.PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        debug(\"close (%s)\", reason);\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser_1.PacketType.EVENT:\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser_1.PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            debug(\"sending ack %j\", args);\n            self.packet({\n                type: socket_io_parser_1.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        debug(\"socket connected with id %s\", id);\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"server disconnect (%s)\", this.nsp);\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            debug(\"performing disconnect (%s)\", this.nsp);\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\nexports.Socket = Socket;\n\n},{\"./on.js\":79,\"@socket.io/component-emitter\":34,\"debug\":82,\"socket.io-parser\":85}],81:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.url = void 0;\nconst engine_io_client_1 = require(\"engine.io-client\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:url\"); // debug()\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            debug(\"protocol-less url %s\", uri);\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        debug(\"parse %s\", uri);\n        obj = engine_io_client_1.parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\nexports.url = url;\n\n},{\"debug\":82,\"engine.io-client\":44}],82:[function(require,module,exports){\n(function (process){(function (){\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"./common\":83,\"_process\":65}],83:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n},{\"ms\":64}],84:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructPacket = exports.deconstructPacket = void 0;\nconst is_binary_js_1 = require(\"./is-binary.js\");\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nexports.deconstructPacket = deconstructPacket;\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if ((0, is_binary_js_1.isBinary)(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nexports.reconstructPacket = reconstructPacket;\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n\n},{\"./is-binary.js\":86}],85:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst binary_js_1 = require(\"./binary.js\");\nconst is_binary_js_1 = require(\"./is-binary.js\");\nconst debug_1 = require(\"debug\"); // debug()\nconst debug = (0, debug_1.default)(\"socket.io-parser\"); // debug()\n/**\n * Protocol version.\n *\n * @public\n */\nexports.protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        debug(\"encoding packet %j\", obj);\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if ((0, is_binary_js_1.hasBinary)(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        debug(\"encoded %j as %s\", obj, str);\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\nexports.Encoder = Encoder;\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends component_emitter_1.Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        debug(\"decoded %s as %j\", str, p);\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return Array.isArray(payload) && payload.length > 0;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\nexports.Decoder = Decoder;\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n\n},{\"./binary.js\":84,\"./is-binary.js\":86,\"@socket.io/component-emitter\":34,\"debug\":36}],86:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasBinary = exports.isBinary = void 0;\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexports.isBinary = isBinary;\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasBinary = hasBinary;\n\n},{}],87:[function(require,module,exports){\nvar v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n},{\"./v1\":90,\"./v4\":91}],88:[function(require,module,exports){\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n},{}],89:[function(require,module,exports){\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n},{}],90:[function(require,module,exports){\nvar rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n},{\"./lib/bytesToUuid\":88,\"./lib/rng\":89}],91:[function(require,module,exports){\nvar rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n},{\"./lib/bytesToUuid\":88,\"./lib/rng\":89}],92:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _adapter_factory = require('./adapter_factory.js');\n\nvar adapter = (0, _adapter_factory.adapterFactory)({ window: typeof window === 'undefined' ? undefined : window });\nexports.default = adapter;\n\n},{\"./adapter_factory.js\":93}],93:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.adapterFactory = adapterFactory;\n\nvar _utils = require('./utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nvar _chrome_shim = require('./chrome/chrome_shim');\n\nvar chromeShim = _interopRequireWildcard(_chrome_shim);\n\nvar _edge_shim = require('./edge/edge_shim');\n\nvar edgeShim = _interopRequireWildcard(_edge_shim);\n\nvar _firefox_shim = require('./firefox/firefox_shim');\n\nvar firefoxShim = _interopRequireWildcard(_firefox_shim);\n\nvar _safari_shim = require('./safari/safari_shim');\n\nvar safariShim = _interopRequireWildcard(_safari_shim);\n\nvar _common_shim = require('./common_shim');\n\nvar commonShim = _interopRequireWildcard(_common_shim);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Shimming starts here.\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\nfunction adapterFactory() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      window = _ref.window;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimEdge: true,\n    shimSafari: true\n  };\n\n  // Utils.\n  var logging = utils.log;\n  var browserDetails = utils.detectBrowser(window);\n\n  var adapter = {\n    browserDetails: browserDetails,\n    commonShim: commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n\n      chromeShim.shimGetUserMedia(window);\n      chromeShim.shimMediaStream(window);\n      chromeShim.shimPeerConnection(window);\n      chromeShim.shimOnTrack(window);\n      chromeShim.shimAddTrackRemoveTrack(window);\n      chromeShim.shimGetSendersWithDtmf(window);\n      chromeShim.shimGetStats(window);\n      chromeShim.shimSenderReceiverGetStats(window);\n      chromeShim.fixNegotiationNeeded(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimConnectionState(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      commonShim.removeAllowExtmapMixed(window);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n\n      firefoxShim.shimGetUserMedia(window);\n      firefoxShim.shimPeerConnection(window);\n      firefoxShim.shimOnTrack(window);\n      firefoxShim.shimRemoveStream(window);\n      firefoxShim.shimSenderGetStats(window);\n      firefoxShim.shimReceiverGetStats(window);\n      firefoxShim.shimRTCDataChannel(window);\n      firefoxShim.shimAddTransceiver(window);\n      firefoxShim.shimGetParameters(window);\n      firefoxShim.shimCreateOffer(window);\n      firefoxShim.shimCreateAnswer(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimConnectionState(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'edge':\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edgeShim;\n\n      edgeShim.shimGetUserMedia(window);\n      edgeShim.shimGetDisplayMedia(window);\n      edgeShim.shimPeerConnection(window);\n      edgeShim.shimReplaceTrack(window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n\n      safariShim.shimRTCIceServerUrls(window);\n      safariShim.shimCreateOfferLegacy(window);\n      safariShim.shimCallbacksAPI(window);\n      safariShim.shimLocalStreamsAPI(window);\n      safariShim.shimRemoteStreamsAPI(window);\n      safariShim.shimTrackEventTransceiver(window);\n      safariShim.shimGetUserMedia(window);\n      safariShim.shimAudioContext(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      commonShim.removeAllowExtmapMixed(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n\n// Browser shims.\n\n},{\"./chrome/chrome_shim\":94,\"./common_shim\":97,\"./edge/edge_shim\":98,\"./firefox/firefox_shim\":102,\"./safari/safari_shim\":105,\"./utils\":106}],94:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _getusermedia = require('./getusermedia');\n\nObject.defineProperty(exports, 'shimGetUserMedia', {\n  enumerable: true,\n  get: function get() {\n    return _getusermedia.shimGetUserMedia;\n  }\n});\n\nvar _getdisplaymedia = require('./getdisplaymedia');\n\nObject.defineProperty(exports, 'shimGetDisplayMedia', {\n  enumerable: true,\n  get: function get() {\n    return _getdisplaymedia.shimGetDisplayMedia;\n  }\n});\nexports.shimMediaStream = shimMediaStream;\nexports.shimOnTrack = shimOnTrack;\nexports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;\nexports.shimGetStats = shimGetStats;\nexports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;\nexports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;\nexports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;\nexports.shimPeerConnection = shimPeerConnection;\nexports.fixNegotiationNeeded = fixNegotiationNeeded;\n\nvar _utils = require('../utils.js');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nfunction shimOnTrack(window) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get: function get() {\n        return this._ontrack;\n      },\n      set: function set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n\n      enumerable: true,\n      configurable: true\n    });\n    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      var _this = this;\n\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = function (e) {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', function (te) {\n            var receiver = void 0;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = _this.getReceivers().find(function (r) {\n                return r.track && r.track.id === te.track.id;\n              });\n            } else {\n              receiver = { track: te.track };\n            }\n\n            var event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = { receiver: receiver };\n            event.streams = [e.stream];\n            _this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(function (track) {\n            var receiver = void 0;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = _this.getReceivers().find(function (r) {\n                return r.track && r.track.id === track.id;\n              });\n            } else {\n              receiver = { track: track };\n            }\n            var event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = { receiver: receiver };\n            event.streams = [e.stream];\n            _this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', function (e) {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });\n      }\n      return e;\n    });\n  }\n}\n\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {\n      return {\n        track: track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        var sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n\n      var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        var idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      var _this2 = this;\n\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(function (track) {\n        _this2._senders.push(shimSenderWithDtmf(_this2, track));\n      });\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      var _this3 = this;\n\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n\n      stream.getTracks().forEach(function (track) {\n        var sender = _this3._senders.find(function (s) {\n          return s.track === track;\n        });\n        if (sender) {\n          // remove sender\n          _this3._senders.splice(_this3._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      var _this4 = this;\n\n      var senders = origGetSenders.apply(this, []);\n      senders.forEach(function (sender) {\n        return sender._pc = _this4;\n      });\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get: function get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nfunction shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  var origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    var _this5 = this;\n\n    var _arguments = Array.prototype.slice.call(arguments),\n        selector = _arguments[0],\n        onSucc = _arguments[1],\n        onErr = _arguments[2];\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n\n\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    var fixChromeStats_ = function fixChromeStats_(response) {\n      var standardReport = {};\n      var reports = response.result();\n      reports.forEach(function (report) {\n        var standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(function (name) {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    var makeMapStats = function makeMapStats(stats) {\n      return new Map(Object.keys(stats).map(function (key) {\n        return [key, stats[key]];\n      }));\n    };\n\n    if (arguments.length >= 2) {\n      var successCallbackWrapper_ = function successCallbackWrapper_(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    }\n\n    // promise-support\n    return new Promise(function (resolve, reject) {\n      origGetStats.apply(_this5, [function (response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nfunction shimSenderReceiverGetStats(window) {\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        var _this6 = this;\n\n        var senders = origGetSenders.apply(this, []);\n        senders.forEach(function (sender) {\n          return sender._pc = _this6;\n        });\n        return senders;\n      };\n    }\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        var sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      var sender = this;\n      return this._pc.getStats().then(function (result) {\n        return (\n          /* Note: this will include stats of all senders that\n           *   send a track with the same id as sender.track as\n           *   it is not possible to identify the RTCRtpSender.\n           */\n          utils.filterStats(result, sender.track, true)\n        );\n      });\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        var _this7 = this;\n\n        var receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(function (receiver) {\n          return receiver._pc = _this7;\n        });\n        return receivers;\n      };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', function (e) {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      var receiver = this;\n      return this._pc.getStats().then(function (result) {\n        return utils.filterStats(result, receiver.track, false);\n      });\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  var origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      var track = arguments[0];\n      var sender = void 0;\n      var receiver = void 0;\n      var err = void 0;\n      this.getSenders().forEach(function (s) {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(function (r) {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    var _this8 = this;\n\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(function (streamId) {\n      return _this8._shimmedLocalStreams[streamId][0];\n    });\n  };\n\n  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    var sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n\n  var origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    var _this9 = this;\n\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(function (track) {\n      var alreadyExists = _this9.getSenders().find(function (s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    var existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    var newSenders = this.getSenders().filter(function (newSender) {\n      return existingSenders.indexOf(newSender) === -1;\n    });\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n\n  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    var _this10 = this;\n\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {\n        var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          _this10._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (_this10._shimmedLocalStreams[streamId].length === 1) {\n          delete _this10._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\n\nfunction shimAddTrackRemoveTrack(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var browserDetails = utils.detectBrowser(window);\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    var _this11 = this;\n\n    var nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(function (stream) {\n      return _this11._reverseStreams[stream.id];\n    });\n  };\n\n  var origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    var _this12 = this;\n\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(function (track) {\n      var alreadyExists = _this12.getSenders().find(function (s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      var newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    var _this13 = this;\n\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    var streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {\n      return t === track;\n    })) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n\n    var alreadyExists = this.getSenders().find(function (s) {\n      return s.track === track;\n    });\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    var oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(function () {\n        _this13.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      var newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(function (s) {\n      return s.track === track;\n    });\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    var sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {\n      var externalStream = pc._reverseStreams[internalId];\n      var internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp: sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    var sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {\n      var externalStream = pc._reverseStreams[internalId];\n      var internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp: sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    var nativeMethod = window.RTCPeerConnection.prototype[method];\n    var methodObj = _defineProperty({}, method, function () {\n      var _this14 = this;\n\n      var args = arguments;\n      var isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [function (description) {\n          var desc = replaceInternalStreamId(_this14, description);\n          args[0].apply(null, [desc]);\n        }, function (err) {\n          if (args[1]) {\n            args[1].apply(null, err);\n          }\n        }, arguments[2]]);\n      }\n      return nativeMethod.apply(this, arguments).then(function (description) {\n        return replaceInternalStreamId(_this14, description);\n      });\n    });\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get: function get() {\n      var description = origLocalDescription.get.apply(this);\n      if (description.type === '') {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    var _this15 = this;\n\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    var isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    var stream = void 0;\n    Object.keys(this._streams).forEach(function (streamid) {\n      var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {\n        return sender.track === track;\n      });\n      if (hasTrack) {\n        stream = _this15._streams[streamid];\n      }\n    });\n\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\n\nfunction shimPeerConnection(window) {\n  var browserDetails = utils.detectBrowser(window);\n\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  var addIceCandidateNullSupported = window.RTCPeerConnection.prototype.addIceCandidate.length === 0;\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      var methodObj = _defineProperty({}, method, function () {\n        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n        return nativeMethod.apply(this, arguments);\n      });\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n\n  // support for addIceCandidate(null or undefined)\n  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!addIceCandidateNullSupported && !arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n    // in older versions. Native support planned for Chrome M77.\n    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\n\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window) {\n  var browserDetails = utils.detectBrowser(window);\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {\n    var pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n\n},{\"../utils.js\":106,\"./getdisplaymedia\":95,\"./getusermedia\":96}],95:[function(require,module,exports){\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetDisplayMedia = shimGetDisplayMedia;\nfunction shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    return getSourceId(constraints).then(function (sourceId) {\n      var widthSpecified = constraints.video && constraints.video.width;\n      var heightSpecified = constraints.video && constraints.video.height;\n      var frameRateSpecified = constraints.video && constraints.video.frameRate;\n      constraints.video = {\n        mandatory: {\n          chromeMediaSource: 'desktop',\n          chromeMediaSourceId: sourceId,\n          maxFrameRate: frameRateSpecified || 3\n        }\n      };\n      if (widthSpecified) {\n        constraints.video.mandatory.maxWidth = widthSpecified;\n      }\n      if (heightSpecified) {\n        constraints.video.mandatory.maxHeight = heightSpecified;\n      }\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    });\n  };\n}\n\n},{}],96:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.shimGetUserMedia = shimGetUserMedia;\n\nvar _utils = require('../utils.js');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar logging = utils.log;\n\nfunction shimGetUserMedia(window) {\n  var navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  var browserDetails = utils.detectBrowser(window);\n\n  var constraintsToChrome_ = function constraintsToChrome_(c) {\n    if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    var cc = {};\n    Object.keys(c).forEach(function (key) {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      var oldname_ = function oldname_(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === 'deviceId' ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        var oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(function (mix) {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  var shimConstraints_ = function shimConstraints_(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && _typeof(constraints.audio) === 'object') {\n      var remap = function remap(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && _typeof(constraints.video) === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      var face = constraints.video.facingMode;\n      face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });\n      var getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        var matches = void 0;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices().then(function (devices) {\n            devices = devices.filter(function (d) {\n              return d.kind === 'videoinput';\n            });\n            var dev = devices.find(function (d) {\n              return matches.some(function (match) {\n                return d.label.toLowerCase().includes(match);\n              });\n            });\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  var shimError_ = function shimError_(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString: function toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, function (c) {\n      navigator.webkitGetUserMedia(c, onSuccess, function (e) {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (cs) {\n      return shimConstraints_(cs, function (c) {\n        return origGetUserMedia(c).then(function (stream) {\n          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n            stream.getTracks().forEach(function (track) {\n              track.stop();\n            });\n            throw new DOMException('', 'NotFoundError');\n          }\n          return stream;\n        }, function (e) {\n          return Promise.reject(shimError_(e));\n        });\n      });\n    };\n  }\n}\n\n},{\"../utils.js\":106}],97:[function(require,module,exports){\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.shimRTCIceCandidate = shimRTCIceCandidate;\nexports.shimMaxMessageSize = shimMaxMessageSize;\nexports.shimSendThrowTypeError = shimSendThrowTypeError;\nexports.shimConnectionState = shimConnectionState;\nexports.removeAllowExtmapMixed = removeAllowExtmapMixed;\n\nvar _sdp = require('sdp');\n\nvar _sdp2 = _interopRequireDefault(_sdp);\n\nvar _utils = require('./utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n\n  var NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substr(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      var nativeCandidate = new NativeRTCIceCandidate(args);\n      var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);\n      var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);\n\n      // Add a serializer that does not serialize the extra attributes.\n      augmentedCandidate.toJSON = function toJSON() {\n        return {\n          candidate: augmentedCandidate.candidate,\n          sdpMid: augmentedCandidate.sdpMid,\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n          usernameFragment: augmentedCandidate.usernameFragment\n        };\n      };\n      return augmentedCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\n\nfunction shimMaxMessageSize(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var browserDetails = utils.detectBrowser(window);\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get: function get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n\n  var sctpInDescription = function sctpInDescription(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    var sections = _sdp2.default.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(function (mediaSection) {\n      var mLine = _sdp2.default.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    var version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n\n  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    var canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n\n  var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    var maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substr(19), 10);\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n\n  var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null;\n    // Chrome decided to not expose .sctp in plan-b mode.\n    // As usual, adapter.js has to do an 'ugly worakaround'\n    // to cover up the mess.\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n      var _getConfiguration = this.getConfiguration(),\n          sdpSemantics = _getConfiguration.sdpSemantics;\n\n      if (sdpSemantics === 'plan-b') {\n        Object.defineProperty(this, 'sctp', {\n          get: function get() {\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\n          },\n\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    if (sctpInDescription(arguments[0])) {\n      // Check if the remote is FF.\n      var isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n      // Get the maximum message size the local peer is capable of sending\n      var canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n      // Get the maximum message size of the remote peer.\n      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n      // Determine final maximum message size\n      var maxMessageSize = void 0;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n      // attribute.\n      var sctp = {};\n      Object.defineProperty(sctp, 'maxMessageSize', {\n        get: function get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\n\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    var origDataChannelSend = dc.send;\n    dc.send = function send() {\n      var data = arguments[0];\n      var length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    var dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  var proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get: function get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get: function get() {\n      return this._onconnectionstatechange || null;\n    },\n    set: function set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n\n  ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {\n    var origMethod = proto[method];\n    proto[method] = function () {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = function (e) {\n          var pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            var newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\n\nfunction removeAllowExtmapMixed(window) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var browserDetails = utils.detectBrowser(window);\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n    return;\n  }\n  var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      desc.sdp = desc.sdp.split('\\n').filter(function (line) {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\n\n},{\"./utils\":106,\"sdp\":75}],98:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;\n\nvar _getusermedia = require('./getusermedia');\n\nObject.defineProperty(exports, 'shimGetUserMedia', {\n  enumerable: true,\n  get: function get() {\n    return _getusermedia.shimGetUserMedia;\n  }\n});\n\nvar _getdisplaymedia = require('./getdisplaymedia');\n\nObject.defineProperty(exports, 'shimGetDisplayMedia', {\n  enumerable: true,\n  get: function get() {\n    return _getdisplaymedia.shimGetDisplayMedia;\n  }\n});\nexports.shimPeerConnection = shimPeerConnection;\nexports.shimReplaceTrack = shimReplaceTrack;\n\nvar _utils = require('../utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nvar _filtericeservers = require('./filtericeservers');\n\nvar _rtcpeerconnectionShim = require('rtcpeerconnection-shim');\n\nvar _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction shimPeerConnection(window) {\n  var browserDetails = utils.detectBrowser(window);\n\n  if (window.RTCIceGatherer) {\n    if (!window.RTCIceCandidate) {\n      window.RTCIceCandidate = function RTCIceCandidate(args) {\n        return args;\n      };\n    }\n    if (!window.RTCSessionDescription) {\n      window.RTCSessionDescription = function RTCSessionDescription(args) {\n        return args;\n      };\n    }\n    // this adds an additional event listener to MediaStrackTrack that signals\n    // when a tracks enabled property was changed. Workaround for a bug in\n    // addStream, see below. No longer required in 15025+\n    if (browserDetails.version < 15025) {\n      var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');\n      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n        set: function set(value) {\n          origMSTEnabled.set.call(this, value);\n          var ev = new Event('enabled');\n          ev.enabled = value;\n          this.dispatchEvent(ev);\n        }\n      });\n    }\n  }\n\n  // ORTC defines the DTMF sender a bit different.\n  // https://github.com/w3c/ortc/issues/714\n  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get: function get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = new window.RTCDtmfSender(this);\n          } else if (this.track.kind === 'video') {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n  // Edge currently only implements the RTCDtmfSender, not the\n  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n  if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n    window.RTCDTMFSender = window.RTCDtmfSender;\n  }\n\n  var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);\n  window.RTCPeerConnection = function RTCPeerConnection(config) {\n    if (config && config.iceServers) {\n      config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);\n      utils.log('ICE servers after filtering:', config.iceServers);\n    }\n    return new RTCPeerConnectionShim(config);\n  };\n  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n}\n\nfunction shimReplaceTrack(window) {\n  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {\n    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;\n  }\n}\n\n},{\"../utils\":106,\"./filtericeservers\":99,\"./getdisplaymedia\":100,\"./getusermedia\":101,\"rtcpeerconnection-shim\":70}],99:[function(require,module,exports){\n/*\n *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filterIceServers = filterIceServers;\n\nvar _utils = require('../utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function (server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function (url) {\n        // filter STUN unconditionally.\n        if (url.indexOf('stun:') === 0) {\n          return false;\n        }\n\n        var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');\n        if (validTurn && !hasTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return validTurn && !hasTurn;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n},{\"../utils\":106}],100:[function(require,module,exports){\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetDisplayMedia = shimGetDisplayMedia;\nfunction shimGetDisplayMedia(window) {\n  if (!('getDisplayMedia' in window.navigator)) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);\n}\n\n},{}],101:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetUserMedia = shimGetUserMedia;\nfunction shimGetUserMedia(window) {\n  var navigator = window && window.navigator;\n\n  var shimError_ = function shimError_(e) {\n    return {\n      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString: function toString() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function (c) {\n    return origGetUserMedia(c).catch(function (e) {\n      return Promise.reject(shimError_(e));\n    });\n  };\n}\n\n},{}],102:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _getusermedia = require('./getusermedia');\n\nObject.defineProperty(exports, 'shimGetUserMedia', {\n  enumerable: true,\n  get: function get() {\n    return _getusermedia.shimGetUserMedia;\n  }\n});\n\nvar _getdisplaymedia = require('./getdisplaymedia');\n\nObject.defineProperty(exports, 'shimGetDisplayMedia', {\n  enumerable: true,\n  get: function get() {\n    return _getdisplaymedia.shimGetDisplayMedia;\n  }\n});\nexports.shimOnTrack = shimOnTrack;\nexports.shimPeerConnection = shimPeerConnection;\nexports.shimSenderGetStats = shimSenderGetStats;\nexports.shimReceiverGetStats = shimReceiverGetStats;\nexports.shimRemoveStream = shimRemoveStream;\nexports.shimRTCDataChannel = shimRTCDataChannel;\nexports.shimAddTransceiver = shimAddTransceiver;\nexports.shimGetParameters = shimGetParameters;\nexports.shimCreateOffer = shimCreateOffer;\nexports.shimCreateAnswer = shimCreateAnswer;\n\nvar _utils = require('../utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction shimOnTrack(window) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get: function get() {\n        return { receiver: this.receiver };\n      }\n    });\n  }\n}\n\nfunction shimPeerConnection(window) {\n  var browserDetails = utils.detectBrowser(window);\n\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      var methodObj = _defineProperty({}, method, function () {\n        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n        return nativeMethod.apply(this, arguments);\n      });\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n\n  // support for addIceCandidate(null or undefined)\n  // as well as ignoring {sdpMid, candidate: \"\"}\n  if (browserDetails.version < 68) {\n    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions.\n      if (arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  }\n\n  var modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n\n  var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    var _arguments = Array.prototype.slice.call(arguments),\n        selector = _arguments[0],\n        onSucc = _arguments[1],\n        onErr = _arguments[2];\n\n    return nativeGetStats.apply(this, [selector || null]).then(function (stats) {\n      if (browserDetails.version < 53 && !onSucc) {\n        // Shim only promise getStats with spec-hyphens in type names\n        // Leave callback version alone; misc old uses of forEach before Map\n        try {\n          stats.forEach(function (stat) {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== 'TypeError') {\n            throw e;\n          }\n          // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n          stats.forEach(function (stat, i) {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\n\nfunction shimSenderGetStats(window) {\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      var _this = this;\n\n      var senders = origGetSenders.apply(this, []);\n      senders.forEach(function (sender) {\n        return sender._pc = _this;\n      });\n      return senders;\n    };\n  }\n\n  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      var sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n  };\n}\n\nfunction shimReceiverGetStats(window) {\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      var _this2 = this;\n\n      var receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(function (receiver) {\n        return receiver._pc = _this2;\n      });\n      return receivers;\n    };\n  }\n  utils.wrapPeerConnectionEvent(window, 'track', function (e) {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\n\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    var _this3 = this;\n\n    utils.deprecated('removeStream', 'removeTrack');\n    this.getSenders().forEach(function (sender) {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        _this3.removeTrack(sender);\n      }\n    });\n  };\n}\n\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\n\nfunction shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      var initParameters = arguments[1];\n      var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;\n      if (shouldPerformCheck) {\n        // If sendEncodings params are provided, validate grammar\n        initParameters.sendEncodings.forEach(function (encodingParam) {\n          if ('rid' in encodingParam) {\n            var ridRegex = /^[a-z0-9]{0,16}$/i;\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError('Invalid RID value provided.');\n            }\n          }\n          if ('scaleResolutionDownBy' in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\n            }\n          }\n          if ('maxFramerate' in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError('max_framerate must be >= 0.0');\n            }\n          }\n        });\n      }\n      var transceiver = origAddTransceiver.apply(this, arguments);\n      if (shouldPerformCheck) {\n        // Check if the init options were applied. If not we do this in an\n        // asynchronous way and save the promise reference in a global object.\n        // This is an ugly hack, but at the same time is way more robust than\n        // checking the sender parameters before and after the createOffer\n        // Also note that after the createoffer we are not 100% sure that\n        // the params were asynchronously applied so we might miss the\n        // opportunity to recreate offer.\n        var sender = transceiver.sender;\n\n        var params = sender.getParameters();\n        if (!('encodings' in params) ||\n        // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = initParameters.sendEncodings;\n          sender.sendEncodings = initParameters.sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(function () {\n            delete sender.sendEncodings;\n          }).catch(function () {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n      return transceiver;\n    };\n  }\n}\n\nfunction shimGetParameters(window) {\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  var origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\n      var params = origGetParameters.apply(this, arguments);\n      if (!('encodings' in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n      return params;\n    };\n  }\n}\n\nfunction shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    var _this4 = this,\n        _arguments2 = arguments;\n\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(function () {\n        return origCreateOffer.apply(_this4, _arguments2);\n      }).finally(function () {\n        _this4.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\n\nfunction shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    var _this5 = this,\n        _arguments3 = arguments;\n\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(function () {\n        return origCreateAnswer.apply(_this5, _arguments3);\n      }).finally(function () {\n        _this5.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n\n},{\"../utils\":106,\"./getdisplaymedia\":103,\"./getusermedia\":104}],103:[function(require,module,exports){\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shimGetDisplayMedia = shimGetDisplayMedia;\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n      err.name = 'NotFoundError';\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = { mediaSource: preferredMediaSource };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\n\n},{}],104:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.shimGetUserMedia = shimGetUserMedia;\n\nvar _utils = require('../utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction shimGetUserMedia(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n  var MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    var remap = function remap(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (c) {\n      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function () {\n        var obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\n        if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n\n},{\"../utils\":106}],105:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.shimLocalStreamsAPI = shimLocalStreamsAPI;\nexports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;\nexports.shimCallbacksAPI = shimCallbacksAPI;\nexports.shimGetUserMedia = shimGetUserMedia;\nexports.shimConstraints = shimConstraints;\nexports.shimRTCIceServerUrls = shimRTCIceServerUrls;\nexports.shimTrackEventTransceiver = shimTrackEventTransceiver;\nexports.shimCreateOfferLegacy = shimCreateOfferLegacy;\nexports.shimAudioContext = shimAudioContext;\n\nvar _utils = require('../utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction shimLocalStreamsAPI(window) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      var _this = this;\n\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(function (track) {\n        return _addTrack.call(_this, track, stream);\n      });\n      stream.getVideoTracks().forEach(function (track) {\n        return _addTrack.call(_this, track, stream);\n      });\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      var _this2 = this;\n\n      for (var _len = arguments.length, streams = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n\n      if (streams) {\n        streams.forEach(function (stream) {\n          if (!_this2._localStreams) {\n            _this2._localStreams = [stream];\n          } else if (!_this2._localStreams.includes(stream)) {\n            _this2._localStreams.push(stream);\n          }\n        });\n      }\n      return _addTrack.apply(this, arguments);\n    };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      var _this3 = this;\n\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      var index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      var tracks = stream.getTracks();\n      this.getSenders().forEach(function (sender) {\n        if (tracks.includes(sender.track)) {\n          _this3.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\n\nfunction shimRemoteStreamsAPI(window) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get: function get() {\n        return this._onaddstream;\n      },\n      set: function set(f) {\n        var _this4 = this;\n\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\n          e.streams.forEach(function (stream) {\n            if (!_this4._remoteStreams) {\n              _this4._remoteStreams = [];\n            }\n            if (_this4._remoteStreams.includes(stream)) {\n              return;\n            }\n            _this4._remoteStreams.push(stream);\n            var event = new Event('addstream');\n            event.stream = stream;\n            _this4.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      var pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\n          e.streams.forEach(function (stream) {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            var event = new Event('addstream');\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\n\nfunction shimCallbacksAPI(window) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  var prototype = window.RTCPeerConnection.prototype;\n  var origCreateOffer = prototype.createOffer;\n  var origCreateAnswer = prototype.createAnswer;\n  var setLocalDescription = prototype.setLocalDescription;\n  var setRemoteDescription = prototype.setRemoteDescription;\n  var addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    var options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    var promise = origCreateOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    var options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    var promise = origCreateAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  var withCallback = function withCallback(description, successCallback, failureCallback) {\n    var promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function withCallback(description, successCallback, failureCallback) {\n    var promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function withCallback(candidate, successCallback, failureCallback) {\n    var promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\n\nfunction shimGetUserMedia(window) {\n  var navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    var mediaDevices = navigator.mediaDevices;\n    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (constraints) {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator);\n  }\n}\n\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });\n  }\n\n  return constraints;\n}\n\nfunction shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  var OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      var newIceServers = [];\n      for (var i = 0; i < pcConfig.iceServers.length; i++) {\n        var server = pcConfig.iceServers[i];\n        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {\n          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get: function get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\n\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get: function get() {\n        return { receiver: this.receiver };\n      }\n    });\n  }\n}\n\nfunction shimCreateOfferLegacy(window) {\n  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      var audioTransceiver = this.getTransceivers().find(function (transceiver) {\n        return transceiver.receiver.track.kind === 'audio';\n      });\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === 'sendrecv') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('sendonly');\n          } else {\n            audioTransceiver.direction = 'sendonly';\n          }\n        } else if (audioTransceiver.direction === 'recvonly') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('inactive');\n          } else {\n            audioTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver('audio');\n      }\n\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      var videoTransceiver = this.getTransceivers().find(function (transceiver) {\n        return transceiver.receiver.track.kind === 'video';\n      });\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === 'sendrecv') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('sendonly');\n          } else {\n            videoTransceiver.direction = 'sendonly';\n          }\n        } else if (videoTransceiver.direction === 'recvonly') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('inactive');\n          } else {\n            videoTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver('video');\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\n\nfunction shimAudioContext(window) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}\n\n},{\"../utils\":106}],106:[function(require,module,exports){\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.extractVersion = extractVersion;\nexports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;\nexports.disableLog = disableLog;\nexports.disableWarnings = disableWarnings;\nexports.log = log;\nexports.deprecated = deprecated;\nexports.detectBrowser = detectBrowser;\nexports.compactObject = compactObject;\nexports.walkStats = walkStats;\nexports.filterStats = filterStats;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  var match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var proto = window.RTCPeerConnection.prototype;\n  var nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    var wrappedCallback = function wrappedCallback(e) {\n      var modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n\n  var nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    var unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get: function get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set: function set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\n\nfunction log() {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  // Returned result object.\n  var result = { browser: null, version: null };\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  var navigator = window.navigator;\n\n\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n    // Edge.\n    result.browser = 'edge';\n    result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function (accumulator, key) {\n    var isObj = isObject(data[key]);\n    var value = isObj ? compactObject(data[key]) : data[key];\n    var isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, _defineProperty({}, key, value));\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(function (name) {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(function (id) {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  var filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  var trackStats = [];\n  result.forEach(function (value) {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(function (trackStat) {\n    result.forEach(function (stats) {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n},{}],107:[function(require,module,exports){\n/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nmodule.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);\n\n},{}]},{},[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,26,25,27,28,30,29,31])\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJfY29tcGlsZWQvYXBwbGljYXRpb24uanMiLCJsaWJfY29tcGlsZWQvY29udmVyc2F0aW9uLmpzIiwibGliX2NvbXBpbGVkL2V2ZW50cy9pbWFnZV9ldmVudC5qcyIsImxpYl9jb21waWxlZC9ldmVudHMvbWVzc2FnZV9ldmVudC5qcyIsImxpYl9jb21waWxlZC9ldmVudHMvbnhtRXZlbnQuanMiLCJsaWJfY29tcGlsZWQvZXZlbnRzL3RleHRfZXZlbnQuanMiLCJsaWJfY29tcGlsZWQvaGFuZGxlcnMvYXBwbGljYXRpb25fZXZlbnRzLmpzIiwibGliX2NvbXBpbGVkL2hhbmRsZXJzL2NvbnZlcnNhdGlvbl9ldmVudHMuanMiLCJsaWJfY29tcGlsZWQvaGFuZGxlcnMvZXZlbnRzX3F1ZXVlLmpzIiwibGliX2NvbXBpbGVkL2hhbmRsZXJzL3J0Y19ldmVudHMuanMiLCJsaWJfY29tcGlsZWQvaGFuZGxlcnMvc2lwX2V2ZW50cy5qcyIsImxpYl9jb21waWxlZC9pbmRleC5qcyIsImxpYl9jb21waWxlZC9tZW1iZXIuanMiLCJsaWJfY29tcGlsZWQvbW9kdWxlcy9lcnJvcnNfZW1pdHRlci5qcyIsImxpYl9jb21waWxlZC9tb2R1bGVzL21lZGlhLmpzIiwibGliX2NvbXBpbGVkL21vZHVsZXMvbnhtQ2FsbC5qcyIsImxpYl9jb21waWxlZC9tb2R1bGVzL3B1YmxpY2lwLmpzIiwibGliX2NvbXBpbGVkL21vZHVsZXMvcnRjX2hlbHBlci5qcyIsImxpYl9jb21waWxlZC9tb2R1bGVzL3J0Y3N0YXRzX2FuYWx5dGljcy5qcyIsImxpYl9jb21waWxlZC9uZXhtb0NsaWVudEVycm9yLmpzIiwibGliX2NvbXBpbGVkL25leG1vQ2xpZW50RXJyb3JUeXBlcy5qcyIsImxpYl9jb21waWxlZC9wYWdlcy9jb252ZXJzYXRpb25zX3BhZ2UuanMiLCJsaWJfY29tcGlsZWQvcGFnZXMvZXZlbnRzX3BhZ2UuanMiLCJsaWJfY29tcGlsZWQvcGFnZXMvbWVtYmVyc19wYWdlLmpzIiwibGliX2NvbXBpbGVkL3BhZ2VzL3BhZ2UuanMiLCJsaWJfY29tcGlsZWQvcGFnZXMvcGFnZV9jb25maWcuanMiLCJsaWJfY29tcGlsZWQvcGFnZXMvdXNlcl9zZXNzaW9uc19wYWdlLmpzIiwibGliX2NvbXBpbGVkL3Nkay5qcyIsImxpYl9jb21waWxlZC91c2VyLmpzIiwibGliX2NvbXBpbGVkL3VzZXJfc2Vzc2lvbi5qcyIsImxpYl9jb21waWxlZC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AYnVnc25hZy9icm93c2VyL2Rpc3QvYnVnc25hZy5qcyIsIm5vZGVfbW9kdWxlcy9AYnVnc25hZy9qcy9icm93c2VyL25vdGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZGV0ZWN0LWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvY29udHJpYi9oYXMtY29ycy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy9jb250cmliL3BhcnNlcXMuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvY29udHJpYi9wYXJzZXVyaS5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy9jb250cmliL3llYXN0LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL2dsb2JhbFRoaXMuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2Nqcy9zb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL3RyYW5zcG9ydHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL3RyYW5zcG9ydHMvd2Vic29ja2V0LWNvbnN0cnVjdG9yLmJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9janMvdHJhbnNwb3J0cy94bWxodHRwcmVxdWVzdC5icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvY2pzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvY29tbW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9jb250cmliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9kZWNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9lbmNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcC1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1pcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2dsZXZlbC1wbHVnaW4tcHJlZml4L2xpYi9sb2dsZXZlbC1wbHVnaW4tcHJlZml4LmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcnRjLXN0YXRzLWFkYXB0ZXIvY2FsY3VsYXRlLW1vcy5qcyIsIm5vZGVfbW9kdWxlcy9ydGMtc3RhdHMtYWRhcHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ydGMtc3RhdHMtYWRhcHRlci9wYXJzZXJzL25ldy1hcGkuanMiLCJub2RlX21vZHVsZXMvcnRjLXN0YXRzLWFkYXB0ZXIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcnRjcGVlcmNvbm5lY3Rpb24tc2hpbS9ydGNwZWVyY29ubmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9ncmFtbWFyLmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanMiLCJub2RlX21vZHVsZXMvc2RwL3NkcC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2Nqcy9jb250cmliL2JhY2tvMi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2Nqcy9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvY2pzL29uLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvY2pzL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2Nqcy91cmwuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2Nqcy9iaW5hcnkuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9idWlsZC9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9idWlsZC9janMvaXMtYmluYXJ5LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvYWRhcHRlcl9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvYWRhcHRlcl9mYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvY2hyb21lL2Nocm9tZV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvY2hyb21lL2dldGRpc3BsYXltZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9kaXN0L2Nocm9tZS9nZXR1c2VybWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvZGlzdC9jb21tb25fc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9kaXN0L2VkZ2UvZWRnZV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvZWRnZS9maWx0ZXJpY2VzZXJ2ZXJzLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvZWRnZS9nZXRkaXNwbGF5bWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvZGlzdC9lZGdlL2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9kaXN0L2ZpcmVmb3gvZmlyZWZveF9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL2Rpc3QvZmlyZWZveC9nZXRkaXNwbGF5bWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvZGlzdC9maXJlZm94L2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9kaXN0L3NhZmFyaS9zYWZhcmlfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3dpbGRlbWl0dGVyL3dpbGRlbWl0dGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNycEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3QyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Y0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoaUdBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2owREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBBcHBsaWNhdGlvbiBPYmplY3QgTW9kZWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiovXG5jb25zdCBXaWxkRW1pdHRlciA9IHJlcXVpcmUoJ3dpbGRlbWl0dGVyJyk7XG5jb25zdCBsb2dsZXZlbF8xID0gcmVxdWlyZShcImxvZ2xldmVsXCIpO1xuY29uc3QgbmV4bW9DbGllbnRFcnJvcl8xID0gcmVxdWlyZShcIi4vbmV4bW9DbGllbnRFcnJvclwiKTtcbmNvbnN0IHVzZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91c2VyXCIpKTtcbmNvbnN0IGNvbnZlcnNhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnNhdGlvblwiKSk7XG5jb25zdCBueG1DYWxsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbW9kdWxlcy9ueG1DYWxsXCIpKTtcbmNvbnN0IHNpcF9ldmVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9oYW5kbGVycy9zaXBfZXZlbnRzXCIpKTtcbmNvbnN0IHJ0Y19ldmVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9oYW5kbGVycy9ydGNfZXZlbnRzXCIpKTtcbmNvbnN0IGFwcGxpY2F0aW9uX2V2ZW50c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2hhbmRsZXJzL2FwcGxpY2F0aW9uX2V2ZW50c1wiKSk7XG5jb25zdCB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IHBhZ2VfY29uZmlnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFnZXMvcGFnZV9jb25maWdcIikpO1xuY29uc3QgY29udmVyc2F0aW9uc19wYWdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFnZXMvY29udmVyc2F0aW9uc19wYWdlXCIpKTtcbmNvbnN0IHVzZXJfc2Vzc2lvbnNfcGFnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2VzL3VzZXJfc2Vzc2lvbnNfcGFnZVwiKSk7XG5jb25zdCBldmVudHNfcXVldWVfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL2V2ZW50c19xdWV1ZVwiKTtcbmNvbnN0IG1lbWJlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21lbWJlclwiKSk7XG5sZXQgc2lwRXZlbnRIYW5kbGVyID0gbnVsbDtcbmxldCBydGNFdmVudEhhbmRsZXIgPSBudWxsO1xubGV0IGFwcGxpY2F0aW9uRXZlbnRzSGFuZGxlciA9IG51bGw7XG4vKipcbiAqIENvcmUgYXBwbGljYXRpb24gY2xhc3MgZm9yIHRoZSBTREsuXG4gKiBBcHBsaWNhdGlvbiBpcyB0aGUgcGFyZW50IG9iamVjdCBob2xkaW5nIHRoZSBsaXN0IG9mIGNvbnZlcnNhdGlvbnMsIHRoZSBzZXNzaW9uIG9iamVjdC5cbiAqIFByb3ZpZGVzIG1ldGhvZHMgdG8gY3JlYXRlIGNvbnZlcnNhdGlvbnMgYW5kIHJldHJpZXZlIGEgbGlzdCBvZiB0aGUgdXNlcidzIGNvbnZlcnNhdGlvbnMsIHdoaWxlIGl0IGhvbGRzIHRoZSBsaXN0ZW5lcnMgZm9yXG4gKiB1c2VyJ3MgaW52aXRhdGlvbnNcbiAqIEBjbGFzcyBBcHBsaWNhdGlvblxuICogQHBhcmFtIHtOZXhtb0NsaWVudH0gU0RLIHNlc3Npb24gT2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BY2Nlc3NpbmcgdGhlIGxpc3Qgb2YgY29udmVyc2F0aW9uczwvY2FwdGlvbj5cbiAqICBydGMuY3JlYXRlU2Vzc2lvbih0b2tlbikudGhlbigoYXBwbGljYXRpb24pID0+IHtcbiAqICAgIGNvbnNvbGUubG9nKGFwcGxpY2F0aW9uLmNvbnZlcnNhdGlvbnMpO1xuICogICAgY29uc29sZS5sb2coYXBwbGljYXRpb24ubWUubmFtZSwgYXBwbGljYXRpb24ubWUuaWQpO1xuICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gKiAgfSk7XG4gKiBAZW1pdHMgQXBwbGljYXRpb24jbWVtYmVyOmludml0ZWRcbiAqIEBlbWl0cyBBcHBsaWNhdGlvbiNtZW1iZXI6am9pbmVkXG4gKiBAZW1pdHMgQXBwbGljYXRpb24jTlhNLWVycm9yc1xuICogQGVtaXRzIEFwcGxpY2F0aW9uI3J0Y3N0YXRzOmFuYWx5dGljc1xuKi9cbmNsYXNzIEFwcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dsZXZlbF8xLmdldExvZ2dlcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3luY2VkX2NvbnZlcnNhdGlvbnNfY291bnQgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0X3N5bmNfdGltZSA9IDA7XG4gICAgICAgIHRoaXMuc3RvcF9zeW5jX3RpbWUgPSAwO1xuICAgICAgICAvLyBjb252ZXJzYXRpb25faWQsIG54bUNhbGxcbiAgICAgICAgdGhpcy5jYWxscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8ga25vY2tpbmdfaWQsIG54bUNhbGxcbiAgICAgICAgdGhpcy5fY2FsbF9kcmFmdF9saXN0ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhZ2VDb25maWcgPSBuZXcgcGFnZV9jb25maWdfMS5kZWZhdWx0KChzZXNzaW9uLmNvbmZpZyB8fCB7fSkuY29udmVyc2F0aW9uc19wYWdlX2NvbmZpZyk7XG4gICAgICAgIHRoaXMuY29udmVyc2F0aW9uc19wYWdlX2xhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgc2lwRXZlbnRIYW5kbGVyID0gbmV3IHNpcF9ldmVudHNfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICBydGNFdmVudEhhbmRsZXIgPSBuZXcgcnRjX2V2ZW50c18xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIGFwcGxpY2F0aW9uRXZlbnRzSGFuZGxlciA9IG5ldyBhcHBsaWNhdGlvbl9ldmVudHNfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB0aGlzLm1lID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbXMpO1xuICAgICAgICBXaWxkRW1pdHRlci5taXhpbihBcHBsaWNhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBDb252ZXJzYXRpb24gaW5zdGFuY2Ugb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIFByZS1jcmVhdGVkIGNvbnZlcnNhdGlvbiBleGlzdCBmcm9tIGdldENvbnZlcnNhdGlvbnNcbiAgICAgKiBsaWtlIGluaXRpYWxpc2VkIHRlbXBsYXRlcy4gV2hlbiB3ZSBleHBsaWNpdGx5IGFzayB0b1xuICAgICAqIGdldENvbnZlcnNhdGlvbigpLCB3ZSByZWNlaXZlIG1lbWJlcnMgYW5kIG90aGVyIGRldGFpbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkIENvbnZlcnNhdGlvbiBwYXlsb2FkXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHVwZGF0ZU9yQ3JlYXRlQ29udmVyc2F0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5jb252ZXJzYXRpb25zLmdldChwYXlsb2FkLmlkKTtcbiAgICAgICAgaWYgKGNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgY29udmVyc2F0aW9uLl91cGRhdGVPYmplY3RJbnN0YW5jZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuY29udmVyc2F0aW9ucy5zZXQocGF5bG9hZC5pZCwgY29udmVyc2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVyc2F0aW9ucy5zZXQocGF5bG9hZC5pZCwgbmV3IGNvbnZlcnNhdGlvbl8xLmRlZmF1bHQodGhpcywgcGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnNhdGlvbnMuZ2V0KHBheWxvYWQuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWNhdGlvbiBsaXN0ZW5pbmcgZm9yIG1lbWJlciBpbnZpdGVkIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBldmVudCBBcHBsaWNhdGlvbiNtZW1iZXI6aW52aXRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIFRoZSBpbnZpdGVkIG1lbWJlclxuICAgICAqIEBwcm9wZXJ0eSB7TlhNRXZlbnR9IGV2ZW50IC0gVGhlIGludml0YXRpb24gZXZlbnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmxpc3RlbiBmb3IgbWVtYmVyIGludml0ZWQgZXZlbnRzIG9uIEFwcGxpY2F0aW9uIGxldmVsPC9jYXB0aW9uPlxuICAgICAqICBhcHBsaWNhdGlvbi5vbihcIm1lbWJlcjppbnZpdGVkXCIsKG1lbWJlciwgZXZlbnQpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIkludml0ZWQgdG8gdGhlIGNvbnZlcnNhdGlvbjogXCIgKyBldmVudC5jb252ZXJzYXRpb24uZGlzcGxheV9uYW1lIHx8IGV2ZW50LmNvbnZlcnNhdGlvbi5uYW1lKTtcbiAgICAgKiAgICAvLyBpZGVudGlmeSB0aGUgc2VuZGVyLlxuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSW52aXRlZCBieTogXCIgKyBtZW1iZXIuaW52aXRlZF9ieSk7XG4gICAgICogICAgLy9hY2NlcHQgYW4gaW52aXRhdGlvbi5cbiAgICAgKiAgICBhcHBsaWNhdGlvbi5jb252ZXJzYXRpb25zLmdldChldmVudC5jb252ZXJzYXRpb24uaWQpLmpvaW4oKTtcbiAgICAgKiAgICAvL2RlY2xpbmUgdGhlIGludml0YXRpb24uXG4gICAgICogICAgIGFwcGxpY2F0aW9uLmNvbnZlcnNhdGlvbnMuZ2V0KGV2ZW50LmNvbnZlcnNhdGlvbi5pZCkubGVhdmUoKTtcbiAgICAgKiAgfSk7XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBBcHBsaWNhdGlvbiBsaXN0ZW5pbmcgZm9yIG1lbWJlciBqb2luZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQGV2ZW50IEFwcGxpY2F0aW9uI21lbWJlcjpqb2luZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TWVtYmVyfSBtZW1iZXIgLSB0aGUgbWVtYmVyIHRoYXQgam9pbmVkIHRoZSBjb252ZXJzYXRpb25cbiAgICAgKiBAcHJvcGVydHkge05YTUV2ZW50fSBldmVudCAtIHRoZSBqb2luIGV2ZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIG1lbWJlciBqb2luZWQgZXZlbnRzIG9uIEFwcGxpY2F0aW9uIGxldmVsPC9jYXB0aW9uPlxuICAgICAqICBhcHBsaWNhdGlvbi5vbihcIm1lbWJlcjpqb2luZWRcIiwobWVtYmVyLCBldmVudCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSk9JTkVEXCIsIFwiSm9pbmVkIGNvbnZlcnNhdGlvbjogXCIgKyBldmVudC5jb252ZXJzYXRpb24uZGlzcGxheV9uYW1lIHx8IGV2ZW50LmNvbnZlcnNhdGlvbi5uYW1lKTtcbiAgICAgKiAgfSk7XG4gICovXG4gICAgLyoqXG4gICAgICAgKiBFbnRyeSBwb2ludCBmb3IgcXVlaW5nIGV2ZW50cyBpbiBBcHBsaWNhdGlvbiBsZXZlbFxuICAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIF9lbnF1ZXVlRXZlbnQocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5jb25maWcuZW5hYmxlRXZlbnRzUXVldWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVudHNRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzUXVldWUgPSBuZXcgZXZlbnRzX3F1ZXVlXzEuRXZlbnRzUXVldWUoKGV2ZW50KSA9PiB0aGlzLl9oYW5kbGVFdmVudChldmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudHNRdWV1ZS5lbnF1ZXVlKHJlc3BvbnNlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgZXZlbnRzIGluIEFwcGxpY2F0aW9uIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGNvbnN0IGlzRXZlbnRGcm9tTWUgPSAoKF9hID0gZXZlbnQuX2VtYmVkZGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbV91c2VyKSA/ICgoX2MgPSAoX2IgPSBldmVudC5fZW1iZWRkZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mcm9tX3VzZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pZCkgPT09ICgoX2QgPSB0aGlzLm1lKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaWQpXG4gICAgICAgICAgICA6ICgoX2YgPSAoX2UgPSBldmVudC5ib2R5KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudXNlcikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnVzZXJfaWQpID09PSAoKF9nID0gdGhpcy5tZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmlkKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdXNlciBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGNvbnZlcnNhdGlvbiBhbmQgaWYgaXQgaGFzIGEgbWVtYmVyIG9uIGEgdmFsaWRcbiAgICAgICAgLy8gc3RhdGUgKElOVklURUQsIEpPSU5FRCkgb3RoZXJ3aXNlIHVzZXIgaXMgYmVpbmcgcmUtaW52aXRlZCBhbmQgd2UgbmVlZCB0byBmZXRjaCB0aGVcbiAgICAgICAgLy8gY29udmVyc2F0aW9uIGFuZCBtZW1iZXJzIGluZm8gYWdhaW5cbiAgICAgICAgY29uc3QgaXNVc2VyUmVJbnZpdGVkID0gdXRpbHNfMS5kZWZhdWx0Ll9jaGVja0lmVXNlcklzUmVJbnZpdGVkKHRoaXMuY29udmVyc2F0aW9ucywgZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKCdzaXAnKSkge1xuICAgICAgICAgICAgc2lwRXZlbnRIYW5kbGVyLl9oYW5kbGVTaXBDYWxsRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnZlcnNhdGlvbnMuaGFzKGV2ZW50LmNpZCkgJiYgZXZlbnQudHlwZSAhPT0gXCJydGM6dHJhbnNmZXJcIiAmJiAhaXNVc2VyUmVJbnZpdGVkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKCdydGMnKSkge1xuICAgICAgICAgICAgICAgIHJ0Y0V2ZW50SGFuZGxlci5faGFuZGxlUnRjRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb25zLmdldChldmVudC5jaWQpLl9oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnR5cGUgPT09ICdtZW1iZXI6am9pbmVkJyB8fCBldmVudC50eXBlID09PSAnbWVtYmVyOmludml0ZWQnKSAmJiBpc0V2ZW50RnJvbU1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQXBwbGljYXRpb25FdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBldmVudCBoYXMgY2lkIGdldCB0aGUgY29udmVyc2F0aW9uIHlvdSBkb24ndCBrbm93IGFib3V0IChjYXNlOiBqb2luZWQgYnkgYW5vdGhlciB1c2VyKVxuICAgICAgICAgICAgaWYgKGV2ZW50LmNpZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VzZXJSZUludml0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbnMuZGVsZXRlKGV2ZW50LmNpZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb252ZXJzYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmRlZmF1bHQuX2lzQ2FsbEV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5nZXRDb252ZXJzYXRpb24oZXZlbnQuY2lkLCBBcHBsaWNhdGlvbi5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5nZXRDb252ZXJzYXRpb24oZXZlbnQuY2lkLCBBcHBsaWNhdGlvbi5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVyc2F0aW9ucy5zZXQoZXZlbnQuY2lkLCBjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb252ZXJzYXRpb24uX2hhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlQXBwbGljYXRpb25FdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJydGNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0Y0V2ZW50SGFuZGxlci5faGFuZGxlUnRjRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdXNlcidzIHRva2VuIHRoYXQgd2FzIGdlbmVyYXRlZCB3aGVuIHRoZXkgd2VyZSBmaXJzdCBhdXRoZW50aWNhdGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIHRoZSBuZXcgdG9rZW5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciBleHBpcmVkLXRva2VuIGVycm9yIGV2ZW50cyBhbmQgdGhlbiB1cGRhdGUgdGhlIHRva2VuIG9uIEFwcGxpY2F0aW9uIGxldmVsPC9jYXB0aW9uPlxuICAgKiBhcHBsaWNhdGlvbi5vbignc3lzdGVtOmVycm9yOmV4cGlyZWQtdG9rZW4nLCAnTlhNLWVycm9ycycsIChlcnJvcikgPT4ge1xuICAgKiBcdGNvbnNvbGUubG9nKCd0b2tlbiBleHBpcmVkJyk7XG4gICAqIFx0YXBwbGljYXRpb24udXBkYXRlVG9rZW4odG9rZW4pO1xuICAgKiB9KTtcbiAgKi9cbiAgICBhc3luYyB1cGRhdGVUb2tlbih0b2tlbikge1xuICAgICAgICAvLyBTREsgY2FuIGJlIGRpc2Nvbm5lY3RlZCBiZWNhdXNlIG9mIGV4cGlyZWQgdG9rZW5cbiAgICAgICAgLy8gdGhpcyBsZXRzIHVzIHVwZGF0ZSB0b2tlbiBmb3IgbmV4dCByZWNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmNvbm5lY3Rpb24gJiYgdGhpcy5zZXNzaW9uLmNvbm5lY3Rpb24uZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uY29uZmlnLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uY29ubmVjdGlvbi5pby5vcHRzLnF1ZXJ5LnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxT2JqID0ge1xuICAgICAgICAgICAgdXJsOiBgJHt0aGlzLnNlc3Npb24uY29uZmlnLm5leG1vX2FwaV91cmx9L3YwLjIvc2Vzc2lvbnMvJHt0aGlzLnNlc3Npb24uc2Vzc2lvbl9pZH1gLFxuICAgICAgICAgICAgdHlwZTogJ1BVVCcsXG4gICAgICAgICAgICB0b2tlblxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdXRpbHNfMS5kZWZhdWx0Lm5ldHdvcmtSZXF1ZXN0KHJlcU9iaik7XG4gICAgICAgICAgICBpZiAodGhpcy5tZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5jb25maWcudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uY29ubmVjdGlvbi5pby5vcHRzLnF1ZXJ5LnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyAobmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBldmVudCB0byBtYXAgbG9jYWwgZ2VuZXJhdGVkIGV2ZW50c1xuICAgICAqIGluIGNhc2Ugd2UgbmVlZCBhIG1vcmUgc3BlY2lmaWMgZXZlbnQgdG8gcGFzcyBpbiB0aGUgYXBwbGljYXRpb24gbGlzdGVuZXJcbiAgICAgKiBvciBmL3cgdGhlIGV2ZW50IGFzIGl0IGNvbWVzXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGVBcHBsaWNhdGlvbkV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIl9oYW5kbGVBcHBsaWNhdGlvbkV2ZW50OiBcIiwgeyBldmVudCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZF9ldmVudCA9IGFwcGxpY2F0aW9uRXZlbnRzSGFuZGxlci5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmNvbnZlcnNhdGlvbnMuZ2V0KGV2ZW50LmNpZCk7XG4gICAgICAgICAgICBsZXQgbWVtYmVyO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnNhdGlvbi5tZW1iZXJzLmhhcygocHJvY2Vzc2VkX2V2ZW50IHx8IHt9KS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIG1lbWJlciA9IGNvbnZlcnNhdGlvbi5tZW1iZXJzLmdldChwcm9jZXNzZWRfZXZlbnQuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnbWVtYmVyOmpvaW5lZCcgfHwgZXZlbnQudHlwZSA9PT0gJ21lbWJlcjppbnZpdGVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgLi4uZXZlbnQuYm9keSwgLi4uKGV2ZW50LmZyb20gJiYgeyBtZW1iZXJfaWQ6IGV2ZW50LmZyb20gfSkgfTtcbiAgICAgICAgICAgICAgICBtZW1iZXIgPSBuZXcgbWVtYmVyXzEuZGVmYXVsdChjb252ZXJzYXRpb24sIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSBhd2FpdCBjb252ZXJzYXRpb24uZ2V0TWVtYmVyKHByb2Nlc3NlZF9ldmVudC5mcm9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYFRoZXJlIGlzIGFuIGVycm9yIGdldHRpbmcgdGhlIG1lbWJlciAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChwcm9jZXNzZWRfZXZlbnQudHlwZSwgbWVtYmVyLCBwcm9jZXNzZWRfZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihcIl9oYW5kbGVBcHBsaWNhdGlvbkV2ZW50OiBcIiwgZSk7XG4gICAgICAgICAgICB0aHJvdyAoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhbGwgdG8gc3BlY2lmaWVkIHVzZXIvcy5cbiAgICAgKiBAY2xhc3NkZXNjIGNyZWF0ZXMgYSBjYWxsIGJldHdlZW4gdGhlIGRlZmluZWQgdXNlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2VybmFtZXMgLSB0aGUgdXNlciBuYW1lcyBmb3IgdGhvc2Ugd2Ugd2FudCB0byBjYWxsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TlhNQ2FsbD59IGEgTlhNQ2FsbCBvYmplY3Qgd2l0aCBhbGwgdGhlIGNhbGwgcHJvcGVydGllc1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIGNhbGwgd2l0aCB1c2VyczwvY2FwdGlvbj5cbiAgICAgKiAgYXBwbGljYXRpb24ub24oXCJjYWxsOnN0YXR1czpjaGFuZ2VkXCIsIChueG1DYWxsKSA9PiB7XG4gICAgICogICAgaWYgKG54bUNhbGwuc3RhdHVzID09PSBueG1DYWxsLkNBTExfU1RBVFVTLlNUQVJURUQpIHtcbiAgICAgKlx0XHQgIGNvbnNvbGUubG9nKCd0aGUgY2FsbCBoYXMgc3RhcnRlZCcpO1xuICAgICAqXHRcdH1cbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiAgYXBwbGljYXRpb24uaW5BcHBDYWxsKHVzZXJuYW1lcykudGhlbigoKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coJ0NhbGxpbmcgdXNlcihzKS4uLicpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgKi9cbiAgICBhc3luYyBpbkFwcENhbGwodXNlcm5hbWVzKSB7XG4gICAgICAgIGlmICghdXNlcm5hbWVzIHx8ICFBcnJheS5pc0FycmF5KHVzZXJuYW1lcykgfHwgdXNlcm5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcignZXJyb3I6YXBwbGljYXRpb246Y2FsbDpwYXJhbXMnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG54bUNhbGwgPSBuZXcgbnhtQ2FsbF8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgICAgICBhd2FpdCBueG1DYWxsLmNyZWF0ZUNhbGwodXNlcm5hbWVzKTtcbiAgICAgICAgICAgIG54bUNhbGwuZGlyZWN0aW9uID0gbnhtQ2FsbC5DQUxMX0RJUkVDVElPTi5PVVRCT1VORDtcbiAgICAgICAgICAgIHJldHVybiBueG1DYWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhbGwgdG8gcGhvbmUgYSBudW1iZXIuXG4gICAgICogVGhlIGNhbGwgb2JqZWN0IGlzIGNyZWF0ZWQgdW5kZXIgYXBwbGljYXRpb24uY2FsbHMgd2hlbiB0aGUgY2FsbCBoYXMgc3RhcnRlZC5cbiAgICAgKiBsaXN0ZW4gZm9yIGl0IHdpdGggYXBwbGljYXRpb24ub24oXCJjYWxsOnN0YXR1czpjaGFuZ2VkXCIpXG4gICAgICpcbiAgICAgKiBZb3UgZG9uJ3QgbmVlZCB0byBzdGFydCB0aGUgc3RyZWFtLCB0aGUgU0RLIHdpbGwgcGxheSB0aGUgYXVkaW8gZm9yIHlvdVxuICAgICAqXG4gICAgICogQGNsYXNzZGVzYyBjcmVhdGVzIGEgY2FsbCB0byBhIHBob25lIG51bWJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlciB0aGUgcGhvbmUgbnVtYmVyIG9yIHRoZSB1c2VybmFtZSB5b3Ugd2FudCB0byBjYWxsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1cInBob25lXCJdIHRoZSB0eXBlIG9mIHRoZSBjYWxsIHlvdSB3YW50IHRvIGhhdmUuIHBvc3NpYmxlIHZhbHVlcyBcInBob25lXCIgb3IgXCJhcHBcIiAoZGVmYXVsdCBpcyBcInBob25lXCIpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3VzdG9tX2RhdGFdIGN1c3RvbSBkYXRhIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBjYWxsIG9iamVjdCwgaS5lLiB7IHlvdXJDdXN0b21LZXk6IHlvdXJDdXN0b21WYWx1ZSB9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TlhNQ2FsbD59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGEgY2FsbCB0byBhIHBob25lPC9jYXB0aW9uPlxuICAgICAqICBhcHBsaWNhdGlvbi5vbihcImNhbGw6c3RhdHVzOmNoYW5nZWRcIiwgKG54bUNhbGwpID0+IHtcbiAgICAgKiAgICBpZiAobnhtQ2FsbC5zdGF0dXMgPT09IG54bUNhbGwuQ0FMTF9TVEFUVVMuU1RBUlRFRCkge1xuICAgICAqXHRcdCAgY29uc29sZS5sb2coJ3RoZSBjYWxsIGhhcyBzdGFydGVkJyk7XG4gICAqXHRcdH1cbiAgICogIH0pO1xuICAgKlxuICAgICAqICBhcHBsaWNhdGlvbi5jYWxsU2VydmVyKHBob25lX251bWJlcikudGhlbigobnhtQ2FsbCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKCdDYWxsaW5nIHBob25lICcgKyBwaG9uZV9udW1iZXIpO1xuICAgKiAgICBjb25zb2xlLmxvZygnQ2FsbCBPYmplY3QgJzogbnhtQ2FsbCk7XG4gICAgICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgKiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICogIH0pO1xuICAgICovXG4gICAgYXN5bmMgY2FsbFNlcnZlcih1c2VyLCB0eXBlID0gJ3Bob25lJywgY3VzdG9tX2RhdGEgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbnhtQ2FsbCA9IG5ldyBueG1DYWxsXzEuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgICAgIG54bUNhbGwuZGlyZWN0aW9uID0gbnhtQ2FsbC5DQUxMX0RJUkVDVElPTi5PVVRCT1VORDtcbiAgICAgICAgICAgIGF3YWl0IG54bUNhbGwuY3JlYXRlU2VydmVyQ2FsbCh1c2VyLCB0eXBlLCBjdXN0b21fZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gbnhtQ2FsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogUmVjb25uZWN0IGEgbGVnIHRvIGFuIG9uZ29pbmcgY2FsbC5cbiAgICAgICAqIFlvdSBkb24ndCBuZWVkIHRvIHN0YXJ0IHRoZSBzdHJlYW0sIHRoZSBTREsgd2lsbCBwbGF5IHRoZSBhdWRpbyBmb3IgeW91XG4gICAgICAgKlxuICAgICAgICogQGNsYXNzZGVzYyByZWNvbm5lY3QgbGVnIHRvIGFuIG9uZ29pbmcgY2FsbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb252ZXJzYXRpb25faWQgdGhlIGNvbnZlcnNhdGlvbiB0aGF0IHlvdSB3YW50IHRvIHJlY29ubmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydGNfaWQgdGhlIGlkIG9mIHRoZSBsZWcgdGhhdCB3aWxsIGJlIHJlY29ubmVjdGVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFttZWRpYVBhcmFtc10gLSBNZWRpYVN0cmVhbSBwYXJhbXMgKHNhbWUgYXMgTWVkaWEuZW5hYmxlKCkpXG4gICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOWE1DYWxsPn1cbiAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlJlY29ubmVjdCBhIGxlZyB0byBhbiBvbmdvaW5nIGNhbGw8L2NhcHRpb24+XG4gICAgICAgKiAgYXBwbGljYXRpb24ucmVjb25uZWN0Q2FsbChcImNvbnZlcnNhdGlvbl9pZFwiLCBcInJ0Y19pZFwiKS50aGVuKChueG1DYWxsKSA9PiB7XG4gICAgICAgKiAgICBjb25zb2xlLmxvZyhueG1DYWxsKTtcbiAgICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZWNvbm5lY3QgYSBsZWcgdG8gYW4gb25nb2luZyBjYWxsIHdpdGhvdXQgYXV0byBwbGF5aW5nIGF1ZGlvPC9jYXB0aW9uPlxuICAgICAgICogIGFwcGxpY2F0aW9uLnJlY29ubmVjdENhbGwoXCJjb252ZXJzYXRpb25faWRcIiwgXCJydGNfaWRcIiwgeyBhdXRvUGxheUF1ZGlvOiBmYWxzZSB9KS50aGVuKChueG1DYWxsKSA9PiB7XG4gICAgICAgKiAgICBjb25zb2xlLmxvZyhueG1DYWxsKTtcbiAgICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZWNvbm5lY3QgYSBsZWcgdG8gYW4gb25nb2luZyBjYWxsIGNob29zaW5nIGRldmljZSBJRDwvY2FwdGlvbj5cbiAgICAgICAqICBhcHBsaWNhdGlvbi5yZWNvbm5lY3RDYWxsKFwiY29udmVyc2F0aW9uX2lkXCIsIFwicnRjX2lkXCIsIHsgYXVkaW9Db25zdHJhaW50czogeyBkZXZpY2VJZDogXCJkZXZpY2VfaWRcIiB9IH0pLnRoZW4oKG54bUNhbGwpID0+IHtcbiAgICAgICAqICAgIGNvbnNvbGUubG9nKG54bUNhbGwpO1xuICAgICAgICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAgICovXG4gICAgYXN5bmMgcmVjb25uZWN0Q2FsbChjb252ZXJzYXRpb25JZCwgcnRjSWQsIG1lZGlhUGFyYW1zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY29udmVyc2F0aW9uSWQgfHwgIXJ0Y0lkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKCdlcnJvcjptaXNzaW5nOnBhcmFtcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5nZXRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uSWQsIEFwcGxpY2F0aW9uLkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTi52MSk7XG4gICAgICAgICAgICBhd2FpdCBjb252ZXJzYXRpb24ubWVkaWEuZW5hYmxlKHsgLi4ubWVkaWFQYXJhbXMsIHJlY29ubmVjdFJ0Y0lkOiBydGNJZCB9KTtcbiAgICAgICAgICAgIGNvbnN0IG54bUNhbGwgPSBuZXcgbnhtQ2FsbF8xLmRlZmF1bHQodGhpcywgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgIC8vIGFzc2lnbmluZyB0aGUgY29ycmVjdCBjYWxsIHN0YXR1cyB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBzaXAgc3RhdHVzIChvdXRib3VuZClcbiAgICAgICAgICAgIC8vIG9uIGluYm91bmQgY2FsbHMgdGhlIHJlY29ubmVjdCB3aWxsIGhhcHBlbiBhZnRlciB0aGUgY2FsbCBpcyBlc3RhYmlsaXNoZWQgYW5kIGJvdGggbGVncyBhcmUgYW5zd2VyZWRcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50X3R5cGVzID0gQXJyYXkuZnJvbShjb252ZXJzYXRpb24uZXZlbnRzLnZhbHVlcygpKS5tYXAoZXZlbnQgPT4gZXZlbnQudHlwZSk7XG4gICAgICAgICAgICBpZiAoZXZlbnRfdHlwZXMuaW5jbHVkZXMoJ3NpcDphbnN3ZXJlZCcpKVxuICAgICAgICAgICAgICAgIG54bUNhbGwuc3RhdHVzID0gbnhtQ2FsbC5DQUxMX1NUQVRVUy5BTlNXRVJFRDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50X3R5cGVzLmluY2x1ZGVzKCdzaXA6cmluZ2luZycpKVxuICAgICAgICAgICAgICAgIG54bUNhbGwuc3RhdHVzID0gbnhtQ2FsbC5DQUxMX1NUQVRVUy5SSU5HSU5HO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG54bUNhbGwuc3RhdHVzID0gbnhtQ2FsbC5DQUxMX1NUQVRVUy5TVEFSVEVEO1xuICAgICAgICAgICAgbnhtQ2FsbC5ydGNPYmplY3RzID0gY29udmVyc2F0aW9uLm1lZGlhLnJ0Y09iamVjdHM7XG4gICAgICAgICAgICB0aGlzLmNhbGxzLnNldChjb252ZXJzYXRpb24uaWQsIG54bUNhbGwpO1xuICAgICAgICAgICAgcmV0dXJuIG54bUNhbGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSB0aGUgc2VydmljZSB0byBjcmVhdGUgYSBuZXcgY29udmVyc2F0aW9uXG4gICAgICogVGhlIGNvbnZlcnNhdGlvbiBuYW1lIG11c3QgYmUgdW5pcXVlIHBlciBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gLSBsZWF2ZSBlbXB0eSB0byBnZXQgYSBHVUlEIGFzIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgY29udmVyc2F0aW9uLiBBIFVJRCB3aWxsIGJlIGFzc2lnbmVkIGlmIHRoaXMgaXMgc2tpcHBlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGlzcGxheV9uYW1lIC0gdGhlIGRpc3BsYXlfbmFtZSBvZiB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbnZlcnNhdGlvbj59IC0gdGhlIGNyZWF0ZWQgQ29udmVyc2F0aW9uXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGEgY29udmVyc2F0aW9uIGFuZCBqb2luPC9jYXB0aW9uPlxuICAgICAqICBhcHBsaWNhdGlvbi5uZXdDb252ZXJzYXRpb24oKS50aGVuKChjb252ZXJzYXRpb24pID0+IHtcbiAgICAgKiAgICAvL2pvaW4gdGhlIGNyZWF0ZWQgY29udmVyc2F0aW9uXG4gICAgICogICAgY29udmVyc2F0aW9uLmpvaW4oKS50aGVuKChtZW1iZXIpID0+IHtcbiAgICAgKiAgICAgIC8vR2V0IHRoZSB1c2VyJ3MgbWVtYmVyIGJlbG9uZ2luZyBpbiB0aGlzIGNvbnZlcnNhdGlvbi5cbiAgICAgKiAgICAgIC8vWW91IGNhbiBhbHNvIGFjY2VzcyBpdCB2aWEgY29udmVyc2F0aW9uLm1lXG4gICAgICogICAgICBjb25zb2xlLmxvZyhcIkpvaW5lZCBhcyBcIiArIG1lbWJlci51c2VyLm5hbWUpO1xuICAgKiAgICB9KTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgYXN5bmMgbmV3Q29udmVyc2F0aW9uKGRhdGEgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJ2NvbnZlcnNhdGlvbnMnLFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29udiA9IG5ldyBjb252ZXJzYXRpb25fMS5kZWZhdWx0KHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY29udmVyc2F0aW9ucy5zZXQoY29udi5pZCwgY29udik7XG4gICAgICAgICAgICAvLyBkbyBhIGdldCBjb252ZXJzYXRpb24gdG8gZ2V0IHRoZSB3aG9sZSBtb2RlbCBhcyBzaGFwZWQgaW4gdGhlIHNlcnZpY2UsXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb252ZXJzYXRpb24oY29udi5pZCwgQXBwbGljYXRpb24uQ09OVkVSU0FUSU9OX0FQSV9WRVJTSU9OLnYxKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gY3JlYXRlIGEgbmV3IGNvbnZlcnNhdGlvbiBhbmQgam9pbiBpdFxuICAgICAqIFRoZSBjb252ZXJzYXRpb24gbmFtZSBtdXN0IGJlIHVuaXF1ZSBwZXIgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gbGVhdmUgZW1wdHkgdG8gZ2V0IGEgR1VJRCBhcyBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGNvbnZlcnNhdGlvbi4gQSBVSUQgd2lsbCBiZSBhc3NpZ25lZCBpZiB0aGlzIGlzIHNraXBwZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRpc3BsYXlfbmFtZSAtIHRoZSBkaXNwbGF5X25hbWUgb2YgdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb252ZXJzYXRpb24+fSAtIHRoZSBjcmVhdGVkIENvbnZlcnNhdGlvblxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIGNvbnZlcnNhdGlvbiBhbmQgam9pbjwvY2FwdGlvbj5cbiAgICAgKiAgYXBwbGljYXRpb24ubmV3Q29udmVyc2F0aW9uQW5kSm9pbigpLnRoZW4oKGNvbnZlcnNhdGlvbikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSm9pbmVkIGFzIFwiICsgY29udmVyc2F0aW9uLm1lLmRpc3BsYXlfbmFtZSk7XG4gICAgICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBhIGNvbnZlcnNhdGlvbiBhbmQgam9pbmluZyBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGFzeW5jIG5ld0NvbnZlcnNhdGlvbkFuZEpvaW4ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGF3YWl0IHRoaXMubmV3Q29udmVyc2F0aW9uKHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGNvbnZlcnNhdGlvbi5qb2luKCk7XG4gICAgICAgIHJldHVybiBjb252ZXJzYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHRoZSBzZXJ2aWNlIHRvIHNlZSBpZiB0aGlzIGNvbnZlcnNhdGlvbiBleGlzdHMgd2l0aCB0aGVcbiAgICAgKiBsb2dnZWQgaW4gdXNlciBhcyBhIG1lbWJlciBhbmQgcmV0cmlldmUgdGhlIGRhdGEgb2JqZWN0XG4gICAgICogUmVzdWx0IGFkZGVkIChvciB1cGRhdGVkKSBpbiB0aGlzLmNvbnZlcnNhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgY29udmVyc2F0aW9uIHRvIGZldGNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uPUFwcGxpY2F0aW9uLkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTi52MyB7QXBwbGljYXRpb24uQ09OVkVSU0FUSU9OX0FQSV9WRVJTSU9OLnYxIHx8IEFwcGxpY2F0aW9uLkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTi52M30gLSB0aGUgdmVyc2lvbiBvZiB0aGUgQ29udmVyc2F0aW9uIFNlcnZpY2UgQVBJIHRvIHVzZSAodjEgaW5jbHVkZXMgdGhlIGZ1bGwgbGlzdCBvZiB0aGUgbWVtYmVycyBvZiB0aGUgY29udmVyc2F0aW9uIGJ1dCB2MyBkb2VzIG5vdClcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb252ZXJzYXRpb24+fSAtIHRoZSByZXF1ZXN0ZWQgY29udmVyc2F0aW9uXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IGEgY29udmVyc2F0aW9uPC9jYXB0aW9uPlxuICAgICAqICBhcHBsaWNhdGlvbi5nZXRDb252ZXJzYXRpb24oaWQpLnRoZW4oKGNvbnZlcnNhdGlvbikgPT4ge1xuICAgICAqICAgICAgY29uc29sZS5sb2coXCJSZXRyaWV2ZWQgY29udmVyc2F0aW9uOiBcIiwgY29udmVyc2F0aW9uKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgYXN5bmMgZ2V0Q29udmVyc2F0aW9uKGlkLCB2ZXJzaW9uID0gQXBwbGljYXRpb24uQ09OVkVSU0FUSU9OX0FQSV9WRVJTSU9OLnYzKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBBcHBsaWNhdGlvbi5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjEgJiYgdmVyc2lvbiAhPT0gQXBwbGljYXRpb24uQ09OVkVSU0FUSU9OX0FQSV9WRVJTSU9OLnYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOmNvbnZlcnNhdGlvbi1zZXJ2aWNlOnZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSBBcHBsaWNhdGlvbi5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7aWR9YFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlWydpZCddID0gcmVzcG9uc2VbJ3V1aWQnXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzcG9uc2VbJ3V1aWQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke2lkfWAsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICd2MC4zJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb252ZXJzYXRpb25fb2JqZWN0ID0gdGhpcy51cGRhdGVPckNyZWF0ZUNvbnZlcnNhdGlvbihyZXNwb25zZSk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSBBcHBsaWNhdGlvbi5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjMgJiYgIWNvbnZlcnNhdGlvbl9vYmplY3QubWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gYXdhaXQgY29udmVyc2F0aW9uX29iamVjdC5nZXRNeU1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbl9vYmplY3QubWUgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uX29iamVjdC5tZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSByZXRyeSBpbiBjYXNlIG9mIGEgZmFpbHVyZSBpbiBmZXRjaGluZyB0aGUgbWVtYmVyXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gYXdhaXQgY29udmVyc2F0aW9uX29iamVjdC5nZXRNeU1lbWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25fb2JqZWN0Lm1lID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25fb2JqZWN0Lm1lbWJlcnMuc2V0KG1lbWJlci5pZCwgbWVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYFlvdSBkb24ndCBoYXZlIGFueSBtZW1iZXJzaGlwIGluICR7Y29udmVyc2F0aW9uX29iamVjdC5pZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5jb25maWcuc3luYyA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgZXZlbnRzXG4gICAgICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBhd2FpdCBjb252ZXJzYXRpb25fb2JqZWN0LmdldEV2ZW50cygpO1xuICAgICAgICAgICAgY29udmVyc2F0aW9uX29iamVjdC5ldmVudHMgPSBpdGVtcztcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJzYXRpb25fb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbl9vYmplY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gb2J0YWluIGEgY29tcGxldGUgbGlzdCBvZiBjb252ZXJzYXRpb25zIG9mIHdoaWNoIHRoZVxuICAgICAqIGxvZ2dlZC1pbiB1c2VyIGlzIGEgbWVtYmVyIHdpdGggYSBzdGF0ZSBvZiBgSk9JTkVEYCBvciBgSU5WSVRFRGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgY29uZmlndXJlIGRlZmF1bHRzIGZvciBwYWdpbmF0ZWQgY29udmVyc2F0aW9ucyBxdWVyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm9yZGVyICdhc2MnIG9yICdkZXNjJyBvcmRlcmluZyBvZiByZXNvdXJjZXMgYmFzZWQgb24gY3JlYXRpb24gdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2Vfc2l6ZSB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyByZXR1cm5lZCBpbiBhIHNpbmdsZSByZXF1ZXN0IGxpc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY3Vyc29yXSBzdHJpbmcgdG8gYWNjZXNzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIGRhdGFzZXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBhZ2U8TWFwPENvbnZlcnNhdGlvbj4+Pn0gLSBQb3B1bGF0ZSBBcHBsaWNhdGlvbi5jb252ZXJzYXRpb25zLlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZXQgQ29udmVyc2F0aW9uczwvY2FwdGlvbj5cbiAgICogIGFwcGxpY2F0aW9uLmdldENvbnZlcnNhdGlvbnMoeyBwYWdlX3NpemU6IDIwIH0pLnRoZW4oKGNvbnZlcnNhdGlvbnNfcGFnZSkgPT4ge1xuICAgKiAgICBjb252ZXJzYXRpb25zX3BhZ2UuaXRlbXMuZm9yRWFjaChjb252ZXJzYXRpb24gPT4ge1xuICAgKiAgICAgIHJlbmRlcihjb252ZXJzYXRpb24pXG4gICAqICAgIH0pXG4gICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICogICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICogIH0pO1xuICAgKlxuICAgICovXG4gICAgYXN5bmMgZ2V0Q29udmVyc2F0aW9ucyhwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLnNlc3Npb24uY29uZmlnLm5leG1vX2FwaV91cmx9L2JldGEyL3VzZXJzLyR7dGhpcy5tZS5pZH0vY29udmVyc2F0aW9uc2A7XG4gICAgICAgIC8vIENyZWF0ZSBwYWdlQ29uZmlnIGlmIHNvbWUgZWxlbWVudHMgZ2l2ZW4gb3RoZXJ3aXNlIHVzZSBkZWZhdWx0XG4gICAgICAgIGxldCBwYWdlQ29uZmlnID0gT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDAgPyB0aGlzLnBhZ2VDb25maWcgOiBuZXcgcGFnZV9jb25maWdfMS5kZWZhdWx0KHBhcmFtcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHV0aWxzXzEuZGVmYXVsdC5wYWdpbmF0aW9uUmVxdWVzdCh1cmwsIHBhZ2VDb25maWcsIHRoaXMuc2Vzc2lvbi5jb25maWcudG9rZW4pO1xuICAgICAgICAgICAgcmVzcG9uc2UuYXBwbGljYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9uc19wYWdlID0gbmV3IGNvbnZlcnNhdGlvbnNfcGFnZV8xLmRlZmF1bHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb25zX3BhZ2VfbGFzdCA9IGNvbnZlcnNhdGlvbnNfcGFnZTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJzYXRpb25zX3BhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpY2F0aW9uIGxpc3RlbmluZyBmb3Igc3luYyBzdGF0dXMgZXZlbnRzLlxuICAgICAqXG4gICAgICogQGV2ZW50IEFwcGxpY2F0aW9uI3N5bmM6cHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGF0dXMuc3luY19wcm9ncmVzcyAtIFBlcmNlbnRhZ2Ugb2YgZmV0Y2hlZCBjb252ZXJzYXRpb25zXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBzeW5jaHJvbmlzYXRpb24gcHJvZ3Jlc3MgZXZlbnRzIG9uIEFwcGxpY2F0aW9uIGxldmVsPC9jYXB0aW9uPlxuICAgICAqICBhcHBsaWNhdGlvbi5vbihcInN5bmM6cHJvZ3Jlc3NcIiwoc3RhdHVzKSA9PiB7XG4gICAgICpcdCAgY29uc29sZS5sb2coc3RhdHVzLnN5bmNfcHJvZ3Jlc3MpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEZldGNoaW5nIGFsbCB0aGUgY29udmVyc2F0aW9ucyBhbmQgc3luYyBwcm9ncmVzcyBldmVudHNcbiAgICAqL1xuICAgIHN5bmNDb252ZXJzYXRpb25zKGNvbnZlcnNhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uX2FycmF5ID0gQXJyYXkuZnJvbShjb252ZXJzYXRpb25zLnZhbHVlcygpKTtcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uc19sZW5ndGggPSBjb252ZXJzYXRpb25fYXJyYXkubGVuZ3RoO1xuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5zdGFydF9zeW5jX3RpbWUgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IGQuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBmZXRjaENvbnZlcnNhdGlvbkZvclN0b3JhZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN5bmNlZF9jb252ZXJzYXRpb25zX3BlcmNlbnRhZ2UgPSBOdW1iZXIoKCh0aGlzLnN5bmNlZF9jb252ZXJzYXRpb25zX2NvdW50IC8gY29udmVyc2F0aW9uc19sZW5ndGgpICogMTAwKS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c19wYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN5bmNfcHJvZ3Jlc3M6IHRoaXMuc3luY2VkX2NvbnZlcnNhdGlvbnNfcGVyY2VudGFnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3luYzpwcm9ncmVzcycsIHN0YXR1c19wYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ0xvYWRpbmcgc3luYyBwcm9ncmVzczogJyArIHRoaXMuc3luY2VkX2NvbnZlcnNhdGlvbnNfY291bnQgKyAnLycgK1xuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbnNfbGVuZ3RoICsgJyAtICcgKyB0aGlzLnN5bmNlZF9jb252ZXJzYXRpb25zX3BlcmNlbnRhZ2UgKyAnJScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3luY2VkX2NvbnZlcnNhdGlvbnNfcGVyY2VudGFnZSA+PSAxMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3Bfc3luY190aW1lID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiBkLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdMb2FkZWQgY29udmVyc2F0aW9ucyBpbiAnICsgKHRoaXMuc3RvcF9zeW5jX3RpbWUgLSB0aGlzLnN0YXJ0X3N5bmNfdGltZSkgKyAnbXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN5bmNlZF9jb252ZXJzYXRpb25zX2NvdW50IDwgY29udmVyc2F0aW9uc19sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldENvbnZlcnNhdGlvbihjb252ZXJzYXRpb25fYXJyYXlbdGhpcy5zeW5jZWRfY29udmVyc2F0aW9uc19jb3VudF0uaWQpO1xuICAgICAgICAgICAgICAgIGZldGNoQ29udmVyc2F0aW9uRm9yU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY2VkX2NvbnZlcnNhdGlvbnNfY291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNfcHJvZ3Jlc3NfYnVmZmVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZldGNoQ29udmVyc2F0aW9uRm9yU3RvcmFnZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRGV0YWlscyBvZiBhIHVzZXIgYnkgdXNpbmcgdGhlaXIgaWQuIElmIG5vIGlkIGlzIHByZXNlbnQsIHdpbGwgcmV0dXJuIHlvdXIgb3duIHVzZXIgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gZmV0Y2gsIGlmIHNraXBwZWQsIGl0IHJldHVybnMgeW91ciBvd24gdXNlciBkZXRhaWxzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcj59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IFVzZXIgZGV0YWlsczwvY2FwdGlvbj5cbiAgICAgKiAgYXBwbGljYXRpb24uZ2V0VXNlcihpZCkudGhlbigodXNlcikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKCdVc2VyIGRldGFpbHM6ICd1c2VyKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgKi9cbiAgICBhc3luYyBnZXRVc2VyKHVzZXJfaWQgPSB0aGlzLm1lLmlkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6IGB1c2Vycy8ke3VzZXJfaWR9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHVzZXJfMS5kZWZhdWx0KHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gb2J0YWluIGEgY29tcGxldGUgbGlzdCBvZiB1c2VyU2Vzc2lvbnMgb2YgYSBnaXZlbiB1c2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgY29uZmlndXJlIGRlZmF1bHRzIGZvciBwYWdpbmF0ZWQgdXNlciBzZXNzaW9ucyBxdWVyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm9yZGVyICdhc2MnIG9yICdkZXNjJyBvcmRlcmluZyBvZiByZXNvdXJjZXMgYmFzZWQgb24gY3JlYXRpb24gdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2Vfc2l6ZSB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyByZXR1cm5lZCBpbiBhIHNpbmdsZSByZXF1ZXN0IGxpc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY3Vyc29yXSBzdHJpbmcgdG8gYWNjZXNzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIGRhdGFzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMudXNlcl9pZF0gdGhlIHVzZXIgaWQgdGhhdCB0aGUgc2Vzc2lvbnMgYXJlIGJlaW5nIGZldGNoZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBhZ2U8TWFwPFVzZXJTZXNzaW9uPj4+fVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZXQgVXNlciBTZXNzaW9uczwvY2FwdGlvbj5cbiAgICogIGFwcGxpY2F0aW9uLmdldFVzZXJTZXNzaW9ucyh7IHVzZXJfaWQ6IFwiaWRcIiwgcGFnZV9zaXplOiAyMCB9KS50aGVuKCh1c2VyX3Nlc3Npb25zX3BhZ2UpID0+IHtcbiAgICogICAgdXNlcl9zZXNzaW9uc19wYWdlLml0ZW1zLmZvckVhY2godXNlcl9zZXNzaW9uID0+IHtcbiAgICogICAgICByZW5kZXIodXNlcl9zZXNzaW9uKVxuICAgKiAgICB9KVxuICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAqICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAqICB9KTtcbiAgICpcbiAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJTZXNzaW9ucyhwYXJhbXMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHVzZXJfaWQgPSAoKF9hID0gcGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlcl9pZCkgfHwgdGhpcy5tZS5pZDtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5zZXNzaW9uLmNvbmZpZy5uZXhtb19hcGlfdXJsfS92MC4zL3VzZXJzLyR7dXNlcl9pZH0vc2Vzc2lvbnNgO1xuICAgICAgICAvLyBDcmVhdGUgcGFnZUNvbmZpZyBpZiBzb21lIGVsZW1lbnRzIGdpdmVuIG90aGVyd2lzZSB1c2UgZGVmYXVsdFxuICAgICAgICBsZXQgcGFnZUNvbmZpZyA9IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwID8gdGhpcy5wYWdlQ29uZmlnIDogbmV3IHBhZ2VfY29uZmlnXzEuZGVmYXVsdChwYXJhbXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1dGlsc18xLmRlZmF1bHQucGFnaW5hdGlvblJlcXVlc3QodXJsLCBwYWdlQ29uZmlnLCB0aGlzLnNlc3Npb24uY29uZmlnLnRva2VuLCBBcHBsaWNhdGlvbi5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjMpO1xuICAgICAgICAgICAgcmVzcG9uc2UuYXBwbGljYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgdXNlcl9zZXNzaW9uc19wYWdlID0gbmV3IHVzZXJfc2Vzc2lvbnNfcGFnZV8xLmRlZmF1bHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy51c2VyX3Nlc3Npb25zX3BhZ2VfbGFzdCA9IHVzZXJfc2Vzc2lvbnNfcGFnZTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyX3Nlc3Npb25zX3BhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQXBwbGljYXRpb247XG4vKipcbiAqIEVudW0gZm9yIEFwcGxpY2F0aW9uIGdldENvbnZlcnNhdGlvbiB2ZXJzaW9uLlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGFsaWFzIEFwcGxpY2F0aW9uLkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTlxuKi9cbkFwcGxpY2F0aW9uLkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTiA9IHtcbiAgICB2MTogJ3YwLjEnLFxuICAgIHYzOiAndjAuMydcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFwcGxpY2F0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBDb252ZXJzYXRpb24gT2JqZWN0IE1vZGVsXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4gKi9cbmNvbnN0IFdpbGRFbWl0dGVyID0gcmVxdWlyZSgnd2lsZGVtaXR0ZXInKTtcbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5jb25zdCBuZXhtb0NsaWVudEVycm9yXzEgPSByZXF1aXJlKFwiLi9uZXhtb0NsaWVudEVycm9yXCIpO1xuY29uc3QgbWVtYmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWVtYmVyXCIpKTtcbmNvbnN0IG54bUV2ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXZlbnRzL254bUV2ZW50XCIpKTtcbmNvbnN0IHRleHRfZXZlbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ldmVudHMvdGV4dF9ldmVudFwiKSk7XG5jb25zdCBtZXNzYWdlX2V2ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXZlbnRzL21lc3NhZ2VfZXZlbnRcIikpO1xuY29uc3QgbWVkaWFfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tb2R1bGVzL21lZGlhXCIpKTtcbmNvbnN0IGNvbnZlcnNhdGlvbl9ldmVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9oYW5kbGVycy9jb252ZXJzYXRpb25fZXZlbnRzXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgcGFnZV9jb25maWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlcy9wYWdlX2NvbmZpZ1wiKSk7XG5jb25zdCBldmVudHNfcGFnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2VzL2V2ZW50c19wYWdlXCIpKTtcbmNvbnN0IG1lbWJlcnNfcGFnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2VzL21lbWJlcnNfcGFnZVwiKSk7XG5jb25zdCBhcHBsaWNhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwcGxpY2F0aW9uXCIpKTtcbi8qKlxuICogQSBzaW5nbGUgY29udmVyc2F0aW9uIE9iamVjdC5cbiAqIEBjbGFzcyBDb252ZXJzYXRpb25cbiAqIEBwcm9wZXJ0eSB7TWVtYmVyfSBtZSAtIG15IE1lbWJlciBvYmplY3QgdGhhdCBiZWxvbmdzIHRvIHRoaXMgY29udmVyc2F0aW9uXG4gKiBAcHJvcGVydHkge0FwcGxpY2F0aW9ufSBhcHBsaWNhdGlvbiAtIHRoZSBwYXJlbnQgQXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIENvbnZlcnNhdGlvbiAodW5pcXVlKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkaXNwbGF5X25hbWVdIC0gdGhlIGRpc3BsYXlfbmFtZSBvZiB0aGUgQ29udmVyc2F0aW9uXG4gKiBAcHJvcGVydHkge01hcDxzdHJpbmcsIE1lbWJlcj59IFttZW1iZXJzXSAtIHRoZSBtZW1iZXJzIG9mIHRoZSBDb252ZXJzYXRpb24ga2V5ZWQgYnkgYSBtZW1iZXIncyBpZFxuICogQHByb3BlcnR5IHtNYXA8c3RyaW5nLCBOWE1FdmVudD59IFtldmVudHNdIC0gdGhlIGV2ZW50cyBvZiB0aGUgQ29udmVyc2F0aW9uIGtleWVkIGJ5IGFuIGV2ZW50J3MgaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2VxdWVuY2VfbnVtYmVyXSAtIHRoZSBsYXN0IGV2ZW50IGlkXG4qL1xuY2xhc3MgQ29udmVyc2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGF5X25hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VfbnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5wYWdlQ29uZmlnID0gbmV3IHBhZ2VfY29uZmlnXzEuZGVmYXVsdCgoKHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbiB8fCB7fSkuY29uZmlnIHx8IHt9KS5ldmVudHNfcGFnZV9jb25maWcpO1xuICAgICAgICB0aGlzLmV2ZW50c19wYWdlX2xhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLm1lbWJlcnNfcGFnZV9sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25FdmVudEhhbmRsZXIgPSBuZXcgY29udmVyc2F0aW9uX2V2ZW50c18xLmRlZmF1bHQoYXBwbGljYXRpb24sIHRoaXMpO1xuICAgICAgICB0aGlzLm1lZGlhID0gbmV3IG1lZGlhXzEuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgTWVtYmVyIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgICAgICogT25seSBzZXQgaWYgdGhlIHVzZXIgaXMgb3IgaGFzIGJlZW4gYSBtZW1iZXIgb2YgdGhlIENvbnZlcnNhdGlvbixcbiAgICAgICAgICogb3RoZXJ3aXNlIHRoZSB2YWx1ZSB3aWxsIGJlIGBudWxsYC5cbiAgICAgICAgICogQHR5cGUgTWVtYmVyXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWUgPSBudWxsOyAvLyBXZSBhcmUgbm90IGluIHRoZSBjb252ZXJzYXRpb24gb3Vyc2VsdmVzIGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gTWFwIHRoZSBwYXJhbXMgKHdoaWNoIGluY2x1ZGVzIHRoZSBpZClcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0SW5zdGFuY2UocGFyYW1zKTtcbiAgICAgICAgV2lsZEVtaXR0ZXIubWl4aW4oQ29udmVyc2F0aW9uKTtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZSBDb252ZXJzYXRpb24gb2JqZWN0IHBhcmFtc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwYXJhbXMgdGhlIHBhcmFtcyB0byB1cGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3VwZGF0ZU9iamVjdEluc3RhbmNlKHBhcmFtcykge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNwbGF5X25hbWUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlfbmFtZSA9IHBhcmFtcy5kaXNwbGF5X25hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lbWJlcnMnOlxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGNvbnZlcnNhdGlvbiBqYXZhc2NyaXB0IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubWVtYmVycy5mb3JFYWNoKChtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmhhcyhtLm1lbWJlcl9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuZ2V0KG0ubWVtYmVyX2lkKS5fbm9ybWFsaXNlKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLnVzZXJfaWQgPT09IHRoaXMuYXBwbGljYXRpb24ubWUuaWQgJiYgbS5zdGF0ZSAhPT0gJ0xFRlQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWUgPSB0aGlzLm1lbWJlcnMuZ2V0KG0ubWVtYmVyX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldCh0aGlzLm1lLmlkLCB0aGlzLm1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW1iZXIgPSBuZXcgbWVtYmVyXzEuZGVmYXVsdCh0aGlzLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS51c2VyX2lkID09PSB0aGlzLmFwcGxpY2F0aW9uLm1lLmlkICYmIG0uc3RhdGUgIT09ICdMRUZUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0KG1lbWJlci5pZCwgbWVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gcGFyYW1zLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VxdWVuY2VfbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZV9udW1iZXIgPSBwYXJhbXMuc2VxdWVuY2VfbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtZW1iZXJfaWQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgbmVlZGVkIHBhcmFtcyB0byBjcmVhdGUgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY29udmVyc2F0aW9uIGxpc3QgZ2l2ZXMgdXMgdGhlIG1lbWJlcl9pZCB0byBwcmVwYXJlIHRoZSBtZW1iZXIvdGhpcyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0X3BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMubWVtYmVyX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHBhcmFtcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IHRoaXMuYXBwbGljYXRpb24ubWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBtZW1iZXIgb2JqZWN0IG9yIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmhhcyhwYXJhbXMubWVtYmVyX2lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyX29iamVjdCA9IHRoaXMubWVtYmVycy5nZXQocGFyYW1zLm1lbWJlcl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lbWJlcl9vYmplY3QsIG9iamVjdF9wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gbmV3IG1lbWJlcl8xLmRlZmF1bHQodGhpcywgb2JqZWN0X3BhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiB0aGUgZ2l2ZW4gVXNlciB0byB0aGlzIENvbnZlcnNhdGlvbi4gV2lsbCB0eXBpY2FsbHkgYmUgdXNlZCB0aGlzIHRvIGpvaW5cbiAgICAgKiBvdXJzZWx2ZXMgdG8gYSBDb252ZXJzYXRpb24gd2UgY3JlYXRlLlxuICAgICAqIEFjY2VwdCBhbiBpbnZpdGF0aW9uIGlmIG91ciBNZW1iZXIgaGFzIHN0YXRlIElOVklURUQgYW5kIG5vIHVzZXJfaWQgLyB1c2VyX25hbWUgaXMgZ2l2ZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zID0gdGhpcy5hcHBsaWNhdGlvbi5tZS5pZF0gVGhlIFVzZXIgdG8gam9pbiAoZGVmYXVsdHMgdG8gdGhpcylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVzZXJfbmFtZSB0aGUgdXNlcl9uYW1lIG9mIHRoZSBVc2VyIHRvIGpvaW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVzZXJfaWQgdGhlIHVzZXJfaWQgb2YgdGhlIFVzZXIgdG8gam9pblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1lbWJlcj59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5qb2luIGEgdXNlciB0byB0aGUgQ29udmVyc2F0aW9uPC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogY29udmVyc2F0aW9uLmpvaW4oKS50aGVuKChtZW1iZXIpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2coXCJqb2luZWQgYXMgbWVtYmVyOiBcIiwgbWVtYmVyKVxuICAgICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3Igam9pbmluZyBjb252ZXJzYXRpb24gXCIsIGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAqL1xuICAgIGFzeW5jIGpvaW4ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2pvaW5lZCcsXG4gICAgICAgICAgICAgICAgY2hhbm5lbDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXBwJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgICAgICAuLi4oIXBhcmFtcyAmJiB7IG5hbWU6IHRoaXMuYXBwbGljYXRpb24ubWUubmFtZSwgaWQ6IHRoaXMuYXBwbGljYXRpb24ubWUuaWQgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihwYXJhbXMgJiYgcGFyYW1zLnVzZXJfbmFtZSAmJiB7IG5hbWU6IHBhcmFtcy51c2VyX25hbWUgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihwYXJhbXMgJiYgcGFyYW1zLnVzZXJfaWQgJiYgeyBpZDogcGFyYW1zLnVzZXJfaWQgfSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5tZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSAmJiAoKF9iID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLm1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpICE9PSAnTEVGVCcpIHtcbiAgICAgICAgICAgICAgICBkYXRhW1wiZnJvbVwiXSA9IHRoaXMubWUuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMuaWR9L21lbWJlcnNgLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICd2MC4zJyxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IG5ldyBtZW1iZXJfMS5kZWZhdWx0KHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5fZW1iZWRkZWQudXNlci5pZCA9PT0gdGhpcy5hcHBsaWNhdGlvbi5tZS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWUgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1c2UgY2FzZSB3aGVyZSBiZXR3ZWVuIHRoZSB0aW1lIHdlIGdvdCB0aGUgY29udmVyc2F0aW9uIGFuZCB0aGUgdGltZSB3ZSBmaW5pc2hlZCBqb2luaW5nXG4gICAgICAgICAgICAvLyB0aGUgY29udmVyc2F0aW9uIG9iamVjdCBjaGFuZ2VkLlxuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5nZXRDb252ZXJzYXRpb24odGhpcy5pZCwgYXBwbGljYXRpb25fMS5kZWZhdWx0LkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTi52Myk7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBjb252ZXJzYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5kZWxldGUgdGhlIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGNvbnZlcnNhdGlvbi5kZWwoKS50aGVuKCgpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcImNvbnZlcnNhdGlvbiBkZWxldGVkXCIpO1xuICAgICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZGVsZXRpbmcgY29udmVyc2F0aW9uIFwiLCBlcnJvcik7XG4gICAgICogfSk7XG4gICAgKi9cbiAgICBhc3luYyBkZWwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5pZH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24uY29udmVyc2F0aW9ucy5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBOWE1FdmVudCAoZS5nLiBUZXh0KVxuICAgICAqIEBwYXJhbSB7TlhNRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZGVsZXRlIGFuIEV2ZW50PC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogY29udmVyc2F0aW9uLmRlbGV0ZUV2ZW50KGV2ZW50VG9CZURlbGV0ZWQpLnRoZW4oKCkgPT4ge1xuICAgICAqICBjb25zb2xlLmxvZyhcImV2ZW50IHdhcyBkZWxldGVkXCIpO1xuICAgICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZGVsZXRpbmcgdGhlIGV2ZW50IFwiLCBlcnJvcik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAqL1xuICAgIGRlbGV0ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5kZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIEludml0ZSB0aGUgZ2l2ZW4gdXNlciAoaWQgb3IgbmFtZSkgdG8gdGhpcyBjb252ZXJzYXRpb25cbiAgICAgICogQHBhcmFtIHtNZW1iZXJ9IHBhcmFtc1xuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5pZCBvciB1c2VyX25hbWVdIC0gdGhlIGlkIG9yIHRoZSB1c2VybmFtZSBvZiB0aGUgVXNlciB0byBpbnZpdGVcbiAgICAgICpcbiAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVtYmVyPn1cbiAgICAgICpcbiAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+aW52aXRlIGEgdXNlciB0byBhIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgICogY29uc3QgdXNlcl9pZCA9ICdpZCBvZiBVc2VyIHRvIGludml0ZSc7XG4gICAgICAqIGNvbnN0IHVzZXJfbmFtZSA9ICd1c2VybmFtZSBvZiBVc2VyIHRvIGludml0ZSc7XG4gICAgICAqXG4gICAgICAqIGNvbnZlcnNhdGlvbi5pbnZpdGUoe1xuICAgICAgKiAgaWQ6IHVzZXJfaWQsXG4gICAgICAqICB1c2VyX25hbWU6IHVzZXJfbmFtZVxuICAgICAgKiB9KS50aGVuKChtZW1iZXIpID0+IHtcbiAgICAgICogIGRpc3BsYXlNZXNzYWdlKG1lbWJlci5zdGF0ZSArIFwiIHVzZXI6IFwiICsgdXNlcl9pZCArIFwiIFwiICsgdXNlcl9uYW1lKTtcbiAgICAgICogfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3IgaW52aXRpbmcgdXNlciBcIiwgZXJyb3IpO1xuICAgICAgKiB9KTtcbiAgICAgICpcbiAgICAqL1xuICAgIGFzeW5jIGludml0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgKCFwYXJhbXMuaWQgJiYgIXBhcmFtcy51c2VyX25hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOmludml0ZTptaXNzaW5nOnBhcmFtcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBzdGF0ZTogJ2ludml0ZWQnLFxuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIC4uLihwYXJhbXMuaWQgJiYgeyBpZDogcGFyYW1zLmlkIH0pLFxuICAgICAgICAgICAgICAgIC4uLihwYXJhbXMudXNlcl9uYW1lICYmIHsgbmFtZTogcGFyYW1zLnVzZXJfbmFtZSB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhOiBwYXJhbXMubWVkaWEsXG4gICAgICAgICAgICBjaGFubmVsOiB7XG4gICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXBwJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FwcCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhcHAnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICgoKF9hID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLm1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpICYmICgoX2IgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMubWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGF0ZSkgIT09ICdMRUZUJykge1xuICAgICAgICAgICAgZGF0YVtcImZyb21cIl0gPSB0aGlzLm1lLmlkO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMuaWR9L21lbWJlcnNgLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICd2MC4zJyxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IG5ldyBtZW1iZXJfMS5kZWZhdWx0KHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBJbnZpdGUgdGhlIGdpdmVuIHVzZXIgKGlkIG9yIG5hbWUpIHRvIHRoaXMgY29udmVyc2F0aW9uIHdpdGggbWVkaWEgYXVkaW9cbiAgICAgICogQHBhcmFtIHtNZW1iZXJ9IHBhcmFtc1xuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5pZCBvciB1c2VyX25hbWVdIC0gdGhlIGlkIG9yIHRoZSB1c2VybmFtZSBvZiB0aGUgVXNlciB0byBpbnZpdGVcbiAgICAgICpcbiAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVtYmVyPn1cbiAgICAgICpcbiAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+aW52aXRlIGEgdXNlciB0byBhIGNvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgICogY29uc3QgdXNlcl9pZCA9ICdpZCBvZiBVc2VyIHRvIGludml0ZSc7XG4gICAgICAqIGNvbnN0IHVzZXJfbmFtZSA9ICd1c2VybmFtZSBvZiBVc2VyIHRvIGludml0ZSc7XG4gICAgICAqXG4gICAgICAqIGNvbnZlcnNhdGlvbi5pbnZpdGVXaXRoQXVkaW8oe1xuICAgICAgKiAgaWQ6IHVzZXJfaWQsXG4gICAgICAqICB1c2VyX25hbWU6IHVzZXJfbmFtZVxuICAgICAgKiB9KS50aGVuKChtZW1iZXIpID0+IHtcbiAgICAgICogIGRpc3BsYXlNZXNzYWdlKG1lbWJlci5zdGF0ZSArIFwiIHVzZXI6IFwiICsgdXNlcl9pZCArIFwiIFwiICsgdXNlcl9uYW1lKTtcbiAgICAgICogfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3IgaW52aXRpbmcgdXNlciBcIiwgZXJyb3IpO1xuICAgICAgKiB9KTtcbiAgICAgICpcbiAgICAqL1xuICAgIGludml0ZVdpdGhBdWRpbyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgKCFwYXJhbXMuaWQgJiYgIXBhcmFtcy51c2VyX25hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKCdlcnJvcjppbnZpdGU6bWlzc2luZzpwYXJhbXMnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLm1lZGlhID0ge1xuICAgICAgICAgICAgYXVkaW9fc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG11dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlYXJtdWZmZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmludml0ZShwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZSBmcm9tIHRoZSBDb252ZXJzYXRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3JlYXNvbl0gdGhlIHJlYXNvbiBmb3IgbGVhdmluZyB0aGUgY29udmVyc2F0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb24ucmVhc29uX2NvZGVdIHRoZSBjb2RlIG9mIHRoZSByZWFzb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbi5yZWFzb25fdGV4dF0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5sZWF2ZSB0aGUgQ29udmVyc2F0aW9uPC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogY29udmVyc2F0aW9uLmxlYXZlKHtyZWFzb25fY29kZTogXCJteWNvZGVcIiwgcmVhc29uX3RleHQ6IFwibXkgcmVhc29uIGZvciBsZWF2aW5nXCJ9KS50aGVuKCgpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2coXCJzdWNjZXNzZnVsbHkgbGVmdCBjb252ZXJzYXRpb25cIik7XG4gICAgICogfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBsZWF2aW5nIGNvbnZlcnNhdGlvbiBcIiwgZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgKi9cbiAgICBsZWF2ZShyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWUua2ljayhyZWFzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogU2VuZCBhIHRleHQgbWVzc2FnZSB0byB0aGUgY29udmVyc2F0aW9uLCB3aGljaCB3aWxsIGJlIHJlbGF5ZWQgdG8gZXZlcnkgb3RoZXIgbWVtYmVyIG9mIHRoZSBjb252ZXJzYXRpb25cbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgdGV4dCBtZXNzYWdlIHRvIGJlIHNlbnRcbiAgICAgICpcbiAgICAgICogQHJldHVybnMge1Byb21pc2U8VGV4dEV2ZW50Pn0gLSB0aGUgdGV4dCBtZXNzYWdlIHRoYXQgd2FzIHNlbnRcbiAgICAgICpcbiAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+IHNlbmRpbmcgYSB0ZXh0IDwvY2FwdGlvbj5cbiAgICAgICogY29udmVyc2F0aW9uLnNlbmRUZXh0KFwiSGkgVm9uYWdlXCIpLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICAqICBjb25zb2xlLmxvZyhcIm1lc3NhZ2Ugd2FzIHNlbnRcIiwgZXZlbnQpO1xuICAgICAgKiB9KS5jYXRjaCgoZXJyb3IpPT57XG4gICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3Igc2VuZGluZyB0aGUgbWVzc2FnZSBcIiwgZXJyb3IpO1xuICAgICAgKiB9KTtcbiAgICAgICpcbiAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA4LjMuMFxuICAgICAgKlxuICAgICovXG4gICAgYXN5bmMgc2VuZFRleHQodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOnNlbGYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgY2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMubWUuaWQsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHRpbWVzdGFtcCB9ID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICBkYXRhOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXNnLmlkID0gaWQ7XG4gICAgICAgICAgICBtc2cuYm9keS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRleHRfZXZlbnRfMS5kZWZhdWx0KHRoaXMsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBTZW5kIGEgY3VzdG9tIGV2ZW50IHRvIHRoZSBDb252ZXJzYXRpb25cbiAgICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIHBhcmFtcyBvZiB0aGUgY3VzdG9tIGV2ZW50XG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudHlwZSB0aGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50LiBNdXN0IG5vdCBleGNlZWQgMTAwIGNoYXIgbGVuZ3RoIGFuZCBjb250YWluIG9ubHkgYWxwaGEgbnVtZXJpY3MgYW5kICctJyBhbmQgJ18nIGNoYXJhY3RlcnMuXG4gICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYm9keSBjdXN0b21pemFibGUga2V5IHZhbHVlIHBhaXJzXG4gICAgICAqXG4gICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5YTUV2ZW50Pn0gLSB0aGUgY3VzdG9tIGV2ZW50IHRoYXQgd2FzIHNlbnRcbiAgICAgICpcbiAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+IHNlbmRpbmcgYSBjdXN0b20gZXZlbnQgPC9jYXB0aW9uPlxuICAgICAgKiBjb252ZXJzYXRpb24uc2VuZEN1c3RvbUV2ZW50KHsgdHlwZTogXCJteS1ldmVudFwiLCBib2R5OiB7IG15a2V5OiBcIm15IHZhbHVlXCIgfX0pLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICAqICBjb25zb2xlLmxvZyhcImN1c3RvbSBldmVudCB3YXMgc2VudFwiLCBldmVudCk7XG4gICAgICAqIH0pLmNhdGNoKChlcnJvcik9PntcbiAgICAgICogIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBzZW5kaW5nIHRoZSBjdXN0b20gZXZlbnRcIiwgZXJyb3IpO1xuICAgICAgKiB9KTtcbiAgICAgICpcbiAgICAqL1xuICAgIGFzeW5jIHNlbmRDdXN0b21FdmVudCh7IHR5cGUsIGJvZHkgfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOnNlbGYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCB0eXBlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOmN1c3RvbS1ldmVudDppbnZhbGlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGBjdXN0b206JHt0eXBlfWAsXG4gICAgICAgICAgICAgICAgY2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMubWUuaWQsXG4gICAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHRpbWVzdGFtcCB9ID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEuaWQgPSBpZDtcbiAgICAgICAgICAgIGRhdGEudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBueG1FdmVudF8xLmRlZmF1bHQodGhpcywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYW4gSW1hZ2UgdG8gTWVkaWEgU2VydmljZS5cbiAgICAgKiBpbXBsZW1lbnRzIHhociAoaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLykgLSB0aGlzLmltYWdlUmVxdWVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaWxlfSBmaWxlIHNpbmdsZSBpbnB1dCBmaWxlIChqcGVnL2pwZylcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gcGFyYW1zIG9mIGltYWdlIHNlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5xdWFsaXR5X3JhdGlvID0gMTAwXSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLiAwIGluZGljYXRlcyAnbWF4aW11bSBjb21wcmVzc2lvbicgYW5kIHRoZSBsb3dlc3QgcXVhbGl0eSwgMTAwIHdpbGwgcmVzdWx0IGluIHRoZSBoaWdoZXN0IHF1YWxpdHkgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5tZWRpdW1fc2l6ZV9yYXRpbyA9IDUwXSBhIHZhbHVlIGJldHdlZW4gMSBhbmQgMTAwLiAxIGluZGljYXRlcyB0aGUgbmV3IGltYWdlIGlzIDElIG9mIG9yaWdpbmFsLCAxMDAgLSBzYW1lIHNpemUgYXMgb3JpZ2luYWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy50aHVtYm5haWxfc2l6ZV9yYXRpbyA9IDMwXSBhIHZhbHVlIGJldHdlZW4gMSBhbmQgMTAwLiAxIGluZGljYXRlcyB0aGUgbmV3IGltYWdlIGlzIDElIG9mIG9yaWdpbmFsLCAxMDAgLSBzYW1lIHNpemUgYXMgb3JpZ2luYWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFhNTEh0dHBSZXF1ZXN0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPnVwbG9hZGluZyBhbiBpbWFnZTwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCBwYXJhbXMgPSB7XG4gICAgICogIHF1YWxpdHlfcmF0aW8gOiBcIjkwXCIsXG4gICAgICogIG1lZGl1bV9zaXplX3JhdGlvOiBcIjQwXCIsXG4gICAgICogIHRodW1ibmFpbF9zaXplX3JhdGlvOiBcIjIwXCJcbiAgICAgKiB9XG4gICAgICogY29udmVyc2F0aW9uLnVwbG9hZEltYWdlKGZpbGVJbnB1dC5maWxlc1swXSwgcGFyYW1zKS50aGVuKCh1cGxvYWRJbWFnZVJlcXVlc3QpID0+IHtcbiAgICAgKiAgdXBsb2FkSW1hZ2VSZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSAoZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgcmVxdWVzdCBwcm9ncmVzczogXCIsIGUpO1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgcHJvZ3Jlc3M6IFwiICsgZS5sb2FkZWQgKyBcIi9cIiArIGUudG90YWwpO1xuICAgICAqICB9O1xuICAgICAqICB1cGxvYWRJbWFnZVJlcXVlc3Qub25hYm9ydCA9IChlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJJbWFnZSByZXF1ZXN0IGFib3J0ZWQ6IFwiLCBlKTtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIkltYWdlOiBcIiArIGUudHlwZSk7XG4gICAgICogIH07XG4gICAgICogIHVwbG9hZEltYWdlUmVxdWVzdC5vbmxvYWRlbmQgPSAoZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgcmVxdWVzdCBzdWNjZXNzZnVsOiBcIiwgZSk7XG4gICAgICogICAgY29uc29sZS5sb2coXCJJbWFnZTogXCIgKyBlLnR5cGUpO1xuICAgICAqICB9O1xuICAgICAqICB1cGxvYWRJbWFnZVJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAqICAgIGlmICh1cGxvYWRJbWFnZVJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCAmJiB1cGxvYWRJbWFnZVJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgKiAgICAgIGNvbnN0IHJlcHJlc2VudGF0aW9ucyA9IEpTT04ucGFyc2UodXBsb2FkSW1hZ2VSZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICogICAgICBjb25zb2xlLmxvZyhcIk9yaWdpbmFsIGltYWdlIHVybDogXCIsIHJlcHJlc2VudGF0aW9ucy5vcmlnaW5hbC51cmwpO1xuICAgICAqICAgICAgY29uc29sZS5sb2coXCJNZWRpdW0gaW1hZ2UgdXJsOiBcIiwgcmVwcmVzZW50YXRpb25zLm1lZGl1bS51cmwpO1xuICAgICAqICAgICAgY29uc29sZS5sb2coXCJUaHVtYm5haWwgaW1hZ2UgdXJsOiBcIiwgcmVwcmVzZW50YXRpb25zLnRodW1ibmFpbC51cmwpO1xuICAgICAqICAgIH1cbiAgICAgKiAgfTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgdXBsb2FkaW5nIHRoZSBpbWFnZSBcIiwgZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICovXG4gICAgYXN5bmMgdXBsb2FkSW1hZ2UoZmlsZUlucHV0LCBwYXJhbXMgPSB7XG4gICAgICAgIHF1YWxpdHlfcmF0aW86ICcxMDAnLFxuICAgICAgICBtZWRpdW1fc2l6ZV9yYXRpbzogJzUwJyxcbiAgICAgICAgdGh1bWJuYWlsX3NpemVfcmF0aW86ICczMCdcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGVJbnB1dCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgncXVhbGl0eV9yYXRpbycsIHBhcmFtcy5xdWFsaXR5X3JhdGlvKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdtZWRpdW1fc2l6ZV9yYXRpbycsIHBhcmFtcy5tZWRpdW1fc2l6ZV9yYXRpbyk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgndGh1bWJuYWlsX3NpemVfcmF0aW8nLCBwYXJhbXMudGh1bWJuYWlsX3NpemVfcmF0aW8pO1xuICAgICAgICBjb25zdCBpbWFnZVJlcXVlc3QgPSBhd2FpdCB1dGlsc18xLmRlZmF1bHQubmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uY29uZmlnLmlwc191cmwsXG4gICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uY29uZmlnLnRva2VuXG4gICAgICAgIH0pO1xuICAgICAgICBpbWFnZVJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2dC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwbG9hZGluZyBpbWFnZSAnICsgZXZ0LmxvYWRlZCArICcvJyArIGV2dC50b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgaW1hZ2VSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbWFnZVJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihpbWFnZVJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW1hZ2VSZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEltYWdlIG1lc3NhZ2UgdG8gdGhlIGNvbnZlcnNhdGlvbiwgd2hpY2ggd2lsbCBiZSByZWxheWVkIHRvIGV2ZXJ5IG90aGVyIG1lbWJlciBvZiB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqIGltcGxlbWVudHMgeGhyIChodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvKSAtIHRoaXMuaW1hZ2VSZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgc2luZ2xlIGlucHV0IGZpbGUgKGpwZWcvanBnKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBwYXJhbXMgb2YgaW1hZ2Ugc2VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnF1YWxpdHlfcmF0aW8gPSAxMDBdIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuIDAgaW5kaWNhdGVzICdtYXhpbXVtIGNvbXByZXNzaW9uJyBhbmQgdGhlIGxvd2VzdCBxdWFsaXR5LCAxMDAgd2lsbCByZXN1bHQgaW4gdGhlIGhpZ2hlc3QgcXVhbGl0eSBpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLm1lZGl1bV9zaXplX3JhdGlvID0gNTBdIGEgdmFsdWUgYmV0d2VlbiAxIGFuZCAxMDAuIDEgaW5kaWNhdGVzIHRoZSBuZXcgaW1hZ2UgaXMgMSUgb2Ygb3JpZ2luYWwsIDEwMCAtIHNhbWUgc2l6ZSBhcyBvcmlnaW5hbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnRodW1ibmFpbF9zaXplX3JhdGlvID0gMzBdIGEgdmFsdWUgYmV0d2VlbiAxIGFuZCAxMDAuIDEgaW5kaWNhdGVzIHRoZSBuZXcgaW1hZ2UgaXMgMSUgb2Ygb3JpZ2luYWwsIDEwMCAtIHNhbWUgc2l6ZSBhcyBvcmlnaW5hbFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8WE1MSHR0cFJlcXVlc3Q+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+c2VuZGluZyBhbiBpbWFnZTwvY2FwdGlvbj5cbiAgICAgKiBjb25zdCBwYXJhbXMgPSB7XG4gICAgICogIHF1YWxpdHlfcmF0aW8gOiBcIjkwXCIsXG4gICAgICogIG1lZGl1bV9zaXplX3JhdGlvOiBcIjQwXCIsXG4gICAgICogIHRodW1ibmFpbF9zaXplX3JhdGlvOiBcIjIwXCJcbiAgICAgKiB9XG4gICAgICogY29udmVyc2F0aW9uLnNlbmRJbWFnZShmaWxlSW5wdXQuZmlsZXNbMF0sIHBhcmFtcykudGhlbigoaW1hZ2VSZXF1ZXN0KSA9PiB7XG4gICAgICogIGltYWdlUmVxdWVzdC5vbnByb2dyZXNzID0gKGUpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIkltYWdlIHJlcXVlc3QgcHJvZ3Jlc3M6IFwiLCBlKTtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIkltYWdlIHByb2dyZXNzOiBcIiArIGUubG9hZGVkICsgXCIvXCIgKyBlLnRvdGFsKTtcbiAgICAgKiAgfTtcbiAgICAgKiAgaW1hZ2VSZXF1ZXN0Lm9uYWJvcnQgPSAoZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgcmVxdWVzdCBhYm9ydGVkOiBcIiwgZSk7XG4gICAgICogICAgY29uc29sZS5sb2coXCJJbWFnZTogXCIgKyBlLnR5cGUpO1xuICAgICAqICB9O1xuICAgICAqICBpbWFnZVJlcXVlc3Qub25sb2FkZW5kID0gKGUpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIkltYWdlIHJlcXVlc3Qgc3VjY2Vzc2Z1bDogXCIsIGUpO1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiSW1hZ2U6IFwiICsgZS50eXBlKTtcbiAgICAgKiAgfTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgY29uc29sZS5lcnJvcihcImVycm9yIHNlbmRpbmcgdGhlIGltYWdlIFwiLCBlcnJvcik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDguMy4wXG4gICAgKi9cbiAgICBhc3luYyBzZW5kSW1hZ2UoZmlsZUlucHV0LCBwYXJhbXMgPSB7XG4gICAgICAgIHF1YWxpdHlfcmF0aW86ICcxMDAnLFxuICAgICAgICBtZWRpdW1fc2l6ZV9yYXRpbzogJzUwJyxcbiAgICAgICAgdGh1bWJuYWlsX3NpemVfcmF0aW86ICczMCdcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGltYWdlUmVxdWVzdCA9IGF3YWl0IHRoaXMudXBsb2FkSW1hZ2UoZmlsZUlucHV0LCBwYXJhbXMpO1xuICAgICAgICBpbWFnZVJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGltYWdlUmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICYmIGltYWdlUmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLmlkfS9ldmVudHNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5tZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHJlc2VudGF0aW9uczogSlNPTi5wYXJzZShpbWFnZVJlcXVlc3QucmVzcG9uc2VUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oaW1hZ2VSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGltYWdlUmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHVwbG9hZGluZyBvciBzZW5kaW5nIGFuIEltYWdlIG1lc3NhZ2UgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IGltYWdlUmVxdWVzdFxuICAgICAqXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Y2FuY2VsIHNlbmRpbmcgYW4gaW1hZ2U8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLnNlbmRJbWFnZShmaWxlSW5wdXQuZmlsZXNbMF0pLnRoZW4oKGltYWdlUmVxdWVzdCkgPT4ge1xuICAgICAqICAgIGNvbnZlcnNhdGlvbi5hYm9ydFNlbmRJbWFnZShpbWFnZVJlcXVlc3QpO1xuICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICogICAgY29uc29sZS5lcnJvcihcImVycm9yIHNlbmRpbmcgdGhlIGltYWdlIFwiLCBlcnJvcik7XG4gICAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmNhbmNlbCB1cGxvYWRpbmcgYW4gaW1hZ2U8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLnVwbG9hZEltYWdlKGZpbGVJbnB1dC5maWxlc1swXSkudGhlbigoaW1hZ2VSZXF1ZXN0KSA9PiB7XG4gICAgICogICAgY29udmVyc2F0aW9uLmFib3J0U2VuZEltYWdlKGltYWdlUmVxdWVzdCk7XG4gICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgKiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgdXBsb2FkaW5nIHRoZSBpbWFnZSBcIiwgZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICovXG4gICAgYWJvcnRTZW5kSW1hZ2UoaW1hZ2VSZXF1ZXN0KSB7XG4gICAgICAgIGlmIChpbWFnZVJlcXVlc3QgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlUmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcignZXJyb3I6aW52YWxpZDpwYXJhbTp0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICAqIFNlbmQgYSBtZXNzYWdlIGV2ZW50IHRvIHRoZSBjb252ZXJzYXRpb24sIHdoaWNoIHdpbGwgYmUgcmVsYXllZCB0byBldmVyeSBvdGhlciBtZW1iZXIgb2YgdGhlIGNvbnZlcnNhdGlvblxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIHlvdSB3YW50IHNlbnRcbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXNzYWdlX3R5cGUgdGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2UuIEl0IHNob3VsZCBiZSBvbmUgb2YgJ3RleHQnLCAnaW1hZ2UnLCAnYXVkaW8nLCAndmlkZW8nLCAnZmlsZSdcbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMudGV4dF0gdGhlIHRleHQgY29udGVudCB3aGVuIG1lc3NhZ2UgdHlwZSBpcyAndGV4dFxuICAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5pbWFnZV1cbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pbWFnZS51cmwgdGhlIGltYWdlIHVybCB3aGVuIG1lc3NhZ2UgdHlwZSBpcyAnaW1hZ2UnXG4gICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmF1ZGlvXVxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmF1ZGlvLnVybCB0aGUgYXVkaW8gdXJsIHdoZW4gbWVzc2FnZSB0eXBlIGlzICdhdWRpbydcbiAgICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMudmlkZW9dXG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudmlkZW8udXJsIHRoZSB2aWRlbyB1cmwgd2hlbiBtZXNzYWdlIHR5cGUgaXMgJ3ZpZGVvJ1xuICAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5maWxlXVxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZpbGUudXJsIHRoZSBmaWxlIHVybCB3aGVuIG1lc3NhZ2UgdHlwZSBpcyAnZmlsZSdcbiAgICAgICpcbiAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZUV2ZW50Pn0gLSB0aGUgbWVzc2FnZSB0aGF0IHdhcyBzZW50XG4gICAgICAqXG4gICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPiBzZW5kaW5nIGEgbWVzc2FnZSA8L2NhcHRpb24+XG4gICAgICAqIGNvbnZlcnNhdGlvbi5zZW5kTWVzc2FnZSh7IFwibWVzc2FnZV90eXBlXCI6IFwidGV4dFwiLCBcInRleHRcIjogXCJIaSBWb25hZ2UhXCIgfSkudGhlbigoZXZlbnQpID0+IHtcbiAgICAgICogIGNvbnNvbGUubG9nKFwibWVzc2FnZSB3YXMgc2VudFwiLCBldmVudCk7XG4gICAgICAqIH0pLmNhdGNoKChlcnJvcik9PntcbiAgICAgICogIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBzZW5kaW5nIHRoZSBtZXNzYWdlIFwiLCBlcnJvcik7XG4gICAgICAqIH0pO1xuICAgICAgKlxuICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLm1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOnNlbGYnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5tZXNzYWdlX3R5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOm1lc3NhZ2UtZXZlbnQ6aW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIGNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLm1lLmlkLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHRpbWVzdGFtcCB9ID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICBkYXRhOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXNnLmlkID0gaWQ7XG4gICAgICAgICAgICBtc2cuYm9keS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VfZXZlbnRfMS5kZWZhdWx0KHRoaXMsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF90eXBpbmcoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgYWN0aXZpdHk6IChzdGF0ZSA9PT0gJ29uJykgPyAxIDogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQ6dHlwaW5nOicgKyBzdGF0ZSxcbiAgICAgICAgICAgIGNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGZyb206IHRoaXMubWUuaWQsXG4gICAgICAgICAgICBib2R5OiBwYXJhbXNcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMuaWR9L2V2ZW50c2AsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYHRleHQ6dHlwaW5nOiR7c3RhdGV9OnN1Y2Nlc3NgO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHN0YXJ0IHR5cGluZyBpbmRpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSByZXNvbHZlcyB0aGUgcHJvbWlzZSBvbiBzdWNjZXNzZnVsIHNlbnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPnNlbmQgc3RhcnQgdHlwaW5nIGV2ZW50IHdoZW4ga2V5IGlzIHByZXNzZWQ8L2NhcHRpb24+XG4gICAgICogbWVzc2FnZVRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICogICAgY29udmVyc2F0aW9uLnN0YXJ0VHlwaW5nKCk7XG4gICAgICogfSk7XG4gICAgKi9cbiAgICBzdGFydFR5cGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGluZygnb24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBzdG9wIHR5cGluZyBpbmRpY2F0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSByZXNvbHZlcyB0aGUgcHJvbWlzZSBvbiBzdWNjZXNzZnVsIHNlbnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPnNlbmQgc3RvcCB0eXBpbmcgZXZlbnQgd2hlbiBhIGtleSBoYXMgbm90IGJlZW4gcHJlc3NlZCBmb3IgaGFsZiBhIHNlY29uZDwvY2FwdGlvbj5cbiAgICAgKiBsZXQgdGltZW91dCA9IG51bGw7XG4gICAgICogbWVzc2FnZVRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICogICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAqICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgKiAgICAgIGNvbnZlcnNhdGlvbi5zdG9wVHlwaW5nKCk7XG4gICAgICogICAgfSwgNTAwKTtcbiAgICAgKiB9KTtcbiAgICAqL1xuICAgIHN0b3BUeXBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBpbmcoJ29mZicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gZ2V0IGEgbGlzdCBvZiBldmVudHMgaW4gdGhpcyBjb252ZXJzYXRpb24uXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgY29uZmlndXJlIGRlZmF1bHRzIGZvciBwYWdpbmF0ZWQgZXZlbnRzIHF1ZXJ5XG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMub3JkZXIgJ2FzYycgb3IgJ2Rlc2MnIG9yZGVyaW5nIG9mIHJlc291cmNlcyBiYXNlZCBvbiBjcmVhdGlvbiB0aW1lXG4gICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucGFnZV9zaXplIHRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHJldHVybmVkIGluIGEgc2luZ2xlIHJlcXVlc3QgbGlzdFxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5jdXJzb3JdIHN0cmluZyB0byBhY2Nlc3MgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGEgZGF0YXNldFxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5ldmVudF90eXBlXSB0aGUgdHlwZSBvZiBldmVudCB1c2VkIHRvIGZpbHRlciBldmVudCByZXF1ZXN0cy4gU3VwcG9ydHMgd2lsZGNhcmQgb3B0aW9ucyB3aXRoIDoqIGVnLiAnbWVtYmVyczoqJ1xuICAgICAgKlxuICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFdmVudHNQYWdlPE1hcDxFdmVudHM+Pj59IC0gUG9wdWxhdGUgQ29udmVyc2F0aW9ucy5ldmVudHMuXG4gICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdldCBFdmVudHM8L2NhcHRpb24+XG4gICAgICAqIGNvbnZlcnNhdGlvbi5nZXRFdmVudHMoeyBldmVudF90eXBlOiAnbWVtYmVyOionIH0pLnRoZW4oKGV2ZW50c19wYWdlKSA9PiB7XG4gICAgICAqICAgZXZlbnRzX3BhZ2UuaXRlbXMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAqICAgICByZW5kZXIoZXZlbnQpXG4gICAgICAqICAgfSlcbiAgICAgICogfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZ2V0dGluZyB0aGUgZXZlbnRzIFwiLCBlcnJvcik7XG4gICAgICAqIH0pO1xuICAgICovXG4gICAgYXN5bmMgZ2V0RXZlbnRzKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5jb25maWcubmV4bW9fYXBpX3VybH0vYmV0YTIvY29udmVyc2F0aW9ucy8ke3RoaXMuaWR9L2V2ZW50c2A7XG4gICAgICAgIC8vIENyZWF0ZSBwYWdlQ29uZmlnIGlmIGdpdmVuIHBhcmFtcyBvdGhlcndpc2UgdXNlIGRlZmF1bHRcbiAgICAgICAgbGV0IHBhZ2VDb25maWcgPSBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCA/IHRoaXMucGFnZUNvbmZpZyA6IG5ldyBwYWdlX2NvbmZpZ18xLmRlZmF1bHQocGFyYW1zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXRpbHNfMS5kZWZhdWx0LnBhZ2luYXRpb25SZXF1ZXN0KHVybCwgcGFnZUNvbmZpZywgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLmNvbmZpZy50b2tlbik7XG4gICAgICAgICAgICByZXNwb25zZS5hcHBsaWNhdGlvbiA9IHRoaXMuYXBwbGljYXRpb247XG4gICAgICAgICAgICByZXNwb25zZS5jb252ZXJzYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzX3BhZ2UgPSBuZXcgZXZlbnRzX3BhZ2VfMS5kZWZhdWx0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzX3BhZ2VfbGFzdCA9IGV2ZW50c19wYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50c19wYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gZ2V0IGEgbGlzdCBvZiBtZW1iZXJzIGluIHRoaXMgY29udmVyc2F0aW9uLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGNvbmZpZ3VyZSBkZWZhdWx0cyBmb3IgcGFnaW5hdGVkIGV2ZW50cyBxdWVyeVxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm9yZGVyICdhc2MnIG9yICdkZXNjJyBvcmRlcmluZyBvZiByZXNvdXJjZXMgYmFzZWQgb24gY3JlYXRpb24gdGltZVxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2Vfc2l6ZSB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyByZXR1cm5lZCBpbiBhIHNpbmdsZSByZXF1ZXN0IGxpc3RcbiAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY3Vyc29yXSBzdHJpbmcgdG8gYWNjZXNzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIGRhdGFzZXRcbiAgICAgICpcbiAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVtYmVyc1BhZ2U8TWFwPE1lbWJlcj4+Pn1cbiAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IE1lbWJlcnM8L2NhcHRpb24+XG4gICAgICAqIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICogICBvcmRlcjogXCJkZXNjXCIsXG4gICAgICAqICAgcGFnZV9zaXplOiAxMDBcbiAgICAgICogfVxuICAgICAgKiBjb252ZXJzYXRpb24uZ2V0TWVtYmVycyhwYXJhbXMpLnRoZW4oKG1lbWJlcnNfcGFnZSkgPT4ge1xuICAgICAgKiAgIG1lbWJlcnNfcGFnZS5pdGVtcy5mb3JFYWNoKG1lbWJlciA9PiB7XG4gICAgICAqICAgICByZW5kZXIobWVtYmVyKVxuICAgICAgKiAgIH0pXG4gICAgICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgKiAgY29uc29sZS5lcnJvcihcImVycm9yIGdldHRpbmcgdGhlIG1lbWJlcnMgXCIsIGVycm9yKTtcbiAgICAgICogfSk7XG4gICAgKi9cbiAgICBhc3luYyBnZXRNZW1iZXJzKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5jb25maWcubmV4bW9fYXBpX3VybH0vYmV0YTIvY29udmVyc2F0aW9ucy8ke3RoaXMuaWR9L21lbWJlcnNgO1xuICAgICAgICAvLyBDcmVhdGUgcGFnZUNvbmZpZyBpZiBnaXZlbiBwYXJhbXMgb3RoZXJ3aXNlIHVzZSBkZWZhdWx0XG4gICAgICAgIGxldCBwYWdlQ29uZmlnID0gT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDAgPyB0aGlzLnBhZ2VDb25maWcgOiBuZXcgcGFnZV9jb25maWdfMS5kZWZhdWx0KHBhcmFtcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHV0aWxzXzEuZGVmYXVsdC5wYWdpbmF0aW9uUmVxdWVzdCh1cmwsIHBhZ2VDb25maWcsIHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5jb25maWcudG9rZW4pO1xuICAgICAgICAgICAgcmVzcG9uc2UuYXBwbGljYXRpb24gPSB0aGlzLmFwcGxpY2F0aW9uO1xuICAgICAgICAgICAgcmVzcG9uc2UuY29udmVyc2F0aW9uID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlcnNfcGFnZSA9IG5ldyBtZW1iZXJzX3BhZ2VfMS5kZWZhdWx0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMubWVtYmVyc19wYWdlX2xhc3QgPSBtZW1iZXJzX3BhZ2U7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyc19wYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gZ2V0IG15IG1lbWJlciBpbiB0aGlzIGNvbnZlcnNhdGlvbi5cbiAgICAgICpcbiAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVtYmVyPn1cbiAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IE15IE1lbWJlcjwvY2FwdGlvbj5cbiAgICAgICogY29udmVyc2F0aW9uLmdldE15TWVtYmVyKCkudGhlbigobWVtYmVyKSA9PiB7XG4gICAgICAqICAgcmVuZGVyKG1lbWJlcilcbiAgICAgICogfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAqICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZ2V0dGluZyBteSBtZW1iZXJcIiwgZXJyb3IpO1xuICAgICAgKiB9KTtcbiAgICAqL1xuICAgIGFzeW5jIGdldE15TWVtYmVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMuaWR9L21lbWJlcnMvbWVgLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICd2MC4zJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtZW1iZXIgPSBuZXcgbWVtYmVyXzEuZGVmYXVsdCh0aGlzLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICogUXVlcnkgdGhlIHNlcnZpY2UgdG8gZ2V0IGEgbWVtYmVyIGluIHRoaXMgY29udmVyc2F0aW9uLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyX2lkIHRoZSBpZCBvZiB0aGUgbWVtYmVyIHRvIHJldHVyblxuICAgICAgKlxuICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZW1iZXI+fVxuICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZXQgTWVtYmVyPC9jYXB0aW9uPlxuICAgICAgKiBjb252ZXJzYXRpb24uZ2V0TWVtYmVyKFwiTUVNLWlkXCIpLnRoZW4oKG1lbWJlcikgPT4ge1xuICAgICAgKiAgIHJlbmRlcihtZW1iZXIpXG4gICAgICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgKiAgY29uc29sZS5lcnJvcihcImVycm9yIGdldHRpbmcgbWVtYmVyXCIsIGVycm9yKTtcbiAgICAgICogfSk7XG4gICAgKi9cbiAgICBhc3luYyBnZXRNZW1iZXIobWVtYmVyX2lkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5pZH0vbWVtYmVycy8ke21lbWJlcl9pZH1gLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICd2MC4zJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtZW1iZXIgPSBuZXcgbWVtYmVyXzEuZGVmYXVsdCh0aGlzLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW5kIGV2ZW50IGZyb20gdGhlIGNsb3VkLlxuICAgICAqIHVzaW5nIGNvbnZlcnNhdGlvbkV2ZW50SGFuZGxlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgncnRjJykpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgdGhlIHJ0YyBldmVudHMgZ29pbmcgdG8gdGhlIGFwcGxpY2F0aW9uIGxheWVyLCB3ZSB1c2UgdGhlbSBpbiBtZWRpYSBtb2R1bGVcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcXVlbmNlX251bWJlcisrO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGV2ZW50X2lkIGlzIG5vdCBhIHN0cmluZ1xuICAgICAgICBpZiAoZXZlbnQuYm9keSAmJiBldmVudC5ib2R5LmV2ZW50X2lkICYmIHR5cGVvZiBldmVudC5ib2R5LmV2ZW50X2lkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXZlbnQuYm9keS5ldmVudF9pZCA9IHBhcnNlSW50KGV2ZW50LmJvZHkuZXZlbnRfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZW1iZXJJbmZvID0geyBtZW1iZXJJZDogZXZlbnQuZnJvbSB9O1xuICAgICAgICBpZiAoKF9hID0gZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBuYW1lLCBkaXNwbGF5X25hbWUsIGltYWdlX3VybCwgY3VzdG9tX2RhdGEgfSA9IGV2ZW50LmJvZHkudXNlcjtcbiAgICAgICAgICAgIG1lbWJlckluZm8gPSB7IC4uLm1lbWJlckluZm8sIC4uLntcbiAgICAgICAgICAgICAgICAgICAgLi4uKGlkICYmIHsgdXNlcklkOiBpZCB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKG5hbWUgJiYgeyB1c2VyTmFtZTogbmFtZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGRpc3BsYXlfbmFtZSAmJiB7IGRpc3BsYXlOYW1lOiBkaXNwbGF5X25hbWUgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihpbWFnZV91cmwgJiYgeyBpbWFnZVVybDogaW1hZ2VfdXJsIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oY3VzdG9tX2RhdGEgJiYgeyBjdXN0b21EYXRhOiBjdXN0b21fZGF0YSB9KVxuICAgICAgICAgICAgICAgIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoX2IgPSBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQuX2VtYmVkZGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZnJvbV91c2VyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBuYW1lLCBkaXNwbGF5X25hbWUsIGltYWdlX3VybCwgY3VzdG9tX2RhdGEgfSA9IGV2ZW50Ll9lbWJlZGRlZC5mcm9tX3VzZXI7XG4gICAgICAgICAgICBtZW1iZXJJbmZvID0geyAuLi5tZW1iZXJJbmZvLCAuLi57XG4gICAgICAgICAgICAgICAgICAgIC4uLihpZCAmJiB7IHVzZXJJZDogaWQgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihuYW1lICYmIHsgdXNlck5hbWU6IG5hbWUgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihkaXNwbGF5X25hbWUgJiYgeyBkaXNwbGF5TmFtZTogZGlzcGxheV9uYW1lIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oaW1hZ2VfdXJsICYmIHsgaW1hZ2VVcmw6IGltYWdlX3VybCB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGN1c3RvbV9kYXRhICYmIHsgY3VzdG9tRGF0YTogY3VzdG9tX2RhdGEgfSlcbiAgICAgICAgICAgICAgICB9IH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnN0cnVjdGVkX2V2ZW50ID0gdGhpcy5jb252ZXJzYXRpb25FdmVudEhhbmRsZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAvLyBVbmxlc3MgdGhleSBhcmUgdHlwaW5nIGV2ZW50cywgYWRkIHRoZSBldmVudCB0byB0aGUgY29udmVyc2F0aW9uLmV2ZW50cyBtYXBcbiAgICAgICAgaWYgKCFbJ3RleHQ6dHlwaW5nOm9uJywgJ3RleHQ6dHlwaW5nOm9mZiddLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5zZXQoY29uc3RydWN0ZWRfZXZlbnQuaWQsIGNvbnN0cnVjdGVkX2V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgY3VzdG9tIGV2ZW50cyByZW1vdmUgdGhlIGN1c3RvbTogcHJlZml4IGJlZm9yZSBlbWl0dGluZyBldmVudFxuICAgICAgICBpZiAoZXZlbnQudHlwZS5zdGFydHNXaXRoKCdjdXN0b206JykpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChjb25zdHJ1Y3RlZF9ldmVudC50eXBlLCBtZW1iZXJJbmZvLCBjb25zdHJ1Y3RlZF9ldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXZlbnQudHlwZSwgbWVtYmVySW5mbywgY29uc3RydWN0ZWRfZXZlbnQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV2ZW50KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb252ZXJzYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IENvbnZlcnNhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKiAgSW1hZ2VFdmVudCBPYmplY3QgTW9kZWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiAqL1xuY29uc3QgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3QgbG9nbGV2ZWxfMSA9IHJlcXVpcmUoXCJsb2dsZXZlbFwiKTtcbmNvbnN0IG54bUV2ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbnhtRXZlbnRcIikpO1xuLyoqXG4gKiBBbiBpbWFnZSBldmVudFxuICpcbiAqIEBjbGFzcyBJbWFnZUV2ZW50XG4gKiBAZXh0ZW5kcyBOWE1FdmVudFxuKi9cbmNsYXNzIEltYWdlRXZlbnQgZXh0ZW5kcyBueG1FdmVudF8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnZlcnNhdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKGNvbnZlcnNhdGlvbiwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dsZXZlbF8xLmdldExvZ2dlcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IGNvbnZlcnNhdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlZW5fYnk6IHt9LFxuICAgICAgICAgICAgZGVsaXZlcmVkX3RvOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5ib2R5ICYmIHBhcmFtcy5ib2R5LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBwYXJhbXMuYm9keS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGltYWdlRXZlbnQgc3RhdHVzIHRvICdzZWVuJ1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCB0aGUgaW1hZ2VFdmVudCBzdGF0dXMgdG8gJ3NlZW4nPC9jYXB0aW9uPlxuICAgICAqICBpbWFnZUV2ZW50LnNlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcImltYWdlIGV2ZW50IHN0YXR1cyBzZXQgdG8gc2VlblwiKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAqXHRjb25zb2xlLmxvZyhcImVycm9yIHNldHRpbmcgaW1hZ2UgZXZlbnQgc3RhdHVzIHRvIHNlZW4gXCIsIGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgc2VlbigpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNlZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbWFnZUV2ZW50IHN0YXR1cyB0byAnZGVsaXZlcmVkJ1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCB0aGUgaW1hZ2VFdmVudCBzdGF0dXMgdG8gJ2RlbGl2ZXJlZCc8L2NhcHRpb24+XG4gICAgICogIGltYWdlRXZlbnQuZGVsaXZlcmVkKCkudGhlbigoKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJpbWFnZSBldmVudCBzdGF0dXMgc2V0IHRvIGRlbGl2ZXJlZFwiKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAqXHRjb25zb2xlLmxvZyhcImVycm9yIHNldHRpbmcgaW1hZ2UgZXZlbnQgc3RhdHVzIHRvIGRlbGl2ZXJlZCAgXCIsIGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgZGVsaXZlcmVkKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGVsaXZlcmVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgaW1hZ2UgZXZlbnQsIGFsbCAzIHJlcHJlc2VudGF0aW9ucyBvZiBpdFxuICAgICAqIHBhc3Npbmcgb25seSB0aGUgb25lIG9mIHRoZSB0aHJlZSBVUkxzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RGVsZXRlIHRoZSBpbWFnZUV2ZW50PC9jYXB0aW9uPlxuICAgICAqICBpbWFnZUV2ZW50LmRlbCgpLnRoZW4oKCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwiaW1hZ2UgZXZlbnQgZGVsZXRlZFwiKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAqXHRjb25zb2xlLmxvZyhcImVycm9yIGRlbGV0aW5nIGltYWdlIGV2ZW50ICBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBhc3luYyBkZWwoKSB7XG4gICAgICAgIGF3YWl0IHV0aWxzXzEuZGVmYXVsdC5uZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICAgICAgICAgIHVybDogdGhpcy5ib2R5LnJlcHJlc2VudGF0aW9ucy5vcmlnaW5hbC51cmwsXG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jb252ZXJzYXRpb24uYXBwbGljYXRpb24uc2Vzc2lvbi5jb25maWcudG9rZW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdXBlci5kZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWQgYW4gSW1hZ2UgZnJvbSBNZWRpYSBzZXJ2aWNlIC8vMyByZXByZXNlbnRhdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9XCJ0aHVtYm5haWxcIl0gb3JpZ2luYWwsIG1lZGl1bSwgb3IgdGh1bWJuYWlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXByZXNlbnRhdGlvbnM9dGhpcy5ib2R5LnJlcHJlc2VudGF0aW9uc10gIHRoZSBJbWFnZUV2ZW50LmJvZHkgZm9yIHRoZSBpbWFnZSB0byBkb3dubG9hZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBkYXRhVXJsIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NC4uLlwiXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RG93bmxvYWRpbmcgYW4gaW1hZ2UgZnJvbSB0aGUgaW1hZ2VFdmVudDwvY2FwdGlvbj5cbiAgICAgKiAgaW1hZ2VFdmVudC5mZXRjaEltYWdlKFwibWVkaXVtXCIpLnRoZW4oKGltYWdlRGF0YSkgPT4ge1xuICAgICAqICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAqICAgIGltZy5zcmMgPSBpbWFnZURhdGE7XG4gICAgICogICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpPT57XG4gICAgICpcdGNvbnNvbGUubG9nKFwiZXJyb3IgZ2V0dGluZyBpbWFnZSBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGFzeW5jIGZldGNoSW1hZ2UodHlwZSA9ICd0aHVtYm5haWwnLCBpbWFnZVJlcHJlc2VudGF0aW9ucyA9IHRoaXMuYm9keS5yZXByZXNlbnRhdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmRlZmF1bHQuX2ZldGNoSW1hZ2UoaW1hZ2VSZXByZXNlbnRhdGlvbnNbdHlwZV0udXJsLCB0aGlzLmNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5zZXNzaW9uLmNvbmZpZy50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEltYWdlRXZlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICogIE1lc3NhZ2UgTlhNRXZlbnQgT2JqZWN0IE1vZGVsXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4qL1xuY29uc3QgbG9nbGV2ZWxfMSA9IHJlcXVpcmUoXCJsb2dsZXZlbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG54bUV2ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbnhtRXZlbnRcIikpO1xuY29uc3QgbmV4bW9DbGllbnRFcnJvcl8xID0gcmVxdWlyZShcIi4uL25leG1vQ2xpZW50RXJyb3JcIik7XG4vKipcbiAqIEEgbWVzc2FnZSBldmVudFxuICpcbiAqIEBjbGFzcyBNZXNzYWdlRXZlbnRcbiAqIEBleHRlbmRzIE5YTUV2ZW50XG4qL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgbnhtRXZlbnRfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb252ZXJzYXRpb24sIHBhcmFtcykge1xuICAgICAgICBzdXBlcihjb252ZXJzYXRpb24sIHBhcmFtcyk7XG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ21lc3NhZ2UnO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IGNvbnZlcnNhdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlZW5fYnk6IHt9LFxuICAgICAgICAgICAgZGVsaXZlcmVkX3RvOiB7fSxcbiAgICAgICAgICAgIHN1Ym1pdHRlZF90bzoge30sXG4gICAgICAgICAgICByZWplY3RlZF9ieToge30sXG4gICAgICAgICAgICB1bmRlbGl2ZXJhYmxlX3RvOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5ib2R5ICYmIHBhcmFtcy5ib2R5LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBwYXJhbXMuYm9keS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1lc3NhZ2VFdmVudCBzdGF0dXMgdG8gJ3NlZW4nXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2V0IHRoZSBtZXNzYWdlRXZlbnQgc3RhdHVzIHRvICdzZWVuJzwvY2FwdGlvbj5cbiAgICAgKiAgbWVzc2FnZUV2ZW50LnNlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIm1lc3NhZ2UgZXZlbnQgc3RhdHVzIHNldCB0byBzZWVuXCIpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpPT57XG4gICAgICpcdCAgY29uc29sZS5sb2coXCJlcnJvciBzZXR0aW5nIG1lc3NhZ2UgZXZlbnQgc3RhdHVzIHRvIHNlZW4gXCIsIGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgc2VlbigpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNlZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtZXNzYWdlRXZlbnQgc3RhdHVzIHRvICdkZWxpdmVyZWQnLlxuICAgICAqIGhhbmRsZWQgYnkgdGhlIFNES1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCB0aGUgbWVzc2FnZUV2ZW50IHN0YXR1cyB0byAnZGVsaXZlcmVkJzwvY2FwdGlvbj5cbiAgICAgKiAgbWVzc2FnZUV2ZW50LmRlbGl2ZXJlZCgpLnRoZW4oKCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwibWVzc2FnZSBldmVudCBzdGF0dXMgc2V0IHRvIGRlbGl2ZXJlZFwiKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAqXHQgIGNvbnNvbGUubG9nKFwiZXJyb3Igc2V0dGluZyBtZXNzYWdlIGV2ZW50IHN0YXR1cyB0byBkZWxpdmVyZWQgIFwiLCBlcnJvcik7XG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIGRlbGl2ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlbGl2ZXJlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIG1lc3NhZ2VFdmVudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGV0ZSB0aGUgbWVzc2FnZUV2ZW50PC9jYXB0aW9uPlxuICAgICAqICBtZXNzYWdlRXZlbnQuZGVsKCkudGhlbigoKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJtZXNzYWdlIGV2ZW50IGRlbGV0ZWRcIik7XG4gICAgICogIH0pLmNhdGNoKChlcnJvcik9PntcbiAgICAgKlx0ICBjb25zb2xlLmxvZyhcImVycm9yIGRlbGV0aW5nIG1lc3NhZ2UgZXZlbnQgIFwiLCBlcnJvcik7XG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIGRlbCgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbiBJbWFnZSBmcm9tIE1lZGlhIHNlcnZpY2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZGF0YVVybCBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQuLi5cIlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkRvd25sb2FkaW5nIGFuIGltYWdlIGZyb20gdGhlIG1lc3NhZ2VFdmVudDwvY2FwdGlvbj5cbiAgICAgKiAgbWVzc2FnZUV2ZW50LmZldGNoSW1hZ2UoKS50aGVuKChpbWFnZURhdGEpID0+IHtcbiAgICAgKiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgKiAgICBpbWcuc3JjID0gaW1hZ2VEYXRhO1xuICAgICAqICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJlcnJvciBnZXR0aW5nIGltYWdlIFwiLCBlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgYXN5bmMgZmV0Y2hJbWFnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5tZXNzYWdlX3R5cGUgIT09IFwiaW1hZ2VcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKCdlcnJvcjptZXNzYWdlLWV2ZW50OmludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuZGVmYXVsdC5fZmV0Y2hJbWFnZSh0aGlzLmJvZHkuaW1hZ2UudXJsLCB0aGlzLmNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5zZXNzaW9uLmNvbmZpZy50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2VFdmVudDtcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZUV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBOWE1FdmVudCBPYmplY3QgTW9kZWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiovXG5jb25zdCBXaWxkRW1pdHRlciA9IHJlcXVpcmUoJ3dpbGRlbWl0dGVyJyk7XG5jb25zdCBuZXhtb0NsaWVudEVycm9yXzEgPSByZXF1aXJlKFwiLi4vbmV4bW9DbGllbnRFcnJvclwiKTtcbi8qKlxuICogQ29udmVyc2F0aW9uIE5YTUV2ZW50IE9iamVjdC5cbiAqIFRoZSBzdXBlciBjbGFzcyB0aGF0IGhvbGRzIHRoZSBiYXNlIGV2ZW50cyB0aGF0IGFwcGx5IHRvXG4gKiBjb21tb24gZXZlbnQgb2JqZWN0cy5cbiAqIEBjbGFzcyBOWE1FdmVudFxuICovXG5jbGFzcyBOWE1FdmVudCB7XG4gICAgY29uc3RydWN0b3IoY29udmVyc2F0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IGNvbnZlcnNhdGlvbjtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnR5cGUuc3RhcnRzV2l0aCgnY3VzdG9tOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gcGFyYW1zLnR5cGUucmVwbGFjZSgnY3VzdG9tOicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHBhcmFtcy50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uX2lkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25faWQgPSBwYXJhbXMuYXBwbGljYXRpb25faWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2lkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2lkID0gcGFyYW1zLmNpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmcm9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbJ21lbWJlcjppbnZpdGVkJywgJ21lbWJlcjpqb2luZWQnLCAnbWVtYmVyOmxlZnQnXS5pbmRleE9mKHBhcmFtcy50eXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHBhcmFtcy5fZW1iZWRkZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tX21lbWJlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IChfZCA9IChfYyA9IHBhcmFtcy5fZW1iZWRkZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mcm9tX21lbWJlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IHBhcmFtcy5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHBhcmFtcy50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyYW1zLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luZGV4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBwYXJhbXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyZWFtSW5kZXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmRleCA9IHBhcmFtcy5zdHJlYW1JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9keSA9IHBhcmFtcy5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS51c2VyICYmIHRoaXMuYm9keS51c2VyLnVzZXJfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvZHkudXNlci5pZCA9IHRoaXMuYm9keS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYm9keS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib2R5LmRpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWdpdCA9IHRoaXMuYm9keS5kaWdpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ib2R5LmRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5kaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpZ2l0ID0gdGhpcy5ib2R5LmRpZ2l0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ib2R5LmRpZ2l0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBXaWxkRW1pdHRlci5taXhpbihOWE1FdmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2V2ZW50X2lkPXRoaXMuZXZlbnRfaWRdIGlmIHRoZSBldmVudCBpZCBwYXJhbSBpcyBub3QgcHJlc2VudCwgXCJ0aGlzXCIgZXZlbnQgd2lsbCBiZSBkZWZhdWx0XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIGRlbChldmVudF9pZCA9IHRoaXMuaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMuY29udmVyc2F0aW9uLmlkfS9ldmVudHMvJHtldmVudF9pZH0/ZnJvbT0ke3RoaXMuY29udmVyc2F0aW9uLm1lLmlkfWAsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJ2JldGEyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgYXMgRGVsaXZlcmVkIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZXZlbnRfaWQ9dGhpcy5ldmVudF9pZF0gaWYgdGhlIGV2ZW50IGlkIGlzIG5vdCBwcm92aWRlZCwgdGhlIHRoaXMgZXZlbnQgd2lsbCBiZSB1c2VkXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBkZWxpdmVyZWQoZXZlbnRfaWQgPSB0aGlzLmlkKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0JyAmJiB0aGlzLnR5cGUgIT09ICdpbWFnZScgJiYgdGhpcy50eXBlICE9PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdldmVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udmVyc2F0aW9uLm1lLmlkID09PSB0aGlzLmZyb20pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcignZXJyb3I6ZGVsaXZlcmVkOm93bi1tZXNzYWdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLmRlbGl2ZXJlZF90byAmJiB0aGlzLnN0YXRlLmRlbGl2ZXJlZF90b1t0aGlzLmNvbnZlcnNhdGlvbi5tZS5pZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcignZXJyb3I6YWxyZWFkeS1kZWxpdmVyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb252ZXJzYXRpb24uYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5jb252ZXJzYXRpb24uaWR9L2V2ZW50c2AsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGAke3RoaXMudHlwZX06ZGVsaXZlcmVkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuY29udmVyc2F0aW9uLm1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50X2lkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgYXMgU2VlbiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2V2ZW50X2lkPXRoaXMuZXZlbnRfaWRdIGlmIHRoZSBldmVudCBpZCBpcyBub3QgcHJvdmlkZWQsIHRoZSB0aGlzIGV2ZW50IHdpbGwgYmUgdXNlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBhc3luYyBzZWVuKGV2ZW50X2lkID0gdGhpcy5pZCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcgJiYgdGhpcy50eXBlICE9PSAnaW1hZ2UnICYmIHRoaXMudHlwZSAhPT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZXZlbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnZlcnNhdGlvbi5tZS5pZCA9PT0gdGhpcy5mcm9tKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOnNlZW46b3duLW1lc3NhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUuc2Vlbl9ieSAmJiB0aGlzLnN0YXRlLnNlZW5fYnlbdGhpcy5jb252ZXJzYXRpb24ubWUuaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOmFscmVhZHktc2VlbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLmNvbnZlcnNhdGlvbi5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7dGhpcy50eXBlfTpzZWVuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuY29udmVyc2F0aW9uLm1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50X2lkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTlhNRXZlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IE5YTUV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBUZXh0IE5YTUV2ZW50IE9iamVjdCBNb2RlbFxuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuKi9cbmNvbnN0IG54bUV2ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbnhtRXZlbnRcIikpO1xuLyoqXG4gKiBBIHRleHQgZXZlbnRcbiAqXG4gKiBAY2xhc3MgVGV4dEV2ZW50XG4gKiBAZXh0ZW5kcyBOWE1FdmVudFxuKi9cbmNsYXNzIFRleHRFdmVudCBleHRlbmRzIG54bUV2ZW50XzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoY29udmVyc2F0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoY29udmVyc2F0aW9uLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMuY29udmVyc2F0aW9uID0gY29udmVyc2F0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2Vlbl9ieToge30sXG4gICAgICAgICAgICBkZWxpdmVyZWRfdG86IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmJvZHkgJiYgcGFyYW1zLmJvZHkudGltZXN0YW1wKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHBhcmFtcy5ib2R5LnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGV4dEV2ZW50IHN0YXR1cyB0byAnc2VlbidcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZXQgdGhlIHRleHRFdmVudCBzdGF0dXMgdG8gJ3NlZW4nPC9jYXB0aW9uPlxuICAgICAqICB0ZXh0RXZlbnQuc2VlbigpLnRoZW4oKCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwidGV4dCBldmVudCBzdGF0dXMgc2V0IHRvIHNlZW5cIik7XG4gICAgICogIH0pLmNhdGNoKChlcnJvcik9PntcbiAgICAgKlx0Y29uc29sZS5sb2coXCJlcnJvciBzZXR0aW5nIHRleHQgZXZlbnQgc3RhdHVzIHRvIHNlZW4gXCIsIGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgc2VlbigpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNlZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZXh0RXZlbnQgc3RhdHVzIHRvICdkZWxpdmVyZWQnLlxuICAgICAqIGhhbmRsZWQgYnkgdGhlIFNES1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNldCB0aGUgdGV4dEV2ZW50IHN0YXR1cyB0byAnZGVsaXZlcmVkJzwvY2FwdGlvbj5cbiAgICAgKiAgdGV4dEV2ZW50LmRlbGl2ZXJlZCgpLnRoZW4oKCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwidGV4dCBldmVudCBzdGF0dXMgc2V0IHRvIGRlbGl2ZXJlZFwiKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKT0+e1xuICAgICAqXHRjb25zb2xlLmxvZyhcImVycm9yIHNldHRpbmcgdGV4dCBldmVudCBzdGF0dXMgdG8gZGVsaXZlcmVkICBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAgKi9cbiAgICBkZWxpdmVyZWQoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5kZWxpdmVyZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSB0ZXh0RXZlbnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxldGUgdGhlIHRleHRFdmVudDwvY2FwdGlvbj5cbiAgICAgKiAgdGV4dEV2ZW50LmRlbCgpLnRoZW4oKCkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwidGV4dCBldmVudCBkZWxldGVkXCIpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpPT57XG4gICAgICpcdGNvbnNvbGUubG9nKFwiZXJyb3IgZGVsZXRpbmcgdGV4dCBldmVudCAgXCIsIGVycm9yKTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgZGVsKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGVsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dEV2ZW50O1xubW9kdWxlLmV4cG9ydHMgPSBUZXh0RXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICogIEFwcGxpY2F0aW9uIEV2ZW50cyBIYW5kbGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4gKi9cbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5jb25zdCBueG1FdmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvbnhtRXZlbnRcIikpO1xuY29uc3QgbnhtQ2FsbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tb2R1bGVzL254bUNhbGxcIikpO1xuY29uc3QgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3QgcnRjX2hlbHBlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tb2R1bGVzL3J0Y19oZWxwZXJcIikpO1xuLyoqXG4gKiBIYW5kbGUgQXBwbGljYXRpb24gRXZlbnRzXG4gKlxuICogQGNsYXNzIEFwcGxpY2F0aW9uRXZlbnRzSGFuZGxlclxuICogQHBhcmFtIHtBcHBsaWNhdGlvbn0gYXBwbGljYXRpb25cbiAqIEBwYXJhbSB7Q29udmVyc2F0aW9ufSBjb252ZXJzYXRpb25cbiAqIEBwcml2YXRlXG4qL1xuY2xhc3MgQXBwbGljYXRpb25FdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvbikge1xuICAgICAgICB0aGlzLmxvZyA9IGxvZ2xldmVsXzEuZ2V0TG9nZ2VyKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5faGFuZGxlQXBwbGljYXRpb25FdmVudE1hcCA9IHtcbiAgICAgICAgICAgICdtZW1iZXI6am9pbmVkJzogdGhpcy5fcHJvY2Vzc01lbWJlckpvaW5lZCxcbiAgICAgICAgICAgICdtZW1iZXI6aW52aXRlZCc6IHRoaXMuX3Byb2Nlc3NNZW1iZXJJbnZpdGVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBIYW5kbGUgYW5kIGV2ZW50LlxuICAgICAgKlxuICAgICAgKiBVcGRhdGUgdGhlIGV2ZW50IHRvIG1hcCBsb2NhbCBnZW5lcmF0ZWQgZXZlbnRzXG4gICAgICAqIGluIGNhc2Ugd2UgbmVlZCBhIG1vcmUgc3BlY2lmaWMgZXZlbnQgdG8gcGFzcyBpbiB0aGUgYXBwbGljYXRpb24gbGlzdGVuZXJcbiAgICAgICogb3IgZi93IHRoZSBldmVudCBhcyBpdCBjb21lc1xuICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuYXBwbGljYXRpb24uY29udmVyc2F0aW9ucy5nZXQoZXZlbnQuY2lkKTtcbiAgICAgICAgY29uc3QgY29waWVkX2V2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5faGFuZGxlQXBwbGljYXRpb25FdmVudE1hcC5oYXNPd25Qcm9wZXJ0eShldmVudC50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUFwcGxpY2F0aW9uRXZlbnRNYXBbZXZlbnQudHlwZV0uY2FsbCh0aGlzLCBjb252ZXJzYXRpb24sIG5ldyBueG1FdmVudF8xLmRlZmF1bHQoY29udmVyc2F0aW9uLCBjb3BpZWRfZXZlbnQpLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBueG1FdmVudF8xLmRlZmF1bHQoY29udmVyc2F0aW9uLCBjb3BpZWRfZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogY2FzZTogY2FsbCB0byBQU1ROLCBhZnRlciBrbm9ja2luZyBldmVudCB3ZSByZWNlaXZlIGpvaW5lZFxuICAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3Byb2Nlc3NNZW1iZXJKb2luZWQoY29udmVyc2F0aW9uLCBldmVudCwgcmF3X2V2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuYm9keS5jaGFubmVsICYmIHRoaXMuYXBwbGljYXRpb24uX2NhbGxfZHJhZnRfbGlzdC5oYXMoZXZlbnQuYm9keS5jaGFubmVsLmlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiX3Byb2Nlc3NNZW1iZXJKb2luZWQ6IG91dGJvdW5kIHNlcnZlckNhbGwgZnJvbSBzZGtcIiwgeyBldmVudCB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBueG1DYWxsID0gdGhpcy5hcHBsaWNhdGlvbi5fY2FsbF9kcmFmdF9saXN0LmdldChldmVudC5ib2R5LmNoYW5uZWwuaWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYyA9ICgobnhtQ2FsbC5ydGNPYmplY3RzIHx8IHt9KVtldmVudC5ib2R5LmNoYW5uZWwuaWRdIHx8IHt9KS5wYztcbiAgICAgICAgICAgICAgICBueG1DYWxsLl9zZXRGcm9tKGNvbnZlcnNhdGlvbi5tZSk7XG4gICAgICAgICAgICAgICAgbnhtQ2FsbC5fc2V0dXBDb252ZXJzYXRpb25PYmplY3QoY29udmVyc2F0aW9uLCBldmVudC5ib2R5LmNoYW5uZWwuaWQpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgbWVkaWEgb2JqZWN0cyB0byBuZXcgY29udmVyc2F0aW9uIGZyb20gcGxhY2Vob2xkZXIgaW4gY2FsbFxuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5tZWRpYS5fYXR0YWNoRW5kaW5nRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNraW5nIHRvIHNlZSBpZiBwbGFjZWhvbGRlciBOeG1DYWxsIGhhcyBydGNPYmplY3QsIHBjIG9yIGFjdGl2ZVN0cmVhbXMgd2hpbGUgbmV3IGNvbnZlcnNhdGlvbiBkb2VzIG5vdCBhbmQgaWYgc28gYWRkXG4gICAgICAgICAgICAgICAgLy8gdG8gbmV3IGNvbnZlcnNhdGlvbiB0aGUgbWlzc2luZyBydGNPYmplY3QsIHBjIG9yIGFjdGl2ZVN0cmVhbVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZW50cmllcyhjb252ZXJzYXRpb24ubWVkaWEucnRjT2JqZWN0cykubGVuZ3RoID09PSAwICYmIE9iamVjdC5lbnRyaWVzKG54bUNhbGwucnRjT2JqZWN0cykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udmVyc2F0aW9uLm1lZGlhLnJ0Y09iamVjdHMsIG54bUNhbGwucnRjT2JqZWN0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29udmVyc2F0aW9uLm1lZGlhLnBjICYmIHBjKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udmVyc2F0aW9uLm1lZGlhLnBjID0gcGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLmFjdGl2ZVN0cmVhbXMubGVuZ3RoID09PSAwICYmIG54bUNhbGwuYXBwbGljYXRpb24uYWN0aXZlU3RyZWFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5hY3RpdmVTdHJlYW1zID0gbnhtQ2FsbC5hcHBsaWNhdGlvbi5hY3RpdmVTdHJlYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgbnhtQ2FsbC5jbGllbnRfcmVmO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBueG1DYWxsLmtub2NraW5nX2lkO1xuICAgICAgICAgICAgICAgIC8vIGlmIHJ0Y1N0YXRzIG9uIGNhbGwgb2JqZWN0IHBsYWNlIG9uIG1lZGlhIG9iamVjdCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgaWYgKG54bUNhbGwucnRjU3RhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uLm1lZGlhLnJ0Y1N0YXRzID0gbnhtQ2FsbC5ydGNTdGF0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsZWdfaWQgZnJvbSB0aGUgY2FsbF9kcmFmdF9saXN0XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5fY2FsbF9kcmFmdF9saXN0LmRlbGV0ZShldmVudC5ib2R5LmNoYW5uZWwuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24uY2FsbHMuc2V0KGNvbnZlcnNhdGlvbi5pZCwgbnhtQ2FsbCk7XG4gICAgICAgICAgICAgICAgbnhtQ2FsbC5faGFuZGxlU3RhdHVzQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIl9wcm9jZXNzTWVtYmVySm9pbmVkOiBwcm9jZXNzZWRDYWxsIFwiLCB7IG54bUNhbGwgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnZlcnNhdGlvbi5tZW1iZXJzICYmIGV2ZW50LmJvZHkubWVtYmVyX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IGNvbnZlcnNhdGlvbi5tZW1iZXJzLmdldChldmVudC5ib2R5Lm1lbWJlcl9pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmVtaXQoJ21lbWJlcjpjYWxsJywgbWVtYmVyLCBueG1DYWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydHMgb2xkIHdheSBvZiBsaXN0ZW5pbmcgZm9yIHRoZSBtZWRpYSBzdHJlYW0gYWZ0ZXIgdGhlIGNvbnZlcnNhdGlvbiBpcyBzZXQgdXAgZXZlbiB0aG91Z2ggaXRzIGFscmVhZHkgdGhlcmVcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnNhdGlvbiA9PT0gbnVsbCB8fCBjb252ZXJzYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnZlcnNhdGlvbi5tZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0Y19oZWxwZXJfMS5kZWZhdWx0LmVtaXRNZWRpYVN0cmVhbShjb252ZXJzYXRpb24ubWUsIHBjLCBueG1DYWxsLnN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiX3Byb2Nlc3NNZW1iZXJKb2luZWQ6IGRlZmF1bHQgbWVtYmVyIGpvaW5lZDogXCIsIHsgZXZlbnQgfSk7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFwiX3Byb2Nlc3NNZW1iZXJKb2luZWQ6IFwiLCB7IGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3NNZW1iZXJJbnZpdGVkKGNvbnZlcnNhdGlvbiwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYG5vIGNvbnZlcnNhdGlvbiBvYmplY3QgZm9yICR7ZXZlbnQudHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHByb2Nlc3MgdGhlIGV2ZW50IGlmIGl0J3Mgbm90IG1lZGlhIHJlbGF0ZWQgaW52aXRlLCBvciB0aGUgbWVtYmVyIGlzIHVzXG4gICAgICAgICAgICBpZiAoKCgoX2EgPSBjb252ZXJzYXRpb24ubWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VyLmlkKSA9PT0gZXZlbnQuYm9keS5pbnZpdGVkX2J5KSB8fCAhKChfYyA9IChfYiA9IGV2ZW50LmJvZHkudXNlci5tZWRpYSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmF1ZGlvX3NldHRpbmdzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW5hYmxlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsZXIgPSB1dGlsc18xLmRlZmF1bHQuZ2V0TWVtYmVyTnVtYmVyRnJvbUV2ZW50T3JOdWxsKGV2ZW50LmJvZHkuY2hhbm5lbCkgfHxcbiAgICAgICAgICAgICAgICB1dGlsc18xLmRlZmF1bHQuZ2V0TWVtYmVyRnJvbU5hbWVPck51bGwoY29udmVyc2F0aW9uLCBldmVudC5ib2R5Lmludml0ZWRfYnkpIHx8ICd1bmtub3duJztcbiAgICAgICAgICAgIGNvbnN0IG54bUNhbGwgPSBuZXcgbnhtQ2FsbF8xLmRlZmF1bHQodGhpcy5hcHBsaWNhdGlvbiwgY29udmVyc2F0aW9uLCBjYWxsZXIpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5jYWxscy5zZXQoY29udmVyc2F0aW9uLmlkLCBueG1DYWxsKTtcbiAgICAgICAgICAgIGlmICgoKF9kID0gZXZlbnQuYm9keSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNkcCkgJiYgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLmNvbmZpZy5lbmFibGVJbmJvdW5kT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICBueG1DYWxsLl9zZXRPZmZlcih7IHNkcDogZXZlbnQuYm9keS5zZHAsIGxlZ19pZDogZXZlbnQuYm9keS5jaGFubmVsLmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gKFZBUEkgY2FsbClcbiAgICAgICAgICAgIGlmICghKChfZSA9IGNvbnZlcnNhdGlvbi5kaXNwbGF5X25hbWUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zdGFydHNXaXRoKCdDQUxMXycpKSkge1xuICAgICAgICAgICAgICAgIG54bUNhbGwuX2hhbmRsZVN0YXR1c0NoYW5nZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmVtaXQoJ21lbWJlcjpjYWxsJywgdGhpcy5hcHBsaWNhdGlvbi5jb252ZXJzYXRpb25zLmdldChldmVudC5jaWQpLm1lbWJlcnMuZ2V0KChfZiA9IGV2ZW50LmJvZHkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tZW1iZXJfaWQpLCBueG1DYWxsKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJfcHJvY2Vzc01lbWJlckludml0ZWQ6IFwiLCB7IGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBcHBsaWNhdGlvbkV2ZW50c0hhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEFwcGxpY2F0aW9uRXZlbnRzSGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKiAgQ29udmVyc2F0aW9uIEV2ZW50cyBIYW5kbGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4gKi9cbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5jb25zdCBueG1FdmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvbnhtRXZlbnRcIikpO1xuY29uc3QgdGV4dF9ldmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvdGV4dF9ldmVudFwiKSk7XG5jb25zdCBpbWFnZV9ldmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvaW1hZ2VfZXZlbnRcIikpO1xuY29uc3QgbWVzc2FnZV9ldmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvbWVzc2FnZV9ldmVudFwiKSk7XG4vKipcbiAqIEhhbmRsZSBDb252ZXJzYXRpb24gRXZlbnRzXG4gKlxuICogQGNsYXNzIENvbnZlcnNhdGlvbkV2ZW50c0hhbmRsZXJcbiAqIEBwYXJhbSB7QXBwbGljYXRpb259IGFwcGxpY2F0aW9uXG4gKiBAcGFyYW0ge0NvbnZlcnNhdGlvbn0gY29udmVyc2F0aW9uXG4gKiBAcHJpdmF0ZVxuKi9cbmNsYXNzIENvbnZlcnNhdGlvbkV2ZW50SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24sIGNvbnZlcnNhdGlvbikge1xuICAgICAgICB0aGlzLmxvZyA9IGxvZ2xldmVsXzEuZ2V0TG9nZ2VyKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252ZXJzYXRpb247XG4gICAgICAgIHRoaXMuY29uc3RydWN0ZWRfZXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9oYW5kbGVFdmVudE1hcCA9IHtcbiAgICAgICAgICAgICdldmVudDpkZWxldGUnOiB0aGlzLl9wcm9jZXNzRGVsZXRlLFxuICAgICAgICAgICAgJ2ltYWdlJzogdGhpcy5fcHJvY2Vzc0ltYWdlLFxuICAgICAgICAgICAgJ2ltYWdlOmRlbGl2ZXJlZCc6IHRoaXMuX3Byb2Nlc3NEZWxpdmVyZWQsXG4gICAgICAgICAgICAnaW1hZ2U6c2Vlbic6IHRoaXMuX3Byb2Nlc3NTZWVuLFxuICAgICAgICAgICAgJ21lbWJlcjppbnZpdGVkJzogdGhpcy5fcHJvY2Vzc01lbWJlcixcbiAgICAgICAgICAgICdtZW1iZXI6am9pbmVkJzogdGhpcy5fcHJvY2Vzc01lbWJlcixcbiAgICAgICAgICAgICdtZW1iZXI6bGVmdCc6IHRoaXMuX3Byb2Nlc3NNZW1iZXIsXG4gICAgICAgICAgICAnYXVkaW86cmluZ2luZzpzdGFydCc6IHRoaXMuX3Byb2Nlc3NNZW1iZXIsXG4gICAgICAgICAgICAnbGVnOnN0YXR1czp1cGRhdGUnOiB0aGlzLl9wcm9jZXNzTGVnU3RhdHVzLFxuICAgICAgICAgICAgJ21lbWJlcjptZWRpYSc6IHRoaXMuX3Byb2Nlc3NNZWRpYSxcbiAgICAgICAgICAgICd0ZXh0JzogdGhpcy5fcHJvY2Vzc1RleHQsXG4gICAgICAgICAgICAndGV4dDpkZWxpdmVyZWQnOiB0aGlzLl9wcm9jZXNzRGVsaXZlcmVkLFxuICAgICAgICAgICAgJ3RleHQ6c2Vlbic6IHRoaXMuX3Byb2Nlc3NTZWVuLFxuICAgICAgICAgICAgJ2F1ZGlvOm11dGU6b24nOiB0aGlzLl9wcm9jZXNzTXV0ZUZvck1lZGlhLFxuICAgICAgICAgICAgJ2F1ZGlvOm11dGU6b2ZmJzogdGhpcy5fcHJvY2Vzc011dGVGb3JNZWRpYSxcbiAgICAgICAgICAgICdtZXNzYWdlJzogdGhpcy5fcHJvY2Vzc01lc3NhZ2UsXG4gICAgICAgICAgICAnbWVzc2FnZTpkZWxpdmVyZWQnOiB0aGlzLl9wcm9jZXNzRGVsaXZlcmVkLFxuICAgICAgICAgICAgJ21lc3NhZ2U6c2Vlbic6IHRoaXMuX3Byb2Nlc3NTZWVuLFxuICAgICAgICAgICAgJ21lc3NhZ2U6c3VibWl0dGVkJzogdGhpcy5fcHJvY2Vzc1N1Ym1pdHRlZCxcbiAgICAgICAgICAgICdtZXNzYWdlOnJlamVjdGVkJzogdGhpcy5fcHJvY2Vzc1JlamVjdGVkLFxuICAgICAgICAgICAgJ21lc3NhZ2U6dW5kZWxpdmVyYWJsZSc6IHRoaXMuX3Byb2Nlc3NVbmRlbGl2ZXJhYmxlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBIYW5kbGUgYW5kIGV2ZW50LlxuICAgICAgKlxuICAgICAgKiBJZGVudGlmeSB0aGUgdHlwZSBvZiB0aGUgZXZlbnQsXG4gICAgICAqIGNyZWF0ZSB0aGUgY29ycmVzcG9uZGluZyBDbGFzcyBpbnN0YW5jZVxuICAgICAgKiBlbWl0IHRvIHRoZSBjb3JyZXNwb25kaW5nIE9iamVjdHNcbiAgICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG4gICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5faGFuZGxlRXZlbnRNYXAuaGFzT3duUHJvcGVydHkoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFdmVudE1hcFtldmVudC50eXBlXS5jYWxsKHRoaXMsIGV2ZW50KSB8fCBuZXcgbnhtRXZlbnRfMS5kZWZhdWx0KHRoaXMuY29udmVyc2F0aW9uLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBueG1FdmVudF8xLmRlZmF1bHQodGhpcy5jb252ZXJzYXRpb24sIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIE1hcmsgdGhlIHJlcXVlc3RlZCBldmVudCBhcyBkZWxpdmVyZWRcbiAgICAgICogdXNlIHRoYXQgZXZlbnQgYXMgY29uc3RydWN0ZWQgdG8gdXBkYXRlIHRoZSBsb2NhbCBldmVudHMnIG1hcFxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAgKiBAcmV0dXJucyB0aGUgTlhNRXZlbnQgdGhhdCBpcyBtYXJrZWQgYXMgZGVsaXZlcmVkXG4gICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfcHJvY2Vzc0RlbGl2ZXJlZChldmVudCkge1xuICAgICAgICBsZXQgZXZlbnRfdG9fbWFyayA9IHRoaXMuY29udmVyc2F0aW9uLmV2ZW50cy5nZXQoZXZlbnQuYm9keS5ldmVudF9pZCk7XG4gICAgICAgIGlmIChldmVudF90b19tYXJrKSB7XG4gICAgICAgICAgICBldmVudF90b19tYXJrLnN0YXRlID0gZXZlbnRfdG9fbWFyay5zdGF0ZSB8fCB7fTtcbiAgICAgICAgICAgIGV2ZW50X3RvX21hcmsuc3RhdGUuZGVsaXZlcmVkX3RvID0gZXZlbnRfdG9fbWFyay5zdGF0ZS5kZWxpdmVyZWRfdG8gfHwge307XG4gICAgICAgICAgICBldmVudF90b19tYXJrLnN0YXRlLmRlbGl2ZXJlZF90b1tldmVudC5mcm9tXSA9IGV2ZW50LnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJldHVybiBldmVudF90b19tYXJrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignTlhNRXZlbnQgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICogRGVsZXRlIHRoZSByZXF1ZXN0ZWQgZXZlbnRcbiAgICAgICogZW1wdHkgdGhlIHBheWxvYWQgb2YgdGhlIGV2ZW50ICh0ZXh0LCBpbWFnZSBvciBtZXNzYWdlKVxuICAgICAgKiB1c2UgdGhhdCBldmVudCBhcyBjb25zdHJ1Y3RlZCB0byB1cGRhdGUgdGhlIGxvY2FsIGV2ZW50cyBtYXBcbiAgICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG4gICAgICAqIEByZXR1cm5zIHRoZSBkZWxldGVkIGV2ZW50c1xuICAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3Byb2Nlc3NEZWxldGUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZXZlbnRfdG9fZGVsZXRlID0gdGhpcy5jb252ZXJzYXRpb24uZXZlbnRzLmdldCgoX2EgPSBldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50X2lkKTtcbiAgICAgICAgaWYgKGV2ZW50X3RvX2RlbGV0ZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50X3RvX2RlbGV0ZS5ib2R5LnRleHQpXG4gICAgICAgICAgICAgICAgZXZlbnRfdG9fZGVsZXRlLmJvZHkudGV4dCA9ICcnO1xuICAgICAgICAgICAgaWYgKGV2ZW50X3RvX2RlbGV0ZS5ib2R5LnJlcHJlc2VudGF0aW9ucylcbiAgICAgICAgICAgICAgICBldmVudF90b19kZWxldGUuYm9keS5yZXByZXNlbnRhdGlvbnMgPSAnJztcbiAgICAgICAgICAgIGV2ZW50X3RvX2RlbGV0ZS5ib2R5LnRpbWVzdGFtcCA9IHtcbiAgICAgICAgICAgICAgICBkZWxldGVkOiBldmVudC50aW1lc3RhbXBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRfdG9fZGVsZXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignTlhNRXZlbnQgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICogUmV0dXJuIGFuIEltYWdlRXZlbnQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBkYXRhXG4gICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAgKiBAcmV0dXJucyB7SW1hZ2VFdmVudH1cbiAgICAqL1xuICAgIF9wcm9jZXNzSW1hZ2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpbWFnZUV2ZW50ID0gbmV3IGltYWdlX2V2ZW50XzEuZGVmYXVsdCh0aGlzLmNvbnZlcnNhdGlvbiwgZXZlbnQpO1xuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHNlbmQgYSBkZWxpdmVyeVxuICAgICAgICAvLyBhdm9pZCBzZW5kaW5nIGRlbGl2ZXJlZCB0byBvdXIgb3duIGV2ZW50c1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuY29udmVyc2F0aW9uLm1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpICE9PSBpbWFnZUV2ZW50LmZyb20pIHtcbiAgICAgICAgICAgIGltYWdlRXZlbnQuZGVsaXZlcmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBIYW5kbGUgZXZlbnRzIGZvciBtZW1iZXIgc3RhdGUgY2hhbmdlcyAoam9pbmVkLCBpbnZpdGVkLCBsZWZ0KVxuICAgICAgKiBpbiBjb252ZXJzYXRpb24gbGV2ZWwuXG4gICAgICAqIE90aGVyIG1lbWJlcnMgYXJlIGdvaW5nIHRocm91Z2ggaGVyZSB0b28uXG4gICAgICAqIEZvciAubWUgbWVtYmVyIGluaXRpYWwgZXZlbnQgKGpvaW4sIGludml0ZSkgdXNlIHRoZSBhcHBsaWNhdGlvbiBsaXN0ZW5lclxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAgKiBAcmV0dXJucyB7TlhNRXZlbnR9XG4gICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfcHJvY2Vzc01lbWJlcihldmVudCkge1xuICAgICAgICAvLyBuZWVkcyB0byBmaXJzdCBwcm9jZXNzIHRoZSBjYWxsIHN0YXRlIGFuZCB0aGVuIGFsdGVyIHRoZSBtZW1iZXJcbiAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24uY2FsbHMuaGFzKHRoaXMuY29udmVyc2F0aW9uLmlkKSkge1xuICAgICAgICAgICAgbGV0IGNhbGwgPSB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLmdldCh0aGlzLmNvbnZlcnNhdGlvbi5pZCk7XG4gICAgICAgICAgICBjYWxsLl9oYW5kbGVTdGF0dXNDaGFuZ2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnZlcnNhdGlvbi5tZW1iZXJzLmhhcyhldmVudC5mcm9tKSlcbiAgICAgICAgICAgIHRoaXMuY29udmVyc2F0aW9uLm1lbWJlcnMuZ2V0KGV2ZW50LmZyb20pLl9oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBuZXcgbnhtRXZlbnRfMS5kZWZhdWx0KHRoaXMuY29udmVyc2F0aW9uLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBldmVudHMgZm9yIGxlZyBzdGF0dXMgdXBkYXRlcyBpbiBjb252ZXJzYXRpb24gbGV2ZWwuXG4gICAgICogT3RoZXIgbWVtYmVyJ3MgbGVncyBhcmUgZ29pbmcgdGhyb3VnaCBoZXJlIHRvby5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7TlhNRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9wcm9jZXNzTGVnU3RhdHVzKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnZlcnNhdGlvbi5tZW1iZXJzLmhhcyhldmVudC5mcm9tKSlcbiAgICAgICAgICAgIHRoaXMuY29udmVyc2F0aW9uLm1lbWJlcnMuZ2V0KGV2ZW50LmZyb20pLl9oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBuZXcgbnhtRXZlbnRfMS5kZWZhdWx0KHRoaXMuY29udmVyc2F0aW9uLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBIYW5kbGUgbWVtYmVyOm1lZGlhIGV2ZW50c1xuICAgICAgKiB1c2UgYSBjYWxsIG9iamVjdCBpZiBhbmQgdGhlIG1lbWJlciBvYmplY3RcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9wcm9jZXNzTWVkaWEoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udmVyc2F0aW9uLm1lbWJlcnMuaGFzKGV2ZW50LmZyb20pKVxuICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb24ubWVtYmVycy5nZXQoZXZlbnQuZnJvbSkuX2hhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBIYW5kbGUgKjptdXRlOiogZXZlbnRzXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50XG4gICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfcHJvY2Vzc011dGVGb3JNZWRpYShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5jb252ZXJzYXRpb24ubWVkaWEucnRjT2JqZWN0c1tldmVudC5ib2R5LnJ0Y19pZF0pIHtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbUluZGV4ID0gdGhpcy5jb252ZXJzYXRpb24ubWVkaWEucnRjT2JqZWN0c1tldmVudC5ib2R5LnJ0Y19pZF0uc3RyZWFtSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdObyBhdWRpbyBzdHJlYW0gd2FzIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBNYXJrIHRoZSByZXF1ZXN0ZWQgZXZlbnQgYXMgc2VlblxuICAgICAgKiB1c2UgdGhhdCBldmVudCBhcyBjb25zdHJ1Y3RlZCB0byB1cGRhdGUgdGhlIGxvY2FsIEV2ZW50cyBtYXBcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9wcm9jZXNzU2VlbihldmVudCkge1xuICAgICAgICBsZXQgZXZlbnRfdG9fbWFyayA9IHRoaXMuY29udmVyc2F0aW9uLmV2ZW50cy5nZXQoZXZlbnQuYm9keS5ldmVudF9pZCk7XG4gICAgICAgIGlmIChldmVudF90b19tYXJrKSB7XG4gICAgICAgICAgICBldmVudF90b19tYXJrLnN0YXRlID0gZXZlbnRfdG9fbWFyay5zdGF0ZSB8fCB7fTtcbiAgICAgICAgICAgIGV2ZW50X3RvX21hcmsuc3RhdGUuc2Vlbl9ieSA9IGV2ZW50X3RvX21hcmsuc3RhdGUuc2Vlbl9ieSB8fCB7fTtcbiAgICAgICAgICAgIGV2ZW50X3RvX21hcmsuc3RhdGUuc2Vlbl9ieVtldmVudC5mcm9tXSA9IGV2ZW50LnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJldHVybiBldmVudF90b19tYXJrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignTlhNRXZlbnQgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgICogQ3JlYXRlIHRoZSBUZXh0RXZlbnQgb2JqZWN0IGFuZCB0cmlnZ2VyIC5kZWxpdmVyZWQoKVxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3Byb2Nlc3NUZXh0KGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHRleHRFdmVudCA9IG5ldyB0ZXh0X2V2ZW50XzEuZGVmYXVsdCh0aGlzLmNvbnZlcnNhdGlvbiwgZXZlbnQpO1xuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHNlbmQgYSBkZWxpdmVyeVxuICAgICAgICAvLyBhdm9pZCBzZW5kaW5nIGRlbGl2ZXJlZCB0byBvdXIgb3duIGV2ZW50c1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuY29udmVyc2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZCkgIT09IHRleHRFdmVudC5mcm9tKSB7XG4gICAgICAgICAgICB0ZXh0RXZlbnQuZGVsaXZlcmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRFdmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIENyZWF0ZSB0aGUgTWVzc2FnZUV2ZW50IG9iamVjdCBhbmQgdHJpZ2dlciAuZGVsaXZlcmVkKClcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9wcm9jZXNzTWVzc2FnZShldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlRXZlbnQgPSBuZXcgbWVzc2FnZV9ldmVudF8xLmRlZmF1bHQodGhpcy5jb252ZXJzYXRpb24sIGV2ZW50KTtcbiAgICAgICAgLy8gQXV0b21hdGljYWxseSBzZW5kIGEgZGVsaXZlcnlcbiAgICAgICAgLy8gYXZvaWQgc2VuZGluZyBkZWxpdmVyZWQgdG8gb3VyIG93biBldmVudHNcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmNvbnZlcnNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQpICE9PSBtZXNzYWdlRXZlbnQuZnJvbSkge1xuICAgICAgICAgICAgbWVzc2FnZUV2ZW50LmRlbGl2ZXJlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlRXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBNYXJrIHRoZSByZXF1ZXN0ZWQgZXZlbnQgYXMgc3VibWl0dGVkXG4gICAgICAqIHVzZSB0aGF0IGV2ZW50IGFzIGNvbnN0cnVjdGVkIHRvIHVwZGF0ZSB0aGUgbG9jYWwgRXZlbnRzIG1hcFxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3Byb2Nlc3NTdWJtaXR0ZWQoZXZlbnQpIHtcbiAgICAgICAgbGV0IGV2ZW50X3RvX21hcmsgPSB0aGlzLmNvbnZlcnNhdGlvbi5ldmVudHMuZ2V0KGV2ZW50LmJvZHkuZXZlbnRfaWQpO1xuICAgICAgICBpZiAoZXZlbnRfdG9fbWFyaykge1xuICAgICAgICAgICAgZXZlbnRfdG9fbWFyay5zdGF0ZSA9IGV2ZW50X3RvX21hcmsuc3RhdGUgfHwge307XG4gICAgICAgICAgICBldmVudF90b19tYXJrLnN0YXRlLnN1Ym1pdHRlZF90byA9IGV2ZW50X3RvX21hcmsuc3RhdGUuc3VibWl0dGVkX3RvIHx8IHt9O1xuICAgICAgICAgICAgZXZlbnRfdG9fbWFyay5zdGF0ZS5zdWJtaXR0ZWRfdG9bZXZlbnQuZnJvbV0gPSBldmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRfdG9fbWFyaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ05YTUV2ZW50IG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICAqIE1hcmsgdGhlIHJlcXVlc3RlZCBldmVudCBhcyByZWplY3RlZFxuICAgICAgKiB1c2UgdGhhdCBldmVudCBhcyBjb25zdHJ1Y3RlZCB0byB1cGRhdGUgdGhlIGxvY2FsIEV2ZW50cyBtYXBcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9wcm9jZXNzUmVqZWN0ZWQoZXZlbnQpIHtcbiAgICAgICAgbGV0IGV2ZW50X3RvX21hcmsgPSB0aGlzLmNvbnZlcnNhdGlvbi5ldmVudHMuZ2V0KGV2ZW50LmJvZHkuZXZlbnRfaWQpO1xuICAgICAgICBpZiAoZXZlbnRfdG9fbWFyaykge1xuICAgICAgICAgICAgZXZlbnRfdG9fbWFyay5zdGF0ZSA9IGV2ZW50X3RvX21hcmsuc3RhdGUgfHwge307XG4gICAgICAgICAgICBldmVudF90b19tYXJrLnN0YXRlLnJlamVjdGVkX2J5ID0gZXZlbnRfdG9fbWFyay5zdGF0ZS5yZWplY3RlZF9ieSB8fCB7fTtcbiAgICAgICAgICAgIGV2ZW50X3RvX21hcmsuc3RhdGUucmVqZWN0ZWRfYnlbZXZlbnQuZnJvbV0gPSBldmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRfdG9fbWFyaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ05YTUV2ZW50IG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICAqIE1hcmsgdGhlIHJlcXVlc3RlZCBldmVudCBhcyB1bmRlbGl2ZXJhYmxlXG4gICAgICAqIHVzZSB0aGF0IGV2ZW50IGFzIGNvbnN0cnVjdGVkIHRvIHVwZGF0ZSB0aGUgbG9jYWwgRXZlbnRzIG1hcFxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3Byb2Nlc3NVbmRlbGl2ZXJhYmxlKGV2ZW50KSB7XG4gICAgICAgIGxldCBldmVudF90b19tYXJrID0gdGhpcy5jb252ZXJzYXRpb24uZXZlbnRzLmdldChldmVudC5ib2R5LmV2ZW50X2lkKTtcbiAgICAgICAgaWYgKGV2ZW50X3RvX21hcmspIHtcbiAgICAgICAgICAgIGV2ZW50X3RvX21hcmsuc3RhdGUgPSBldmVudF90b19tYXJrLnN0YXRlIHx8IHt9O1xuICAgICAgICAgICAgZXZlbnRfdG9fbWFyay5zdGF0ZS51bmRlbGl2ZXJhYmxlX3RvID0gZXZlbnRfdG9fbWFyay5zdGF0ZS51bmRlbGl2ZXJhYmxlX3RvIHx8IHt9O1xuICAgICAgICAgICAgZXZlbnRfdG9fbWFyay5zdGF0ZS51bmRlbGl2ZXJhYmxlX3RvW2V2ZW50LmZyb21dID0gZXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50X3RvX21hcms7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdOWE1FdmVudCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udmVyc2F0aW9uRXZlbnRIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJzYXRpb25FdmVudEhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3NvciA9IGV4cG9ydHMuRXZlbnRzUXVldWUgPSB2b2lkIDA7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICogRXZlbnRzIFF1ZXVlXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4qL1xuY29uc3QgbmV4bW9DbGllbnRFcnJvcl8xID0gcmVxdWlyZShcIi4uL25leG1vQ2xpZW50RXJyb3JcIik7XG5jb25zdCB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBsb2dsZXZlbF8xID0gcmVxdWlyZShcImxvZ2xldmVsXCIpO1xuLyoqXG4gKiBIYW5kbGUgTWFwcGluZyBvZiBDb252ZXJzYXRpb24gSWRzIHRvIENvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3NvclxuICpcbiAqIEBjbGFzcyBFdmVudHNRdWV1ZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnRzUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5jaWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB9XG4gICAgLy8gZW5xdWV1ZShpdGVtKVxuICAgIGFzeW5jIGVucXVldWUoZXZlbnQsIGFwcGxpY2F0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy9DaGVjayBpZiBjaWQgb3IgZXZlbnQgaWQgYW5kIGlmIG5vdCBqdXN0IHNlbmQgdG8gYXBwbGljYXRpb24gdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgIGNvbnN0IHsgY2lkLCBpZCB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50SWQgPSBOdW1iZXIoaWQpO1xuICAgICAgICBpZiAoIWNpZCB8fCBpc05hTihldmVudElkKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgQ29udmVyc2F0aW9uIEV2ZW50cyBRdWV1ZSBmb3IgQ0lEIGFuZCBpZiBub3QgY3JlYXRlIG9uZVxuICAgICAgICBpZiAoIXRoaXMuY2lkTWFwLmdldChjaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgZW5xdWV1ZTogY3JlYXRlIG5ldyBDb252ZXJzYXRpb25FdmVudHNQcm9jZXNzb3IgZm9yICR7Y2lkfWApO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yID0gbmV3IENvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3NvcihjaWQsIGV2ZW50SWQgLSAxLCBhcHBsaWNhdGlvbik7XG4gICAgICAgICAgICB0aGlzLmNpZE1hcC5zZXQoY2lkLCBuZXdDb252ZXJzYXRpb25FdmVudHNQcm9jZXNzb3IpO1xuICAgICAgICAgICAgLy8gZWRnZSBjYXNlIGZvciBtZW1iZXI6bWVkaWEgb3IgbWVtYmVyOmpvaW5lZCBldmVudCBiZWZvcmUgdHJhbnNmZXIgb3IgbWVtYmVyOmpvaW5lZCAmJiBjaGFubmVsLmlkXG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSAnbWVtYmVyOm1lZGlhJyAmJiAoKF9iID0gKF9hID0gZXZlbnQuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lZGlhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXVkaW8pIHx8IGV2ZW50LnR5cGUgPT0gJ21lbWJlcjpqb2luZWQnICYmICgoX2QgPSAoX2MgPSBldmVudC5ib2R5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2hhbm5lbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkKSkge1xuICAgICAgICAgICAgICAgIC8vIGZldGNoIGxhc3QgMjAgZXZlbnRzIG9mIGNvbnZlcnNhdGlvbiAmIGlmIHRoZXJlIGlzIGEgdHJhbnNmZXIgdG8gdGhpcyBjb252ZXJzdGFpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydGluZ0ZldGNoRXZlbnRJZCA9IGV2ZW50SWQgLSAyMCA8IDEgPyAxIDogZXZlbnRJZCAtIDIwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IG5ld0NvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3Nvci5mZXRjaENvbnZlcnNhdGlvbkV2ZW50cyhzdGFydGluZ0ZldGNoRXZlbnRJZCwgMjApO1xuICAgICAgICAgICAgICAgIGxldCB0cmFuc2ZlckV2ZW50Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmZXRjaGVkRXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmV0Y2hlZEV2ZW50LnR5cGUgPT09ICdydGM6dHJhbnNmZXInICYmIGZldGNoZWRFdmVudC5mcm9tID09PSBldmVudC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlckV2ZW50Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGV2ZW50cyBwcm9jZXNzb3IgdG8gcHJvY2VzcyB0cmFuc2ZlciBldmVudCBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb252ZXJzYXRpb25FdmVudHNQcm9jZXNzb3IubGFzdEV2ZW50SWRQcm9jZXNzZWQgPSBOdW1iZXIoZmV0Y2hlZEV2ZW50LmlkKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyRXZlbnRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9FbnF1ZXVlIGFsbCBldmVudHMgYWZ0ZXIgcnRjOnRyYW5zZmVyIGV2ZW50IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb252ZXJzYXRpb25FdmVudHNQcm9jZXNzb3IuZW5xdWV1ZShOdW1iZXIoZmV0Y2hlZEV2ZW50LmlkKSwgZmV0Y2hlZEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3NvciA9IHRoaXMuY2lkTWFwLmdldChjaWQpO1xuICAgICAgICAvLyBBZGQgbmV3IGV2ZW50IHRvIGNvbnZlcnNhdGlvbiBldmVudHMgcXVldWVcbiAgICAgICAgY29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yLmVucXVldWUoZXZlbnRJZCwgZXZlbnQpO1xuICAgICAgICAvLyBJZiBub3QgY3VycmVudGx5IHByb2Nlc3NpbmcgZXZlbnRzIGluIHF1ZXVlIGJlZ2luIHByb2Nlc3NpbmdcbiAgICAgICAgaWYgKCFjb252ZXJzYXRpb25FdmVudHNQcm9jZXNzb3IucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgY29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yLnByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgY29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yLnByb2Nlc3NFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudHNRdWV1ZSA9IEV2ZW50c1F1ZXVlO1xuLyoqXG4gKiBIYW5kbGUgT3JkZXJpbmcgb2YgQ29udmVyc2F0aW9uIEV2ZW50cyBmb3IgUHJvY2Vzc2luZ1xuICpcbiAqIEBjbGFzcyBDb252ZXJzYXRpb25FdmVudHNQcm9jZXNzb3JcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoY2lkLCBsYXN0RXZlbnRJZFByb2Nlc3NlZCwgYXBwbGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5jaWQgPSBjaWQ7XG4gICAgICAgIHRoaXMuZXZlbnRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gKGV2ZW50KSA9PiBhcHBsaWNhdGlvbi5faGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLmxhc3RFdmVudElkUHJvY2Vzc2VkID0gbGFzdEV2ZW50SWRQcm9jZXNzZWQ7XG4gICAgICAgIHRoaXMubGFyZ2VzdEV2ZW50SWRJblF1ZXVlID0gbGFzdEV2ZW50SWRQcm9jZXNzZWQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgICAgIHRoaXMuZXZlbnRzRmV0Y2hSYW5nZSA9IDk7XG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB9XG4gICAgZW5xdWV1ZShldmVudElkLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnRJZCA+IHRoaXMubGFyZ2VzdEV2ZW50SWRJblF1ZXVlKVxuICAgICAgICAgICAgdGhpcy5sYXJnZXN0RXZlbnRJZEluUXVldWUgPSBldmVudElkO1xuICAgICAgICBpZiAoZXZlbnRJZCA+IHRoaXMubGFzdEV2ZW50SWRQcm9jZXNzZWQpXG4gICAgICAgICAgICB0aGlzLmV2ZW50c01hcC5zZXQoZXZlbnRJZCwgZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGRlcXVldWUoZXZlbnRJZCkge1xuICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRzTWFwLmdldChldmVudElkKTtcbiAgICAgICAgdGhpcy5ldmVudHNNYXAuZGVsZXRlKGV2ZW50SWQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IGRvbmVQcm9jZXNzaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBwcm9jZXNzRXZlbnRzOiBEb25lIFByb2Nlc3NpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzTWFwLnNpemUgPCAxKVxuICAgICAgICAgICAgcmV0dXJuIGRvbmVQcm9jZXNzaW5nKCk7XG4gICAgICAgIGNvbnN0IG5leHRFdmVudFRvUHJvY2VzcyA9IHRoaXMubGFzdEV2ZW50SWRQcm9jZXNzZWQgKyAxO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IGF3YWl0IHRoaXMucHJvY2Vzc05leHRFdmVudChuZXh0RXZlbnRUb1Byb2Nlc3MpO1xuICAgICAgICBpZiAocHJvY2Vzc2VkRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50SWRQcm9jZXNzZWQgPSBOdW1iZXIocHJvY2Vzc2VkRXZlbnQuaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0V2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmVQcm9jZXNzaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc05leHRFdmVudChldmVudElkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBwcm9jZXNzTmV4dEV2ZW50OiBwcm9jZXNzaW5nIGV2ZW50IG51bWJlciAke2V2ZW50SWR9YCk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5kZXF1ZXVlKGV2ZW50SWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWxsYmFjayhldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5leHQgZXZlbnQgaW4gdGhlIHNlcXVlbmNlIHdhcyBub3QgaW4gdGhlIG1hcCwgaWYgbGFyZ2VyIGV2ZW50IGlkIGluIHF1ZXVlIChnYXApXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBhIHJlcXVlc3QgdG8gQ1MgdG8gZ2V0IGFsbCBjb252ZXJzYXRpb24gZXZlbnRzIGFuZCBhZGQgYW55IG1pc3NlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhcmdlc3RFdmVudElkSW5RdWV1ZSA+IGV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHByb2Nlc3NOZXh0RXZlbnQ6IGxhcmdlc3RFdmVudElkSW5RdWV1ZS0ke3RoaXMubGFyZ2VzdEV2ZW50SWRJblF1ZXVlfSA+IGV2ZW50SWQtJHtldmVudElkfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEV2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50c0FuZFByb2Nlc3MoZXZlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByb2Nlc3NOZXh0RXZlbnQ6IGZvdW5kRXZlbnQgXCIsIHsgZm91bmRFdmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FsbGJhY2soZm91bmRFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRFdmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBwcm9jZXNzTmV4dEV2ZW50OiBub3QgZm91bmQgcHJvY2VzcyBuZXh0ICR7ZXZlbnRJZCArIDF9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzTmV4dEV2ZW50KGV2ZW50SWQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaEV2ZW50c0FuZFByb2Nlc3MobWlzc2luZ0V2ZW50KSB7XG4gICAgICAgIC8vZmV0Y2ggY29udmVyc2F0aW9uIGV2ZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzTGlzdCA9IGF3YWl0IHRoaXMuZmV0Y2hDb252ZXJzYXRpb25FdmVudHMobWlzc2luZ0V2ZW50LCB0aGlzLmV2ZW50c0ZldGNoUmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJmZXRjaEV2ZW50c0FuZFByb2Nlc3M6IGZldGNoZWQgZXZlbnRzIGxpc3QgXCIsIHsgZXZlbnRzTGlzdCB9KTtcbiAgICAgICAgICAgIC8vY2hlY2sgZm9yIG5leHQgZXZlbnQgaWRcbiAgICAgICAgICAgIGxldCBmb3VuZEV2ZW50O1xuICAgICAgICAgICAgZXZlbnRzTGlzdC5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vYWRkIGNpZCBiYWNrIHRvIGZldGNoZWQgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudC5jaWQgPSB0aGlzLmNpZDtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudElkID0gTnVtYmVyKGV2ZW50LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZXZlbnRJZCkgfHwgZXZlbnRJZCA8IG1pc3NpbmdFdmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChldmVudElkID4gbWlzc2luZ0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBmZXRjaEV2ZW50c0FuZFByb2Nlc3M6IGV2ZW50ID4gbWlzc2luZ0V2ZW50ICR7ZXZlbnRJZH0gYCwgeyBtaXNzaW5nRXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5xdWV1ZShldmVudElkLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZldGNoRXZlbnRzQW5kUHJvY2VzczogZm91bmRFdmVudCBcIiwgeyBldmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZmV0Y2hFdmVudHNBbmRQcm9jZXNzOiBlcnJvciBcIiwgeyBlIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29udmVyc2F0aW9uRXZlbnRzKHN0YXJ0X2lkLCByYW5nZSkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZldGNoQ29udmVyc2F0aW9uRXZlbnRzOiBcIiwgdGhpcy5jaWQsIHN0YXJ0X2lkKTtcbiAgICAgICAgLy8gZnJvbSAmIHRvIGJ5IGV2ZW50IGlkIHRvIHJlc3RyaWN0XG4gICAgICAgIGNvbnN0IGVuZF9pZCA9IHRoaXMubGFyZ2VzdEV2ZW50SWRJblF1ZXVlID4gc3RhcnRfaWQgPyB0aGlzLmxhcmdlc3RFdmVudElkSW5RdWV1ZSArIHJhbmdlIDogc3RhcnRfaWQgKyByYW5nZTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLmNvbmZpZy5uZXhtb19hcGlfdXJsfS9iZXRhMi9jb252ZXJzYXRpb25zLyR7dGhpcy5jaWR9L2V2ZW50c2A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHV0aWxzXzEuZGVmYXVsdC5wYWdpbmF0aW9uUmVxdWVzdCh1cmwsIHsgc3RhcnRfaWQsIGVuZF9pZCB9LCB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uY29uZmlnLnRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50c0xpc3QgPSByZXNwb25zZS5pdGVtcztcbiAgICAgICAgICAgIHJldHVybiBldmVudHNMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yID0gQ29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXZlbnRzUXVldWU6IEV2ZW50c1F1ZXVlLFxuICAgIENvbnZlcnNhdGlvbkV2ZW50c1Byb2Nlc3NvcjogQ29udmVyc2F0aW9uRXZlbnRzUHJvY2Vzc29yXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICogIFJUQyBFdmVudHMgSGFuZGxlclxuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuICovXG5jb25zdCBsb2dsZXZlbF8xID0gcmVxdWlyZShcImxvZ2xldmVsXCIpO1xuLyoqXG4gKiBIYW5kbGUgcnRjIEV2ZW50c1xuICpcbiAqIEBjbGFzcyBSdGNFdmVudEhhbmRsZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJ0Y0V2ZW50SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dsZXZlbF8xLmdldExvZ2dlcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgICAgIHRoaXMuX2hhbmRsZVJ0Y0V2ZW50TWFwID0ge1xuICAgICAgICAgICAgJ3J0Yzp0cmFuc2Zlcic6IHRoaXMuX3Byb2Nlc3NSdGNUcmFuc2ZlcixcbiAgICAgICAgICAgICdydGM6YW5zd2VyJzogdGhpcy5fcHJvY2Vzc1J0Y0Fuc3dlcixcbiAgICAgICAgICAgICdydGM6aGFuZ3VwJzogdGhpcy5fcHJvY2Vzc1J0Y0hhbmd1cFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgcnRjIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVJ0Y0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVSdGNFdmVudE1hcC5oYXNPd25Qcm9wZXJ0eShldmVudC50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVJ0Y0V2ZW50TWFwW2V2ZW50LnR5cGVdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBvbiB0cmFuc2ZlciBldmVudFxuICAgICAgKiB1cGRhdGUgdGhlIGNvbnZlcnNhdGlvbiBvYmplY3QgaW4gdGhlIE5YTUNhbGwsXG4gICAgICAqIHVwZGF0ZSB0aGUgbWVkaWEgb2JqZWN0IGluIHRoZSBuZXcgY29udmVyc2F0aW9uXG4gICAgICAqIHNldCBgdHJhbnNmZXJyZWRfdG9gIDxDb252ZXJzYXRpb24+IG9uIHRoZSBtZW1iZXIgdGhhdCBpcyB0cmFuc2ZlcnJlZFxuICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9wcm9jZXNzUnRjVHJhbnNmZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ19wcm9jZXNzUnRjVHJhbnNmZXI6ICcsIHsgZXZlbnQgfSk7XG4gICAgICAgIGNvbnN0IG9sZF9jb252ZXJzYXRpb24gPSB0aGlzLmFwcGxpY2F0aW9uLmNvbnZlcnNhdGlvbnMuZ2V0KGV2ZW50LmJvZHkudHJhbnNmZXJyZWRfZnJvbSk7XG4gICAgICAgIGNvbnN0IG5ld19jb252ZXJzYXRpb24gPSB0aGlzLmFwcGxpY2F0aW9uLmNvbnZlcnNhdGlvbnMuZ2V0KGV2ZW50LmNpZCk7XG4gICAgICAgIGNvbnN0IG54bUNhbGwgPSB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLmdldChldmVudC5ib2R5LnRyYW5zZmVycmVkX2Zyb20pO1xuICAgICAgICBpZiAoIW54bUNhbGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ05YTUNhbGwgdHJhbnNmZXIgZm9yIHVua25vd24gbnhtQ2FsbCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmsgdGhlIHRyYW5zZmVycmVkIG1lbWJlciBpbiB0aGUgb2xkIGNvbnZlcnNhdGlvblxuICAgICAgICBueG1DYWxsLmNvbnZlcnNhdGlvbi5tZW1iZXJzLmdldChldmVudC5ib2R5Lndhc19tZW1iZXIpLnRyYW5zZmVycmVkX3RvID0gbmV3X2NvbnZlcnNhdGlvbjtcbiAgICAgICAgbnhtQ2FsbC5fc2V0dXBDb252ZXJzYXRpb25PYmplY3QobmV3X2NvbnZlcnNhdGlvbik7XG4gICAgICAgIG54bUNhbGwudHJhbnNmZXJyZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLnNldChldmVudC5jaWQsIG54bUNhbGwpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLmRlbGV0ZShldmVudC5ib2R5LnRyYW5zZmVycmVkX2Zyb20pO1xuICAgICAgICAvLyBpbiBjYXNlIHdlIGpvaW5lZCBpbiB0aGUgbWlkZGxlIG9mIGEgdHJhbnNmZXIgYW5kIHdlIGRvbid0IGhhdmUgdGhlXG4gICAgICAgIC8vIHByZXZpb3VzIGNvbnZlcnNhdGlvbiBpbiBvdXIgbGlzdCB5ZXRcbiAgICAgICAgaWYgKG9sZF9jb252ZXJzYXRpb24pIHtcbiAgICAgICAgICAgIG5ld19jb252ZXJzYXRpb24ubWVtYmVycy5nZXQoZXZlbnQuZnJvbSkudHJhbnNmZXJyZWRfZnJvbSA9IG9sZF9jb252ZXJzYXRpb247XG4gICAgICAgICAgICBuZXdfY29udmVyc2F0aW9uLm1lZGlhLl9hdHRhY2hFbmRpbmdFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAvLyBDaGVja2luZyB0byBzZWUgaWYgb2xkIGNvbnZlcnNhdGlvbiBoYXMgcnRjT2JqZWN0LCBwYyBvciBhY3RpdmVTdHJlYW1zIHdoaWxlIG5ldyBjb252ZXJzYXRpb24gZG9lcyBub3QgYW5kIGlmIHNvIGFkZFxuICAgICAgICAgICAgLy8gdG8gbmV3IGNvbnZlcnNhdGlvbiB0aGUgbWlzc2luZyBydGNPYmplY3QsIHBjIG9yIGFjdGl2ZVN0cmVhbVxuICAgICAgICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKG5ld19jb252ZXJzYXRpb24ubWVkaWEucnRjT2JqZWN0cykubGVuZ3RoID09PSAwICYmIE9iamVjdC5lbnRyaWVzKG9sZF9jb252ZXJzYXRpb24ubWVkaWEucnRjT2JqZWN0cykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdfY29udmVyc2F0aW9uLm1lZGlhLnJ0Y09iamVjdHMsIG9sZF9jb252ZXJzYXRpb24ubWVkaWEucnRjT2JqZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5ld19jb252ZXJzYXRpb24ubWVkaWEucGMgJiYgb2xkX2NvbnZlcnNhdGlvbi5tZWRpYS5wYykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3X2NvbnZlcnNhdGlvbi5tZWRpYS5wYyA9IG9sZF9jb252ZXJzYXRpb24ubWVkaWEucGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld19jb252ZXJzYXRpb24uYXBwbGljYXRpb24uYWN0aXZlU3RyZWFtcy5sZW5ndGggPT09IDAgJiYgb2xkX2NvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5hY3RpdmVTdHJlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdfY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLmFjdGl2ZVN0cmVhbXMgPSBvbGRfY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLmFjdGl2ZVN0cmVhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJ0YzphbnN3ZXIgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2Nlc3NSdGNBbnN3ZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ19wcm9jZXNzUnRjQW5zd2VyOiAnLCB7IGV2ZW50IH0pO1xuICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbi5jYWxscy5oYXMoZXZlbnQuY2lkKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5jYWxscy5nZXQoZXZlbnQuY2lkKS5pZCA9IGV2ZW50LmJvZHkucnRjX2lkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBydGM6aGFuZ3VwIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzUnRjSGFuZ3VwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdfcHJvY2Vzc1J0Y0hhbmd1cDogJywgeyBldmVudCB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24uY2FsbHMuaGFzKGV2ZW50LmNpZCkpIHtcbiAgICAgICAgICAgIGxldCBjYWxsID0gdGhpcy5hcHBsaWNhdGlvbi5jYWxscy5nZXQoZXZlbnQuY2lkKTtcbiAgICAgICAgICAgIGNhbGwuX2hhbmRsZVN0YXR1c0NoYW5nZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSdGNFdmVudEhhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFJ0Y0V2ZW50SGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKiAgU0lQIEV2ZW50cyBIYW5kbGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4gKi9cbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG4vKipcbiAqIEhhbmRsZSBzaXAgRXZlbnRzXG4gKlxuICogQGNsYXNzIFNpcEV2ZW50SGFuZGxlclxuICogQHByaXZhdGVcbiAgKi9cbmNsYXNzIFNpcEV2ZW50SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dsZXZlbF8xLmdldExvZ2dlcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgICAgIHRoaXMuX2hhbmRsZVNpcENhbGxFdmVudE1hcCA9IHtcbiAgICAgICAgICAgICdzaXA6aGFuZ3VwJzogdGhpcy5fcHJvY2Vzc1NpcEhhbmd1cCxcbiAgICAgICAgICAgICdzaXA6cmluZ2luZyc6IHRoaXMuX3Byb2Nlc3NTaXBSaW5naW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBzaXAgZXZlbnRzXG4gICAgICogVGhlIGV2ZW50IGJlbG9uZ3MgdG8gYSBjYWxsIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfaGFuZGxlU2lwQ2FsbEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiX2hhbmRsZVNpcENhbGxFdmVudDogXCIsIHsgZXZlbnQgfSk7XG4gICAgICAgIGlmICghdGhpcy5hcHBsaWNhdGlvbi5jYWxscy5oYXMoZXZlbnQuY2lkKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignVGhlcmUgaXMgbm8gY2FsbCBvYmplY3QgZm9yIHRoaXMgQ29udmVyc2F0aW9uIGlkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50X2NhbGwgPSB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLmdldChldmVudC5jaWQpO1xuICAgICAgICBpZiAodGhpcy5faGFuZGxlU2lwQ2FsbEV2ZW50TWFwLmhhc093blByb3BlcnR5KGV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU2lwQ2FsbEV2ZW50TWFwW2V2ZW50LnR5cGVdLmNhbGwodGhpcywgZXZlbnRfY2FsbCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzaXA6aGFuZ3VwIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRfY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2Nlc3NTaXBIYW5ndXAoZXZlbnRfY2FsbCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJfcHJvY2Vzc1NpcEhhbmd1cDogXCIsIGV2ZW50KTtcbiAgICAgICAgZXZlbnRfY2FsbC5faGFuZGxlU3RhdHVzQ2hhbmdlKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHNpcDpyaW5naW5nIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRfY2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2Nlc3NTaXBSaW5naW5nKGV2ZW50X2NhbGwsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiX3Byb2Nlc3NTaXBSaW5naW5nOiBcIiwgZXZlbnQpO1xuICAgICAgICBldmVudF9jYWxsLl9oYW5kbGVTdGF0dXNDaGFuZ2UoZXZlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNpcEV2ZW50SGFuZGxlcjtcbm1vZHVsZS5leHBvcnRzID0gU2lwRXZlbnRIYW5kbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xubGV0IE5leG1vQ2xpZW50ID0gZ2xvYmFsLk5leG1vQ2xpZW50IHx8IHt9O1xuTmV4bW9DbGllbnQgPSByZXF1aXJlKCcuL3NkaycpO1xuZ2xvYmFsLk5leG1vQ2xpZW50ID0gTmV4bW9DbGllbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICogIE1lbWJlciBPYmplY3QgTW9kZWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiovXG5jb25zdCBXaWxkRW1pdHRlciA9IHJlcXVpcmUoJ3dpbGRlbWl0dGVyJyk7XG5jb25zdCBuZXhtb0NsaWVudEVycm9yXzEgPSByZXF1aXJlKFwiLi9uZXhtb0NsaWVudEVycm9yXCIpO1xuY29uc3QgbnhtRXZlbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ldmVudHMvbnhtRXZlbnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG4vKipcbiAqIEFuIGluZGl2aWR1YWwgdXNlciAoaS5lLiBjb252ZXJzYXRpb24gbWVtYmVyKS5cbiAqIEBjbGFzcyBNZW1iZXJcbiAqIEBwYXJhbSB7Q29udmVyc2F0aW9ufSBjb252ZXJzYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiovXG5jbGFzcyBNZW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnZlcnNhdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY29udmVyc2F0aW9uID0gY29udmVyc2F0aW9uO1xuICAgICAgICB0aGlzLmNhbGxTdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9ub3JtYWxpc2UocGFyYW1zKTtcbiAgICAgICAgV2lsZEVtaXR0ZXIubWl4aW4oTWVtYmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9iamVjdCBpbnN0YW5jZSBhbmQgYWxpZ24gYXR0cmlidXRlIG5hbWVzXG4gICAgICpcbiAgICAgKiBIYW5kbGUgcGFyYW1zIGlucHV0IHRvIGtlZXAgY29uc2lzdGVudCB0aGUgbWVtYmVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgbWVtYmVyIGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX25vcm1hbGlzZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdGhpcy51c2VyIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsID0gcGFyYW1zLmNoYW5uZWwgfHwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcHAnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lbWJlcl9pZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gcGFyYW1zLm1lbWJlcl9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBwYXJhbXMudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJhbXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gcGFyYW1zLmZyb207IC8vIHNwZWNpYWwgY2FzZSBmb3IgbWVtYmVyIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VzZXJfaWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLmlkID0gcGFyYW1zLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIubmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VzZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy51c2VyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy51c2VyLnVzZXJfaWQgfHwgcGFyYW1zLnVzZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlfbmFtZSA9IHRoaXMuZGlzcGxheV9uYW1lIHx8IHBhcmFtcy51c2VyLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnZpdGVkX2J5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52aXRlZF9ieSA9IHBhcmFtcy5pbnZpdGVkX2J5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc3BsYXlfbmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlfbmFtZSA9IHRoaXMuZGlzcGxheV9uYW1lIHx8IHBhcmFtcy5kaXNwbGF5X25hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnX2VtYmVkZGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuX2VtYmVkZGVkLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuX2VtYmVkZGVkLnVzZXIuaWQgfHwgdGhpcy51c2VyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMuX2VtYmVkZGVkLnVzZXIubmFtZSB8fCB0aGlzLnVzZXIubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5X25hbWUgPSB0aGlzLmRpc3BsYXlfbmFtZSB8fCBwYXJhbXMuX2VtYmVkZGVkLnVzZXIuZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb252ZXJzYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gam9pbiBjb252ZXJzYXRpb24gcmV0dXJucyBvdXIgbWVtYmVyIHdpdGggb25seSBpZCxcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgaXQgZm9yIG5vdyBhbmQgdXNlIHRoZSB1c2VybmFtZSB3ZSBoYXZlIGluIHRoZSBhcHBsaWNhdGlvbiBvYmplY3RcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5tZSAmJiBwYXJhbXMudXNlcl9pZCA9PT0gdGhpcy5jb252ZXJzYXRpb24uYXBwbGljYXRpb24ubWUuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXIubmFtZSA9IHRoaXMuY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLm1lLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3Qga2VlcCBhIG1lbWJlci51c2VyX2lkLCBuYW1lIGluIGFueSBmbG93XG4gICAgICAgICAgICBkZWxldGUgdGhpcy51c2VyX2lkO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVzZXIudXNlcl9pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBnaXZlbiBzdHJlYW0gb25seSB0byB0aGlzIG1lbWJlciB3aXRoaW4gdGhlIGNvbnZlcnNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXNdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOWE1FdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIHBsYXlTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLmlkfS9ldmVudHNgLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvOnBsYXknLFxuICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyYW1zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG54bUV2ZW50XzEuZGVmYXVsdCh0aGlzLmNvbnZlcnNhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVhayB0aGUgZ2l2ZW4gdGV4dCBvbmx5IHRvIHRoaXMgbWVtYmVyIHdpdGhpbiB0aGUgQ29udmVyc2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXNdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOWE1FdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIHNheVRleHQocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29udmVyc2F0aW9uLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLmlkfS9ldmVudHNgLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvOnNheScsXG4gICAgICAgICAgICAgICAgICAgIGNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5jb252ZXJzYXRpb24ubWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhbXMudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWNlX25hbWU6IHBhcmFtcy52b2ljZV9uYW1lIHx8ICdBbXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IHBhcmFtcy5sZXZlbCB8fCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWU6IHBhcmFtcy5xdWV1ZSB8fCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcDogcGFyYW1zLmxvb3AgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNzbWw6IHBhcmFtcy5zc21sIHx8IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbnhtRXZlbnRfMS5kZWZhdWx0KHRoaXMuY29udmVyc2F0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEtpY2sgYSBNZW1iZXIgZnJvbSB0aGUgQ29udmVyc2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtyZWFzb25dIHRoZSByZWFzb24gZm9yIGtpY2tpbmcgb3V0IGEgbWVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWFzb24ucmVhc29uX2NvZGVdIHRoZSBjb2RlIG9mIHRoZSByZWFzb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlYXNvbi5yZWFzb25fdGV4dF0gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb25cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZW1vdmUgYSBtZW1iZXIgZnJvbSB0aGUgQ29udmVyc2F0aW9uLjwvY2FwdGlvbj5cbiAgICAgKiAvLyBSZW1vdmUgYSBtZW1iZXJcbiAgICAgKiBtZW1iZXIua2ljayh7cmVhc29uX2NvZGU6IFwiUmVhc29uIENvZGVcIiwgcmVhc29uX3RleHQ6IFwiUmVhc29uIFRleHRcIn0pXG4gICAgICogLnRoZW4oKCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSByZW1vdmVkIG1lbWJlci5cIik7XG4gICAgICogfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZW1vdmluZyBtZW1iZXI6IFwiLCBlcnJvcik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBSZW1vdmUgeW91cnNlbGZcbiAgICAgKiBjb252ZXJzYXRpb24ubWUua2ljayh7cmVhc29uX2NvZGU6IFwiUmVhc29uIENvZGVcIiwgcmVhc29uX3RleHQ6IFwiUmVhc29uIFRleHRcIn0pXG4gICAgICogLnRoZW4oKCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSByZW1vdmVkIHlvdXJzZWxmLlwiKTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlbW92aW5nIHlvdXJzZWxmOiBcIiwgZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBhc3luYyBraWNrKHJlYXNvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcGF0aCA9IGBjb252ZXJzYXRpb25zLyR7dGhpcy5jb252ZXJzYXRpb24uaWR9L21lbWJlcnMvJHt0aGlzLmlkfWA7XG4gICAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIC8vIGFkZCBtZW1iZXJfaWQgb2YgZnJvbVxuICAgICAgICBpZiAoKF9iID0gKF9hID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLmNvbnZlcnNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoJ2Zyb20nLCB0aGlzLmNvbnZlcnNhdGlvbi5tZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVhc29uKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgcmVhc29uW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCArPSBgPyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGUgeW91ciBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdXRlXSB0cnVlIGZvciBtdXRlLCBmYWxzZSBmb3IgdW5tdXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdHJlYW1JbmRleF0gc3RyZWFtIGluZGV4IG9mIHRoZSBzdHJlYW1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NdXRlIGF1ZGlvIHN0cmVhbSBvZiB5b3VyIE1lbWJlci48L2NhcHRpb24+XG4gICAgICogLy8gTXV0ZSB5b3Vyc2VsZlxuICAgICAqIGNvbnZlcnNhdGlvbi5tZS5tdXRlKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gVW5tdXRlIHlvdXJzZWxmXG4gICAgICogY29udmVyc2F0aW9uLm1lLm11dGUoZmFsc2UpO1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgKi9cbiAgICBtdXRlKG11dGUsIHN0cmVhbUluZGV4ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJzYXRpb24ubWVkaWEubXV0ZShtdXRlLCBzdHJlYW1JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhcm11ZmYgeW91cnNlbGYgaW4gdGhlIENvbnZlcnNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZWFybXVmZiB0cnVlIG9yIGZhbHNlXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RGlzYWJsZXMgeW91ciBNZW1iZXIgZnJvbSBoZWFyaW5nIG90aGVyIE1lbWJlcnMgaW4gdGhlIENvbnZlcnNhdGlvbi48L2NhcHRpb24+XG4gICAgICogLy8gRWFybXVmZiB5b3Vyc2VsZlxuICAgICAqIGNvbnZlcnNhdGlvbi5tZS5lYXJtdWZmKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gVW5lYXJtdWZmIHlvdXJzZWxmXG4gICAgICogY29udmVyc2F0aW9uLm1lLmVhcm11ZmYoZmFsc2UpO1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICpcbiAgICAqL1xuICAgIGVhcm11ZmYoZWFybXVmZikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJzYXRpb24ubWVkaWEuZWFybXVmZihlYXJtdWZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIG1lbWJlciBvYmplY3QgZXZlbnRzXG4gICAgICpcbiAgICAgKiBIYW5kbGUgZXZlbnRzIHRoYXQgYXJlIG1vZGlmeWluZyB0aGlzIG1lbWJlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TlhNRXZlbnR9IGV2ZW50IGludml0ZWQsIGpvaW5lZCwgbGVmdCwgbWVkaWEgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9oYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21lbWJlcjppbnZpdGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpc2UoZXZlbnQuYm9keSk7IC8vIHRha2UgY2FyZSBvZiBtaXNhbGlnbmVkIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdJTlZJVEVEJztcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcC5pbnZpdGVkID0gZXZlbnQuYm9keS50aW1lc3RhbXAuaW52aXRlZDtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmJvZHkuaW52aXRlZF9ieSAmJiBldmVudC5ib2R5LnVzZXIubWVkaWEgJiYgZXZlbnQuYm9keS51c2VyLm1lZGlhLmF1ZGlvX3NldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgICYmIGV2ZW50LmJvZHkudXNlci5tZWRpYS5hdWRpb19zZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhbGxTdGF0dXNBbmRFbWl0KCdzdGFydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWVtYmVyOmpvaW5lZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXNlKGV2ZW50LmJvZHkpOyAvLyB0YWtlIGNhcmUgb2YgbWlzYWxpZ25lZCBvYmplY3RzLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSk9JTkVEJztcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcC5qb2luZWQgPSBldmVudC5ib2R5LnRpbWVzdGFtcC5qb2luZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmJvZHkuY2hhbm5lbCAmJiBldmVudC5ib2R5LmNoYW5uZWwua25vY2tpbmdfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FsbFN0YXR1c0FuZEVtaXQoJ3N0YXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZW1iZXI6bGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXNlKGV2ZW50LmJvZHkpOyAvLyB0YWtlIGNhcmUgb2YgbWlzYWxpZ25lZCBvYmplY3RzLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnTEVGVCc7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAubGVmdCA9IGV2ZW50LmJvZHkudGltZXN0YW1wLmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmJvZHkucmVhc29uICYmIGV2ZW50LmJvZHkucmVhc29uLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FsbFN0YXR1c0FuZEVtaXQoZXZlbnQuYm9keS5yZWFzb24udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWVtYmVyOm1lZGlhJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1lZGlhID0gZXZlbnQuYm9keS5tZWRpYTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZzpzdGF0dXM6dXBkYXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwubGVncyA9IHV0aWxzXzEuZGVmYXVsdC51cGRhdGVNZW1iZXJMZWdzKHRoaXMuY2hhbm5lbC5sZWdzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FsbFN0YXR1c0FuZEVtaXQoZXZlbnQuYm9keS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXVkaW86cmluZ2luZzpzdGFydCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxTdGF0dXMgfHwgdGhpcy5jYWxsU3RhdHVzID09PSAnc3RhcnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FsbFN0YXR1c0FuZEVtaXQoJ3JpbmdpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogU2V0IHRoZSBtZW1iZXIuY2FsbFN0YXR1cyBhbmQgZW1pdCBhIG1lbWJlcjpjYWxsOnN0YXR1cyBldmVudFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TWVtYmVyLmNhbGxTdGF0dXN9IHRoaXMuY2FsbFN0YXR1cyB0aGUgY2FsbCBzdGF0dXMgdG8gc2V0XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cbiAgICBfc2V0Q2FsbFN0YXR1c0FuZEVtaXQoY2FsbFN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy5jYWxsU3RhdHVzICE9PSBTdHJpbmcoY2FsbFN0YXR1cykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFN0YXR1cyA9IGNhbGxTdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbi5lbWl0KCdtZW1iZXI6Y2FsbDpzdGF0dXMnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1lbWJlcjtcbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBFcnJvcnMgRW1pdHRlclxuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuKi9cbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5jb25zdCBuZXhtb0NsaWVudEVycm9yXzEgPSByZXF1aXJlKFwiLi4vbmV4bW9DbGllbnRFcnJvclwiKTtcbi8qKlxuICogQ2xhc3MgdGhhdCBjYW4gZW1pdCBlcnJvcnMgdmlhIGFueSBlbWl0dGVyIHBhc3NlZCB0byBpdC5cbiAqIEBjbGFzcyBFcnJvcnNFbWl0dGVyXG4gKiBAcGFyYW0ge0VtaXR0ZXJ9IGVtaXR0ZXIgLSBBbnkgZXZlbnQgZW1pdHRlciB0aGF0IGltcGxlbWVudHMgXCJlbWl0XCIgYW5kIFwicmVsZWFzZUdyb3VwXCIuIEJhc2ljYWxseSBvYmplY3QgdGhhdCBpcyBtaXhlZCB3aXRoIFdpbGRlbWl0dGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IExJU1RFTkVSX0dST1VQPSdOWE0tZXJyb3JzJyAtIHRoZSBncm91cCB0aGlzIGVtaXR0ZXIgd2lsbCByZWdpc3RlclxuICogQGVtaXRzIEVtaXR0ZXIjTlhNLWVycm9yc1xuICogQHByaXZhdGVcbiovXG4vKipcbiAqIEFwcGxpY2F0aW9uIGxpc3RlbmluZyBmb3IgY2xpZW50IGFuZCBleHBpcmVkLXRva2VuIGVycm9ycyBldmVudHMuXG4gKlxuICogQGV2ZW50IEFwcGxpY2F0aW9uI05YTS1lcnJvcnNcbiAqXG4gKiBAcHJvcGVydHkge05leG1vQ2xpZW50RXJyb3J9IGVycm9yXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciBjbGllbnQgZXJyb3IgZXZlbnRzIG9uIEFwcGxpY2F0aW9uIGxldmVsPC9jYXB0aW9uPlxuICogYXBwbGljYXRpb24ub24oJyonLCAnTlhNLWVycm9ycycsIChlcnJvcikgPT4ge1xuICogICAgY29uc29sZS5sb2coJ0Vycm9yIHRocm93biB3aXRoIHR5cGUgJyArIGVycm9yLnR5cGUpO1xuICogIH0pO1xuICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciBleHBpcmVkLXRva2VuIGVycm9yIGV2ZW50cyBhbmQgdGhlbiB1cGRhdGUgdGhlIHRva2VuIG9uIEFwcGxpY2F0aW9uIGxldmVsPC9jYXB0aW9uPlxuICogYXBwbGljYXRpb24ub24oJ3N5c3RlbTplcnJvcjpleHBpcmVkLXRva2VuJywgJ05YTS1lcnJvcnMnLCAoZXJyb3IpID0+IHtcbiAqIFx0Y29uc29sZS5sb2coJ3Rva2VuIGV4cGlyZWQnKTtcbiAqIFx0YXBwbGljYXRpb24udXBkYXRlVG9rZW4odG9rZW4pO1xuICogfSk7XG4qL1xuY2xhc3MgRXJyb3JzRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZW1pdHRlcikge1xuICAgICAgICB0aGlzLmxvZyA9IGxvZ2xldmVsXzEuZ2V0TG9nZ2VyKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIGlmICghZW1pdHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKCdubyBlbWl0dGVyIG9iamVjdCBwYXNzZWQgZm9yIHRoZSBFcnJvciBFbWl0dGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5MSVNURU5FUl9HUk9VUCA9ICdOWE0tZXJyb3JzJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSBwYXJhbS50eXBlIGluY2x1ZGVzIGVycm9yIGFuZCBlbWl0IHRoYXQgcGF5bG9hZCBpbiB0aGUgTElTVEVORVJfR1JPVVBcbiAgICAgKiBAcGFyYW0gcGFyYW0gLSB0aGUgcGF5bG9hZCB0byBmb3J3YXJkIGluIHRoZSBMSVNURU5FUl9HUk9VUFxuICAgICAqIEBwYXJhbSBwYXJhbS50eXBlIC0gdGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNoZWNrIGlmIGl0J3MgYW4gZXJyb3JcbiAgICAqL1xuICAgIGVtaXRSZXNwb25zZUlmRXJyb3IocGFyYW0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVHlwZUVycm9yKHBhcmFtLnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLmVtaXQocGFyYW0udHlwZSwgdGhpcy5MSVNURU5FUl9HUk9VUCwgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSBHcm91cCBvbiB0aGUgcmVnaXN0ZXJlZCBlbWl0dGVyICh1c2luZyB0aGUgbmFtZXNwYWNlIExJU1RFTkVSX0dST1VQIHRoYXQgaXMgc2V0KVxuICAgICovXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlci5yZWxlYXNlR3JvdXAodGhpcy5MSVNURU5FUl9HUk9VUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyYW0gaW5jbHVkZXMgJ2Vycm9yJ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gdGhlIGVycm9yIHR5cGUgdG8gY2hlY2tcbiAgICAqL1xuICAgIF9pc1R5cGVFcnJvcihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0uaW5kZXhPZignZXJyb3InKSAhPT0gLTE7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JzRW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzID0gRXJyb3JzRW1pdHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBNZWRpYSBPYmplY3QgTW9kZWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiAqL1xuY29uc3QgbG9nbGV2ZWxfMSA9IHJlcXVpcmUoXCJsb2dsZXZlbFwiKTtcbmNvbnN0IG5leG1vQ2xpZW50RXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9uZXhtb0NsaWVudEVycm9yXCIpO1xuY29uc3QgcnRjX2hlbHBlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3J0Y19oZWxwZXJcIikpO1xuY29uc3QgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3QgbnhtRXZlbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXZlbnRzL254bUV2ZW50XCIpKTtcbmNvbnN0IGNvbnZlcnNhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb252ZXJzYXRpb25cIikpO1xuY29uc3QgYXBwbGljYXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vYXBwbGljYXRpb25cIikpO1xuLyoqXG4gKiBNZW1iZXIgbGlzdGVuaW5nIGZvciBhdWRpbyBzdHJlYW0gb24uXG4gKlxuICogQGV2ZW50IE1lbWJlciNtZWRpYTpzdHJlYW06b25cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGF5bG9hZC5zdHJlYW1JbmRleCB0aGUgaW5kZXggbnVtYmVyIG9mIHRoaXMgc3RyZWFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BheWxvYWQucnRjX2lkXSB0aGUgcnRjX2lkIC8gbGVnX2lkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BheWxvYWQucmVtb3RlX21lbWJlcl9pZF0gdGhlIGlkIG9mIHRoZSBNZW1iZXIgdGhlIHN0cmVhbSBiZWxvbmdzIHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BheWxvYWQubmFtZV0gdGhlIHN0cmVhbSdzIGRpc3BsYXkgbmFtZVxuICogQHByb3BlcnR5IHtNZWRpYVN0cmVhbX0gcGF5bG9hZC5zdHJlYW0gdGhlIHN0cmVhbSB0aGF0IGlzIGFjdGl2YXRlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGF5bG9hZC5hdWRpb19tdXRlXSBpZiB0aGUgYXVkaW8gaXMgbXV0ZWRcbiAqL1xuLyoqXG4gKiBXZWJSVEMgTWVkaWEgY2xhc3NcbiAqIEBjbGFzcyBNZWRpYVxuICogQHByb3BlcnR5IHtBcHBsaWNhdGlvbn0gYXBwbGljYXRpb24gVGhlIHBhcmVudCBhcHBsaWNhdGlvbiBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7Q29udmVyc2F0aW9ufSBwYXJlbnRDb252ZXJzYXRpb24gdGhlIGNvbnZlcnNhdGlvbiBvYmplY3QgdGhpcyBtZWRpYSBpbnN0YW5jZSBiZWxvbmdzIHRvXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGFyZW50Q29udmVyc2F0aW9uLnN0cmVhbUluZGV4IHRoZSBsYXRlc3QgaW5kZXggb2YgdGhlIHN0cmVhbXMsIHVwZGF0ZWQgaW4gZWFjaCBuZXcgcGVlciBvZmZlclxuICogQHByb3BlcnR5IHtvYmplY3RbXX0gcnRjT2JqZWN0cyBkYXRhIHJlbGF0ZWQgdG8gdGhlIHJ0YyBjb25uZWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcnRjT2JqZWN0cy5ydGNfaWQgdGhlIHJ0Y19pZFxuICogQHByb3BlcnR5IHtQZWVyQ29ubmVjdGlvbn0gcnRjT2JqZWN0cy5wYyB0aGUgY3VycmVudCBQZWVyQ29ubmVjdGlvbiBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyZWFtfSBydGNPYmplY3RzLnN0cmVhbSB0aGUgc3RyZWFtIG9mIHRoZSBzcGVjaWZpYyBydGNfaWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcnRjT2JqZWN0cy50eXBlXSBhdWRpbyB0aGUgdHlwZSBvZiB0aGUgc3RyZWFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gcnRjT2JqZWN0cy5zdHJlYW1JbmRleCB0aGUgaW5kZXggbnVtYmVyIG9mIHRoZSBzdHJlYW0gKGUuZy4gdXNlIHRvIG11dGUpXG4gKiBAcHJvcGVydHkge1JUQ1N0YXRzQ29uZmlnfSBydGNzdGF0c19jb25mIHRoZSBjb25maWcgbmVlZGVkIHRvIGNvbnRyb2xsIHJ0Y3N0YXRzIGFuYWx5dGljcyBiZWhhdmlvclxuICogQHByb3BlcnR5IHtSVENTdGF0c0FuYWx5dGljc30gcnRjc3RhdHMgYW4gaW5zdGFuY2UgdG8gY29sbGVjdCBhbmFseXRpY3MgZnJvbSBhIHBlZXIgY29ubmVjdGlvblxuICogQGVtaXRzIEFwcGxpY2F0aW9uI3J0Y3N0YXRzOnJlcG9ydFxuICogQGVtaXRzIEFwcGxpY2F0aW9uI3J0Y3N0YXRzOmFuYWx5dGljc1xuICogQGVtaXRzIE1lbWJlciNtZWRpYTpzdHJlYW06b25cbiAqL1xuY2xhc3MgTWVkaWEge1xuICAgIGNvbnN0cnVjdG9yKGNvbnZlcnNhdGlvbk9yQXBwbGljYXRpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGNvbnZlcnNhdGlvbk9yQXBwbGljYXRpb24gaW5zdGFuY2VvZiBjb252ZXJzYXRpb25fMS5kZWZhdWx0XG4gICAgICAgICAgICA/IGNvbnZlcnNhdGlvbk9yQXBwbGljYXRpb25cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb24gPSBjb252ZXJzYXRpb25PckFwcGxpY2F0aW9uIGluc3RhbmNlb2YgYXBwbGljYXRpb25fMS5kZWZhdWx0XG4gICAgICAgICAgICA/IGNvbnZlcnNhdGlvbk9yQXBwbGljYXRpb25cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dsZXZlbF8xLmdldExvZ2dlcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICBpZiAoY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ0Y0hlbHBlciA9IG5ldyBydGNfaGVscGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGNvbnZlcnNhdGlvbi5hcHBsaWNhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24uYWN0aXZlU3RyZWFtcyA9IHRoaXMuYXBwbGljYXRpb24uYWN0aXZlU3RyZWFtcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Q29udmVyc2F0aW9uID0gY29udmVyc2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5ydGNPYmplY3RzID0ge307XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucnRjc3RhdHNfY29uZiA9ICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmFwcGxpY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJ0Y1N0YXRzKSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMucnRjU3RhdHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwcGxpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ0Y0hlbHBlciA9IG5ldyBydGNfaGVscGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybihcIk5vIGNvbnZlcnNhdGlvbiBvYmplY3QgaW4gTWVkaWFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGFjaEVuZGluZ0V2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRDb252ZXJzYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImF0dGFjaGluZyBsZWF2ZSBsaXN0ZW5lcnMgaW4gbWVkaWEgZm9yIFwiICsgdGhpcy5wYXJlbnRDb252ZXJzYXRpb24uaWQpO1xuICAgICAgICB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5vbihcInJ0YzpoYW5ndXBcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgbWVtYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q29udmVyc2F0aW9uLm1lbWJlcnMuaGFzKGV2ZW50LmZyb20pKSB7XG4gICAgICAgICAgICAgICAgbWVtYmVyID0gdGhpcy5wYXJlbnRDb252ZXJzYXRpb24ubWVtYmVycy5nZXQoZXZlbnQuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSBhd2FpdCB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5nZXRNZW1iZXIoZXZlbnQuZnJvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKGBUaGVyZSBpcyBhbiBlcnJvciBnZXR0aW5nIHRoZSBtZW1iZXIgJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVtYmVyLnVzZXIuaWQgPT09IHRoaXMuYXBwbGljYXRpb24ubWUuaWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmFjdGl2ZVN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW5NZWRpYVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlcm1pbmF0ZSBwZWVyIGNvbm5lY3Rpb24gc3RyZWFtIGluIGNhc2Ugb2YgYSB0cmFuc2ZlclxuICAgICAgICAgICAgaWYgKG1lbWJlci51c2VyLmlkID09PSB0aGlzLmFwcGxpY2F0aW9uLm1lLmlkICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyLnRyYW5zZmVycmVkX2Zyb20pIHtcbiAgICAgICAgICAgICAgICBtZW1iZXIudHJhbnNmZXJyZWRfZnJvbS5tZWRpYS5fY2xlYW5NZWRpYVByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZW1iZXIudXNlci5pZCA9PT0gdGhpcy5hcHBsaWNhdGlvbi5tZS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q29udmVyc2F0aW9uLm9mZihcInJ0YzpoYW5ndXBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggb24gdGhlIHJ0YyBzdGF0cyBlbWl0IGV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2VuYWJsZVN0YXRzRXZlbnRzKCkge1xuICAgICAgICB0aGlzLnJ0Y3N0YXRzX2NvbmYuZW1pdF9ydGNfYW5hbHl0aWNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ydGNzdGF0c19jb25mLnJlbW90ZV9jb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcnRjT2JqZWN0ID0gdGhpcy5fZmluZFJ0Y09iamVjdEJ5VHlwZShcImF1ZGlvXCIpO1xuICAgICAgICBpZiAoIXRoaXMucnRjU3RhdHMgJiYgcnRjT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgZW5hYmxpbmcgc3RhdHMgZXZlbnRzIGZvciAke3J0Y09iamVjdC5ydGNfaWR9YCk7XG4gICAgICAgICAgICB0aGlzLnJ0Y1N0YXRzID0gcnRjX2hlbHBlcl8xLmRlZmF1bHQuX2luaXRTdGF0c0V2ZW50cyh7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb246IHRoaXMuYXBwbGljYXRpb24sXG4gICAgICAgICAgICAgICAgcnRjX2lkOiBydGNPYmplY3QucnRjX2lkLFxuICAgICAgICAgICAgICAgIHBjOiB0aGlzLnBjLFxuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbjogdGhpcy5wYXJlbnRDb252ZXJzYXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggb2ZmIHRoZSBydGNTdGF0IGV2ZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Rpc2FibGVTdGF0c0V2ZW50cygpIHtcbiAgICAgICAgdGhpcy5ydGNzdGF0c19jb25mLmVtaXRfZXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnRjc3RhdHNfY29uZi5lbWl0X3J0Y19hbmFseXRpY3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydGNzdGF0c19jb25mLnJlbW90ZV9jb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnRjU3RhdHMucmVtb3ZlSW50ZXJ2YWxzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJ0Y1N0YXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGluaXQgdGhlIG1lZGlhIHN0cmVhbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F1ZGlvSW5pdEhhbmRsZXIocGFyYW1zID0ge30sIG9uSWNlQ2FuZGlkYXRlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtSW5kZXggPSB0aGlzLnN0cmVhbUluZGV4O1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmRleCsrO1xuICAgICAgICAgICAgY29uc3QgeyBhdWRpb0NvbnN0cmFpbnRzIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RyZWFtID0gYXdhaXQgcnRjX2hlbHBlcl8xLmRlZmF1bHQuZ2V0VXNlckF1ZGlvKGF1ZGlvQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBjID0gcnRjX2hlbHBlcl8xLmRlZmF1bHQuY3JlYXRlUGVlckNvbm5lY3Rpb24odGhpcy5hcHBsaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYyA9IHBjO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXBwbGljYXRpb24sIGxvZywgcGFyZW50Q29udmVyc2F0aW9uOiBjb252ZXJzYXRpb24sIHJ0Y09iamVjdHMgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGMsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbG9nLFxuICAgICAgICAgICAgICAgICAgICBydGNPYmplY3RzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvbkljZUNhbmRpZGF0ZUhhbmRsZXIoeyAuLi5jb250ZXh0LCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICAgICAgcnRjX2hlbHBlcl8xLmRlZmF1bHQuYXR0YWNoQ29udmVyc2F0aW9uRXZlbnRIYW5kbGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hFbmRpbmdFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBlbmFibGluZyBvZiBhdWRpbyB3aGVuIGFuIG9mZmVyIGlzIGF2YWlsYWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4ZWNBbnN3ZXIocGFyYW1zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBvZmZlcjogeyBzZHAsIGxlZ19pZCB9IH0gPSBwYXJhbXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdWRpb0luaXRIYW5kbGVyKHBhcmFtcywgKGNvbnRleHQpID0+IHJ0Y19oZWxwZXJfMS5kZWZhdWx0LmRvQW5zd2VyKGNvbnRleHQsIHNkcCwgbGVnX2lkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGVuYWJsaW5nIG9mIGF1ZGlvIG9ubHkgc3RyZWFtIHdpdGggcnRjOm5ld1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZUF1ZGlvKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcmVjb25uZWN0UnRjSWQgfSA9IHBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1ZGlvSW5pdEhhbmRsZXIocGFyYW1zLCAoY29udGV4dCkgPT4gcnRjX2hlbHBlcl8xLmRlZmF1bHQuYXR0YWNoUGVlckNvbm5lY3Rpb25FdmVudEhhbmRsZXJzKHsgLi4uY29udGV4dCwgcmVjb25uZWN0UnRjSWQgfSkpO1xuICAgIH1cbiAgICBfZmluZFJ0Y09iamVjdEJ5VHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMucnRjT2JqZWN0cykuZmluZCgocnRjT2JqZWN0KSA9PiBydGNPYmplY3QudHlwZSA9PT0gdHlwZSk7XG4gICAgfVxuICAgIGFzeW5jIF9jbGVhbkNvbnZlcnNhdGlvblByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBjKSB7XG4gICAgICAgICAgICB0aGlzLnBjLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcCBhY3RpdmUgc3RyZWFtXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBjO1xuICAgICAgICB0aGlzLnJ0Y1N0YXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5hY3RpdmVTdHJlYW1zID0gW107XG4gICAgICAgIHRoaXMubGlzdGVuaW5nVG9SdGNFdmVudCA9IGZhbHNlO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHRoZSB1c2VyJ3MgbWVkaWEgYmVmb3JlIGxlYXZpbmcgdGhlIGNvbnZlcnNhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFuTWVkaWFQcm9wZXJ0aWVzKCkge1xuICAgICAgICBpZiAodGhpcy5wYykge1xuICAgICAgICAgICAgdGhpcy5wYy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ0Y09iamVjdHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVnX2lkIGluIHRoaXMucnRjT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIHJ0Y19oZWxwZXJfMS5kZWZhdWx0LmNsb3NlU3RyZWFtKHRoaXMucnRjT2JqZWN0c1tsZWdfaWRdLnN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMucGM7XG4gICAgICAgIHRoaXMucnRjU3RhdHMgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmFjdGl2ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5ydGNPYmplY3RzID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuaW5nVG9SdGNFdmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBfZGlzYWJsZUxlZyhsZWdfaWQpIHtcbiAgICAgICAgY29uc3QgY3NSZXF1ZXN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5wYXJlbnRDb252ZXJzYXRpb24uaWR9L3J0Yy8ke2xlZ19pZH0/ZnJvbT0ke3RoaXMucGFyZW50Q29udmVyc2F0aW9uLm1lLmlkfSZvcmlnaW5hdGluZ19zZXNzaW9uPSR7dGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlc3Npb25faWR9YCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCJiZXRhMlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoXCJydGM6dGVybWluYXRlOnN1Y2Nlc3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbG9zZVJlc291cmNlc1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucnRjT2JqZWN0c1tsZWdfaWRdLnBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydGNPYmplY3RzW2xlZ19pZF0ucGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJ0Y09iamVjdHNbbGVnX2lkXS5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBydGNfaGVscGVyXzEuZGVmYXVsdC5jbG9zZVN0cmVhbSh0aGlzLnJ0Y09iamVjdHNbbGVnX2lkXS5zdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtjc1JlcXVlc3RQcm9taXNlLCBjbG9zZVJlc291cmNlc1Byb21pc2VdKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Q29udmVyc2F0aW9uLm1lLmVtaXQoXCJtZWRpYTpzdHJlYW06b2ZmXCIsIHRoaXMucnRjT2JqZWN0c1tsZWdfaWRdLnN0cmVhbUluZGV4KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJ0Y09iamVjdHNbbGVnX2lkXTtcbiAgICAgICAgICAgIHJldHVybiBcInJ0Yzp0ZXJtaW5hdGU6c3VjY2Vzc1wiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuYWJsZU1lZGlhVHJhY2tzKHRyYWNrcywgZW5hYmxlZCkge1xuICAgICAgICB0cmFja3MuZm9yRWFjaCgobWVkaWFUcmFjaykgPT4ge1xuICAgICAgICAgICAgbWVkaWFUcmFjay5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtdXRlIHJlcXVlc3Qgd2l0aCB0aGUgcnRjX2lkIGFuZCBlbmFibGUvZGlzYWJsZSB0aGUgdHJhY2tzXG4gICAgICogSWYgdGhlIG11dGUgcmVxdWVzdCBmYWlscyByZXZlcnQgdGhlIGNoYW5nZXMgaW4gdGhlIHRyYWNrc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3NldE1lZGlhVHJhY2tzQW5kTXV0ZShydGNfaWQsIHRyYWNrcywgbXV0ZSwgbWVkaWFUeXBlKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZU1lZGlhVHJhY2tzKHRyYWNrcywgIW11dGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5wYXJlbnRDb252ZXJzYXRpb24uaWR9L2V2ZW50c2AsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5tZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5wYXJlbnRDb252ZXJzYXRpb24ubWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0Y19pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVNZWRpYVRyYWNrcyh0cmFja3MsIG11dGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0FwaUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0aGUgc3RyZWFtJ3MgYXVkaW8gdHJhY2tzIGN1cnJlbnRseSBiZWluZyB1c2VkIGFzIHRoZSBzZW5kZXIncyBzb3VyY2VzIHdpdGggYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnN0cmFpbnRzIC0gYXVkaW8gY29uc3RyYWludHMgLSB7IGRldmljZUlkOiB7IGV4YWN0OiBzZWxlY3RlZEF1ZGlvRGV2aWNlSWQgfSB9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBydGMgb2JqZWN0IHR5cGUgLSBhdWRpb1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1lZGlhU3RyZWFtPn0gLSBSZXR1cm5zIHRoZSBuZXcgc3RyZWFtLlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlVwZGF0ZSB0aGUgc3RyZWFtIGN1cnJlbnRseSBiZWluZyB1c2VkIHdpdGggYSBuZXcgYXVkaW8gc291cmNlPC9jYXB0aW9uPlxuICAgICAqIGNvbnZlcnNhdGlvbi5tZWRpYS51cGRhdGVBdWRpb0NvbnN0cmFpbnRzKHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IHNlbGVjdGVkQXVkaW9EZXZpY2VJZCB9IH0sIFwiYXVkaW9cIilcbiAgICAgKiAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVBdWRpb0NvbnN0cmFpbnRzKGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICAgICAgbGV0IHJ0Y09iamVjdEJ5VHlwZSA9IHRoaXMuX2ZpbmRSdGNPYmplY3RCeVR5cGUoJ2F1ZGlvJyk7XG4gICAgICAgIGlmIChydGNPYmplY3RCeVR5cGUgJiYgcnRjT2JqZWN0QnlUeXBlLnBjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RyZWFtID0gYXdhaXQgcnRjX2hlbHBlcl8xLmRlZmF1bHQuZ2V0VXNlckF1ZGlvKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSBydGNPYmplY3RCeVR5cGUucGNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTZW5kZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLnRyYWNrLmtpbmQgPT09IHRyYWNrLmtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gc2VuZGVyLnRyYWNrLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJ0Y19oZWxwZXJfMS5kZWZhdWx0LmNsb3NlU3RyZWFtKHJ0Y09iamVjdEJ5VHlwZS5zdHJlYW0pO1xuICAgICAgICAgICAgICAgIHJ0Y09iamVjdEJ5VHlwZS5zdHJlYW0gPSBsb2NhbFN0cmVhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoXCJlcnJvcjptZWRpYTpzdHJlYW06bm90LWZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGUgeW91ciBNZW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGU9ZmFsc2VdIHRydWUgZm9yIG11dGUsIGZhbHNlIGZvciB1bm11dGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0cmVhbUluZGV4XSBzdHJlYW0gaWQgdG8gc2V0IC0gaWYgaXQncyBub3Qgc2V0IGFsbCBzdHJlYW1zIHdpbGwgYmUgbXV0ZWRcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NdXRlIHlvdXIgYXVkaW8gc3RyZWFtIGluIHRoZSBDb252ZXJzYXRpb248L2NhcHRpb24+XG4gICAgICogLy8gTXV0ZSB5b3VyIE1lbWJlclxuICAgICAqIGNvbnZlcnNhdGlvbi5tZWRpYS5tdXRlKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gVW5tdXRlIHlvdXIgTWVtYmVyXG4gICAgICogY29udmVyc2F0aW9uLm1lZGlhLm11dGUoZmFsc2UpO1xuICAgICAqL1xuICAgIG11dGUobXV0ZSA9IGZhbHNlLCBzdHJlYW1JbmRleCA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBtdXRlID8gXCJvblwiIDogXCJvZmZcIjtcbiAgICAgICAgY29uc3QgYXVkaW9UeXBlID0gXCJhdWRpbzptdXRlOlwiICsgc3RhdGU7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBsZXQgbXV0ZU9iamVjdHMgPSB7fTtcbiAgICAgICAgaWYgKHN0cmVhbUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtdXRlT2JqZWN0c1swXSA9IE9iamVjdC52YWx1ZXModGhpcy5ydGNPYmplY3RzKS5maW5kKChydGNPYmopID0+IHJ0Y09iai5zdHJlYW1JbmRleCA9PT0gc3RyZWFtSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFtdXRlT2JqZWN0c1swXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcihcImVycm9yOm1lZGlhOnN0cmVhbTpub3QtZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtdXRlT2JqZWN0cyA9IHRoaXMucnRjT2JqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QudmFsdWVzKG11dGVPYmplY3RzKS5mb3JFYWNoKChydGNPYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gcnRjT2JqZWN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgY29uc3QgYXVkaW9Qcm9taXNlID0gdGhpcy5fc2V0TWVkaWFUcmFja3NBbmRNdXRlKHJ0Y09iamVjdC5ydGNfaWQsIGF1ZGlvVHJhY2tzLCBtdXRlLCBhdWRpb1R5cGUpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChhdWRpb1Byb21pc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFybXVmZiBvdXIgbWVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXNdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIGVhcm11ZmYoZWFybXVmZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoXCJlcnJvcjpzZWxmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImF1ZGlvOmVhcm11ZmY6b2ZmXCI7XG4gICAgICAgICAgICAgICAgaWYgKGVhcm11ZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiYXVkaW86ZWFybXVmZjpvblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlLCB9ID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMucGFyZW50Q29udmVyc2F0aW9uLmlkfS9ldmVudHNgLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMucGFyZW50Q29udmVyc2F0aW9uLm1lLmlkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG1lZGlhIHBhcnRpY2lwYXRpb24gaW4gdGhlIGNvbnZlcnNhdGlvbiBmb3IgdGhpcyBhcHBsaWNhdGlvbiAocmVxdWlyZXMgV2ViUlRDKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIHJ0YyBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5sYWJlbF0gLSBsYWJlbCBpcyBhbiBhcHBsaWNhdGlvbiBkZWZpbmVkIHRhZywgZWcuIOKAmGZ1bGxzY3JlZW7igJlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5yZWNvbm5lY3RSdGNJZF0gLSB0aGUgcnRjX2lkIC8gbGVnX2lkIG9mIHRoZSBjYWxsIHRvIHJlY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmF1ZGlvPXRydWVdIC0gYXVkaW8gZW5hYmxlbWVudCBtb2RlLiBwb3NzaWJsZSB2YWx1ZXMgXCJib3RoXCIsIFwic2VuZF9vbmx5XCIsIFwicmVjZWl2ZV9vbmx5XCIsIFwibm9uZVwiLCB0cnVlIG9yIGZhbHNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMuYXV0b1BsYXlBdWRpbz1mYWxzZV0gLSBhdHRhY2ggdGhlIGF1ZGlvIHN0cmVhbSBhdXRvbWF0aWNhbGx5IHRvIHN0YXJ0IHBsYXlpbmcgYWZ0ZXIgZW5hYmxlIG1lZGlhIChkZWZhdWx0IGZhbHNlKVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmF1ZGlvQ29uc3RyYWludHNdIC0gYXVkaW8gY29uc3RyYWludHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmF1ZGlvQ29uc3RyYWludHMuYXV0b0dhaW5Db250cm9sXSAtIGEgYm9vbGVhbiB3aGljaCBzcGVjaWZpZXMgd2hldGhlciBhdXRvbWF0aWMgZ2FpbiBjb250cm9sIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuYXVkaW9Db25zdHJhaW50cy5lY2hvQ2FuY2VsbGF0aW9uXSAtIGEgYm9vbGVhbiBzcGVjaWZ5aW5nIHdoZXRoZXIgb3Igbm90IGVjaG8gY2FuY2VsbGF0aW9uIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuYXVkaW9Db25zdHJhaW50cy5ub2lzZVN1cHByZXNzaW9uXSAtIGEgYm9vbGVhbiB3aGljaCBzcGVjaWZpZXMgd2hldGhlciBub2lzZSBzdXBwcmVzc2lvbiBpcyBwcmVmZXJyZWQgYW5kL29yIHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBBcnJheX0gW3BhcmFtcy5hdWRpb0NvbnN0cmFpbnRzLmRldmljZUlkXSAtIG9iamVjdCBzcGVjaWZ5aW5nIGEgZGV2aWNlIElEIG9yIGFuIGFycmF5IG9mIGRldmljZSBJRHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWVkaWFTdHJlYW0+fVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVuYWJsZSBtZWRpYSBpbiB0aGUgQ29udmVyc2F0aW9uPC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogY29udmVyc2F0aW9uLm1lZGlhLmVuYWJsZSgpXG4gICAgICogLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAqICAgIGNvbnN0IG1lZGlhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuICAgICAqICAgIGNvbnN0IHNvdXJjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7XG4gICAgICogICAgY29uc3QgbWVkaWFfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgKiAgICBtZWRpYS5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgICAqICAgIG1lZGlhX2Rpdi5hcHBlbmRDaGlsZChtZWRpYSk7XG4gICAgICogICAgZG9jdW1lbnQuaW5zZXJ0QmVmb3JlKG1lZGlhX2Rpdik7XG4gICAgICogICAgLy8gT2xkZXIgYnJvd3NlcnMgbWF5IG5vdCBoYXZlIHNyY09iamVjdFxuICAgICAqICAgIGlmIChcInNyY09iamVjdFwiIGluIG1lZGlhKSB7XG4gICAgICogICAgICBtZWRpYS5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICogICAgfSBlbHNlIHtcbiAgICAgKiAgICAgIC8vIEF2b2lkIHVzaW5nIHRoaXMgaW4gbmV3IGJyb3dzZXJzLCBhcyBpdCBpcyBnb2luZyBhd2F5LlxuICAgICAqICAgICAgbWVkaWEuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgKiAgICB9XG4gICAgICogICAgbWVkaWEub25sb2FkZWRtZXRhZGF0YSA9IChlKSA9PiB7XG4gICAgICogICAgICBtZWRpYS5wbGF5KCk7XG4gICAgICogICAgfTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqKi9cbiAgICBhc3luYyBlbmFibGUocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDb252ZXJzYXRpb24ubWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoXCJlcnJvcjpzZWxmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvZmZlciB9ID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgICAgICAgICAgbGV0IHJlbW90ZVN0cmVhbSA9IGF3YWl0IChvZmZlciAhPT0gdW5kZWZpbmVkID8gdGhpcy5fZXhlY0Fuc3dlcihwYXJhbXMpIDogdGhpcy5faGFuZGxlQXVkaW8ocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoZSBhdWRpbyBzdHJlYW0gYXV0b21hdGljYWxseSB0byBzdGFydCBwbGF5aW5nXG4gICAgICAgICAgICAgICAgbGV0IGF1dG9QbGF5QXVkaW8gPSBwYXJhbXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHBhcmFtcy5hdXRvUGxheUF1ZGlvIHx8IHBhcmFtcy5hdXRvUGxheUF1ZGlvID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zIHx8IGF1dG9QbGF5QXVkaW8pIHtcbiAgICAgICAgICAgICAgICAgICAgcnRjX2hlbHBlcl8xLmRlZmF1bHQucGxheUF1ZGlvU3RyZWFtKHJlbW90ZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdGVTdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIG1lZGlhIHBhcnRpY2lwYXRpb24gaW4gdGhlIGNvbnZlcnNhdGlvbiBmb3IgdGhpcyBhcHBsaWNhdGlvblxuICAgICAqIGlmIFJ0Y1N0YXRzIE1PUyBpcyBlbmFibGVkLCBhIGZpbmFsIHJlcG9ydCB3aWxsIGJlIGF2YWlsYWJsZSBpblxuICAgICAqIE5leG1vQ2xpZW50I3J0Y3N0YXRzOnJlcG9ydFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkRpc2FibGUgbWVkaWEgaW4gdGhlIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGNvbnZlcnNhdGlvbi5tZWRpYS5kaXNhYmxlKClcbiAgICAgKiAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICoqL1xuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2NsZWFuQ29udmVyc2F0aW9uUHJvcGVydGllcygpKTtcbiAgICAgICAgZm9yIChjb25zdCBsZWdfaWQgaW4gdGhpcy5ydGNPYmplY3RzKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2Rpc2FibGVMZWcobGVnX2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheSBhIHZvaWNlIHRleHQgaW4gdGhlIENvbnZlcnNhdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnRleHQgLSBUaGUgdGV4dCB0byBzYXkgaW4gdGhlIENvbnZlcnNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy52b2ljZV9uYW1lPVwiQW15XCJdIC0gTmFtZSBvZiB0aGUgdm9pY2UgdG8gdXNlIGZvciBzcGVlY2ggdG8gdGV4dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5sZXZlbD0xXSAtIFNldCB0aGUgYXVkaW8gbGV2ZWwgb2YgdGhlIGF1ZGlvIHN0cmVhbTogbWluPS0xIG1heD0xIGluY3JlbWVudD0wLjEuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnF1ZXVlPXRydWVdIC0gP1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5sb29wPTFdIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYXVkaW8uIFNldCB0byAwIHRvIGxvb3AgaW5maW5pdGVseS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc3NtbD1mYWxzZV0gLSBDdXN0b21pemUgdGhlIHNwb2tlbiB0ZXh0IHdpdGggPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm5leG1vLmNvbS92b2ljZS92b2ljZS1hcGkvZ3VpZGVzL2N1c3RvbWl6aW5nLXR0c1wiPlNwZWVjaCBTeW50aGVzaXMgTWFya3VwIExhbmd1YWdlIChTU01MKTwvYT4gc3BlY2lmaWNhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TlhNRXZlbnQ+fVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlBsYXkgc3BlZWNoIHRvIHRleHQgaW4gdGhlIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ubWVkaWEuc2F5VGV4dCh7dGV4dDpcImhpXCJ9KVxuICAgICAqIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiB9KVxuICAgICAqIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiovXG4gICAgYXN5bmMgc2F5VGV4dChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXVkaW86c2F5XCIsXG4gICAgICAgICAgICAgICAgICAgIGNpZDogdGhpcy5wYXJlbnRDb252ZXJzYXRpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMucGFyZW50Q29udmVyc2F0aW9uLm1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhbXMudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWNlX25hbWU6IHBhcmFtcy52b2ljZV9uYW1lIHx8IFwiQW15XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogcGFyYW1zLmxldmVsIHx8IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogcGFyYW1zLnF1ZXVlIHx8IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wOiBwYXJhbXMubG9vcCB8fCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3NtbDogcGFyYW1zLnNzbWwgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBueG1FdmVudF8xLmRlZmF1bHQodGhpcy5wYXJlbnRDb252ZXJzYXRpb24sIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBEVE1GIGluIHRoZSBDb252ZXJzYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlnaXQgLSB0aGUgRFRNRiBkaWdpdChzKSB0byBzZW5kXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOWE1FdmVudD59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2VuZCBEVE1GIGluIHRoZSBDb252ZXJzYXRpb248L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm1lZGlhLnNlbmREVE1GKFwiZGlnaXRcIik7XG4gICAgICogLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIH0pXG4gICAgICogLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKiovXG4gICAgYXN5bmMgc2VuZERUTUYoZGlnaXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdXRpbHNfMS5kZWZhdWx0LnZhbGlkYXRlRFRNRihkaWdpdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoXCJlcnJvcjphdWRpbzpkdG1mOmludmFsaWQtZGlnaXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydGNfaWQgPSAodGhpcy5fZmluZFJ0Y09iamVjdEJ5VHlwZSgnYXVkaW8nKSB8fCB7fSkucnRjX2lkO1xuICAgICAgICAgICAgaWYgKCFydGNfaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoXCJlcnJvcjphdWRpbzpkdG1mOmF1ZGlvLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBpZCwgdGltZXN0YW1wLCB9ID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXVkaW86ZHRtZlwiLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5tZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5fZmluZFJ0Y09iamVjdEJ5VHlwZSgnYXVkaW8nKS5ydGNfaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlcl9ldmVudCA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0LFxuICAgICAgICAgICAgICAgICAgICBkdG1mX2lkOiBcIlwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2lkOiB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5pZCxcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5tZS5pZCxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhdWRpbzpkdG1mXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZHRtZkV2ZW50ID0gbmV3IG54bUV2ZW50XzEuZGVmYXVsdCh0aGlzLnBhcmVudENvbnZlcnNhdGlvbiwgcGxhY2Vob2xkZXJfZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRDb252ZXJzYXRpb24uZXZlbnRzLnNldChwbGFjZWhvbGRlcl9ldmVudC5pZCwgZHRtZkV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBkdG1mRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXkgYW4gYXVkaW8gc3RyZWFtIGluIHRoZSBDb252ZXJzYXRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sZXZlbCAtIFNldCB0aGUgYXVkaW8gbGV2ZWwgb2YgdGhlIGF1ZGlvIHN0cmVhbTogbWluPS0xIG1heD0xIGluY3JlbWVudD0wLjEuXG4gICAgICogQHBhcmFtIHthcnJheX0gcGFyYW1zLnN0cmVhbV91cmwgLSBMaW5rIHRvIHRoZSBhdWRpbyBmaWxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubG9vcCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGF1ZGlvLiBTZXQgdG8gMCB0byBsb29wIGluZmluaXRlbHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOWE1FdmVudD59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+UGxheSBhbiBhdWRpbyBzdHJlYW0gaW4gdGhlIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ubWVkaWEucGxheVN0cmVhbSh7IGxldmVsOiAwLjUsIHN0cmVhbV91cmw6IFtcImh0dHBzOi8vbmV4bW8tY29tbXVuaXR5LmdpdGh1Yi5pby9uY2NvLWV4YW1wbGVzL2Fzc2V0cy92b2ljZV9hcGlfYXVkaW9fc3RyZWFtaW5nLm1wM1wiXSwgbG9vcDogMSB9KVxuICAgICAqIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coXCJyZXNwb25zZTogXCIsIHJlc3BvbnNlKTtcbiAgICAgKiB9KVxuICAgICAqIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvcjogXCIsIGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHBsYXlTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IGBjb252ZXJzYXRpb25zLyR7dGhpcy5wYXJlbnRDb252ZXJzYXRpb24uaWR9L2V2ZW50c2AsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImF1ZGlvOnBsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbnhtRXZlbnRfMS5kZWZhdWx0KHRoaXMucGFyZW50Q29udmVyc2F0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgc3RhcnQgcmluZ2luZyBldmVudFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5YTUV2ZW50Pn1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TZW5kIHN0YXJ0IHJpbmdpbmcgZXZlbnQgaW4gdGhlIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGNvbnZlcnNhdGlvbi5tZWRpYS5zdGFydFJpbmdpbmcoKVxuICAgICAqIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIExpc3RlbiBmb3Igc3RhcnQgcmluZ2luZyBldmVudFxuICAgICAqIGNvbnZlcnNhdGlvbi5vbignYXVkaW86cmluZ2luZzpzdGFydCcsIChkYXRhKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJyaW5naW5nIHN0YXJ0ZWQ6IFwiLCBkYXRhKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0UmluZ2luZygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYGNvbnZlcnNhdGlvbnMvJHt0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5pZH0vZXZlbnRzYCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXVkaW86cmluZ2luZzpzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnBhcmVudENvbnZlcnNhdGlvbi5tZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBueG1FdmVudF8xLmRlZmF1bHQodGhpcy5wYXJlbnRDb252ZXJzYXRpb24sIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBzdG9wIHJpbmdpbmcgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOWE1FdmVudD59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2VuZCBzdG9wIHJpbmdpbmcgZXZlbnQgaW4gdGhlIENvbnZlcnNhdGlvbjwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAqIGNvbnZlcnNhdGlvbi5tZWRpYS5zdG9wUmluZ2luZygpXG4gICAgICogLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gTGlzdGVuIGZvciBzdG9wIHJpbmdpbmcgZXZlbnRcbiAgICAgKiBjb252ZXJzYXRpb24ub24oJ2F1ZGlvOnJpbmdpbmc6c3RvcCcsIChkYXRhKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJyaW5naW5nIHN0b3BwZWQ6IFwiLCBkYXRhKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3BSaW5naW5nKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBgY29udmVyc2F0aW9ucy8ke3RoaXMucGFyZW50Q29udmVyc2F0aW9uLmlkfS9ldmVudHNgLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhdWRpbzpyaW5naW5nOnN0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5wYXJlbnRDb252ZXJzYXRpb24ubWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbnhtRXZlbnRfMS5kZWZhdWx0KHRoaXMucGFyZW50Q29udmVyc2F0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWVkaWE7XG5tb2R1bGUuZXhwb3J0cyA9IE1lZGlhO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBOWE1DYWxsIE9iamVjdCBNb2RlbFxuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuKi9cbmNvbnN0IFdpbGRFbWl0dGVyID0gcmVxdWlyZSgnd2lsZGVtaXR0ZXInKTtcbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5jb25zdCBuZXhtb0NsaWVudEVycm9yXzEgPSByZXF1aXJlKFwiLi4vbmV4bW9DbGllbnRFcnJvclwiKTtcbmNvbnN0IHJ0Y19oZWxwZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ydGNfaGVscGVyXCIpKTtcbi8qKlxuICogQ29udmVyc2F0aW9uIE5YTUNhbGwgT2JqZWN0LlxuICogQGNsYXNzIE5YTUNhbGxcbiAqIEBwYXJhbSB7QXBwbGljYXRpb259IGFwcGxpY2F0aW9uIC0gVGhlIEFwcGxpY2F0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Q29udmVyc2F0aW9ufSBjb252ZXJzYXRpb24gLSBUaGUgQ29udmVyc2F0aW9uIG9iamVjdCB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBueG1DYWxsLlxuICogQHBhcmFtIHtNZW1iZXJ9IGZyb20gLSBUaGUgbWVtYmVyIHRoYXQgaW5pdGlhdGVkIHRoZSBueG1DYWxsLlxuICogQHByb3BlcnR5IHtBcHBsaWNhdGlvbn0gYXBwbGljYXRpb24gLSAgVGhlIEFwcGxpY2F0aW9uIG9iamVjdCB0aGF0IHRoZSBueG1DYWxsIGJlbG9uZ3MgdG8uXG4gKiBAcHJvcGVydHkge0NvbnZlcnNhdGlvbn0gY29udmVyc2F0aW9uIC0gIFRoZSBDb252ZXJzYXRpb24gb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIG54bUNhbGwuXG4gKiBAcHJvcGVydHkge01lbWJlcn0gZnJvbSAtIFRoZSBjYWxsZXIuIFRoZSBtZW1iZXIgb2JqZWN0IG9mIHRoZSBjYWxsZXIgKG5vdCBhIHJlZmVyZW5jZSB0byB0aGUgb25lIGluIGNvbnZlcnNhdGlvbi5tZW1iZXJzKVxuICogQHByb3BlcnR5IHtNYXA8c3RyaW5nLCBNZW1iZXI+fSB0byAtIFRoZSBjYWxsZWVzIGtleWVkIGJ5IGEgbWVtYmVyJ3MgaWQuIFRoZSBtZW1iZXJzIHRoYXQgcmVjZWl2ZSB0aGUgbnhtQ2FsbCAobm90IGEgcmVmZXJlbmNlIHRvIGNvbnZlcnNhdGlvbi5tZW1iZXJzKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGlkIC0gVGhlIG54bUNhbGwgaWQgKG91ciBtZW1iZXIncyBsZWdfaWQsIGNvbWVzIGZyb20gcnRjOmFuc3dlciBldmVudCwgb3IgbWVtYmVyOm1lZGlhKVxuICogQHByb3BlcnR5IHtOWE1DYWxsLkNBTExfU1RBVFVTfSBDQUxMX1NUQVRVUz1cInN0YXJ0ZWRcIiAtIHRoZSBhdmFpbGFibGUgbnhtQ2FsbCBzdGF0dXNlc1xuICogQHByb3BlcnR5IHtOWE1DYWxsLkNBTExfRElSRUNUSU9OfSBkaXJlY3Rpb24gLSB0aGUgRGlyZWN0aW9uIG9mIHRoZSBueG1DYWxsLCBPdXRib3VuZCwgSW5ib3VuZFxuICogQHByb3BlcnR5IHtOWE1DYWxsLlNUQVRVU19QRVJNSVRURURfRkxPV30gU1RBVFVTX1BFUk1JVFRFRF9GTE9XIC0gdGhlIHBlcm1pdHRlZCBueG1DYWxsIHN0YXR1cyB0cmFuc2l0aW9uIG1hcCwgZGVzY3JpYmVzIHRoZSBcImZyb21cIiBhbmQgYWxsb3dlZCBcInRvXCIgdHJhbnNpdGlvbnNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0W119IHJ0Y09iamVjdHMgZGF0YSByZWxhdGVkIHRvIHRoZSBydGMgY29ubmVjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJ0Y09iamVjdHMucnRjX2lkIHRoZSBydGNfaWRcbiAqIEBwcm9wZXJ0eSB7UGVlckNvbm5lY3Rpb259IHJ0Y09iamVjdHMucGMgdGhlIGN1cnJlbnQgUGVlckNvbm5lY3Rpb24gb2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmVhbX0gcnRjT2JqZWN0cy5zdHJlYW0gdGhlIHN0cmVhbSBvZiB0aGUgc3BlY2lmaWMgcnRjX2lkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3J0Y09iamVjdHMudHlwZV0gYXVkaW8gdGhlIHR5cGUgb2YgdGhlIHN0cmVhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJ0Y09iamVjdHMuc3RyZWFtSW5kZXggdGhlIGluZGV4IG51bWJlciBvZiB0aGUgc3RyZWFtIChlLmcuIHVzZSB0byBtdXRlKVxuICogQHByb3BlcnR5IHtTdHJlYW19IHN0cmVhbSB0aGUgcmVtb3RlIHN0cmVhbVxuICogQGVtaXRzIEFwcGxpY2F0aW9uI21lbWJlcjpjYWxsXG4gKiBAZW1pdHMgQXBwbGljYXRpb24jY2FsbDpzdGF0dXM6Y2hhbmdlZFxuKi9cbi8qKlxuICogQXBwbGljYXRpb24gbGlzdGVuaW5nIGZvciBtZW1iZXIgY2FsbCBldmVudHMuXG4gKlxuICogQGV2ZW50IEFwcGxpY2F0aW9uI21lbWJlcjpjYWxsXG4gKlxuICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBtZW1iZXIgdGhhdCBpbml0aWF0ZWQgdGhlIG54bUNhbGxcbiAqIEBwcm9wZXJ0eSB7TlhNQ2FsbH0gbnhtQ2FsbCAtICByZXNvbHZlcyB0aGUgbnhtQ2FsbCBvYmplY3RcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIG1lbWJlciBjYWxsIGV2ZW50cyBvbiBBcHBsaWNhdGlvbiBsZXZlbDwvY2FwdGlvbj5cbiAqICBhcHBsaWNhdGlvbi5vbihcIm1lbWJlcjpjYWxsXCIsIChtZW1iZXIsIG54bUNhbGwpID0+IHtcbiAqICAgIGNvbnNvbGUubG9nKFwiTlhNQ2FsbCBcIiwgbnhtQ2FsbCk7XG4gKiAgfSk7XG4qL1xuLyoqXG4gKiBBcHBsaWNhdGlvbiBsaXN0ZW5pbmcgZm9yIG54bUNhbGwgc3RhdHVzIGNoYW5nZWQgZXZlbnRzLlxuICpcbiAqIEBldmVudCBBcHBsaWNhdGlvbiNjYWxsOnN0YXR1czpjaGFuZ2VkXG4gKiBAcHJvcGVydHkge05YTUNhbGx9IG54bUNhbGwgLSAgdGhlIGFjdHVhbCBldmVudFxuICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciBueG1DYWxsIHN0YXR1cyBjaGFuZ2VkIGV2ZW50cyBvbiBBcHBsaWNhdGlvbiBsZXZlbDwvY2FwdGlvbj5cbiAqICBhcHBsaWNhdGlvbi5vbihcImNhbGw6c3RhdHVzOmNoYW5nZWRcIiwobnhtQ2FsbCkgPT4ge1xuICogICAgY29uc29sZS5sb2coXCJjYWxsOiBcIiArIG54bUNhbGwuc3RhdHVzKTtcbiAqICB9KTtcbiovXG5jbGFzcyBOWE1DYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvbiwgY29udmVyc2F0aW9uLCBmcm9tKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dsZXZlbF8xLmdldExvZ2dlcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucnRjT2JqZWN0cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bSBmb3IgTlhNQ2FsbCBzdGF0dXMuXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICAgKiBAYWxpYXMgTlhNQ2FsbC5DQUxMX1NUQVRVU1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLkNBTExfU1RBVFVTID0ge1xuICAgICAgICAgICAgLyoqIFRoZSBOWE1DYWxsIGlzIGluIHN0YXJ0ZWQgc3RhdHVzICovXG4gICAgICAgICAgICBTVEFSVEVEOiAnc3RhcnRlZCcsXG4gICAgICAgICAgICAvKiogVGhlIE5YTUNhbGwgaXMgaW4gcmluZ2luZyBzdGF0dXMgKi9cbiAgICAgICAgICAgIFJJTkdJTkc6ICdyaW5naW5nJyxcbiAgICAgICAgICAgIC8qKiBUaGUgTlhNQ2FsbCBpcyBpbiBhbnN3ZXJlZCBzdGF0dXMgKi9cbiAgICAgICAgICAgIEFOU1dFUkVEOiAnYW5zd2VyZWQnLFxuICAgICAgICAgICAgLyoqIFRoZSBOWE1DYWxsIGlzIGluIGNvbXBsZXRlZCBzdGF0dXMgKi9cbiAgICAgICAgICAgIENPTVBMRVRFRDogJ2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAvKiogVGhlIE5YTUNhbGwgaXMgaW4gYnVzeSBzdGF0dXMgKi9cbiAgICAgICAgICAgIEJVU1k6ICdidXN5JyxcbiAgICAgICAgICAgIC8qKiBUaGUgTlhNQ2FsbCBpcyBpbiB0aW1lb3V0IHN0YXR1cyAqL1xuICAgICAgICAgICAgVElNRU9VVDogJ3RpbWVvdXQnLFxuICAgICAgICAgICAgLyoqIFRoZSBOWE1DYWxsIGlzIGluIHVuYW5zd2VyZWQgc3RhdHVzICovXG4gICAgICAgICAgICBVTkFOU1dFUkVEOiAndW5hbnN3ZXJlZCcsXG4gICAgICAgICAgICAvKiogVGhlIE5YTUNhbGwgaXMgaW4gcmVqZWN0ZWQgc3RhdHVzICovXG4gICAgICAgICAgICBSRUpFQ1RFRDogJ3JlamVjdGVkJyxcbiAgICAgICAgICAgIC8qKiBUaGUgTlhNQ2FsbCBpcyBpbiBmYWlsZWQgc3RhdHVzICovXG4gICAgICAgICAgICBGQUlMRUQ6ICdmYWlsZWQnXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnVtIGZvciBOWE1DYWxsIGRpcmVjdGlvbi5cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICAgICAqIEBhbGlhcyBOWE1DYWxsLkNBTExfRElSRUNUSU9OXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuQ0FMTF9ESVJFQ1RJT04gPSB7XG4gICAgICAgICAgICAvKiogVGhlIE5YTUNhbGwgc3RhcnRlZCBmcm9tIGFub3RoZXIgZW5kICovXG4gICAgICAgICAgICBJTkJPVU5EOiAnaW5ib3VuZCcsXG4gICAgICAgICAgICAvKiogVGhlIE5YTUNhbGwgc3RhcnRlZCBmcm9tIHRoaXMgY2xpZW50ICovXG4gICAgICAgICAgICBPVVRCT1VORDogJ291dGJvdW5kJ1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMuQ0FMTF9ESVJFQ1RJT04pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bSBmb3IgdGhlIHBlcm1pdHRlZCBjYWxsIHN0YXR1cyB0cmFuc2l0aW9uLlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQGFsaWFzIE5YTUNhbGwuU1RBVFVTX1BFUk1JVFRFRF9GTE9XXG4gICAgICAgICAqIEBlbnVtIHtNYXA8c3RyaW5nLCBTZXQ8TlhNQ2FsbC5DQUxMX1NUQVRVUz4+fVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLlNUQVRVU19QRVJNSVRURURfRkxPVyA9IG5ldyBNYXAoW1xuICAgICAgICAgICAgLyoqIFBlcm1pdHRlZCB0cmFuc2l0aW9uIGFycmF5IGZyb20gU1RBUlRFRCAgKi9cbiAgICAgICAgICAgIFsnU1RBUlRFRCcsIG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkNBTExfU1RBVFVTLlJJTkdJTkcsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ0FMTF9TVEFUVVMuQU5TV0VSRUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ0FMTF9TVEFUVVMuRkFJTEVELFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkNBTExfU1RBVFVTLlRJTUVPVVQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ0FMTF9TVEFUVVMuVU5BTlNXRVJFRCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5DQUxMX1NUQVRVUy5SRUpFQ1RFRCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5DQUxMX1NUQVRVUy5CVVNZXG4gICAgICAgICAgICAgICAgXSldLFxuICAgICAgICAgICAgLyoqIFBlcm1pdHRlZCB0cmFuc2l0aW9uIGFycmF5IGZyb20gUklOR0lORyAgKi9cbiAgICAgICAgICAgIFsnUklOR0lORycsIG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkNBTExfU1RBVFVTLkFOU1dFUkVELFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkNBTExfU1RBVFVTLkZBSUxFRCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5DQUxMX1NUQVRVUy5USU1FT1VULFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkNBTExfU1RBVFVTLlVOQU5TV0VSRUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ0FMTF9TVEFUVVMuUkVKRUNURUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ0FMTF9TVEFUVVMuQlVTWVxuICAgICAgICAgICAgICAgIF0pXSxcbiAgICAgICAgICAgIC8qKiBQZXJtaXR0ZWQgdHJhbnNpdGlvbiBzZXQgZnJvbSBBTlNXRVJFRCAgKi9cbiAgICAgICAgICAgIFsnQU5TV0VSRUQnLCBuZXcgU2V0KFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5DQUxMX1NUQVRVUy5DT01QTEVURUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQ0FMTF9TVEFUVVMuRkFJTEVEXG4gICAgICAgICAgICAgICAgXSldXG4gICAgICAgIF0pO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMuU1RBVFVTX1BFUk1JVFRFRF9GTE9XKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbGxfZGlzY29ubmVjdF90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLkNBTExfRElSRUNUSU9OLklOQk9VTkQ7XG4gICAgICAgIHRoaXMuX3NldHVwQ29udmVyc2F0aW9uT2JqZWN0KGNvbnZlcnNhdGlvbik7XG4gICAgICAgIFdpbGRFbWl0dGVyLm1peGluKE5YTUNhbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgTlhNQ2FsbCBzdGF0cyB0byBiZSBlbWl0dGVkIGluXG4gICAqIC0gYXBwbGljYXRpb24uaW5BcHBDYWxsLm9uKCdydGNzdGF0czpyZXBvcnQnKVxuICAgKiAtIGFwcGxpY2F0aW9uLmluQXBwQ2FsbC5vbigncnRjc3RhdHM6YW5hbHl0aWNzJylcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2VuYWJsZVN0YXRzRXZlbnRzKCkge1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbi5tZWRpYS5fZW5hYmxlU3RhdHNFdmVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIG1lbWJlciBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY29udmVyc2F0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9hdHRhY2hDYWxsTGlzdGVuZXJzKCkge1xuICAgICAgICAvLyBDb252ZXJzYXRpb24gbGV2ZWwgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiX2F0dGFjaENhbGxMaXN0ZW5lcnMgOiBcIiwgeyBueG1DYWxsOiB0aGlzIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb24ucmVsZWFzZUdyb3VwKCdjYWxsX21vZHVsZScpO1xuICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb24ub24oJ21lbWJlcjptZWRpYScsICdjYWxsX21vZHVsZScsIChmcm9tLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uLmNhbGxzICYmIHRoaXMuYXBwbGljYXRpb24uY2FsbHMuaGFzKHRoaXMuY29udmVyc2F0aW9uLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLmdldCh0aGlzLmNvbnZlcnNhdGlvbi5pZCkuX2hhbmRsZVN0YXR1c0NoYW5nZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFwiX2F0dGFjaENhbGxMaXN0ZW5lcnNfZXJyb3I6IFwiLCB7IGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGN1cnJlbnQgbnhtQ2FsbCBzdGF0dXMgdHJhbnNpdGlvblxuICAgICAqIElmIGEgdHJhbnNpdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIGZhbHNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyB0aGUgc3RhdHVzIHRvIHZhbGlkYXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIG5vdCBwZXJtaXR0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2lzVmFsaWRTdGF0dXNUcmFuc2l0aW9uKHN0YXR1cykge1xuICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKGBQcm92aWRlIHRoZSBzdGF0dXMgdG8gdmFsaWRhdGUgdGhlIHRyYW5zaXRpb24gZnJvbSAnJHt0aGlzLnN0YXR1c30nYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG54bUNhbGwgb2JqZWN0IGlzIGp1c3QgaW5pdGlhbGlzZWQgYWxsb3cgYW55IHN0YXRlXG4gICAgICAgIGlmICghdGhpcy5zdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfc3RhdHVzID0gdGhpcy5zdGF0dXMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLlNUQVRVU19QRVJNSVRURURfRkxPVy5oYXMoY3VycmVudF9zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuU1RBVFVTX1BFUk1JVFRFRF9GTE9XLmdldChjdXJyZW50X3N0YXR1cykuaGFzKHN0YXR1cykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyB0aHJvdWdoIHRoZSBtZW1iZXJzIG9mIHRoZSBjb252ZXJzYXRpb24gYW5kIGlmIC5tZSBpcyB0aGUgb25seSBvbmUgKEpPSU5FRCBvciBJTlZJVEVEKVxuICAgICAqIG54bUNhbGwgbnhtQ2FsbC5oYW5nVXAoKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBlbXB0eSBwcm9taXNlIG9yIHRoZSBueG1DYWxsLmhhbmdVcCBwcm9taXNlIGNoYWluXG4gICAgKi9cbiAgICBoYW5nVXBJZkFsbExlZnQoKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiaGFuZ1VwSWZBbGxMZWZ0OiBcIiwgeyBueG1DYWxsOiB0aGlzIH0pO1xuICAgICAgICBpZiAoIXRoaXMuY29udmVyc2F0aW9uLm1lIHx8IHRoaXMuY29udmVyc2F0aW9uLm1lLnN0YXRlID09PSAnTEVGVCcgfHwgdGhpcy5jb252ZXJzYXRpb24ubWVtYmVycy5zaXplIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtZW1iZXIgb2YgdGhpcy5jb252ZXJzYXRpb24ubWVtYmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKG1lbWJlci5zdGF0ZSAhPT0gJ0xFRlQnICYmICh0aGlzLmNvbnZlcnNhdGlvbi5tZS51c2VyLmlkICE9PSBtZW1iZXIudXNlci5pZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZ1VwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udmVyc2F0aW9uIG9iamVjdCBvZiB0aGUgTlhNQ2FsbFxuICAgICAqIHVwZGF0ZSBueG1DYWxsLmZyb20sIGFuZCBueG1DYWxsLnRvIGF0dHJpYnV0ZXMgYmFzZWQgb24gdGhlIGNvbnZlcnNhdGlvbiBtZW1iZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9zZXR1cENvbnZlcnNhdGlvbk9iamVjdChjb252ZXJzYXRpb24sIHJ0Y19pZCkge1xuICAgICAgICBpZiAoIWNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252ZXJzYXRpb247XG4gICAgICAgIGlmICghY29udmVyc2F0aW9uLm1lKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdtaXNzaW5nIG93biBtZW1iZXIgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvID0gbmV3IE1hcChjb252ZXJzYXRpb24ubWVtYmVycyk7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50by5kZWxldGUodGhpcy5mcm9tLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRjaCBDb252ZXJzYXRpb24gTGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX2F0dGFjaENhbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmcm9tIG9iamVjdCBvZiB0aGUgTlhNQ2FsbFxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfc2V0RnJvbShmcm9tKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnJvbSBvYmplY3Qgb2YgdGhlIE5YTUNhbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX3NldE9mZmVyKG9mZmVyKSB7XG4gICAgICAgIHRoaXMub2ZmZXIgPSBvZmZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyByYXcgZXZlbnRzIHRvIGZpZ3VyZSBvdXQgdGhlIG54bUNhbGwgc3RhdHVzXG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9oYW5kbGVTdGF0dXNDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBmb3Iga25vY2tpbmcgY2FzZSB0aGUgY29udmVyc2F0aW9uIG9iamVjdCBpcyBub3QgeWV0IHNldCBpbiB0aGUgbnhtQ2FsbC4gV2Uga25vdyB0aGUgYWN0aW9uIGlzIGluaXRpYXRlZCBmcm9tIHVzXG4gICAgICAgIGNvbnN0IF9pc0V2ZW50RnJvbU1lID0gKHRoaXMuY29udmVyc2F0aW9uKSA/ICgoX2EgPSB0aGlzLmNvbnZlcnNhdGlvbi5tZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSA9PT0gZXZlbnQuZnJvbSA6IHRydWU7XG4gICAgICAgIGNvbnN0IF9pc091dGJvdW5kID0gdGhpcy5kaXJlY3Rpb24gPT09IHRoaXMuQ0FMTF9ESVJFQ1RJT04uT1VUQk9VTkQ7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiX2hhbmRsZVN0YXR1c0NoYW5nZTogXCIsIHsgZXZlbnQgfSwgYF9pc0V2ZW50RnJvbU1lOiAke19pc0V2ZW50RnJvbU1lfSBfaXNPdXRib3VuZDogJHtfaXNPdXRib3VuZH1gKTtcbiAgICAgICAgbGV0IF9oYW5kbGVTdGF0dXNDaGFuZ2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIF9oYW5kbGVTdGF0dXNDaGFuZ2VNYXAuc2V0KCdtZW1iZXI6am9pbmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmJvZHkuY2hhbm5lbCAmJiBldmVudC5ib2R5LmNoYW5uZWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuU1RBUlRFRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXR1c0FuZEVtaXQodGhpcy5DQUxMX1NUQVRVUy5GQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9oYW5kbGVTdGF0dXNDaGFuZ2VNYXAuc2V0KCdtZW1iZXI6aW52aXRlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5ib2R5Lmludml0ZWRfYnkgPT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBldmVudC5ib2R5LnVzZXIubWVkaWEgJiZcbiAgICAgICAgICAgICAgICBldmVudC5ib2R5LnVzZXIubWVkaWEuYXVkaW9fc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuU1RBUlRFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfaGFuZGxlU3RhdHVzQ2hhbmdlTWFwLnNldCgncnRjOmhhbmd1cCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gdGhpcy5DQUxMX1NUQVRVUy5BTlNXRVJFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXR1c0FuZEVtaXQodGhpcy5DQUxMX1NUQVRVUy5DT01QTEVURUQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfaXNFdmVudEZyb21NZSAmJiBfaXNPdXRib3VuZCB8fCAhX2lzRXZlbnRGcm9tTWUgJiYgIV9pc091dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXR1c0FuZEVtaXQodGhpcy5DQUxMX1NUQVRVUy5VTkFOU1dFUkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdHVzQW5kRW1pdCh0aGlzLkNBTExfU1RBVFVTLlJFSkVDVEVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9oYW5kbGVTdGF0dXNDaGFuZ2VNYXAuc2V0KCdtZW1iZXI6bGVmdCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuYm9keS50aW1lc3RhbXAuaGFzT3duUHJvcGVydHkoJ2pvaW5lZCcpICYmIHRoaXMuc3RhdHVzICE9PSB0aGlzLkNBTExfU1RBVFVTLkFOU1dFUkVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pc0V2ZW50RnJvbU1lICYmIF9pc091dGJvdW5kIHx8ICFfaXNFdmVudEZyb21NZSAmJiAhX2lzT3V0Ym91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdHVzQW5kRW1pdCh0aGlzLkNBTExfU1RBVFVTLlVOQU5TV0VSRUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuUkVKRUNURUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX2hhbmRsZVN0YXR1c0NoYW5nZU1hcC5zZXQoJ21lbWJlcjptZWRpYScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gdGhpcy5DQUxMX1NUQVRVUy5BTlNXRVJFRCAmJiBldmVudC5ib2R5LmF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pc0V2ZW50RnJvbU1lICYmIGV2ZW50LmJvZHkuY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gZXZlbnQuYm9keS5jaGFubmVsLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKCFfaXNFdmVudEZyb21NZSB8fCAhX2lzT3V0Ym91bmQpICYmIHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdHVzQW5kRW1pdCh0aGlzLkNBTExfU1RBVFVTLkFOU1dFUkVEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfaGFuZGxlU3RhdHVzQ2hhbmdlTWFwLnNldCgnc2lwOnJpbmdpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IHRoaXMuQ0FMTF9TVEFUVVMuUklOR0lORykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXR1c0FuZEVtaXQodGhpcy5DQUxMX1NUQVRVUy5SSU5HSU5HKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9oYW5kbGVTdGF0dXNDaGFuZ2VNYXAuc2V0KCdzaXA6aGFuZ3VwJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5ib2R5LnJlYXNvbi5zaXBfY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDg2OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuQlVTWSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDg3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuVElNRU9VVCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuRkFJTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfaGFuZGxlU3RhdHVzQ2hhbmdlTWFwLnNldCgna25vY2tpbmc6ZGVsZXRlOnN1Y2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0dXNBbmRFbWl0KHRoaXMuQ0FMTF9TVEFUVVMuVU5BTlNXRVJFRCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoX2hhbmRsZVN0YXR1c0NoYW5nZU1hcC5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaGFuZGxlU3RhdHVzQ2hhbmdlTWFwLmdldChldmVudC50eXBlKS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbnhtQ2FsbC5zdGF0dXMgYW5kIGVtaXQgYSBjYWxsOnN0YXR1czpjaGFuZ2VkIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05YTUNhbGwuQ0FMTF9TVEFUVVN9IHRoaXMuQ0FMTF9TVEFUVVMgdGhlIGNhbnhtQ2FsbGxsIHN0YXR1cyB0byBzZXRcbiAgICAgKiBAZW1pdHMgQXBwbGljYXRpb24jY2FsbDpzdGF0dXM6Y2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfc2V0U3RhdHVzQW5kRW1pdChzdGF0dXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkU3RhdHVzVHJhbnNpdGlvbihzdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBfc2V0U3RhdHVzQW5kRW1pdDogJHtzdGF0dXN9YCwgeyBueG1DYWxsOiB0aGlzIH0pO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmVtaXQoJ2NhbGw6c3RhdHVzOmNoYW5nZWQnLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW5zd2VycyBhbiBpbmNvbWluZyBueG1DYWxsXG4gICAgICogSm9pbiB0aGUgY29udmVyc2F0aW9uIHRoYXQgeW91IGFyZSBpbnZpdGVkXG4gICAgICogQ3JlYXRlIGF1dG9wbGF5IEF1ZGlvIG9iamVjdFxuICAgICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F1dG9QbGF5QXVkaW89dHJ1ZV0gYXR0YWNoIHRoZSBhdWRpbyBzdHJlYW0gYXV0b21hdGljYWxseSB0byBzdGFydCBwbGF5aW5nIChkZWZhdWx0IHRydWUpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXVkaW8+fVxuICAgICovXG4gICAgYXN5bmMgYW5zd2VyKGF1dG9QbGF5QXVkaW8gPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBhbnN3ZXI6IHsgYXV0b1BsYXlBdWRpbzogJHthdXRvUGxheUF1ZGlvfWApO1xuICAgICAgICBpZiAodGhpcy5jb252ZXJzYXRpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb252ZXJzYXRpb24uam9pbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuY29udmVyc2F0aW9uLm1lZGlhLmVuYWJsZSh7IGF1dG9QbGF5QXVkaW8sIG9mZmVyOiB0aGlzLm9mZmVyIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXR1c0FuZEVtaXQodGhpcy5DQUxMX1NUQVRVUy5GQUlMRUQpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcignZXJyb3I6Y2FsbDphbnN3ZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBueG1DYWxsIGZsb3cgZm9yIHRoZSBpbnB1dCB1c2Vycy5cbiAgICAgKiBDcmVhdGUgYSBjb252ZXJzYXRpb24gd2l0aCBwcmVmaXggbmFtZSBcIkNBTExfXCJcbiAgICAgKiBhbmQgaW52aXRlIGFsbCB0aGUgdXNlcnMuXG4gICAgICogSWYgYXQgbGVhc3Qgb25lIHVzZXIgaXMgc3VjY2Vzc2Z1bGx5IGludml0ZWQsIGVuYWJsZSB0aGUgYXVkaW8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB1c2VybmFtZXMgdGhlIHVzZXJuYW1lcyBvZiB0aGUgdXNlcnMgdG8gY2FsbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdXRvUGxheUF1ZGlvPXRydWVdIGF0dGFjaCB0aGUgYXVkaW8gc3RyZWFtIGF1dG9tYXRpY2FsbHkgdG8gc3RhcnQgcGxheWluZyAoZGVmYXVsdCB0cnVlKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlW119IGFuIGFycmF5IG9mIHRoZSBpbnZpdGUgcHJvbWlzZXMgZm9yIHRoZSBwcm92aWRlZCB1c2VybmFtZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ2FsbCh1c2VybmFtZXMsIGF1dG9QbGF5QXVkaW8gPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBjcmVhdGVDYWxsOiB7IHVzZXJuYW1lczogJHt1c2VybmFtZXN9LCBhdXRvUGxheUF1ZGlvOiAke2F1dG9QbGF5QXVkaW99IH1gKTtcbiAgICAgICAgaWYgKCF1c2VybmFtZXMgfHwgIUFycmF5LmlzQXJyYXkodXNlcm5hbWVzKSB8fCB1c2VybmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKCdlcnJvcjphcHBsaWNhdGlvbjpjYWxsOnBhcmFtcycpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5hcHBsaWNhdGlvbi5uZXdDb252ZXJzYXRpb25BbmRKb2luKHsgZGlzcGxheV9uYW1lOiAnQ0FMTF8nICsgdGhpcy5hcHBsaWNhdGlvbi5tZS5uYW1lICsgJ18nICsgdXNlcm5hbWVzLmpvaW4oJ18nKS5yZXBsYWNlKCcgJywgJycpIH0pO1xuICAgICAgICAgICAgY29udmVyc2F0aW9uLm1lbWJlcnMuc2V0KGNvbnZlcnNhdGlvbi5tZS5pZCwgY29udmVyc2F0aW9uLm1lKTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IGNvbnZlcnNhdGlvbi5tZTtcbiAgICAgICAgICAgIHRoaXMuc3VjY2Vzc2Z1bF9pbnZpdGVkX21lbWJlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBpbnZpdGVzID0gdXNlcm5hbWVzLm1hcChhc3luYyAodXNlcm5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBhbGwgaW52aXRlcywgaWYgYXQgbGVhc3Qgb25lIGlzIHJlc29sdmVkIGVuYWJsZSBhdWRpb1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2F0Y2ggcmVqZWN0aW9ucyB0byBhbGxvdyBhbGwgdGhlIGNoYWluIHRvIGdvIHRocm91Z2ggKGFsbCBpbnZpdGVzKVxuICAgICAgICAgICAgICAgIC8vIHdlIHRoZW4gY2F0Y2gtcmVqZWN0IGEgcHJvbWlzZSBzbyB0aGF0IHRoZSBlcnJvcnMgYXJlIHBhc3NpbmcgdGhyb3VnaCB0aGUgZW5kIG9mIHRoZSBjaGFpblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IGF3YWl0IGNvbnZlcnNhdGlvbi5pbnZpdGVXaXRoQXVkaW8oeyB1c2VyX25hbWU6IHVzZXJuYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb24ubWVtYmVycy5zZXQobWVtYmVyLmlkLCBtZW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3NmdWxfaW52aXRlZF9tZW1iZXJzLnNldChtZW1iZXIuaWQsIG1lbWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgdGhlIGVycm9yIHRvIGFsbG93IHRoZSBwcm9taXNlLmFsbCB0byBjb2xsZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gYWxsIHRoZSBwcm9taXNlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gcHJvY2VzcyBpbiBQcm9taXNlLmFsbCgpIHRoZSBmYWlsZWQgaW52aXRlcyB0b29cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NfaW52aXRlcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWNjZXNzZnVsX2ludml0ZWRfbWVtYmVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb252ZXJzYXRpb24ubWVkaWEuZW5hYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhcm11ZmZlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvUGxheUF1ZGlvXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uLmNhbGxzLnNldChjb252ZXJzYXRpb24uaWQsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52aXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGludml0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY29udGludWUgdGhlIGludml0ZXMgZXZlbiBpZiBvbmUgZmFpbHMsXG4gICAgICAgICAgICAvLyBpbiBwcm9jZXNzX2ludml0ZXMgd2UgZG8gdGhlIGNoZWNrIGlmIGF0IGxlYXN0IG9uZSB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW52aXRlcyk7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cENvbnZlcnNhdGlvbk9iamVjdChjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NfaW52aXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdHVzQW5kRW1pdCh0aGlzLkNBTExfU1RBVFVTLkZBSUxFRCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBueG1DYWxsIGZsb3cgZm9yIHRoZSBwaG9uZSBjYWxsLlxuICAgICAqIENyZWF0ZSBhIGtub2NraW5nIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlciB0aGUgcGhvbmUgbnVtYmVyIG9yIHRoZSB1c2VybmFtZSB0byBjYWxsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBjYWxsIHlvdSB3YW50IHRvIGhhdmUuIHBvc3NpYmxlIHZhbHVlcyBcInBob25lXCIgb3IgXCJhcHBcIiAoZGVmYXVsdCBpcyBcInBob25lXCIpXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNlcnZlckNhbGwodXNlciwgdHlwZSwgY3VzdG9tX2RhdGEpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoYGNyZWF0ZVNlcnZlckNhbGw6IHsgdXNlcjogJHt1c2VyfSwgdHlwZTogJHt0eXBlfSwgY3VzdG9tX2RhdGE6IGAsIHsgY3VzdG9tX2RhdGEgfSk7XG4gICAgICAgIGNvbnN0IHRvID0ge1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3Bob25lJykge1xuICAgICAgICAgICAgdG8ubnVtYmVyID0gdXNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvLnVzZXIgPSB1c2VyO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQcmV3YXJtTGVnXG4gICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgbGVnSWQsIHJ0Y09iamVjdHMgfSA9IGF3YWl0IHJ0Y19oZWxwZXJfMS5kZWZhdWx0LnByZXdhcm1MZWcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImNyZWF0ZVNlcnZlckNhbGw6IFwiLCB7IHN0cmVhbSB9LCB7IGxlZ0lkIH0sIHsgcnRjT2JqZWN0cyB9KTtcbiAgICAgICAgICAgIC8vIEFkZCBNZWRpYSB0byB0aGUgQ2FsbCBPYmplY3RcbiAgICAgICAgICAgIHRoaXMucnRjT2JqZWN0cyA9IHJ0Y09iamVjdHM7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBsZWdJZDtcbiAgICAgICAgICAgIC8vIEFkZCBsZWdfaWQgdG8gdGhlIGNhbGwgZHJhZnQgbGlzdFxuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5fY2FsbF9kcmFmdF9saXN0LnNldChsZWdJZCwgdGhpcyk7XG4gICAgICAgICAgICBydGNfaGVscGVyXzEuZGVmYXVsdC5wbGF5QXVkaW9TdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJ2tub2NraW5nJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcHAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogeyB0eXBlOiAnYXBwJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbGVnSWQgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAuLi4oY3VzdG9tX2RhdGEgJiYgT2JqZWN0LmtleXMoY3VzdG9tX2RhdGEpLmxlbmd0aCAmJiB7IHByb3BlcnRpZXM6IHsgY3VzdG9tX2RhdGEgfSB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtub2NraW5nUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5rbm9ja2luZ19pZCA9IGtub2NraW5nUmVzcG9uc2UuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYga25vY2tpbmcgcmVxdWVzdCBkb2Vzbid0IHJlc3VsdCBpbiBtZW1iZXI6am9pbmVkIGFmdGVyIHNldCB0aW1lIGRpc2FibGUgYXVkaW8sIGNsZWFudXAgbWVkaWFcbiAgICAgICAgICAgIHJ0Y19oZWxwZXJfMS5kZWZhdWx0LmNsZWFuQ2FsbE1lZGlhSWZGYWlsZWQodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYga25vY2tpbmcgcmVxdWVzdCBmYWlscyBkaXNhYmxlIGF1ZGlvLCBjbGVhbnVwIG1lZGlhXG4gICAgICAgICAgICBydGNfaGVscGVyXzEuZGVmYXVsdC5jbGVhbk1lZGlhUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmdzIHVwIHRoZSBueG1DYWxsXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBhIGtub2NraW5nIGFjdGl2ZSwgZG8gYSBrbm9ja2luZzpkZWxldGVcbiAgICAgKiBvdGhlcndpc2VcbiAgICAgKiBMZWF2ZSBmcm9tIHRoZSBjb252ZXJzYXRpb25cbiAgICAgKiBEaXNhYmxlIHRoZSBhdWRpb1xuICAgICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcmVhc29uXSB0aGUgcmVhc29uIGZvciBoYW5naW5nIHVwIHRoZSBueG1DYWxsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uLnJlYXNvbl9jb2RlXSB0aGUgY29kZSBvZiB0aGUgcmVhc29uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uLnJlYXNvbl90ZXh0XSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHJlYXNvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgYXN5bmMgaGFuZ1VwKHJlYXNvbikge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgaGFuZ1VwOiB7IHJlYXNvbjogJHtyZWFzb259IH1gKTtcbiAgICAgICAgaWYgKHRoaXMuY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbnZlcnNhdGlvbi5tZWRpYS5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmtub2NraW5nX2lkICYmIHRoaXMuY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJzYXRpb24ubGVhdmUocmVhc29uKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgIT09IFwiY29udmVyc2F0aW9uOmVycm9yOmludmFsaWQtbWVtYmVyLXN0YXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGF0aCA9IGBrbm9ja2luZy8ke3RoaXMua25vY2tpbmdfaWR9YDtcbiAgICAgICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlYXNvbikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCByZWFzb25ba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBgPyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwcGxpY2F0aW9uLnNlc3Npb24uc2VuZE5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBueG1DYWxsID0gdGhpcy5hcHBsaWNhdGlvbi5fY2FsbF9kcmFmdF9saXN0LmdldCh0aGlzLmNsaWVudF9yZWYpO1xuICAgICAgICAgICAgICAgIG54bUNhbGwuX2hhbmRsZVN0YXR1c0NoYW5nZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5fY2FsbF9kcmFmdF9saXN0LmRlbGV0ZSh0aGlzLmNsaWVudF9yZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHN3aXRjaCB5ZXQgdG8gZmFpbCBzdGF0dXMsIGl0IGNvdWxkIGJlIGFuIGV4cGVjdGVkIHJhY2UgYmV0d2VlbiBrbm9ja2luZzpkZWxldGUgYW5kIGNvbnZlcnNhdGlvbi5sZWF2ZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb252ZXJzYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2hhbmd1cDogUHJvYmxlbSBjYW5jZWxsaW5nIHRoZSBjYWxsLiBLbm9ja2luZyBjYW5jZWwgZmFpbGVkIGFuZCBDb252ZXJzYXRpb24uIExlYXZlIG5vdCBhdmFpbGFibGUnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9BcGlFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJzYXRpb24ubGVhdmUocmVhc29uKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudHlwZSAhPT0gXCJjb252ZXJzYXRpb246ZXJyb3I6aW52YWxpZC1tZW1iZXItc3RhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGFuIGluY29taW5nIG54bUNhbGxcbiAgICAgKiBMZWF2ZSBmcm9tIHRoZSBjb252ZXJzYXRpb24gdGhhdCB5b3UgYXJlIGludml0ZWRcbiAgICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW3JlYXNvbl0gdGhlIHJlYXNvbiBmb3IgcmVqZWN0aW5nIHRoZSBueG1DYWxsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uLnJlYXNvbl9jb2RlXSB0aGUgY29kZSBvZiB0aGUgcmVhc29uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVhc29uLnJlYXNvbl90ZXh0XSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIHJlYXNvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICovXG4gICAgcmVqZWN0KHJlYXNvbikge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgcmVqZWN0OiB7IHJlYXNvbjogJHtyZWFzb259IH1gKTtcbiAgICAgICAgaWYgKHRoaXMuY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJzYXRpb24ubGVhdmUocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoJ2Vycm9yOmNhbGw6cmVqZWN0JykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTlhNQ2FsbDtcbm1vZHVsZS5leHBvcnRzID0gTlhNQ2FsbDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlzX2lwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImlzLWlwXCIpKTtcbmNsYXNzIENhbmNlbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUmVxdWVzdCB3YXMgY2FuY2VsbGVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDYW5jZWxFcnJvcic7XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICB0aW1lb3V0OiA1MDAwXG59O1xuY29uc3QgdXJscyA9IHtcbiAgICB2NDogW1xuICAgICAgICAnaHR0cHM6Ly9pcHY0LmljYW5oYXppcC5jb20vJyxcbiAgICAgICAgJ2h0dHBzOi8vYXBpLmlwaWZ5Lm9yZy8nXG4gICAgXSxcbiAgICB2NjogW1xuICAgICAgICAnaHR0cHM6Ly9pcHY2LmljYW5oYXppcC5jb20vJyxcbiAgICAgICAgJ2h0dHBzOi8vYXBpNi5pcGlmeS5vcmcvJ1xuICAgIF1cbn07XG5jb25zdCBzZW5kWGhyID0gKHVybCwgb3B0aW9ucywgdmVyc2lvbikgPT4ge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGxldCBfcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIF9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHJlamVjdCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlwID0geGhyLnJlc3BvbnNlVGV4dC50cmltKCk7XG4gICAgICAgICAgICBpZiAoIWlwIHx8IHZlcnNpb24gPT09ICd2NCcgPyAhaXNfaXBfMS5kZWZhdWx0LnY0KGlwKSA6ICFpc19pcF8xLmRlZmF1bHQudjYoaXApKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShpcCk7XG4gICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgIHhoci50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xuICAgIC8vIHByb21pc2UuY2FuY2VsID0gKCkgPT4ge1xuICAgIC8vIFx0eGhyLmFib3J0KCk7XG4gICAgLy8gXHRfcmVqZWN0KG5ldyBDYW5jZWxFcnJvcigpKTtcbiAgICAvLyB9O1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IHF1ZXJ5SHR0cHMgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICAgIGxldCByZXF1ZXN0O1xuICAgIGNvbnN0IHByb21pc2UgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB1cmxzXyA9IFtdLmNvbmNhdC5hcHBseSh1cmxzW3ZlcnNpb25dLCBvcHRpb25zLmZhbGxiYWNrVXJscyB8fCBbXSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHNfKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBzZW5kWGhyKHVybCwgb3B0aW9ucywgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXAgPSBhd2FpdCByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHJldHVybiBpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENhbmNlbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgZmluZCB5b3VyIElQJyk7XG4gICAgfSkoKTtcbiAgICAvLyBwcm9taXNlLmNhbmNlbCA9ICgpID0+IHtcbiAgICAvLyBcdHJlcXVlc3QuY2FuY2VsKCk7XG4gICAgLy8gfTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5jbGFzcyBQdWJsaWNJcCB7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQdWJsaWNJcDtcblB1YmxpY0lwLnY0ID0gKG9wdGlvbnMpID0+IHF1ZXJ5SHR0cHMoJ3Y0JywgeyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9KTtcblB1YmxpY0lwLnY2ID0gKG9wdGlvbnMpID0+IHF1ZXJ5SHR0cHMoJ3Y2JywgeyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9KTtcbm1vZHVsZS5leHBvcnRzID0gUHVibGljSXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiAqL1xucmVxdWlyZSgnd2VicnRjLWFkYXB0ZXInKTtcbmNvbnN0IHNkcHRyYW5zZm9ybSA9IHJlcXVpcmUoJ3NkcC10cmFuc2Zvcm0nKTtcbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5jb25zdCBicm93c2VyRGV0ZWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkZXRlY3QtYnJvd3NlclwiKSk7XG5jb25zdCBuZXhtb0NsaWVudEVycm9yXzEgPSByZXF1aXJlKFwiLi4vbmV4bW9DbGllbnRFcnJvclwiKTtcbmNvbnN0IHJ0Y3N0YXRzX2FuYWx5dGljc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3J0Y3N0YXRzX2FuYWx5dGljc1wiKSk7XG5jb25zdCBjbGVhcmluZ1RpbWVvdXQgPSAyMDAwMDtcbi8qKlxuICogUlRDIGhlbHBlciBvYmplY3QgZm9yIGFjY2Vzc2luZyB3ZWJSVEMgQVBJLlxuICogQGNsYXNzIFJ0Y0hlbHBlclxuICogQHByaXZhdGVcbiovXG5jbGFzcyBSdGNIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxvZyA9IGxvZ2xldmVsXzEuZ2V0TG9nZ2VyKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVc2VyQXVkaW8oYXVkaW9Db25zdHJhaW50cyA9IHRydWUpIHtcbiAgICAgICAgbGV0IGNvbnN0cmFpbnRzVG9Vc2UgPSB7XG4gICAgICAgICAgICB2aWRlbzogZmFsc2UsXG4gICAgICAgICAgICBhdWRpbzogYXVkaW9Db25zdHJhaW50c1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHNUb1VzZSk7XG4gICAgfVxuICAgIGNyZWF0ZVJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZykge1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWcpO1xuICAgICAgICAvLyBhdHRhY2hpbmcgdGhlIC50cmFjZSB0byBtYWtlIGVhc2llciB0aGUgc3RhdHMgcmVwb3J0aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHBjLnRyYWNlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGM7XG4gICAgfVxuICAgIF9nZXRXaW5kb3dMb2NhdGlvblByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgIH1cbiAgICBzdGF0aWMgX2dldEJyb3dzZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gYnJvd3NlckRldGVjdC5kZXRlY3QoKS5uYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgaXNOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnJvd3Nlck5hbWUoKSA9PT0gJ25vZGUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogQ2hlY2sgaWYgdGhlIGtleXMgaW4gYW4gb2JqZWN0IGFyZSBmb3VuZCBpbiBhbm90aGVyIG9iamVjdFxuICAgICovXG4gICAgY2hlY2tWYWxpZEtleXMob2JqZWN0LCBkZWZhdWx0T2JqZWN0KSB7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRPYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgY2xlYW5DYWxsTWVkaWFJZkZhaWxlZChjYWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYWxsLmNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5NZWRpYVByb3BlcnRpZXMoY2FsbCk7XG4gICAgICAgICAgICAgICAgY2FsbC5zdGF0dXMgPSBjYWxsLkNBTExfU1RBVFVTLkZBSUxFRDtcbiAgICAgICAgICAgICAgICBjYWxsLmFwcGxpY2F0aW9uLmVtaXQoJ2NhbGw6c3RhdHVzOmNoYW5nZWQnLCBjYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICAgIHN0YXRpYyBjYWxsRGlzY29ubmVjdEhhbmRsZXIoY2FsbCwgcGMpIHtcbiAgICAgICAgY29uc3QgY2FsbFN0YXR1cyA9IFtjYWxsLkNBTExfU1RBVFVTLkFOU1dFUkVELCBjYWxsLkNBTExfU1RBVFVTLlNUQVJURUQsIGNhbGwuQ0FMTF9TVEFUVVMuUklOR0lOR107XG4gICAgICAgIGlmIChwYy5jb25uZWN0aW9uU3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnIHx8ICFjYWxsIHx8ICFjYWxsLmNvbnZlcnNhdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVGltZW91dCBhbmQgd2FpdCBmb3IgRlMgMjAgc2Vjb25kcyBvbiBiYWNrZW5kIHVudGlsIG5vcm1hbCBjbGVhcmluZ1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGMuY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBjYWxsU3RhdHVzLmluZGV4T2YoY2FsbC5zdGF0dXMpID09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5NZWRpYVByb3BlcnRpZXMoY2FsbCk7XG4gICAgICAgICAgICBjYWxsLnN0YXR1cyA9IGNhbGwuQ0FMTF9TVEFUVVMuQ09NUExFVEVEO1xuICAgICAgICAgICAgY2FsbC5hcHBsaWNhdGlvbi5lbWl0KCdjYWxsOnN0YXR1czpjaGFuZ2VkJywgY2FsbCk7XG4gICAgICAgIH0sIGNsZWFyaW5nVGltZW91dCk7XG4gICAgfVxuICAgIHN0YXRpYyBjbGVhbk1lZGlhUHJvcGVydGllcyhjYWxsKSB7XG4gICAgICAgIGlmIChjYWxsLnJ0Y09iamVjdHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVnX2lkIGluIGNhbGwucnRjT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNhbGwucnRjT2JqZWN0c1tsZWdfaWRdLnBjLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhbGwucnRjT2JqZWN0c1tsZWdfaWRdLnBjO1xuICAgICAgICAgICAgICAgIFJ0Y0hlbHBlci5jbG9zZVN0cmVhbShjYWxsLnJ0Y09iamVjdHNbbGVnX2lkXS5zdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGwuYXBwbGljYXRpb24uYWN0aXZlU3RyZWFtcyA9IFtdO1xuICAgICAgICBjYWxsLnJ0Y09iamVjdHMgPSB7fTtcbiAgICAgICAgaWYgKGNhbGwuY29udmVyc2F0aW9uICYmIGNhbGwuY29udmVyc2F0aW9uLm1lZGlhKVxuICAgICAgICAgICAgY2FsbC5jb252ZXJzYXRpb24ubWVkaWEucnRjU3RhdHMgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgcGxheUF1ZGlvU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbygpO1xuICAgICAgICBhdWRpby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIGF1ZGlvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGF1ZGlvO1xuICAgIH1cbiAgICAvLyBNZWRpYSBtZXRob2RzXG4gICAgc3RhdGljIGNyZWF0ZUR1bW15Q2FuZGlkYXRlU0RQKHBjKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHtcbiAgICAgICAgICAgIGZvdW5kYXRpb246IDExNzY4OTEwMzIsXG4gICAgICAgICAgICBjb21wb25lbnQ6IDEsXG4gICAgICAgICAgICB0cmFuc3BvcnQ6ICd1ZHAnLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDIxMjIyNjAyMjMsXG4gICAgICAgICAgICBpcDogJzAuMC4wLjAnLFxuICAgICAgICAgICAgcG9ydDogOSxcbiAgICAgICAgICAgIHR5cGU6ICdob3N0JyxcbiAgICAgICAgICAgIGdlbmVyYXRpb246IDAsXG4gICAgICAgICAgICAnbmV0d29yay1pZCc6IDEsXG4gICAgICAgICAgICAnbmV0d29yay1jb3N0JzogNTBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2RwTmV3T2JqID0gc2RwdHJhbnNmb3JtLnBhcnNlKHBjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgc2RwTmV3T2JqLm1lZGlhWzBdLmNhbmRpZGF0ZXMgPSBbY2FuZGlkYXRlXTtcbiAgICAgICAgcmV0dXJuIHNkcHRyYW5zZm9ybS53cml0ZShzZHBOZXdPYmopO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUlRDUGVlckNvbm5lY3Rpb25Db25maWcoYXBwbGljYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdiYWxhbmNlZCcsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVQb29sU2l6ZTogJzAnLFxuICAgICAgICAgICAgLi4uKGFwcGxpY2F0aW9uLnNlc3Npb24uY29uZmlnICYmXG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb24uc2Vzc2lvbi5jb25maWcuaWNlU2VydmVycyAmJiB7XG4gICAgICAgICAgICAgICAgaWNlU2VydmVyczogYXBwbGljYXRpb24uc2Vzc2lvbi5jb25maWcuaWNlU2VydmVyc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVBlZXJDb25uZWN0aW9uKGFwcGxpY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBjX2NvbmZpZyA9IHRoaXMuY3JlYXRlUlRDUGVlckNvbm5lY3Rpb25Db25maWcoYXBwbGljYXRpb24pO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihwY19jb25maWcpO1xuICAgICAgICByZXR1cm4gcGM7XG4gICAgfVxuICAgIHN0YXRpYyBzZW5kT2ZmZXIoYXBwbGljYXRpb24sIHBjLCBjb252ZXJzYXRpb24sIHJlY29ubmVjdFJ0Y0lkKSB7XG4gICAgICAgIGNvbnN0IHNkcCA9IHRoaXMuY3JlYXRlRHVtbXlDYW5kaWRhdGVTRFAocGMpO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgc2RwIH07XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgZnJvbTogY29udmVyc2F0aW9uLm1lLmlkLFxuICAgICAgICAgICAgYm9keTogeyBvZmZlciB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYXRoID0gYGNvbnZlcnNhdGlvbnMvJHtjb252ZXJzYXRpb24uaWR9L3J0Y2A7XG4gICAgICAgIGlmIChyZWNvbm5lY3RSdGNJZCkge1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cmVjb25uZWN0UnRjSWR9L29mZmVyYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgc2VuZEFuc3dlcihhcHBsaWNhdGlvbiwgcGMsIGNvbnZlcnNhdGlvbiwgbGVnX2lkKSB7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHRoaXMuY3JlYXRlRHVtbXlDYW5kaWRhdGVTRFAocGMpO1xuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGZyb206IGNvbnZlcnNhdGlvbi5tZS5pZCxcbiAgICAgICAgICAgIGJvZHk6IHsgYW5zd2VyIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBhdGggPSBgY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbi5pZH0vcnRjLyR7bGVnX2lkfS9hbnN3ZXJgO1xuICAgICAgICByZXR1cm4gYXBwbGljYXRpb24uc2Vzc2lvbi5zZW5kTmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgY3JlYXRlTGVnKGFwcGxpY2F0aW9uLCBwYykge1xuICAgICAgICBjb25zdCBzZHBPZmZlck5ldyA9IHRoaXMuY3JlYXRlRHVtbXlDYW5kaWRhdGVTRFAocGMpO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgc2RwOiBzZHBPZmZlck5ldywgdHlwZTogXCJvZmZlclwiIH07XG4gICAgICAgIHJldHVybiBhcHBsaWNhdGlvbi5zZXNzaW9uLnNlbmROZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBwYXRoOiBgbGVnc2AsXG4gICAgICAgICAgICB2ZXJzaW9uOiBgYmV0YWAsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBvZmZlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjbG9zZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZW1pdE1lZGlhU3RyZWFtKG1lbWJlciwgcGMsIHN0cmVhbSkge1xuICAgICAgICBtZW1iZXIuZW1pdChcIm1lZGlhOnN0cmVhbTpvblwiLCB7XG4gICAgICAgICAgICBwYyxcbiAgICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgICAgICAgIHN0cmVhbUluZGV4OiAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2luaXRTdGF0c0V2ZW50cyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoUnRjSGVscGVyLmlzTm9kZSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoKF9jID0gKF9iID0gKF9hID0gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmFwcGxpY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJ0Y3N0YXRzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBjb250ZXh0LmFwcGxpY2F0aW9uLnNlc3Npb24uY29uZmlnLnJ0Y3N0YXRzO1xuICAgICAgICAgICAgY29uc3QgeyBlbWl0X2V2ZW50cywgcmVtb3RlX2NvbGxlY3Rpb24sIGVtaXRfcnRjX2FuYWx5dGljcywgfSA9IGNvbmZpZztcbiAgICAgICAgICAgIGlmIChlbWl0X2V2ZW50cyB8fCByZW1vdGVfY29sbGVjdGlvbiB8fCBlbWl0X3J0Y19hbmFseXRpY3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IC4uLmNvbnRleHQsIGNvbmZpZzogeyAuLi5jb25maWcgfSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnRjc3RhdHNfYW5hbHl0aWNzXzEuZGVmYXVsdChwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhdHRhY2hDb252ZXJzYXRpb25FdmVudEhhbmRsZXJzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBjb252ZXJzYXRpb24sIHBjLCBsb2cgfSA9IGNvbnRleHQ7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gYmUgYWJsZSB0byBoYW5kbGUgdGhlc2UgZXZlbnRzLCBmb3IgdGhpcyAgbWVtYmVyLCBiZWZvcmUgdGhleSBnZXQgcHJvcGFnYXRlZCBvdXRcbiAgICAgICAgY29udmVyc2F0aW9uLm9uY2UoXCJydGM6YW5zd2VyXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiUlRDOiByZWNlaXZlZCBhbiBhbnN3ZXIgdG9vIGxhdGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhbnN3ZXJcIixcbiAgICAgICAgICAgICAgICBzZHA6IGV2ZW50LmJvZHkuYW5zd2VyLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGRvQW5zd2VyKGNvbnRleHQsIG9mZmVyLCBsZWdfaWQpIHtcbiAgICAgICAgY29uc3QgeyBhcHBsaWNhdGlvbiwgY29udmVyc2F0aW9uLCBwYywgcmVqZWN0LCBsb2NhbFN0cmVhbSB9ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hZGRQZWVyQ29ubmVjdGlvbkxpc3RlbmVycyhjb250ZXh0LCAoKSA9PiBSdGNIZWxwZXIuc2VuZEFuc3dlcihhcHBsaWNhdGlvbiwgcGMsIGNvbnZlcnNhdGlvbiwgbGVnX2lkKS50aGVuKCgpID0+ICh7IHJ0Y19pZDogbGVnX2lkIH0pKSk7XG4gICAgICAgIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oeyB0eXBlOiBcIm9mZmVyXCIsIHNkcDogb2ZmZXIgfSkpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBwYy5jcmVhdGVBbnN3ZXIoKSlcbiAgICAgICAgICAgIC50aGVuKChzZXNzaW9uRGVzY3JpcHRpb24pID0+IHBjLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAobG9jYWxTdHJlYW0pXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN0cmVhbShsb2NhbFN0cmVhbSk7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBhdHRhY2hQZWVyQ29ubmVjdGlvbkV2ZW50SGFuZGxlcnMoY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGFwcGxpY2F0aW9uLCBjb252ZXJzYXRpb24sIHBjLCByZWNvbm5lY3RSdGNJZCB9ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hZGRQZWVyQ29ubmVjdGlvbkxpc3RlbmVycyhjb250ZXh0LCAoKSA9PiBSdGNIZWxwZXIuc2VuZE9mZmVyKGFwcGxpY2F0aW9uLCBwYywgY29udmVyc2F0aW9uLCByZWNvbm5lY3RSdGNJZCkpO1xuICAgIH1cbiAgICBzdGF0aWMgYWRkUGVlckNvbm5lY3Rpb25MaXN0ZW5lcnMoY29udGV4dCwgZGVzY3JpcHRpb25faGFuZGxlcikge1xuICAgICAgICBjb25zdCB7IGFwcGxpY2F0aW9uLCBjb252ZXJzYXRpb24sIHBjLCBzdHJlYW1JbmRleCwgbG9jYWxTdHJlYW0sIGxvZywgcnRjT2JqZWN0cywgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBsZXQgc3RvcF9pY2VfZ2F0aGVyaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBueG1DYWxsO1xuICAgICAgICBpZiAoY29udmVyc2F0aW9uLmlkKSB7XG4gICAgICAgICAgICBueG1DYWxsID0gYXBwbGljYXRpb24uY2FsbHMuZ2V0KGNvbnZlcnNhdGlvbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcGMub250cmFjayA9IChldnQpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbSA9IGV2dC5zdHJlYW1zWzBdO1xuICAgICAgICAgICAgYXBwbGljYXRpb24uYWN0aXZlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBSdGNIZWxwZXIuZW1pdE1lZGlhU3RyZWFtKGNvbnZlcnNhdGlvbi5tZSwgcGMsIHN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgICAgIHBjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKF8pID0+IHRoaXMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2VIYW5kbGVyKHBjLCBsb2csIG54bUNhbGwsICgpID0+IHJlc29sdmUoc3RyZWFtKSwgKCkgPT4gcmVqZWN0KCkpO1xuICAgICAgICBwYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gKCkgPT4gdGhpcy5vbm5lZ290aWF0aW9ubmVlZGVkSGFuZGxlcihwYywgKG5leG1vRXJyb3IpID0+IHJlamVjdChuZXhtb0Vycm9yKSk7XG4gICAgICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKGNvbm5lY3Rpb25fZXZlbnQpID0+IHRoaXMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UoY29ubmVjdGlvbl9ldmVudCwgcGMsIGxvZywgKG5leG1vRXJyb3IpID0+IHJlamVjdChuZXhtb0Vycm9yKSk7XG4gICAgICAgIHBjLm9uaWNlY2FuZGlkYXRlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlICYmICFzdG9wX2ljZV9nYXRoZXJpbmcgJiYgcGMpIHtcbiAgICAgICAgICAgICAgICBzdG9wX2ljZV9nYXRoZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcnRjX2lkIH0gPSBhd2FpdCBkZXNjcmlwdGlvbl9oYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIFJ0Y0hlbHBlci5faW5pdFN0YXRzRXZlbnRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnRjX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vYXR0YWNoIHJ0YyBzdGF0cyB3aXRoIHJ0Y19pZFxuICAgICAgICAgICAgICAgICAgICBpZiAocGMudHJhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYy50cmFjZShcInJ0Y19pZFwiLCBydGNfaWQpO1xuICAgICAgICAgICAgICAgICAgICBydGNPYmplY3RzW3J0Y19pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydGNfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbTogbG9jYWxTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1JbmRleDogc3RyZWFtSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdHJlYW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKGxvY2FsU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9jYWxTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHBjLmFkZFRyYWNrKHRyYWNrKSk7XG4gICAgfVxuICAgIHN0YXRpYyBwcmV3YXJtTGVnKG54bUNhbGwpIHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb24gPSBueG1DYWxsLmFwcGxpY2F0aW9uO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IG9mZmVyX3NlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgICAgICBsZXQgbGVnSWQ7XG4gICAgICAgICAgICBsZXQgcnRjT2JqZWN0cyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsU3RyZWFtID0gYXdhaXQgdGhpcy5nZXRVc2VyQXVkaW8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oYXBwbGljYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjYWxsXG4gICAgICAgICAgICAgICAgcGMub250cmFjayA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtID0gZXZ0LnN0cmVhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmFjdGl2ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoZXZlbnQpID0+IHRoaXMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2VIYW5kbGVyKHBjLCBsb2csIG54bUNhbGwsICgpID0+IHJlc29sdmUoeyBzdHJlYW0sIGxlZ0lkLCBydGNPYmplY3RzIH0pLCAoKSA9PiByZWplY3QoKSk7XG4gICAgICAgICAgICAgICAgcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9ICgpID0+IHRoaXMub25uZWdvdGlhdGlvbm5lZWRlZEhhbmRsZXIocGMsIChuZXhtb0Vycm9yKSA9PiByZWplY3QobmV4bW9FcnJvcikpO1xuICAgICAgICAgICAgICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKGNvbm5lY3Rpb25fZXZlbnQpID0+IHRoaXMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UoY29ubmVjdGlvbl9ldmVudCwgcGMsIGxvZywgKG5leG1vRXJyb3IpID0+IHJlamVjdChuZXhtb0Vycm9yKSk7XG4gICAgICAgICAgICAgICAgcGMub25pY2VjYW5kaWRhdGUgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiAhb2ZmZXJfc2VudCAmJiBwYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmZXJfc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJ0Y19pZCwgc2RwIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZUxlZyhhcHBsaWNhdGlvbiwgcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgUnRjSGVscGVyLl9pbml0U3RhdHNFdmVudHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ0Y19pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVnSWQgPSBydGNfaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBydGNPYmplY3RzW2xlZ0lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydGNfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBsb2NhbFN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImF1ZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtSW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYW5zd2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2RwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gcGMuYWRkVHJhY2sodHJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUnRjSGVscGVyO1xuUnRjSGVscGVyLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlSGFuZGxlciA9IChwYywgbG9nLCBueG1DYWxsLCByZXNvbHZlQ2FsbGJhY2ssIHJlamVjdENhbGxiYWNrKSA9PiB7XG4gICAgc3dpdGNoIChwYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICAgICAgbG9nLmluZm8oXCJUaGUgY29ubmVjdGlvbiBoYXMgYmVjb21lIGZ1bGx5IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIHJlc29sdmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgICAgICAgIGlmICghbnhtQ2FsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChueG1DYWxsLmNhbGxfZGlzY29ubmVjdF90aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG54bUNhbGwuY2FsbF9kaXNjb25uZWN0X3RpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnhtQ2FsbC5jYWxsX2Rpc2Nvbm5lY3RfdGltZW91dCA9IFJ0Y0hlbHBlci5jYWxsRGlzY29ubmVjdEhhbmRsZXIobnhtQ2FsbCwgcGMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgIHJlamVjdENhbGxiYWNrKCk7XG4gICAgICAgICAgICBsb2cuaW5mbyhcIk9uZSBvciBtb3JlIHRyYW5zcG9ydHMgaGFzIHRlcm1pbmF0ZWQgdW5leHBlY3RlZGx5IG9yIGluIGFuIGVycm9yXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjbG9zZWRcIjpcbiAgICAgICAgICAgIGxvZy5pbmZvKFwiVGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblJ0Y0hlbHBlci5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IChjb25uZWN0aW9uX2V2ZW50LCBwYywgbG9nLCByZWplY3RDYWxsYmFjaykgPT4ge1xuICAgIHN3aXRjaCAocGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENQZWVyQ29ubmVjdGlvbi9pY2VDb25uZWN0aW9uU3RhdGVcbiAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICAgICAgbG9nLndhcm4oXCJPbmUgb3IgbW9yZSB0cmFuc3BvcnRzIGlzIGRpc2Nvbm5lY3RlZFwiLCBwYy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgIHJlamVjdENhbGxiYWNrKG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcihjb25uZWN0aW9uX2V2ZW50KSk7XG4gICAgICAgICAgICBsb2cud2FybihcIk9uZSBvciBtb3JlIHRyYW5zcG9ydHMgaGFzIHRlcm1pbmF0ZWQgdW5leHBlY3RlZGx5IG9yIGluIGFuIGVycm9yXCIsIGNvbm5lY3Rpb25fZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2cuaW5mbyhcIlRoZSBpY2UgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlZFwiLCBwYy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgIH1cbn07XG5SdGNIZWxwZXIub25uZWdvdGlhdGlvbm5lZWRlZEhhbmRsZXIgPSBhc3luYyAocGMsIHJlamVjdENhbGxiYWNrKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICByZXR1cm4gcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3RDYWxsYmFjayhuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQ2xpZW50RXJyb3IoZXJyb3IpKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBSdGNIZWxwZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJ0Y1N0YXRzQWRhcHRlclBhcnNlciA9IHJlcXVpcmUoXCJydGMtc3RhdHMtYWRhcHRlclwiKTtcbmNvbnN0IGNhbGN1bGF0ZU1vcyA9IHJlcXVpcmUoJ3J0Yy1zdGF0cy1hZGFwdGVyL2NhbGN1bGF0ZS1tb3MnKTtcbmNvbnN0IHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbi8qKlxuICogQ29sbGVjdCBXZWJSVEMgUmVwb3J0IGRhdGFcbiAqIFJlbW92ZXMgY3JlZGVudGlhbCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBTVFVOLlRVUk4gc2VydmVyIGNvbmZpZ3VyYXRpb24uXG4gKiBwZXJmb3JtcyBEZWx0YSBjb21wcmVzc2lvblxuICpcbiAqIGlmIGlzQ2FsbGJhY2sgaXMgdHJ1ZSB0aGUgcmVwb3J0IGluY2x1ZGVzIGEgTU9TIHNjb3JlIDogdHJhY2UoJ21vcycsIG1vcywgcmVwb3J0KTtcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtBcHBsaWNhdGlvbn0gY29udGV4dC5hcHBsaWNhdGlvblxuICogQHBhcmFtIHtDb252ZXJzYXRpb259IGNvbnRleHQuY29udmVyc2F0aW9uXG4gKiBAcGFyYW0ge1JUQ1BlZXJDb25uZWN0aW9ufSBjb250ZXh0LnBjIHBlZXIgY29ubmVjdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0LnJ0Y19pZCBpZCBvZiBhIGxlZ1xuICogQHBhcmFtIHtSVENTdGF0c0NvbmZpZ30gY29udGV4dC5jb25maWcgY29uZmlnIHNldHRpbmdzIGZvciBhbmFubHl0aWNzXG4gKiBAcHJvcGVydHkge01vc1JlcG9ydH0gbW9zX3JlcG9ydCB0aGUgZmluYWwgbW9zIHJlcG9ydCB0byBiZSBzZW50IHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfcmVwb3J0c0NvdW50IHRoZSBudW1iZXIgb2YgcmVwb3J0cyB0YWtlbiBmb3IgbW9zIGF2ZXJhZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbW9zU3VtIHRoZSBzdW1tYXJ5IG9mIG1vcyBzY29yZXNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJUQ1N0YXRzQW5hbHl0aWNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubW9zX3JlcG9ydCA9IHsgbWluOiA1LCBtYXg6IDAgfTtcbiAgICAgICAgdGhpcy5fcmVwb3J0c0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fbW9zU3VtID0gMDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGVwcmVjYXRpb25XYXJuaW5nU2VudCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuYXBwbGljYXRpb24gfHwgIWNvbnRleHQucnRjX2lkIHx8ICFjb250ZXh0LnBjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdHRhY2hIYW5kbGVycyhjb250ZXh0KTtcbiAgICAgICAgdGhpcy5zdGFydFNlbmRpbmdTdGF0cyhjb250ZXh0KTtcbiAgICAgICAgdGhpcy5zdGFydEVtaXR0aW5nU3RhdHMoY29udGV4dCk7XG4gICAgfVxuICAgIGF0dGFjaEhhbmRsZXJzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBwYyB9ID0gY29udGV4dDtcbiAgICAgICAgY29uc3Qgb25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZVxuICAgICAgICAgICAgPyBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZVxuICAgICAgICAgICAgOiAoKSA9PiB7IH07XG4gICAgICAgIHBjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZS5jYWxsKHBjLCBldmVudCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUludGVydmFscygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRMYXN0UmVwb3J0KGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWNvbnRleHQuY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBhcHBsaWNhdGlvbiA9IGNvbnRleHQuYXBwbGljYXRpb247XG4gICAgICAgICAgICBhcHBsaWNhdGlvbi5vbihcIm1lbWJlcjpqb2luZWRcIiwgKG1lbWJlciwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKCF0aGlzLmNvbnZlcnNhdGlvbiB8fCAhdGhpcy5hcHBsaWNhdGlvbl9pZCkgJiYgKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5ydGNfaWQpID09PSBldmVudC5ib2R5LmNoYW5uZWwuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBtZW1iZXIuY29udmVyc2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uX2lkID0gZXZlbnQuYXBwbGljYXRpb25faWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSBjb250ZXh0LmNvbnZlcnNhdGlvbjtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5vbihcIm1lbWJlcjptZWRpYVwiLCAobWVtYmVyLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hcHBsaWNhdGlvbl9pZCAmJiAoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnJ0Y19pZCkgPT09IGV2ZW50LmJvZHkuY2hhbm5lbC5pZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uX2lkID0gZXZlbnQuYXBwbGljYXRpb25faWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExhc3RSZXBvcnQoY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGFwcGxpY2F0aW9uLCBjb252ZXJzYXRpb24gPSBudWxsLCBydGNfaWQsIGNvbmZpZzogeyBlbWl0X2V2ZW50cywgZW1pdF9ydGNfYW5hbHl0aWNzIH0sIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCBtb3NfcmVwb3J0ID0gdGhpcy5nZXRNT1NSZXBvcnQoKTtcbiAgICAgICAgY29uc3QgbW9zID0gbW9zX3JlcG9ydC5sYXN0O1xuICAgICAgICBpZiAobW9zKSB7XG4gICAgICAgICAgICBpZiAoZW1pdF9ydGNfYW5hbHl0aWNzKSB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb24uZW1pdChcInJ0Y3N0YXRzOmFuYWx5dGljc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibW9zX3JlcG9ydFwiLFxuICAgICAgICAgICAgICAgICAgICBtb3MsXG4gICAgICAgICAgICAgICAgICAgIHJ0Y19pZCxcbiAgICAgICAgICAgICAgICAgICAgbW9zX3JlcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgYXBpX2tleTogYXBwbGljYXRpb24uc2Vzc2lvbi5hcGlLZXksXG4gICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmFwcGxpY2F0aW9uX2lkICYmIHsgYXBwbGljYXRpb25faWQ6IHRoaXMuYXBwbGljYXRpb25faWQgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihjb252ZXJzYXRpb24gJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uX2lkOiBjb252ZXJzYXRpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25fbmFtZTogY29udmVyc2F0aW9uLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbWl0X2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGVwcmVjYXRpb25XYXJuaW5nU2VudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXByZWNhdGlvbldhcm5pbmdTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcInJ0Y3N0YXRzOnJlcG9ydFwiIGV2ZW50IGlzIGRlcHJlY2F0ZWQuIFVzZSBcInJ0Y3N0YXRzOmFuYWx5dGljc1wiIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFwicnRjc3RhdHM6YW5hbHl0aWNzIGluc3RlYWRcIlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmVtaXQoXCJydGNzdGF0czpyZXBvcnRcIiwgbW9zLCBudWxsLCBjb252ZXJzYXRpb24sIG1vc19yZXBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0U2VuZGluZ1N0YXRzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBhcHBsaWNhdGlvbiwgY29udmVyc2F0aW9uID0gbnVsbCwgcGMsIHJ0Y19pZCwgY29uZmlnOiB7IHJlbW90ZV9jb2xsZWN0aW9uLCByZW1vdGVfY29sbGVjdGlvbl91cmwsIHJlbW90ZV9jb2xsZWN0aW9uX2ludGVydmFsLCB9LCB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKCFyZW1vdGVfY29sbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcmVtb3RlX2NvbGxlY3Rpb25faW50ZXJ2YWxfaWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBwYy5nZXRTdGF0cyhudWxsKS50aGVuKChyZXBvcnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udiA9IChfYSA9IGNvbnZlcnNhdGlvbiAhPT0gbnVsbCAmJiBjb252ZXJzYXRpb24gIT09IHZvaWQgMCA/IGNvbnZlcnNhdGlvbiA6IHRoaXMuY29udmVyc2F0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuZGVmYXVsdC5uZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVtb3RlX2NvbGxlY3Rpb25fdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucnRjU3RhdHNBZGFwdGVyUGFyc2VyKHJlcG9ydCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdJZDogcnRjX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5OiBhcHBsaWNhdGlvbi5zZXNzaW9uLmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmFwcGxpY2F0aW9uX2lkICYmIHsgYXBwbGljYXRpb25JZDogdGhpcy5hcHBsaWNhdGlvbl9pZCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihjb252ICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZDogY29udi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25OYW1lOiBjb252Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgIGlmIChwYy5jb25uZWN0aW9uU3RhdGUgPT09IFwiY2xvc2VkXCIgfHwgcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbnRlcnZhbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVtb3RlX2NvbGxlY3Rpb25faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmludGVydmFscy5wdXNoKHJlbW90ZV9jb2xsZWN0aW9uX2ludGVydmFsX2lkKTtcbiAgICB9XG4gICAgc3RhcnRFbWl0dGluZ1N0YXRzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBhcHBsaWNhdGlvbiwgY29udmVyc2F0aW9uID0gbnVsbCwgcGMsIHJ0Y19pZCwgY29uZmlnOiB7IGVtaXRfZXZlbnRzLCBlbWl0X3J0Y19hbmFseXRpY3MsIGVtaXRfaW50ZXJ2YWwgfSwgfSA9IGNvbnRleHQ7XG4gICAgICAgIGlmICghZW1pdF9ldmVudHMgJiYgIWVtaXRfcnRjX2FuYWx5dGljcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZW1pdF9zdGF0c19pbnRlcnZhbF9pZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHBjLmdldFN0YXRzKG51bGwpLnRoZW4oKHN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vcyA9IHRoaXMuZ2V0TW9zKHN0YXRzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnYgPSAoX2EgPSBjb252ZXJzYXRpb24gIT09IG51bGwgJiYgY29udmVyc2F0aW9uICE9PSB2b2lkIDAgPyBjb252ZXJzYXRpb24gOiB0aGlzLmNvbnZlcnNhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW1pdF9ydGNfYW5hbHl0aWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmVtaXQoXCJydGNzdGF0czphbmFseXRpY3NcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJtb3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydDogc3RhdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBydGNfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlfa2V5OiBhcHBsaWNhdGlvbi5zZXNzaW9uLmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmFwcGxpY2F0aW9uX2lkICYmIHsgYXBwbGljYXRpb25faWQ6IHRoaXMuYXBwbGljYXRpb25faWQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oY29udiAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uX2lkOiBjb252LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbl9uYW1lOiBjb252Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW1pdF9ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kZXByZWNhdGlvbldhcm5pbmdTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXByZWNhdGlvbldhcm5pbmdTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCJydGNzdGF0czpyZXBvcnRcIiBldmVudCBpcyBkZXByZWNhdGVkLiBVc2UgXCJydGNzdGF0czphbmFseXRpY3NcIiBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBcInJ0Y3N0YXRzOmFuYWx5dGljcyBpbnN0ZWFkXCJcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmVtaXQoXCJydGNzdGF0czpyZXBvcnRcIiwgbW9zLCBzdGF0cywgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgaWYgKHBjLmNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjbG9zZWRcIiB8fCBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUludGVydmFscygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdExhc3RSZXBvcnQoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb246IChfYSA9IGNvbnZlcnNhdGlvbiAhPT0gbnVsbCAmJiBjb252ZXJzYXRpb24gIT09IHZvaWQgMCA/IGNvbnZlcnNhdGlvbiA6IHRoaXMuY29udmVyc2F0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVtaXRfaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmludGVydmFscy5wdXNoKGVtaXRfc3RhdHNfaW50ZXJ2YWxfaWQpO1xuICAgIH1cbiAgICByZW1vdmVJbnRlcnZhbHMoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLmZvckVhY2goKGludGVydmFsKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0gW107XG4gICAgfVxuICAgIGdldE1vcyhzdGF0cykge1xuICAgICAgICBjb25zdCBtb3MgPSBjYWxjdWxhdGVNb3Moc3RhdHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1PU1JlcG9ydChwYXJzZUludChtb3MpKTtcbiAgICAgICAgcmV0dXJuIG1vcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBtb3NfcmVwb3J0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb3MgdGhlIE1PUyBzY29yZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSByZXBvcnQgb2JqZWN0XG4gICAgICovXG4gICAgdXBkYXRlTU9TUmVwb3J0KG1vcykge1xuICAgICAgICB0aGlzLl9yZXBvcnRzQ291bnQrKztcbiAgICAgICAgdGhpcy5fbW9zU3VtICs9IG1vcztcbiAgICAgICAgdGhpcy5tb3NfcmVwb3J0Lmxhc3QgPSBtb3M7XG4gICAgICAgIHRoaXMubW9zX3JlcG9ydC5taW4gPSBtb3MgPCB0aGlzLm1vc19yZXBvcnQubWluID8gbW9zIDogdGhpcy5tb3NfcmVwb3J0Lm1pbjtcbiAgICAgICAgdGhpcy5tb3NfcmVwb3J0Lm1heCA9IG1vcyA+IHRoaXMubW9zX3JlcG9ydC5tYXggPyBtb3MgOiB0aGlzLm1vc19yZXBvcnQubWF4O1xuICAgICAgICB0aGlzLm1vc19yZXBvcnQuYXZlcmFnZSA9IHRoaXMuX21vc1N1bSAvIHRoaXMuX3JlcG9ydHNDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBNT1MgcmVwb3J0IG9iamVjdFxuICAgICAqIG1vc19yZXBvcnQubWluIC0gdGhlIG1pbmltdW0gTU9TIHZhbHVlIGR1cmluZyB0aGUgc3RyZWFtXG4gICAgICogbW9zX3JlcG9ydC5tYXggLSB0aGUgbWF4aW11bSBNT1MgdmFsdWUgZHVyaW5nIHRoZSBzdHJlYW1cbiAgICAgKiBtb3NfcmVwb3J0Lmxhc3QgLSB0aGUgbGFzdCBNT1MgdmFsdWUgZHVyaW5nIHRoZSBzdHJlYW1cbiAgICAgKiBtb3NfcmVwb3J0LmF2ZXJhZ2UgLSB0aGUgYXZlcmFnZSBNT1MgdmFsdWUgZHVyaW5nIHRoZSBzdHJlYW1cbiAgICAgKiBAcmV0dXJucyB7TW9zUmVwb3J0fSBtb3NfcmVwb3J0IC0gYSByZXBvcnQgZm9yIHRoZSBNT1MgdmFsdWVzXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRNT1NSZXBvcnQoKSB7XG4gICAgICAgIHRoaXMubW9zX3JlcG9ydC5taW4gPSBSVENTdGF0c0FuYWx5dGljcy5ub3JtYWxpc2VGbG9hdCh0aGlzLm1vc19yZXBvcnQubWluKTtcbiAgICAgICAgdGhpcy5tb3NfcmVwb3J0Lm1heCA9IFJUQ1N0YXRzQW5hbHl0aWNzLm5vcm1hbGlzZUZsb2F0KHRoaXMubW9zX3JlcG9ydC5tYXgpO1xuICAgICAgICB0aGlzLm1vc19yZXBvcnQubGFzdCA9IFJUQ1N0YXRzQW5hbHl0aWNzLm5vcm1hbGlzZUZsb2F0KHRoaXMubW9zX3JlcG9ydC5sYXN0KTtcbiAgICAgICAgdGhpcy5tb3NfcmVwb3J0LmF2ZXJhZ2UgPSBSVENTdGF0c0FuYWx5dGljcy5ub3JtYWxpc2VGbG9hdCh0aGlzLm1vc19yZXBvcnQuYXZlcmFnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1vc19yZXBvcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpc2VGbG9hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkudG9GaXhlZCg2KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSVENTdGF0c0FuYWx5dGljcztcbm1vZHVsZS5leHBvcnRzID0gUlRDU3RhdHNBbmFseXRpY3M7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5leG1vQXBpRXJyb3IgPSBleHBvcnRzLk5leG1vQ2xpZW50RXJyb3IgPSB2b2lkIDA7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICogIE5leG1vIENsaWVudCAtIEFQSSBFcnJvciB3cmFwcGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4qL1xuY29uc3QgTmV4bW9DbGllbnRFcnJvclR5cGVzID0gcmVxdWlyZSgnLi9uZXhtb0NsaWVudEVycm9yVHlwZXMnKTtcbmNvbnN0IGxvZ2xldmVsXzEgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG5mdW5jdGlvbiBkZWNvcmF0ZUVycm9yKGluc3RhbmNlLCBlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiBlcnJvci5jb2RlKSB7XG4gICAgICAgIGVycm9yLnR5cGUgPSBlcnJvci5jb2RlO1xuICAgICAgICBkZWxldGUgZXJyb3JbJ2NvZGUnXTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgZXJyb3IpO1xuICAgIGluc3RhbmNlLm1lc3NhZ2UgPSAndHlwZTogJyArIGluc3RhbmNlLnR5cGUgKyAnLCBkZXNjcmlwdGlvbjogJyArIChpbnN0YW5jZS5kZXNjcmlwdGlvbiA/IGluc3RhbmNlLmRlc2NyaXB0aW9uIDogJycpO1xufVxuLyoqXG4gKiBFcnJvciBjb25zdHJ1Y3RvciBvZiBhbiBOZXhtb0NsaWVudC1lcnJvclxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9ySW5wdXQgU3RyaW5nIGNsaWVudCBlcnJvclxuKi9cbmNsYXNzIE5leG1vQ2xpZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ySW5wdXQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBOZXhtb0NsaWVudEVycm9yVHlwZXNbZXJyb3JJbnB1dF07XG4gICAgICAgIC8vIGZvciBvdGhlciBlcnJvcnMgKGxpYnMvYnJvd3NlciBBUElzKSByZS11c2UgdGhlIENsaWVudCBlcnJvclxuICAgICAgICAvLyB0byBmb3J3YXJkIGl0IGJ1dCBkb24ndCB0aHJvdyBpdCBhd2F5XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgLy8gaWYgZXJyb3IgdHlwZSBleGlzdHMgaW4gb3VyIGxpc3Qga2VlcCBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgZGVjb3JhdGVFcnJvcih0aGlzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3RydWN0dXJlIGlzIG5vdCBhcyBleHBlY3RlZCwgZi93IGFzIG11Y2ggYXMgd2UgY2FuIGdldFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JJbnB1dCAmJiBlcnJvcklucHV0Lm1lc3NhZ2UgPyBlcnJvcklucHV0Lm1lc3NhZ2UgOiBlcnJvcklucHV0O1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGVycm9ySW5wdXQuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nIGVycm9yXG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IodGhpcyk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZXJyb3IubmFtZSBtYXRjaGVzIHRoZSBjbGFzcyBuYW1lXG4gICAgICAgIHRoaXMubmFtZSA9ICdOZXhtb0NsaWVudEVycm9yJztcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwuTlhNYnVnc25hZ0NsaWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGdsb2JhbC5OWE1idWdzbmFnQ2xpZW50Lm5vdGlmeSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdpbmZvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk5leG1vQ2xpZW50RXJyb3IgPSBOZXhtb0NsaWVudEVycm9yO1xuLyoqXG4gKiBFcnJvciBjb25zdHJ1Y3RvciBvZiBhbiBBUEktZXJyb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBBUEkgZXJyb3IsIGFsd2F5cyBjb250YWluaW5nIHt0eXBlOiA8c3RyaW5nPn1cbiovXG5jbGFzcyBOZXhtb0FwaUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcklucHV0KSB7XG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5nZXRMb2dnZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgaWYgKGVycm9ySW5wdXQpIHtcbiAgICAgICAgICAgIGRlY29yYXRlRXJyb3IodGhpcywgZXJyb3JJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3RydWN0dXJlIGlzIG5vdCBhcyBleHBlY3RlZCwgZi93IGFzIG11Y2ggYXMgd2UgY2FuIGdldFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JJbnB1dCAmJiBlcnJvcklucHV0Lm1lc3NhZ2UgPyBlcnJvcklucHV0Lm1lc3NhZ2UgOiBlcnJvcklucHV0O1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGVycm9ySW5wdXQgJiYgZXJyb3JJbnB1dC5zdGFjayA/IGVycm9ySW5wdXQuc3RhY2sgOiBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSAnTmV4bW9BcGlFcnJvcic7XG4gICAgICAgIC8vIGxvZyBlcnJvclxuICAgICAgICB0aGlzLmxvZyA9IGxvZ2xldmVsXzEuZ2V0TG9nZ2VyKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbC5OWE1idWdzbmFnQ2xpZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZ2xvYmFsLk5YTWJ1Z3NuYWdDbGllbnQubm90aWZ5KHRoaXMsIHtcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2luZm8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTmV4bW9BcGlFcnJvciA9IE5leG1vQXBpRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBOZXhtb0NsaWVudEVycm9yOiBOZXhtb0NsaWVudEVycm9yLFxuICAgIE5leG1vQXBpRXJyb3I6IE5leG1vQXBpRXJyb3Jcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKlxuICogIE5leG1vIENsaWVudCBTREtcbiAqICBOZXhtbyBDbGllbnQgRXJyb3IgVHlwZXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2Vycm9yOmFwcGxpY2F0aW9uOmNhbGw6cGFyYW1zJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6YXBwbGljYXRpb246Y2FsbDpwYXJhbXMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ25vdCBhIHZhbGlkIFN0cmluZ1tdIG9mIHVzZXJuYW1lcyBwYXJhbSdcbiAgICB9LFxuICAgICdlcnJvcjphcHBsaWNhdGlvbjpjYWxsU2VydmVyOnBhcmFtcyc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmFwcGxpY2F0aW9uOmNhbGw6cGFyYW1zJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdub3QgYSB2YWxpZCBTdHJpbmcgb2YgcGhvbmUgbnVtYmVyJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmNhbGw6cmVqZWN0Jzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6Y2FsbDpyZWplY3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2ZhaWxlZCB0byByZWplY3QgdGhlIGNhbGwnXG4gICAgfSxcbiAgICAnZXJyb3I6Z2V0VXNlck1lZGlhOnBlcm1pc3Npb25zJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6Z2V0VXNlck1lZGlhOnBlcm1pc3Npb25zJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdtaXNzaW5nIGdldFVzZXJNZWRpYSBwZXJtaXNzaW9ucydcbiAgICB9LFxuICAgICdlcnJvcjptZWRpYTpwYXJhbXMnOiB7XG4gICAgICAgIHR5cGU6ICdlcnJvcjptZWRpYTpwYXJhbXMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2N1cnJlbnRseSBzdXBwb3J0ZWQgcGFyYW1zIG1lZGlhIHR5cGU9IHthdWRpbzp7bXV0ZWQ6ZmFsc2UsIGVhcm11ZmZlZDpmYWxzZX19J1xuICAgIH0sXG4gICAgJ2Vycm9yOm1lZGlhOnJlZW5hYmxlJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWVkaWE6cmVlbmFibGUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ21pc3NpbmcgcmVjb25uZWN0UnRjSWQgcmVxdWlyZWQgdG8gcmVlbmFibGUgbWVkaWEnXG4gICAgfSxcbiAgICAnZXJyb3I6c2VsZic6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOnNlbGYnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbnZlcnNhdGlvbiBPYmplY3QgaXMgbWlzc2luZyBzZWxmIChtZSknXG4gICAgfSxcbiAgICAnZXJyb3I6dXNlcjpyZWxvZ2luJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6dXNlcjpyZWxvZ2luJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdwbGVhc2UgcmVsb2dpbidcbiAgICB9LFxuICAgICdlcnJvcjpzZWVuOm93bi1tZXNzYWdlJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6c2Vlbjpvd24tbWVzc2FnZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYXR0ZW1wdCB0byBzZW5kIHNlZW4gZm9yIG93biBtZXNzYWdlJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmFscmVhZHktc2Vlbic6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmFscmVhZHktc2VlbicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnYWxyZWFkeSBtYXJrZWQgYXMgc2VlbidcbiAgICB9LFxuICAgICdlcnJvcjpkZWxpdmVyZWQ6b3duLW1lc3NhZ2UnOiB7XG4gICAgICAgIHR5cGU6ICdlcnJvcjpkZWxpdmVyZWQ6b3duLW1lc3NhZ2UnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2F0dGVtcHQgdG8gc2VuZCBkZWxpdmVyZWQgZm9yIG93biBtZXNzYWdlJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmFscmVhZHktZGVsaXZlcmVkJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6YWxyZWFkeS1kZWxpdmVyZWQnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2FscmVhZHkgbWFya2VkIGFzIGRlbGl2ZXJlZCdcbiAgICB9LFxuICAgICdlcnJvcjpmZXRjaC1pbWFnZSc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmZldGNoLWltYWdlJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICd4aHIuc3RhdHVzIHJlY2VpdmVkIG90aGVyIHRoYW4gMjAwJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmRlbGV0ZS1pbWFnZSc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmRlbGV0ZS1pbWFnZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAneGhyLnN0YXR1cyByZWNlaXZlZCBvdGhlciB0aGFuIDIwNCdcbiAgICB9LFxuICAgICdlcnJvcjptaXNzaW5nOnBhcmFtcyc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOm1pc3Npbmc6cGFyYW1zJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdtaXNzaW5nIHBhcmFtZXRlcnMnXG4gICAgfSxcbiAgICAnZXJyb3I6aW52aXRlOm1pc3Npbmc6cGFyYW1zJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWlzc2luZzpwYXJhbXMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1RoaXMgaW52aXRlIGNhbm5vdCBiZSBzZW50IHRvIGVtcHR5IHVzZXJuYW1lIGFuZCB1c2VyX2lkJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmludmFsaWQ6cGFyYW06dHlwZSc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmludmFsaWQ6cGFyYW06dHlwZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnSW52YWxpZCBPYmplY3QgdHlwZSwgcGFzc2VkIGluIHRoZSBwYXJhbWV0ZXJzJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmF1ZGlvOmFscmVhZHktY29ubmVjdGluZyc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmF1ZGlvOmFscmVhZHktY29ubmVjdGluZycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQXVkaW8gY2FsbCBhbHJlYWR5IGluIHByb2dyZXNzJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmF1ZGlvOm5vdC1lbmFibGVkJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6YXVkaW86bm90LWVuYWJsZWQnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0F1ZGlvIGlzIG5vdCBlbmFibGVkJ1xuICAgIH0sXG4gICAgJ2Vycm9yOm1lZGlhOmFscmVhZHktY29ubmVjdGluZyc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOm1lZGlhOmFscmVhZHktY29ubmVjdGluZycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnTWVkaWEgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcydcbiAgICB9LFxuICAgICdlcnJvcjptZWRpYTp1bnN1cHBvcnRlZC1icm93c2VyJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWVkaWE6dW5zdXBwb3J0ZWQtYnJvd3NlcicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBhY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXInXG4gICAgfSxcbiAgICAnZXJyb3I6bWVkaWE6ZXh0ZW5zaW9uJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWVkaWE6ZXh0ZW5zaW9uJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDaHJvbWUgZXh0ZW5zaW9uIGhhcyB0aHJvd24gYW4gZXJyb3InXG4gICAgfSxcbiAgICAnZXJyb3I6bWVkaWE6ZXh0ZW5zaW9uLW5vdC1pbnN0YWxsZWQnOiB7XG4gICAgICAgIHR5cGU6ICdlcnJvcjptZWRpYTpleHRlbnNpb24tbm90LWluc3RhbGxlZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQ2hyb21lIGV4dGVuc2lvbiBzaG91bGQgYmUgaW5zdGFsbGVkJ1xuICAgIH0sXG4gICAgJ2Vycm9yOm1lZGlhOnVwZGF0ZTpzdHJlYW1zJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWVkaWE6dXBkYXRlOnN0cmVhbXMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ2NhbnQgdXBkYXRlIG1vcmUgdGhhbiBvbmUgc3RyZWFtJ1xuICAgIH0sXG4gICAgJ2Vycm9yOm1lZGlhOnVwZGF0ZTppbnZhbGlkJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWVkaWE6dXBkYXRlOmludmFsaWQnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ3N0YXRlIG9mIG1lZGlhIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgdXBkYXRlJ1xuICAgIH0sXG4gICAgJ2Vycm9yOm1lZGlhOnN0cmVhbTpub3QtZm91bmQnOiB7XG4gICAgICAgIHR5cGU6ICdlcnJvcjptZWRpYTpzdHJlYW06bm90LWZvdW5kJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBIHN0cmVhbSB3aXRoIHRoZSBnaXZlbiBpbmRleCB3YXMgbm90IGZvdW5kJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmF1ZGlvOmR0bWY6aW52YWxpZC1kaWdpdCc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmF1ZGlvOmR0bWY6aW52YWxpZC1kaWdpdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnbm90IGEgdmFsaWQgc3RyaW5nIG9mIGR0bWYgZGlnaXRzICgwLTksYS1kLEEtRCxwLFAsKiwjKSdcbiAgICB9LFxuICAgICdlcnJvcjphdWRpbzpkdG1mOmF1ZGlvLWRpc2FibGVkJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6YXVkaW86ZHRtZjphdWRpby1kaXNhYmxlZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQXVkaW8gbXVzdCBiZSBlbmFibGVkIHRvIHNlbmQgRFRNRidcbiAgICB9LFxuICAgICdlcnJvcjppbnZhbGlkLW9yZGVyJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6aW52YWxpZC1vcmRlcicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAncGFyYW1zIG5vdCB2YWxpZC4gT3JkZXIgbXVzdCBiZSBhc2Mgb3IgZGVzYydcbiAgICB9LFxuICAgICdlcnJvcjpjdXN0b20tZXZlbnQ6aW52YWxpZCc6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmN1c3RvbS1ldmVudDppbnZhbGlkJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdDdXN0b20gZXZlbnQgdHlwZSBub3QgdmFsaWQnXG4gICAgfSxcbiAgICAnZXJyb3I6bWVzc2FnZS1ldmVudDppbnZhbGlkJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bWVzc2FnZS1ldmVudDppbnZhbGlkJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdtZXNzYWdlX3R5cGUgaXMgbWlzc2luZyBvciBpcyBpbnZhbGlkJ1xuICAgIH0sXG4gICAgJ2Vycm9yOmludmFsaWQtY3Vyc29yJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6aW52YWxpZC1jdXJzb3InLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ3BhZ2UgZG9lcyBub3QgZXhpc3QnXG4gICAgfSxcbiAgICAnZXJyb3I6Y2xpZW50OnJlY29ubmVjdGlvbl9mYWlsZWQnOiB7XG4gICAgICAgIHR5cGU6ICdlcnJvcjpjbGllbnQ6cmVjb25uZWN0aW9uX2ZhaWxlZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnd2Vic29ja2V0IGZhaWxlZCB0byByZWNvbm5lY3QnXG4gICAgfSxcbiAgICAnZXJyb3I6Y29udmVyc2F0aW9uLXNlcnZpY2U6dmVyc2lvbic6IHtcbiAgICAgICAgdHlwZTogJ2Vycm9yOmNvbnZlcnNhdGlvbjp2ZXJzaW9uJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdXcm9uZyB2ZXJzaW9uIG9mIENvbnZlcnNhdGlvbiBTZXJ2aWNlIEFQSS4gSXQgc2hvdWxkIGJlIG9uZSBvZiBcInYxXCIgb3IgXCJ2M1wiJ1xuICAgIH0sXG4gICAgJ2Vycm9yOm5vLW1lZGlhLW9mZmVyJzoge1xuICAgICAgICB0eXBlOiAnZXJyb3I6bm8tbWVkaWEtb2ZmZXInLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ01lZGlhIHByZWxvYWQgYXR0ZW1wdCB3aXRob3V0IGhhdmluZyBhbiBvZmZlciBhdmFpbGFibGUnXG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4qL1xuY29uc3QgcGFnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2VcIikpO1xuLyoqXG4gKiBBIENvbnZlcnNhdGlvbnMgUGFnZVxuICpcbiAqIEBjbGFzcyBDb252ZXJzYXRpb25zUGFnZVxuICogQHBhcmFtIHtNYXB9IGl0ZW1zIG1hcCBvZiBjb252ZXJzYXRpb25zIGZldGNoZWQgaW4gdGhlIHBhZ2luYXRlZCBxdWVyeVxuICogQGV4dGVuZHMgUGFnZVxuKi9cbmNsYXNzIENvbnZlcnNhdGlvbnNQYWdlIGV4dGVuZHMgcGFnZV8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBJdGVyYXRlIGFuZCBjcmVhdGUgdGhlIGNvbnZlcnNhdGlvbnMgaWYgbm90IGV4aXN0ZW50XG4gICAgICAgIHBhcmFtcy5pdGVtcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmFwcGxpY2F0aW9uLnVwZGF0ZU9yQ3JlYXRlQ29udmVyc2F0aW9uKGMpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zZXQoY29udmVyc2F0aW9uLmlkLCBjb252ZXJzYXRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2UgaWYgZXhpc3RzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UGFnZT59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RmV0Y2ggdGhlIHByZXZpb3VzIHBhZ2UgaWYgZXhpc3RzPC9jYXB0aW9uPlxuICAgICAqICBjdXJyZW50Q29udlBhZ2UuZ2V0UHJldigpLnRoZW4oKHByZXZDb252UGFnZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKFwicHJldmlvdXMgY29udmVyc2F0aW9uIHBhZ2UgXCIsIHByZXZDb252UGFnZSk7XG4gICAgICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBnZXR0aW5nIHByZXZpb3VzIGNvbnZlcnNhdGlvbiBwYWdlIFwiLCBlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgZ2V0UHJldigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ByZXYoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFcnJvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5nZXRDb252ZXJzYXRpb25zKHRoaXMuX2dldENvbmZpZyh0aGlzLmN1cnNvci5wcmV2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBuZXh0IHBhZ2UgaWYgZXhpc3RzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UGFnZT59XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RmV0Y2ggdGhlIG5leHQgcGFnZSBpZiBleGlzdHM8L2NhcHRpb24+XG4gICAgICogIGN1cnJlbnRDb252UGFnZS5nZXROZXh0KCkudGhlbigobmV4dENvbnZQYWdlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJuZXh0IGNvbnZlcnNhdGlvbiBwYWdlIFwiLCBuZXh0Q29udlBhZ2UpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZ2V0dGluZyBuZXh0IGNvbnZlcnNhdGlvbiBwYWdlIFwiLCBlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgZ2V0TmV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05leHQoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFcnJvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5nZXRDb252ZXJzYXRpb25zKHRoaXMuX2dldENvbmZpZyh0aGlzLmN1cnNvci5uZXh0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udmVyc2F0aW9uc1BhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IENvbnZlcnNhdGlvbnNQYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiovXG5jb25zdCBwYWdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFnZVwiKSk7XG5jb25zdCBueG1FdmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvbnhtRXZlbnRcIikpO1xuY29uc3QgdGV4dF9ldmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvdGV4dF9ldmVudFwiKSk7XG5jb25zdCBpbWFnZV9ldmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvaW1hZ2VfZXZlbnRcIikpO1xuY29uc3QgbWVzc2FnZV9ldmVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvbWVzc2FnZV9ldmVudFwiKSk7XG4vKipcbiAqIEEgRXZlbnRzIFBhZ2VcbiAqXG4gKiBAY2xhc3MgRXZlbnRzUGFnZVxuICogQHBhcmFtIHtNYXB9IGl0ZW1zIG1hcCBvZiBldmVudHMgZmV0Y2hlZCBpbiB0aGUgcGFnaW5hdGVkIHF1ZXJ5XG4gKiBAZXh0ZW5kcyBQYWdlXG4qL1xuY2xhc3MgRXZlbnRzUGFnZSBleHRlbmRzIHBhZ2VfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBwYXJhbXMuY29udmVyc2F0aW9uO1xuICAgICAgICAvLyBJdGVyYXRlIGFuZCBjcmVhdGUgdGhlIGV2ZW50IG9iamVjdHNcbiAgICAgICAgcGFyYW1zLml0ZW1zLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBOWE1FdmVudCB0eXBlcyB3aXRoIGNvcnJlc3BvbmRpbmcgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNldChldmVudC5pZCwgbmV3IHRleHRfZXZlbnRfMS5kZWZhdWx0KHRoaXMuY29udmVyc2F0aW9uLCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc2V0KGV2ZW50LmlkLCBuZXcgaW1hZ2VfZXZlbnRfMS5kZWZhdWx0KHRoaXMuY29udmVyc2F0aW9uLCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zZXQoZXZlbnQuaWQsIG5ldyBtZXNzYWdlX2V2ZW50XzEuZGVmYXVsdCh0aGlzLmNvbnZlcnNhdGlvbiwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zZXQoZXZlbnQuaWQsIG5ldyBueG1FdmVudF8xLmRlZmF1bHQodGhpcy5jb252ZXJzYXRpb24sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBldmVudHMgTWFwIG9uIHRoZSBjb252ZXJzYXRpb25cbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24uZXZlbnRzID0gbmV3IE1hcChbLi4udGhpcy5jb252ZXJzYXRpb24uZXZlbnRzLCAuLi50aGlzLml0ZW1zXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBwcmV2aW91cyBwYWdlIGlmIGV4aXN0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBhZ2U+fVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZldGNoIHRoZSBwcmV2aW91cyBwYWdlIGlmIGV4aXN0czwvY2FwdGlvbj5cbiAgICAgKiAgY3VycmVudEV2ZW50c1BhZ2UuZ2V0UHJldigpLnRoZW4oKHByZXZFdmVudHNQYWdlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJwcmV2aW91cyBldmVudHMgcGFnZSBcIiwgcHJldkV2ZW50c1BhZ2UpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZ2V0dGluZyBwcmV2aW91cyBldmVudHMgcGFnZSBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGdldFByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNQcmV2KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2F0aW9uLmdldEV2ZW50cyh0aGlzLl9nZXRDb25maWcodGhpcy5jdXJzb3IucHJldikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgbmV4dCBwYWdlIGlmIGV4aXN0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBhZ2U+fVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZldGNoIHRoZSBuZXh0IHBhZ2UgaWYgZXhpc3RzPC9jYXB0aW9uPlxuICAgICAqICBjdXJyZW50RXZlbnRzUGFnZS5nZXROZXh0KCkudGhlbigobmV4dEV2ZW50c1BhZ2UpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIm5leHQgZXZlbnRzIHBhZ2UgXCIsIG5leHRFdmVudHNQYWdlKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5lcnJvcihcImVycm9yIGdldHRpbmcgbmV4dCBldmVudHMgcGFnZSBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGdldE5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2F0aW9uLmdldEV2ZW50cyh0aGlzLl9nZXRDb25maWcodGhpcy5jdXJzb3IubmV4dCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50c1BhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50c1BhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuKi9cbmNvbnN0IHBhZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlXCIpKTtcbmNvbnN0IG1lbWJlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tZW1iZXJcIikpO1xuLyoqXG4gKiBBIE1lbWJlcnMgUGFnZVxuICpcbiAqIEBjbGFzcyBNZW1iZXJzUGFnZVxuICogQHBhcmFtIHtNYXB9IGl0ZW1zIG1hcCBvZiBtZW1iZXJzIGZldGNoZWQgaW4gdGhlIHBhZ2luYXRlZCBxdWVyeVxuICogQGV4dGVuZHMgUGFnZVxuKi9cbmNsYXNzIE1lbWJlcnNQYWdlIGV4dGVuZHMgcGFnZV8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IHBhcmFtcy5jb252ZXJzYXRpb247XG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEl0ZXJhdGUgYW5kIGNyZWF0ZSB0aGUgY29udmVyc2F0aW9ucyBpZiBub3QgZXhpc3RlbnRcbiAgICAgICAgcGFyYW1zLml0ZW1zLmZvckVhY2goKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zZXQobWVtYmVyLmlkLCBuZXcgbWVtYmVyXzEuZGVmYXVsdCh0aGlzLmNvbnZlcnNhdGlvbiwgbWVtYmVyKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBpZiBleGlzdHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQYWdlPn1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5GZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBpZiBleGlzdHM8L2NhcHRpb24+XG4gICAgICogIGN1cnJlbnRNZW1iZXJzUGFnZS5nZXRQcmV2KCkudGhlbigocHJldk1lbWJlcnNQYWdlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJwcmV2aW91cyBtZW1iZXJzIHBhZ2UgXCIsIHByZXZNZW1iZXJzUGFnZSk7XG4gICAgICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBnZXR0aW5nIHByZXZpb3VzIG1lbWJlcnMgcGFnZSBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGdldFByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNQcmV2KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2F0aW9uLmdldE1lbWJlcnModGhpcy5fZ2V0Q29uZmlnKHRoaXMuY3Vyc29yLnByZXYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIG5leHQgcGFnZSBpZiBleGlzdHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQYWdlPn1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5GZXRjaCB0aGUgbmV4dCBwYWdlIGlmIGV4aXN0czwvY2FwdGlvbj5cbiAgICAgKiAgY3VycmVudE1lbWJlcnNQYWdlLmdldE5leHQoKS50aGVuKChuZXh0TWVtYmVyc1BhZ2UpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhcIm5leHQgbWVtYmVycyBwYWdlIFwiLCBuZXh0TWVtYmVyc1BhZ2UpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZ2V0dGluZyBuZXh0IG1lbWJlcnMgcGFnZSBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGdldE5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2F0aW9uLmdldE1lbWJlcnModGhpcy5fZ2V0Q29uZmlnKHRoaXMuY3Vyc29yLm5leHQpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNZW1iZXJzUGFnZTtcbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyc1BhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKlxuICogTmV4bW8gQ2xpZW50IFNES1xuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuKi9cbmNvbnN0IG5leG1vQ2xpZW50RXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9uZXhtb0NsaWVudEVycm9yXCIpO1xuLyoqIFBhZ2UgQ2xhc3MgZm9yIFBhZ2luYXRlZCBSZXN1bHRzXG4gKlxuICogQGNsYXNzIFBhZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlX3NpemUgdGhlIG51bWJlciBvZiByZXNvdXJjZXMgcmV0dXJuZWQgaW4gYSBzaW5nbGUgcmVxdWVzdCBsaXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3JkZXIgJ2FzYycgb3IgJ2Rlc2MnIG9yZGVyaW5nIG9mIHJlc291cmNlcyAodXN1YWxseSBiYXNlZCBvbiBjcmVhdGlvbiB0aW1lKVxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnNvciBjdXJzb3IgcGFyYW1ldGVyIHRvIGFjY2VzcyB0aGUgbmV4dCBvciBwcmV2aW91cyBwYWdlIG9mIGEgZGF0YSBzZXRcbiAqIEBwYXJhbSB7QXBwbGljYXRpb259IGFwcGxpY2F0aW9uIC0gdGhlIHBhcmVudCBBcHBsaWNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtldmVudF90eXBlXSB0aGUgdHlwZSBvZiBldmVudCB1c2VkIHRvIGZpbHRlciBldmVudCByZXF1ZXN0c1xuICpcbiAqIEBwcml2YXRlXG4qL1xuY2xhc3MgUGFnZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5wYWdlX3NpemUgPSBwYXJhbXMucGFnZV9zaXplO1xuICAgICAgICB0aGlzLm9yZGVyID0gcGFyYW1zLm9yZGVyO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHBhcmFtcy5jdXJzb3I7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBwYXJhbXMuYXBwbGljYXRpb247XG4gICAgICAgIGlmIChwYXJhbXMuZXZlbnRfdHlwZSAmJiBwYXJhbXMuZXZlbnRfdHlwZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50X3R5cGUgPSBwYXJhbXMuZXZlbnRfdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBwcmV2aW91cyBwYWdlIGV4aXN0c1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNoZWNrIGlmIHByZXZpb3VzIHBhZ2UgZXhpc3RzPC9jYXB0aW9uPlxuICAgICAqIC8vIGN1cnJlbnRQYWdlIGlzIHRoZSBjdXJyZW50IENvbnZlcnNhdGlvbnMgb3IgRXZlbnRzIFBhZ2VcbiAgICAgKiBjdXJyZW50UGFnZS5oYXNQcmV2KCkgLy8gdHJ1ZSBvciBmYWxzZVxuICAgICovXG4gICAgaGFzUHJldigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLnByZXYgPyB0aGlzLmN1cnNvci5wcmV2Lmxlbmd0aCA+IDAgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgbmV4dCBwYWdlIGV4aXN0c1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNoZWNrIGlmIG5leHQgcGFnZSBleGlzdHM8L2NhcHRpb24+XG4gICAgICogLy8gY3VycmVudFBhZ2UgaXMgdGhlIGN1cnJlbnQgQ29udmVyc2F0aW9ucyBvciBFdmVudHMgUGFnZVxuICAgICAqIGN1cnJlbnRQYWdlLmhhc05leHQoKSAvLyB0cnVlIG9yIGZhbHNlXG4gICAgKi9cbiAgICBoYXNOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IubmV4dCA/IHRoaXMuY3Vyc29yLm5leHQubGVuZ3RoID4gMCA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogQ3JlYXRlIGNvbmZpZyBwYXJhbXMgZm9yIHBhZ2luYXRpb25SZXF1ZXN0XG4gICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJzb3IgY3Vyc29yIHBhcmFtZXRlciB0byBhY2Nlc3MgdGhlIG5leHQgb3IgcHJldmlvdXMgcGFnZSBvZiBhIGRhdGEgc2V0XG4gICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIF9nZXRDb25maWcoY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBhZ2Vfc2l6ZTogdGhpcy5wYWdlX3NpemUsXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgIGN1cnNvcixcbiAgICAgICAgICAgIC4uLih0aGlzLmV2ZW50X3R5cGUgJiYgeyBldmVudF90eXBlOiB0aGlzLmV2ZW50X3R5cGUgfSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV4bW9DbGllbnRFcnJvciB3aGVuIHBhZ2UgZG9lcyBub3QgZXhpc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2dldEVycm9yKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKCdlcnJvcjppbnZhbGlkLWN1cnNvcicpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQYWdlO1xubW9kdWxlLmV4cG9ydHMgPSBQYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiovXG4vKiogQ29uZmlnIENsYXNzIGZvciBQYWdpbmF0ZWQgUmVxdWVzdHNcbiAqXG4gKiBAY2xhc3MgUGFnZUNvbmZpZ1xuICogQHBhcmFtIHtudW1iZXJ9IHBhZ2Vfc2l6ZT0xMCB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyByZXR1cm5lZCBpbiBhIHNpbmdsZSByZXF1ZXN0IGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcj1hc2MgdGhlIGFzYycgb3IgJ2Rlc2MnIG9yZGVyaW5nIG9mIHJlc291cmNlcyAodXN1YWxseSBiYXNlZCBvbiBjcmVhdGlvbiB0aW1lKVxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnNvcj0nJyBjdXJzb3IgcGFyYW1ldGVyIHRvIGFjY2VzcyB0aGUgbmV4dCBvciBwcmV2aW91cyBwYWdlIG9mIGEgZGF0YSBzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnRfdHlwZV0gdGhlIHR5cGUgb2YgZXZlbnQgdXNlZCB0byBmaWx0ZXIgZXZlbnQgcmVxdWVzdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZT0nJyB0aGUgSU5WSVRFRCwgSk9JTkVELCBvciBMRUZUIHN0YXRlIG9mIHlvdXIgbWVtYmVyc2hpcCBpbiB0aGUgY29udmVyc2F0aW9uXG4gKiBAcHJpdmF0ZVxuKi9cbmNsYXNzIFBhZ2VDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGFnZV9zaXplID0gcGFyYW1zLnBhZ2Vfc2l6ZSB8fCAxMDtcbiAgICAgICAgdGhpcy5vcmRlciA9IHBhcmFtcy5vcmRlciB8fCAnYXNjJztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBwYXJhbXMuY3Vyc29yIHx8ICcnO1xuICAgICAgICB0aGlzLnN0YXRlID0gcGFyYW1zLnN0YXRlIHx8ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmV2ZW50X3R5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRfdHlwZSA9IHBhcmFtcy5ldmVudF90eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGFnZUNvbmZpZztcbm1vZHVsZS5leHBvcnRzID0gUGFnZUNvbmZpZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4qL1xuY29uc3QgcGFnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2VcIikpO1xuY29uc3QgdXNlcl9zZXNzaW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3VzZXJfc2Vzc2lvblwiKSk7XG4vKipcbiAqIEEgVXNlclNlc3Npb25zIFBhZ2VcbiAqXG4gKiBAY2xhc3MgVXNlclNlc3Npb25zUGFnZVxuICogQHBhcmFtIHtNYXB9IGl0ZW1zIG1hcCBvZiBVc2VyU2Vzc2lvbnMgZmV0Y2hlZCBpbiB0aGUgcGFnaW5hdGVkIHF1ZXJ5XG4gKiBAZXh0ZW5kcyBQYWdlXG4qL1xuY2xhc3MgVXNlclNlc3Npb25zUGFnZSBleHRlbmRzIHBhZ2VfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBVc2VyU2Vzc2lvbnNcbiAgICAgICAgcGFyYW1zLml0ZW1zLmZvckVhY2goKHVzZXJTZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNldCh1c2VyU2Vzc2lvbi5pZCwgbmV3IHVzZXJfc2Vzc2lvbl8xLmRlZmF1bHQodGhpcy5hcHBsaWNhdGlvbiwgdXNlclNlc3Npb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBwcmV2aW91cyBwYWdlIGlmIGV4aXN0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBhZ2U+fVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkZldGNoIHRoZSBwcmV2aW91cyBwYWdlIGlmIGV4aXN0czwvY2FwdGlvbj5cbiAgICAgKiAgY3VycmVudFVzZXJTZXNzaW9uc1BhZ2UuZ2V0UHJldigpLnRoZW4oKHByZXZVc2VyU2Vzc2lvbnNQYWdlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJwcmV2aW91cyB1c2VyIHNlc3Npb25zIHBhZ2UgXCIsIHByZXZVc2VyU2Vzc2lvbnNQYWdlKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5lcnJvcihcImVycm9yIGdldHRpbmcgcHJldmlvdXMgdXNlciBzZXNzaW9ucyBwYWdlIFwiLCBlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgZ2V0UHJldigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ByZXYoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFcnJvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5nZXRVc2VyU2Vzc2lvbnModGhpcy5fZ2V0Q29uZmlnKHRoaXMuY3Vyc29yLnByZXYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIG5leHQgcGFnZSBpZiBleGlzdHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQYWdlPn1cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5GZXRjaCB0aGUgbmV4dCBwYWdlIGlmIGV4aXN0czwvY2FwdGlvbj5cbiAgICAgKiAgY3VycmVudFVzZXJTZXNzaW9uc1BhZ2UuZ2V0TmV4dCgpLnRoZW4oKG5leHRVc2VyU2Vzc2lvbnNQYWdlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coXCJuZXh0IHVzZXIgc2Vzc2lvbnMgcGFnZSBcIiwgbmV4dFVzZXJTZXNzaW9uc1BhZ2UpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgZ2V0dGluZyBuZXh0IHVzZXIgc2Vzc2lvbnMgcGFnZSBcIiwgZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGdldE5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uZ2V0VXNlclNlc3Npb25zKHRoaXMuX2dldENvbmZpZyh0aGlzLmN1cnNvci5uZXh0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVXNlclNlc3Npb25zUGFnZTtcbm1vZHVsZS5leHBvcnRzID0gVXNlclNlc3Npb25zUGFnZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKiAgTWFpbiB3cmFwcGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4qL1xuY29uc3QgV2lsZEVtaXR0ZXIgPSByZXF1aXJlKCd3aWxkZW1pdHRlcicpO1xuY29uc3QgbG9nbGV2ZWxfcGx1Z2luX3ByZWZpeF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2dsZXZlbC1wbHVnaW4tcHJlZml4XCIpKTtcbmNvbnN0IGxvZ2xldmVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZ2xldmVsXCIpKTtcbmNvbnN0IG5leG1vQ2xpZW50RXJyb3JfMSA9IHJlcXVpcmUoXCIuL25leG1vQ2xpZW50RXJyb3JcIik7XG5jb25zdCBzb2NrZXRfaW9fY2xpZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInNvY2tldC5pby1jbGllbnRcIikpO1xuY29uc3QganNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQGJ1Z3NuYWcvanNcIikpO1xuY29uc3QgcHVibGljaXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tb2R1bGVzL3B1YmxpY2lwXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgYXBwbGljYXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcHBsaWNhdGlvblwiKSk7XG5jb25zdCBlcnJvcnNfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21vZHVsZXMvZXJyb3JzX2VtaXR0ZXJcIikpO1xuY29uc3QgdXNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3VzZXJcIikpO1xuY29uc3QgcnRjX2hlbHBlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21vZHVsZXMvcnRjX2hlbHBlclwiKSk7XG5sb2dsZXZlbF9wbHVnaW5fcHJlZml4XzEuZGVmYXVsdC5yZWcobG9nbGV2ZWxfMS5kZWZhdWx0KTtcbmxvZ2xldmVsX3BsdWdpbl9wcmVmaXhfMS5kZWZhdWx0LmFwcGx5KGxvZ2xldmVsXzEuZGVmYXVsdCwge1xuICAgIHRlbXBsYXRlOiAnWyV0XSAlbCAoTlhNLSVuKTonLFxuICAgIHRpbWVzdGFtcEZvcm1hdHRlcjogKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGRhdGUudG9UaW1lU3RyaW5nKCkucmVwbGFjZSgvLiooXFxkezJ9OlxcZHsyfTpcXGR7Mn0pLiovLCAnJDEnKTtcbiAgICB9LFxuICAgIGxldmVsRm9ybWF0dGVyOiAobGV2ZWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGxldmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBuYW1lRm9ybWF0dGVyOiAobmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gbmFtZSB8fCAnU0RLJztcbiAgICB9XG59KTtcbi8qKlxuICogVGhlIHBhcmVudCBOZXhtb0NsaWVudCBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgTmV4bW9DbGllbnRcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHRoZSBzZXR0aW5ncyB0byBpbml0aWFsaXNlIHRoZSBTREtcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVidWc9J3NpbGVudCcgc2V0IG1vZGUgdG8gJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsIG9yICdlcnJvcicgZm9yIGN1c3RvbWl6ZWQgbG9nZ2luZyBsZXZlbHMgaW4gdGhlIGNvbnNvbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsPSduZXhtb193c191cmwnIE5leG1vIENvbnZlcnNhdGlvbiBXZWJzb2NrZXQgdXJsLCBkZWZhdWx0IGlzIHdzczovL3dzLm5leG1vLmNvbSAod3NzOi8vd3MtdXMtMS5uZXhtby5jb20gZm9yIFdEQywgd3NzOi8vd3MtdXMtMi5uZXhtby5jb20gZm9yIERBTCwgd3NzOi8vd3MtZXUtMS5uZXhtby5jb20gZm9yIExPTiwgd3NzOi8vd3Mtc2ctMS5uZXhtby5jb20gZm9yIFNORylcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmV4bW9fYXBpX3VybD1OZXhtbyBDb252ZXJzYXRpb24gQXBpIHVybCwgZGVmYXVsdCBpcyBodHRwczovL2FwaS5uZXhtby5jb20gKGh0dHBzOi8vYXBpLXVzLTEubmV4bW8uY29tIGZvciBXREMsIGh0dHBzOi8vYXBpLXVzLTIubmV4bW8uY29tIGZvciBEQUwsIGh0dHBzOi8vYXBpLWV1LTEubmV4bW8uY29tIGZvciBMT04sIGh0dHBzOi8vYXBpLXNnLTEubmV4bW8uY29tIGZvciBTTkcpXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmlwc191cmw9J2lwc191cmwnIE5leG1vIElQUyB1cmwgZm9yIGltYWdlIHVwbG9hZCwgZGVmYXVsdCBpcyBodHRwczovL2FwaS5uZXhtby5jb20vdjEvaW1hZ2UgKGh0dHBzOi8vYXBpLXVzLTEubmV4bW8uY29tL3YxL2ltYWdlIGZvciBXREMsIGh0dHBzOi8vYXBpLXVzLTIubmV4bW8uY29tL3YxL2ltYWdlIGZvciBEQUwsIGh0dHBzOi8vYXBpLWV1LTEubmV4bW8uY29tL3YxL2ltYWdlIGZvciBMT04sIGh0dHBzOi8vYXBpLXNnLTEubmV4bW8uY29tL3YxL2ltYWdlIGZvciBTTkcpXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhdGg9Jy92Mi9ydGMnIE5leG1vIENvbnZlcnNhdGlvbiBXZWJzb2NrZXQgdXJsIHBhdGggc3VmZml4XG4gKiBAcGFyYW0ge1JUQ1N0YXRzQ29uZmlnfSBwYXJhbXMucnRjc3RhdHMgc2V0IHJlcG9ydGluZyBmb3Igc3RyZWFtIHN0YXRpc3RpY3MgKEludGVybmFsIGV2ZW50IGVtaXQpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5ydGNzdGF0cy5lbWl0X2V2ZW50cz1mYWxzZSByZWNlaXZlIHJ0Y3N0YXRzOnJlcG9ydCBldmVudCAoZGVwcmVjYXRlZClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLnJ0Y3N0YXRzLmVtaXRfcnRjX2FuYWx5dGljcz1mYWxzZSByZWNlaXZlIHJ0Y3N0YXRzOmFuYWx5dGljcyBldmVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5ydGNzdGF0cy5lbWl0X2ludGVydmFsPTEwMDAgaW50ZXJ2YWwgaW4gbXMgZm9yIHJ0Y3N0YXRzOnJlcG9ydCBhbmQgcnRjc3RhdHM6YW5hbHl0aWNzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5ydGNzdGF0cy5yZW1vdGVfY29sbGVjdGlvbj10cnVlIGNvbGxlY3QgY2xpZW50IGxvZ3MgaW50ZXJuYWxseVxuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMucnRjc3RhdHMucmVtb3RlX2NvbGxlY3Rpb25fdXJsPSdnb2xsdW1fdXJsJyB1cmwgZm9yIGNvbGxlY3RpbmcgY2xpZW50IGxvZ3MgaW50ZXJuYWxseVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5ydGNzdGF0cy5yZW1vdGVfY29sbGVjdGlvbl9pbnRlcnZhbD01MDAwIGludGVydmFsIGluIG1zIHRvIGNvbGxlY3QgY2xpZW50IGxvZ3MgaW50ZXJuYWxseVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5zb2NrZXRfaW8gY29uZmlndXJlIHNvY2tldC5pb1xuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuc29ja2V0X2lvLmZvcmNlTmV3PXRydWUgY29uZmlndXJlIHNvY2tldC5pbyBmb3JjZU5ldyBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLnNvY2tldF9pby5hdXRvQ29ubmVjdD10cnVlIHNvY2tldC5pbyBhdXRvQ29ubmVjdCBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLnNvY2tldF9pby5yZWNvbm5lY3Rpb249dHJ1ZSBzb2NrZXQuaW8gcmVjb25uZWN0aW9uIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zb2NrZXRfaW8ucmVjb25uZWN0aW9uQXR0ZW1wdHM9NSBzb2NrZXQuaW8gcmVjb25uZWN0aW9uQXR0ZW1wdHMgYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuc29ja2V0X2lvLnRyYW5zcG9ydHM9J3dlYnNvY2tldCcgc29ja2V0LmlvIHRyYW5zcG9ydHMgcHJvdG9jb2xzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnN5bmM9J25vbmUnIHsnbm9uZScgfHwgJ2xpdGUnIHx8ICdmdWxsJ30gYWZ0ZXIgYSBzdWNjZXNzZnVsIHNlc3Npb24gY3JlYXRpb24sIHN5bmNocm9uaXNlIGNvbnZlcnNhdGlvbnMsIGluY2x1ZGUgZXZlbnRzIG9yIG5vdGhpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZW52aXJvbm1lbnQ9J3Byb2R1Y3Rpb24nIGRldmVsb3BtZW50IC8gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICogQHBhcmFtIHtvYmplY3RbXX0gW3BhcmFtcy5pY2VTZXJ2ZXJzPVtdXSBjb25maWd1cmUgaWNlU2VydmVycyBmb3IgUlRDUGVlckNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubG9nX3JlcG9ydGVyIGNvbmZpZ3VyZSBsb2cgcmVwb3J0cyBmb3IgYnVnc25hZyB0b29sXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5sb2dfcmVwb3J0ZXIuZW5hYmxlZD10cnVlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxvZ19yZXBvcnRlci5idWdzbmFnX2tleSB5b3VyIGJ1Z3NuYWcgYXBpIGtleSAvIGRlZmF1bHRzIHRvIE5leG1vIGFwaSBrZXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuY29udmVyc2F0aW9uc19wYWdlX2NvbmZpZyBjb25maWd1cmUgcGFnaW5hdGVkIHJlcXVlc3RzIGZvciBjb252ZXJzYXRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmNvbnZlcnNhdGlvbnNfcGFnZV9jb25maWcucGFnZV9zaXplPTEwIHRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHJldHVybmVkIGluIGEgc2luZ2xlIHJlcXVlc3QgbGlzdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jb252ZXJzYXRpb25zX3BhZ2VfY29uZmlnLm9yZGVyPWFzYyAnYXNjJyBvciAnZGVzYycgb3JkZXJpbmcgb2YgcmVzb3VyY2VzICh1c3VhbGx5IGJhc2VkIG9uIGNyZWF0aW9uIHRpbWUpXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNvbnZlcnNhdGlvbnNfcGFnZV9jb25maWcuY3Vyc29yIGN1cnNvciBwYXJhbWV0ZXIgdG8gYWNjZXNzIHRoZSBuZXh0IG9yIHByZXZpb3VzIHBhZ2Ugb2YgYSBkYXRhIHNldFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ldmVudHNfcGFnZV9jb25maWcgY29uZmlndXJlIHBhZ2luYXRlZCByZXF1ZXN0cyBmb3IgZXZlbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmV2ZW50c19wYWdlX2NvbmZpZy5wYWdlX3NpemU9MTAgdGhlIG51bWJlciBvZiByZXNvdXJjZXMgcmV0dXJuZWQgaW4gYSBzaW5nbGUgcmVxdWVzdCBsaXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmV2ZW50c19wYWdlX2NvbmZpZy5vcmRlcj1hc2MgJ2FzYycgb3IgJ2Rlc2MnIG9yZGVyaW5nIG9mIHJlc291cmNlcyAodXN1YWxseSBiYXNlZCBvbiBjcmVhdGlvbiB0aW1lKVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5ldmVudHNfcGFnZV9jb25maWcuZXZlbnRfdHlwZSB0aGUgdHlwZSBvZiBldmVudCB1c2VkIHRvIGZpbHRlciBldmVudCByZXF1ZXN0cy4gU3VwcG9ydHMgd2lsZGNhcmQgb3B0aW9ucyB3aXRoIDoqIGVnLiAnbWVtYmVyczoqJ1xuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5hYmxlRXZlbnRzUXVldWU9dHJ1ZSBtZWNoYW5pc20gdG8gZ3VhcmFudGVlIG9yZGVyIG9mIGV2ZW50cyByZWNlaXZlZCBkdXJpbmcgYSBzZXNzaW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5lbmFibGVJbmJvdW5kT2ZmZXI9ZmFsc2UgY29uZmlndXJlIHJlY2VpdmluZyBvZmZlciBmb3IgZmFzdGVyIGluYm91bmQgY2FsbCBzZXR1cFxuICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuYWNrbm93bGVkZ2VFdmVudHM9dHJ1ZSBzZW5kIGFja25vd2xlZGdtZW50IG92ZXIgd2Vic29ja2V0IHRvIHNlcnZlciBmb3IgcmVjZWl2ZWQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnRva2VuIHRoZSBqd3QgdG9rZW4gZm9yIG5ldHdvcmsgcmVxdWVzdHNcbiAqXG4gKiBAZW1pdHMgTmV4bW9DbGllbnQjZGlzY29ubmVjdFxuICogQGVtaXRzIE5leG1vQ2xpZW50I2Vycm9yXG4gKiBAZW1pdHMgTmV4bW9DbGllbnQjcmVhZHlcbiAqIEBlbWl0cyBOZXhtb0NsaWVudCNyZWNvbm5lY3RcbiAqIEBlbWl0cyBOZXhtb0NsaWVudCNyZWNvbm5lY3RpbmdcbiovXG5jbGFzcyBOZXhtb0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgLy8gc2F2ZSBhbiBhcnJheSBvZiBpbnN0YW5jZXNcbiAgICAgICAgY29uc3QgaW5wdXRQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgZGVidWc6ICdzaWxlbnQnLFxuICAgICAgICAgICAgbG9nX3JlcG9ydGVyOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYnVnc25hZ19rZXk6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgICAgaXBzX3VybDogJ2h0dHBzOi8vYXBpLXVzLnZvbmFnZS5jb20vdjEvaW1hZ2UnLFxuICAgICAgICAgICAgbmV4bW9fYXBpX3VybDogJ2h0dHBzOi8vYXBpLXVzLnZvbmFnZS5jb20nLFxuICAgICAgICAgICAgcGF0aDogJy92Mi9ydGMnLFxuICAgICAgICAgICAgcmVwb3NpdG9yeTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9OZXhtby9jb252ZXJzYXRpb24tanMtc2RrJyxcbiAgICAgICAgICAgIFNES192ZXJzaW9uOiAnOS4zLjAnLFxuICAgICAgICAgICAgc29ja2V0X2lvOiB7XG4gICAgICAgICAgICAgICAgcmVjb25uZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiA1LFxuICAgICAgICAgICAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiAyMDAwLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6YXRpb25GYWN0b3I6IDAuNzUsXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDE1MDAwLFxuICAgICAgICAgICAgICAgIGZvcmNlTmV3OiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1dG9Db25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3luYzogJ25vbmUnLFxuICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93cy11cy52b25hZ2UuY29tJyxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgcnRjc3RhdHM6IHtcbiAgICAgICAgICAgICAgICByZW1vdGVfY29sbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZW1vdGVfY29sbGVjdGlvbl91cmw6ICdodHRwczovL2hsZy50b2tib3guY29tL3Byb2QvbG9nZ2luZy9uZXhtb19jbGllbnRfanNfc3RhdHMnLFxuICAgICAgICAgICAgICAgIHJlbW90ZV9jb2xsZWN0aW9uX2ludGVydmFsOiA1MDAwLFxuICAgICAgICAgICAgICAgIGVtaXRfZXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbWl0X3J0Y19hbmFseXRpY3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVtaXRfaW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVyc2F0aW9uc19wYWdlX2NvbmZpZzoge1xuICAgICAgICAgICAgICAgIHBhZ2Vfc2l6ZTogMTAsXG4gICAgICAgICAgICAgICAgb3JkZXI6ICdhc2MnLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudHNfcGFnZV9jb25maWc6IHtcbiAgICAgICAgICAgICAgICBwYWdlX3NpemU6IDEwLFxuICAgICAgICAgICAgICAgIG9yZGVyOiAnYXNjJyxcbiAgICAgICAgICAgICAgICBldmVudF90eXBlOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZUV2ZW50c1F1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgZW5hYmxlSW5ib3VuZE9mZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGFja25vd2xlZGdlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgdG9rZW46IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcuc29ja2V0X2lvLnF1ZXJ5ID0ge1xuICAgICAgICAgICAgdG9rZW46ICcnLFxuICAgICAgICAgICAgU0RLX3ZlcnNpb246IHRoaXMuY29uZmlnLlNES192ZXJzaW9uLFxuICAgICAgICAgICAgc2Vzc2lvbl92ZXJzaW9uOiBwYXJhbXMuZW5hYmxlSW5ib3VuZE9mZmVyID8gJzAuMC4yJyA6ICcwLjAuMScsXG4gICAgICAgICAgICBhY2tub3dsZWRnZV9ldmVudHM6IHRoaXMuY29uZmlnLmFja25vd2xlZGdlRXZlbnRzLFxuICAgICAgICAgICAgT1NfZmFtaWx5OiAnanMnLFxuICAgICAgICAgICAgT1NfcmV2aXNpb246ICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogJ0dlbmVyaWMgSlMgbmF2aWdhdG9yJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlc3Npb25SZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLnNlc3Npb25faWQgPSBudWxsO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IG51bGw7XG4gICAgICAgIC8qXG4gICAgICAgICAgRGVmaW5pdGlvbnMgb2YgbG9nIGxldmVsc1xuICAgICAgICAgIGVycm9yOiBtYWpvciBlcnJvciBtZXNzYWdlcywgc29tZSBsb3N0IGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICB3YXJuOiBlcnJvciBtZXNzYWdlcyB3aGljaCBkbyBub3QgY2F1c2UgYSBmdW5jdGlvbmFsIGZhaWx1cmVcbiAgICAgICAgICBpbmZvOiBpbmZvcm1hdGlvbmFsIG1lc3NhZ2VzLCBzaG93aW5nIGNvbXBsZXRpb24sIHByb2dyZXNzLCBldGMuXG4gICAgICAgICAgZGVidWc6IG1lc3NhZ2VzIHRvIGhlbHAgaW4gZGlhZ25vc2luZyBhIHByb2JsZW1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10uaW5jbHVkZXMoaW5wdXRQYXJhbXMuZGVidWcpKSB7XG4gICAgICAgICAgICBsb2dsZXZlbF8xLmRlZmF1bHQuc2V0TGV2ZWwoaW5wdXRQYXJhbXMuZGVidWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0UGFyYW1zLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2dsZXZlbF8xLmRlZmF1bHQuc2V0TGV2ZWwoJ2RlYnVnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dsZXZlbF8xLmRlZmF1bHQuc2V0TGV2ZWwoJ3NpbGVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nID0gbG9nbGV2ZWxfMS5kZWZhdWx0Lm5vQ29uZmxpY3QoKTtcbiAgICAgICAgLy8gc2V0IG91ciBjb25maWcgZnJvbSB0aGUgaW5wdXRQYXJhbXNcbiAgICAgICAgdGhpcy5jb25maWcgPSB1dGlsc18xLmRlZmF1bHQuZGVlcE1lcmdlT2JqKHRoaXMuY29uZmlnLCB0aGlzLl9zYW5pdGl6ZUNvbmZpZyhpbnB1dFBhcmFtcykpO1xuICAgICAgICAvLyBpbmplY3QgYnVnIHJlcG9ydGluZyB0b29sXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2dfcmVwb3J0ZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgYnVnc25hZ0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBhcGlLZXk6IHRoaXMuY29uZmlnLmxvZ19yZXBvcnRlci5idWdzbmFnX2tleSB8fCB1dGlsc18xLmRlZmF1bHQuX2dldEJ1Z3NuYWdLZXkoKSxcbiAgICAgICAgICAgICAgICBhcHBWZXJzaW9uOiB0aGlzLmNvbmZpZy5zb2NrZXRfaW8ucXVlcnkuU0RLX3ZlcnNpb24sXG4gICAgICAgICAgICAgICAgcmVsZWFzZVN0YWdlOiB0aGlzLmNvbmZpZy5lbnZpcm9ubWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5OWE1idWdzbmFnQ2xpZW50ID0ganNfMS5kZWZhdWx0KGJ1Z3NuYWdDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIFdpbGRFbWl0dGVyLm1peGluKE5leG1vQ2xpZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgc2V0cyB0aGUgc29ja2V0X2lvIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfY3JlYXRlQW5kU2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgbGV0IGNvbm5lY3Rpb247XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc29ja2V0LmlvIGNvbm5lY3Rpb24gYW5kIGFsbG93IG11bHRpcGxlIGluc3RhbmNlc1xuICAgICAgICBsZXQgc29ja2V0X2lvX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBwYXRoOiB0aGlzLmNvbmZpZy5wYXRoIH0sIHRoaXMuY29uZmlnLnNvY2tldF9pbyk7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBzb2NrZXRfaW9fY2xpZW50XzEuZGVmYXVsdC5jb25uZWN0KHRoaXMuY29uZmlnLnVybCwgc29ja2V0X2lvX2NvbmZpZyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIC8vIExpc3RlbiB0byBzb2NrZXQuaW8gZXZlbnRzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGllbnQgbGlzdGVuaW5nIGZvciByZWFkeSBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IE5leG1vQ2xpZW50I3JlYWR5XG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkxpc3RlbiBmb3Igd2Vic29ja2V0IHJlYWR5IGV2ZW50IDwvY2FwdGlvbj5cbiAgICAgICAgICogICAgIHJ0Yy5vbihcInJlYWR5XCIsICgpID0+IHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3Rpb24gcmVhZHlcIik7XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgKi9cbiAgICAgICAgY29ubmVjdGlvbi5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dlYnNvY2tldCByZWFkeScpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsaWVudCBsaXN0ZW5pbmcgZm9yIGRpc2Nvbm5lY3QgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBOZXhtb0NsaWVudCNkaXNjb25uZWN0XG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkxpc3RlbiBmb3Igd2Vic29ja2V0IGRpc2Nvbm5lY3QgZXZlbnQgPC9jYXB0aW9uPlxuICAgICAgICAgKiAgICAgcnRjLm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJkaXNjb25uZWN0XCIsIHJlYXNvbik7XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgKi9cbiAgICAgICAgY29ubmVjdGlvbi5vbignZGlzY29ubmVjdCcsIChyZWFzb24sIGRldGFpbHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIChyZWFzb24gPT09IFwiaW8gY2xpZW50IGRpc2Nvbm5lY3RcIilcbiAgICAgICAgICAgICAgICA/IE5leG1vQ2xpZW50LkRJU0NPTk5FQ1RfUkVBU09OLkNsaWVudERpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIDogKHJlYXNvbiA9PT0gXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiICYmIHRoaXMuc2Vzc2lvbl9pZCkgPyBOZXhtb0NsaWVudC5ESVNDT05ORUNUX1JFQVNPTi5Ub2tlbkV4cGlyZWRcbiAgICAgICAgICAgICAgICAgICAgOiBOZXhtb0NsaWVudC5ESVNDT05ORUNUX1JFQVNPTi5Db25uZWN0aW9uRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dlYnNvY2tldCBkaXNjb25uZWN0ZWQnLCByZWFzb24sIGRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsaWVudCBsaXN0ZW5pbmcgZm9yIHJlY29ubmVjdCBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IE5leG1vQ2xpZW50I3JlY29ubmVjdFxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5MaXN0ZW4gZm9yIHdlYnNvY2tldCByZWNvbm5lY3QgZXZlbnQgPC9jYXB0aW9uPlxuICAgICAgICAgKiAgICAgcnRjLm9uKFwicmVjb25uZWN0XCIsIChyZXRyeV9udW1iZXIpID0+IHtcbiAgICAgICAgICogICAgICBjb25zb2xlLmxvZyhcInJlY29ubmVjdFwiLCByZXRyeV9udW1iZXIpO1xuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICovXG4gICAgICAgIGNvbm5lY3Rpb24uaW8ub24oJ3JlY29ubmVjdCcsIChyZXRyeV9udW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVjb25uZWN0JywgcmV0cnlfbnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dlYnNvY2tldCByZWNvbm5lY3QnLCByZXRyeV9udW1iZXIpO1xuICAgICAgICAgICAgdXRpbHNfMS5kZWZhdWx0Lm5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IGAke3RoaXMuY29uZmlnLnVybC5yZXBsYWNlKCd3c3M6Ly8nLCAnaHR0cHM6Ly8nKX0vdjIvcnRjL21ldHJpY3NgLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy5jb25maWcudG9rZW4sXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbl9pZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0cmljczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUSU1FX1RPX1JFQ09OTkVDVF9TVUNDRVNTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aGlzLmRpc2Nvbm5lY3RUaW1lc3RhbXAgPyBEYXRlLm5vdygpIC0gdGhpcy5kaXNjb25uZWN0VGltZXN0YW1wIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHJldHJ5X251bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ0ZhaWxlZCB0byBwdWJsaXNoIHNvY2tldCByZWNvbm5lY3Rpb24gbWV0cmljcycsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGllbnQgbGlzdGVuaW5nIGZvciByZWNvbm5lY3RpbmcgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBOZXhtb0NsaWVudCNyZWNvbm5lY3RpbmdcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+TGlzdGVuIGZvciB3ZWJzb2NrZXQgcmVjb25uZWN0aW5nIGV2ZW50IDwvY2FwdGlvbj5cbiAgICAgICAgICogICAgIHJ0Yy5vbihcInJlY29ubmVjdGluZ1wiLCAocmV0cnlfbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJyZWNvbm5lY3RpbmdcIiwgcmV0cnlfbnVtYmVyKTtcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAqL1xuICAgICAgICBjb25uZWN0aW9uLmlvLm9uKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIChyZXRyeV9udW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVjb25uZWN0aW5nJywgcmV0cnlfbnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dlYnNvY2tldCByZWNvbm5lY3RpbmcnLCByZXRyeV9udW1iZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsaWVudCBsaXN0ZW5pbmcgZm9yIGVycm9yIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgTmV4bW9DbGllbnQjZXJyb3JcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+TGlzdGVuIGZvciB3ZWJzb2NrZXQgZXJyb3IgZXZlbnQgPC9jYXB0aW9uPlxuICAgICAgICAgKiAgICAgcnRjLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAqICAgICAgY29uc29sZS5sb2coXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgKi9cbiAgICAgICAgY29ubmVjdGlvbi5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBuZXhtb0NsaWVudEVycm9yXzEuTmV4bW9DbGllbnRFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ1NvY2tldC5pbyByZXBvcnRlZCBhIGdlbmVyaWMgZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25uZWN0aW9uLmlvLm9uKFwicmVjb25uZWN0X2ZhaWxlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IG5leG1vQ2xpZW50RXJyb3JfMS5OZXhtb0NsaWVudEVycm9yKFwiZXJyb3I6Y2xpZW50OnJlY29ubmVjdGlvbl9mYWlsZWRcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3dlYnNvY2tldCByZWNvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24uaW8ub24oJ3BhY2tldCcsIChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYWNrZXQudHlwZSAhPT0gMilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocGFja2V0LmRhdGFbMF0gPT09ICdlY2hvJylcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBlY2hvIGV2ZW50c1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tBY2sgPSBwYWNrZXQuZGF0YVsyXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja0FjayAmJiB0eXBlb2YgKGNhbGxiYWNrQWNrKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tBY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcGFja2V0LmRhdGFbMV07XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHR5cGUgb2YgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXNwb25zZS50eXBlID0gcGFja2V0LmRhdGFbMF07XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnPC0tJywgcmVzcG9uc2UudHlwZSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdHNbJ3Nlc3Npb246bG9naW4nXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5yZXF1ZXN0c1snc2Vzc2lvbjpsb2dpbiddLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RzWydzZXNzaW9uOmxvZ2luJ107XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UucmlkIGluIHRoaXMucmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMucmVxdWVzdHNbcmVzcG9uc2UucmlkXS5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c1tyZXNwb25zZS5yaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNwb25zZS5kZWxheTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvcnNFbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzRW1pdHRlci5lbWl0UmVzcG9uc2VJZkVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiB1bnNvbGljaXRlZCBldmVudCB3ZSBlbWl0IGl0IGluIGFwcGxpY2F0aW9uIGxldmVsXG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkaW5nIHNlc3Npb246KiBldmVudHMgZnJvbSBiZWluZyBwcm9jZXNzZWQgYW5kIGNoZWNrIGlmIGV2ZW50IHR5cGUgaXMgYSBzeXN0ZW06ZXJyb3I6KiBvbmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvcnNFbWl0dGVyICYmIHJlc3BvbnNlLnR5cGUuc3RhcnRzV2l0aCgnc3lzdGVtOmVycm9yOicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzRW1pdHRlci5lbWl0UmVzcG9uc2VJZkVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UudHlwZS5zdGFydHNXaXRoKCdzZXNzaW9uOicpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBFdmVudHMgZW1pdHRlZCBmcm9tIFJlY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlc3Npb24ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFwcGxpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24uX2VucXVldWVFdmVudChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldmVydCBhbnkgaW52YWxpZCBwYXJhbXMgdG8gb3VyIGRlZmF1bHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgdGhlIG9iamVjdCB0byBzYW5pdGl6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICBfc2FuaXRpemVDb25maWcoaW5jb21pbmdDb25maWcpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGFsbG93IHNwZWNpZmljIHZhbHVlcyBmb3IgdGhlIHBhcmFtc1xuICAgICAgICAvLyBTeW5jXG4gICAgICAgIGxldCBzYW5pdGl6ZWRDb25maWcgPSBpbmNvbWluZ0NvbmZpZztcbiAgICAgICAgaWYgKGluY29taW5nQ29uZmlnLnN5bmMgJiYgWydub25lJywgJ2xpdGUnLCAnZnVsbCddLmluZGV4T2YoaW5jb21pbmdDb25maWcuc3luYykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKGBpbnZhbGlkIHBhcmFtICcke2luY29taW5nQ29uZmlnLnN5bmN9JyBmb3Igc3luYywgcmV2ZXJ0aW5nIHRvICR7dGhpcy5jb25maWcuc3luY31gKTtcbiAgICAgICAgICAgIHNhbml0aXplZENvbmZpZy5zeW5jID0gdGhpcy5jb25maWcuc3luYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FuaXRpemVkQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJzYXRpb24gbGlzdGVuaW5nIGZvciB0ZXh0IGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jdGV4dFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIHRleHRcbiAgICAgKiBAcHJvcGVydHkge1RleHRFdmVudH0gdGV4dCAtIFRoZSB0ZXh0IG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIHRleHQgZXZlbnRzPC9jYXB0aW9uPlxuICAgICAqICBjb252ZXJzYXRpb24ub24oXCJ0ZXh0XCIsKHNlbmRlciwgbWVzc2FnZSkgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKHNlbmRlciwgbWVzc2FnZSk7XG4gICAgICogICAgLy8gSWRlbnRpZnkgeW91ciBvd24gbWVzc2FnZS5cbiAgICAgKiAgICBpZiAobWVzc2FnZS5mcm9tID09PSBjb252ZXJzYXRpb24ubWUuaWQpe1xuICAgICAqICAgICAgICByZW5kZXJNeU1lc3NhZ2VzKG1lc3NhZ2UpXG4gICAgICogICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICAgcmVuZGVyT3RoZXJNZXNzYWdlcyhtZXNzYWdlKVxuICAgICAqICAgIH1cbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDb252ZXJzYXRpb24gbGlzdGVuaW5nIGZvciBpbWFnZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI2ltYWdlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gc2VuZGVyIC0gVGhlIHNlbmRlciBvZiB0aGUgaW1hZ2VcbiAgICAgKiBAcHJvcGVydHkge0ltYWdlRXZlbnR9IGltYWdlIC0gVGhlIGltYWdlIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIGltYWdlIGV2ZW50czwvY2FwdGlvbj5cbiAgICAgKiAgY29udmVyc2F0aW9uLm9uKFwiaW1hZ2VcIiwgKHNlbmRlciwgaW1hZ2UpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhzZW5kZXIsaW1hZ2UpO1xuICAgICAqICAgIC8vIElkZW50aWZ5IGlmIHlvdXIgb3duIGltYWdlRXZlbnQgb3Igc29tZW9uZSBlbHNlJ3MuXG4gICAgICogICAgaWYgKGltYWdlLmZyb20gIT09IGNvbnZlcnNhdGlvbi5tZS5pZCl7XG4gICAgICogICAgICAgIGRpc3BsYXlJbWFnZXMoaW1hZ2UpO1xuICAgICAqICAgIH1cbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgZGVsZXRlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI2V2ZW50OmRlbGV0ZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBNZW1iZXIgd2hvIGRlbGV0ZWQgYW4gZXZlbnRcbiAgICAgKiBAcHJvcGVydHkge05YTUV2ZW50fSBldmVudCAtIGRlbGV0ZWQgZXZlbnQ6IGV2ZW50LmlkXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Z2V0IGRldGFpbHMgYWJvdXQgdGhlIGRlbGV0ZWQgZXZlbnQ8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwiZXZlbnQ6ZGVsZXRlXCIsIChtZW1iZXIsIGV2ZW50KSA9PiB7XG4gICAgICogIGNvbnNvbGUubG9nKGV2ZW50LmlkKTtcbiAgICAgKiAgY29uc29sZS5sb2coZXZlbnQuYm9keS50aW1lc3RhbXAuZGVsZXRlZCk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgbmV3IE1lbWJlcnMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI21lbWJlcjpqb2luZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TWVtYmVyfSBtZW1iZXIgLSB0aGUgTWVtYmVyIHRoYXQgam9pbmVkXG4gICAgICogQHByb3BlcnR5IHtOWE1FdmVudH0gZXZlbnQgLSB0aGUgam9pbiBldmVudFxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmdldCB0aGUgbmFtZSBvZiB0aGUgbmV3IE1lbWJlcjwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ub24oXCJtZW1iZXI6am9pbmVkXCIsIChtZW1iZXIsIGV2ZW50KSA9PiB7XG4gICAgICogIGNvbnNvbGUubG9nKGV2ZW50LmlkKVxuICAgICAqICBjb25zb2xlLmxvZyhtZW1iZXIudXNlck5hbWUrIFwiIGpvaW5lZCB0aGUgY29udmVyc2F0aW9uXCIpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnNhdGlvbiBsaXN0ZW5pbmcgZm9yIE1lbWJlcnMgYmVpbmcgaW52aXRlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jbWVtYmVyOmludml0ZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TWVtYmVyfSBtZW1iZXIgLSB0aGUgTWVtYmVyIHRoYXQgaXMgaW52aXRlZFxuICAgICAqIEBwcm9wZXJ0eSB7TlhNRXZlbnR9IGV2ZW50IC0gZGF0YSByZWdhcmRpbmcgdGhlIHJlY2VpdmVyIG9mIHRoZSBpbnZpdGF0aW9uXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Z2V0IHRoZSBuYW1lIG9mIHRoZSBpbnZpdGVkIE1lbWJlcjwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ub24oXCJtZW1iZXI6aW52aXRlZFwiLCAobWVtYmVyLCBldmVudCkgPT4ge1xuICAgICAqICBjb25zb2xlLmxvZyhtZW1iZXIudXNlck5hbWUgKyBcIiBpbnZpdGVkIHRvIHRoZSBjb252ZXJzYXRpb25cIik7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBjYWxsU3RhdHVzIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI21lbWJlcjpjYWxsOnN0YXR1c1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBNZW1iZXIgdGhhdCBoYXMgbGVmdFxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmdldCB0aGUgY2FsbFN0YXR1cyBvZiB0aGUgbWVtYmVyIHRoYXQgY2hhbmdlZCBjYWxsIHN0YXR1czwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ub24oXCJtZW1iZXI6Y2FsbDpzdGF0dXNcIiwgKG1lbWJlcikgPT4ge1xuICAgICAqICBjb25zb2xlLmxvZyhtZW1iZXIuY2FsbFN0YXR1cyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBsZWF2aW5nIChraWNrZWQgb3IgbGVmdCkuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI21lbWJlcjpsZWZ0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIE1lbWJlciB0aGF0IGhhcyBsZWZ0XG4gICAgICogQHByb3BlcnR5IHtOWE1FdmVudH0gZXZlbnQgLSBkYXRhIHJlZ2FyZGluZyB0aGUgcmVjZWl2ZXIgb2YgdGhlIGludml0YXRpb25cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5nZXQgdGhlIHVzZXJuYW1lIG9mIHRoZSBNZW1iZXIgdGhhdCBsZWZ0PC9jYXB0aW9uPlxuICAgICAqIGNvbnZlcnNhdGlvbi5vbihcIm1lbWJlcjpsZWZ0XCIsIChtZW1iZXIgLCBldmVudCkgPT4ge1xuICAgICAqICBjb25zb2xlLmxvZyhtZW1iZXIudXNlck5hbWUgKyBcIiBsZWZ0XCIpO1xuICAgICAqICBjb25zb2xlLmxvZyhldmVudC5ib2R5LnJlYXNvbik7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyB0eXBpbmcuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI3RleHQ6dHlwaW5nOm9uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIG1lbWJlciB0aGF0IHN0YXJ0ZWQgdHlwaW5nXG4gICAgICogQHByb3BlcnR5IHtOWE1FdmVudH0gZXZlbnQgLSB0aGUgc3RhcnQgdHlwaW5nIGV2ZW50XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Z2V0IHRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIE1lbWJlciB0aGF0IGlzIHR5cGluZzwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ub24oXCJ0ZXh0OnR5cGluZzpvblwiLCAobWVtYmVyLCBldmVudCkgPT4ge1xuICAgICAqICBjb25zb2xlLmxvZyhtZW1iZXIuZGlzcGxheU5hbWUgKyBcIiBpcyB0eXBpbmcuLi5cIik7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBzdG9wcGVkIHR5cGluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jdGV4dDp0eXBpbmc6b2ZmXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIG1lbWJlciB0aGF0IHN0b3BwZWQgdHlwaW5nXG4gICAgICogQHByb3BlcnR5IHtOWE1FdmVudH0gZXZlbnQgLSB0aGUgc3RvcCB0eXBpbmcgZXZlbnRcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5nZXQgdGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgTWVtYmVyIHRoYXQgc3RvcHBlZCB0eXBpbmc8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwidGV4dDp0eXBpbmc6b2ZmXCIsIChtZW1iZXIsIGV2ZW50KSA9PiB7XG4gICAgICogIGNvbnNvbGUubG9nKG1lbWJlci5kaXNwbGF5TmFtZSArIFwiIHN0b3BwZWQgdHlwaW5nLi4uXCIpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnNhdGlvbiBsaXN0ZW5pbmcgZm9yIE1lbWJlcnMnIHNlZW4gdGV4dHMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI3RleHQ6c2VlblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBNZW1iZXIgdGhhdCBzYXcgdGhlIHRleHRcbiAgICAgKiBAcHJvcGVydHkge1RleHRFdmVudH0gdGV4dCAtIHRoZSB0ZXh0IHRoYXQgd2FzIHNlZW5cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIHNlZW4gdGV4dCBldmVudHM8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwidGV4dDpzZWVuXCIsIChtZW1iZXIsIHRleHQpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb252ZXJzYXRpb24gbGlzdGVuaW5nIGZvciBNZW1iZXJzJyBzZWVuIGltYWdlcy5cbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI2ltYWdlOnNlZW5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TWVtYmVyfSBtZW1iZXIgLSB0aGUgbWVtYmVyIHRoYXQgc2F3IHRoZSBpbWFnZVxuICAgICAqIEBwcm9wZXJ0eSB7SW1hZ2VFdmVudH0gaW1hZ2UgLSB0aGUgaW1hZ2UgdGhhdCB3YXMgc2VlblxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmxpc3RlbiBmb3Igc2VlbiBpbWFnZSBldmVudHM8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwiaW1hZ2U6c2VlblwiLCAobWVtYmVyLCBpbWFnZSkgPT4ge1xuICAgICAqICBjb25zb2xlLmxvZyhpbWFnZSk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH07XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBzdWJtaXR0ZWQgbWVzc2FnZXMuXG4gICAgICogQGV2ZW50IENvbnZlcnNhdGlvbiNtZXNzYWdlOnN1Ym1pdHRlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBtZW1iZXIgdGhhdCBtZXNzYWdlIHdhcyBzdWJtaXR0ZWQgdG9cbiAgICAgKiBAcHJvcGVydHkge01lc3NhZ2VFdmVudH0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRoYXQgd2FzIHN1Ym1pdHRlZFxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmxpc3RlbiBmb3Igc3VibWl0dGVkIG1lc3NhZ2UgZXZlbnRzPC9jYXB0aW9uPlxuICAgICAqIGNvbnZlcnNhdGlvbi5vbihcIm1lc3NhZ2U6c3VibWl0dGVkXCIsIChtZW1iZXIsIG1lc3NhZ2UpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH07XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyByZWplY3RlZCBtZXNzYWdlcy5cbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI21lc3NhZ2U6cmVqZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TWVtYmVyfSBtZW1iZXIgLSB0aGUgbWVtYmVyIHRoYXQgbWVzc2FnZSB3YXMgcmVqZWN0ZWQgYnlcbiAgICAgKiBAcHJvcGVydHkge01lc3NhZ2VFdmVudH0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRoYXQgd2FzIHJlamVjdGVkXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciByZWplY3RlZCBtZXNzYWdlIGV2ZW50czwvY2FwdGlvbj5cbiAgICAgKiBjb252ZXJzYXRpb24ub24oXCJtZXNzYWdlOnJlamVjdGVkXCIsIChtZW1iZXIsIG1lc3NhZ2UpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH07XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyB1bmRlbGl2ZXJhYmxlIG1lc3NhZ2VzLlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jbWVzc2FnZTp1bmRlbGl2ZXJhYmxlXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIG1lbWJlciB0aGF0IG1lc3NhZ2Ugd2FzIHVuZGVsaXZlcmFibGUgdG9cbiAgICAgKiBAcHJvcGVydHkge01lc3NhZ2VFdmVudH0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRoYXQgd2FzIHVuZGVsaXZlcmFibGVcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIHVuZGVsaXZlcmFibGUgbWVzc2FnZSBldmVudHM8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwibWVzc2FnZTp1bmRlbGl2ZXJhYmxlXCIsIChtZW1iZXIsIG1lc3NhZ2UpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH07XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBkZWxpdmVyZWQgbWVzc2FnZXMuXG4gICAgICogQGV2ZW50IENvbnZlcnNhdGlvbiNtZXNzYWdlOmRlbGl2ZXJlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBtZW1iZXIgdGhhdCBtZXNzYWdlIHdhcyBkZWxpdmVyZWQgdG9cbiAgICAgKiBAcHJvcGVydHkge01lc3NhZ2VFdmVudH0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRoYXQgd2FzIGRlbGl2ZXJlZFxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmxpc3RlbiBmb3IgZGVsaXZlcmVkIG1lc3NhZ2UgZXZlbnRzPC9jYXB0aW9uPlxuICAgICAqIGNvbnZlcnNhdGlvbi5vbihcIm1lc3NhZ2U6ZGVsaXZlcmVkXCIsIChtZW1iZXIsIG1lc3NhZ2UpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH07XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBzZWVuIG1lc3NhZ2VzLlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jbWVzc2FnZTpzZWVuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIG1lbWJlciB0aGF0IG1lc3NhZ2Ugd2FzIHNlZW4gYnlcbiAgICAgKiBAcHJvcGVydHkge01lc3NhZ2VFdmVudH0gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRoYXQgd2FzIHNlZW5cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5saXN0ZW4gZm9yIHNlZW4gbWVzc2FnZSBldmVudHM8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwibWVzc2FnZTpzZWVuXCIsIChtZW1iZXIsIG1lc3NhZ2UpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICogIGlmIChjb252ZXJzYXRpb24ubWUuaWQgIT09IG1lbWJlci5tZW1iZXJJZCkge1xuICAgICAqICAgIGNvbnNvbGUubG9nKG1lbWJlcik7XG4gICAgICogIH07XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgTWVtYmVycyBtZWRpYSBjaGFuZ2VzIChhdWRpbyx0ZXh0KVxuICAgICAqXG4gICAgICogQ2hhbmdlIGluIG1lZGlhIHByZXNlbmNlIHN0YXRlLiBUaGV5IGFyZSBpbiB0aGUgQ29udmVyc2F0aW9uIHdpdGggdGV4dCBvciBhdWRpby5cbiAgICAgKlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jbWVtYmVyOm1lZGlhXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIE1lbWJlciBvYmplY3QgbGlua2VkIHRvIHRoaXMgZXZlbnRcbiAgICAgKiBAcHJvcGVydHkge05YTUV2ZW50fSBldmVudCAtIGluZm9ybWF0aW9uIGFib3V0IG1lZGlhIHByZXNlbmNlIHN0YXRlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBldmVudC5ib2R5LmF1ZGlvICAtIGlzIGF1ZGlvIGVuYWJsZWRcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5nZXQgZXZlcnkgTWVtYmVyJ3MgbWVkaWEgY2hhbmdlIGV2ZW50cyA8L2NhcHRpb24+XG4gICAgICogY29udmVyc2F0aW9uLm9uKFwibWVtYmVyOm1lZGlhXCIsIChtZW1iZXIsIGV2ZW50KSA9PiB7XG4gICAgICogIGNvbnNvbGUubG9nKGV2ZW50LmJvZHkubWVkaWEpOyAvL3tcImF1ZGlvXCI6IHRydWUsIFwiYXVkaW9fc2V0dGluZ3NcIjoge1wiZW5hYmxlZFwiOiB0cnVlLCBcIm11dGVkXCI6IGZhbHNlLCBcImVhcm11ZmZlZFwiOiBmYWxzZX19XG4gICAgICogfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVyc2F0aW9uIGxpc3RlbmluZyBmb3IgbXV0ZSBvbiBldmVudHNcbiAgICAgKiBBIE1lbWJlciBoYXMgbXV0ZWQgdGhlaXIgYXVkaW9cbiAgICAgKlxuICAgICAqIEBldmVudCBDb252ZXJzYXRpb24jYXVkaW86bXV0ZTpvblxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtNZW1iZXJ9IG1lbWJlciAtIHRoZSBNZW1iZXIgb2JqZWN0IGxpbmtlZCB0byB0aGlzIGV2ZW50XG4gICAgICogQHByb3BlcnR5IHtOWE1FdmVudH0gZXZlbnQgLSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbXV0ZSBldmVudFxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmxpc3RlbiBmb3IgYXVkaW8gbXV0ZSBvbiBldmVudHMgPC9jYXB0aW9uPlxuICAgICAqIGNvbnZlcnNhdGlvbi5vbihcImF1ZGlvOm11dGU6b25cIiwgKG1lbWJlciwgZXZlbnQpID0+IHtcbiAgICAgKiAgY29uc29sZS5sb2coXCJtZW1iZXIgdGhhdCBpcyBtdXRlZCBcIiwgbWVtYmVyKTtcbiAgICAgKiAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnNhdGlvbiBsaXN0ZW5pbmcgZm9yIG11dGUgb2ZmIGV2ZW50c1xuICAgICAqIEEgbWVtYmVyIGhhcyB1bm11dGVkIHRoZWlyIGF1ZGlvXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uI2F1ZGlvOm11dGU6b2ZmXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge01lbWJlcn0gbWVtYmVyIC0gdGhlIG1lbWJlciBvYmplY3QgbGlua2VkIHRvIHRoaXMgZXZlbnRcbiAgICAgKiBAcHJvcGVydHkge05YTUV2ZW50fSBldmVudCAtIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtdXRlIGV2ZW50XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+bGlzdGVuIGZvciBhdWRpbyBtdXRlIG9mZiBldmVudHMgPC9jYXB0aW9uPlxuICAgICAqIGNvbnZlcnNhdGlvbi5vbihcImF1ZGlvOm11dGU6b2ZmXCIsIChtZW1iZXIsIGV2ZW50KSA9PiB7XG4gICAgICogIGNvbnNvbGUubG9nKFwibWVtYmVyIHRoYXQgaXMgdW5tdXRlZCBcIiwgbWVtYmVyKTtcbiAgICAgKiAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEFkZCBhIG1lc3NhZ2UgSUQgdG8gdGhlIHJlcXVlc3QgYW5kIHNldCB1cCBhIGxpc3RlbmVyIGZvciB0aGUgcmVwbHkgKG9yIGVycm9yKVxuICAgICAgICByZXF1ZXN0LnRpZCA9IHV0aWxzXzEuZGVmYXVsdC5hbGxvY2F0ZVVVSUQoKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHJlcXVlc3QudHlwZTtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QudHlwZTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJy0tPicsIHR5cGUsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCctLT4nLCB0eXBlLCByZXF1ZXN0LnRpZCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5lbWl0KHR5cGUsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLnJlcXVlc3RzW3JlcXVlc3QudGlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE5ldHdvcmtSZXF1ZXN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGFyYW1zLnZlcnNpb24gfHwgJ2JldGEnO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmNvbmZpZy5uZXhtb19hcGlfdXJsfS8ke3ZlcnNpb259LyR7cGFyYW1zLnBhdGh9YDtcbiAgICAgICAgaWYgKCEocGFyYW1zLnR5cGUgPT09ICdHRVQnIHx8IHBhcmFtcy50eXBlID09PSAnREVMRVRFJykpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5kYXRhLm9yaWdpbmF0aW5nX3Nlc3Npb24gPSB0aGlzLnNlc3Npb25faWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYXRpbmdfc2Vzc2lvbjogdGhpcy5zZXNzaW9uX2lkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXMudHlwZSxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogKHBhcmFtcy5kYXRhKSA/IHBhcmFtcy5kYXRhIDogbnVsbCxcbiAgICAgICAgICAgICAgICB0b2tlbjogKHBhcmFtcy5kYXRhIHx8IHt9KS50b2tlbiA/IHBhcmFtcy5kYXRhLnRva2VuIDogdGhpcy5jb25maWcudG9rZW4gfHwgbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kTmV0d29ya1JlcXVlc3Q6ICcsIHsgcmVxdWVzdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IGF3YWl0IHV0aWxzXzEuZGVmYXVsdC5uZXR3b3JrUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoeyByZXNwb25zZSB9KSB7XG4gICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgU2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSB0aGUgdXNlciBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIEByZXR1cm5zICB7UHJvbWlzZTxBcHBsaWNhdGlvbj59IC0gdGhlIGFwcGxpY2F0aW9uIGxvZ2dlZCBpbiB0b1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhIHNlc3Npb24gYW5kIHJldHVybiB0aGUgQXBwbGljYXRpb248L2NhcHRpb24+XG4gICAgICogIHJ0Yy5jcmVhdGVTZXNzaW9uKHRva2VuKS50aGVuKChhcHBsaWNhdGlvbikgPT4ge1xuICAgICAqICAgIGNvbnNvbGUubG9nKGFwcGxpY2F0aW9uKTtcbiAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAqICB9KTtcbiAgICAqL1xuICAgIGNyZWF0ZVNlc3Npb24odG9rZW4pIHtcbiAgICAgICAgdGhpcy5jb25maWcuc29ja2V0X2lvLnF1ZXJ5LnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuX2NyZWF0ZUFuZFNldENvbm5lY3Rpb24oKTtcbiAgICAgICAgLy8gcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKGBDbGllbnQtU0RLIFZlcnNpb246ICR7dGhpcy5jb25maWcuU0RLX3ZlcnNpb259YCk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy50b2tlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzWydzZXNzaW9uOmxvZ2luJ10gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Nlc3Npb246bG9naW4nLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdzZXNzaW9uOnN1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25faWQgPSByZXNwb25zZS5ib2R5LmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSByZXNwb25zZS5ib2R5LmFwaV9rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0b2tlbiBpbiBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIHRoZSBzZXNzaW9uIGlkIGFzIGEgcXVlcnkgcGFyYW1ldGVyIGluIG9yZGVyIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBzYW1lIHNlc3Npb24gaW4gY2FzZSBvZiBhIHJlY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmlvLm9wdHMucXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9pZDogdGhpcy5zZXNzaW9uX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLmNvbmZpZy50b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hcHBsaWNhdGlvbiB8fCAodGhpcy5hcHBsaWNhdGlvbi5tZSAmJiB0aGlzLmFwcGxpY2F0aW9uLm1lLmlkICE9PSByZXNwb25zZS5ib2R5LnVzZXJfaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IG5ldyBhcHBsaWNhdGlvbl8xLmRlZmF1bHQodGhpcywge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFwcGxpY2F0aW9uLm1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5tZSA9IG5ldyB1c2VyXzEuZGVmYXVsdCh0aGlzLmFwcGxpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiByZXNwb25zZS5ib2R5LnVzZXJfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlc3BvbnNlLmJvZHkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVycm9yc0VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yc0VtaXR0ZXIgPSBuZXcgZXJyb3JzX2VtaXR0ZXJfMS5kZWZhdWx0KHRoaXMuYXBwbGljYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IEJ1Z3NuYWcgdXNlciB0byBhcHBsaWNhdGlvbi5tZS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvZ19yZXBvcnRlci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLk5YTWJ1Z3NuYWdDbGllbnQudXNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuYXBwbGljYXRpb24ubWUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuYXBwbGljYXRpb24ubWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9pZDogcmVzcG9uc2UuYm9keS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc3luYyAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGV4aXN0aW5nIGNvbnZlcnNhdGlvbiBkYXRhIGZvciB0aGlzIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcGxpY2F0aW9uLmdldENvbnZlcnNhdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmFwcGxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmFwcGxpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgbmV4bW9DbGllbnRFcnJvcl8xLk5leG1vQXBpRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgZXhpc3RpbmcgU2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyAge1Byb21pc2U8Q0FQSVJlc3BvbnNlPn0gLSByZXNwb25zZSB3aXRoIHJpZCBhbmQgdHlwZVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGV0ZSBleGlzdGluZyBzZXNzaW9uPC9jYXB0aW9uPlxuICAgICAqICBydGMuZGVsZXRlU2Vzc2lvbigpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICogICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgZGVsZXRlU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ291dFJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2Vzc2lvbjpsb2dvdXQnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7fVxuICAgICAgICAgICAgICAgIH0sIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ3Nlc3Npb246bG9nZ2VkLW91dCcgfHwgcmVzcG9uc2UudHlwZSA9PT0gJ3Nlc3Npb246dGVybWluYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXJyb3JzRW1pdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFwcGxpY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBwcmVwYXJlIGZvciBkZWxldGVTZXNzaW9uXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkaXNhYmxlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbi5jb252ZXJzYXRpb25zLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29udmVyc2F0aW9uIG9mIHRoaXMuYXBwbGljYXRpb24uY29udmVyc2F0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVByb21pc2VzLnB1c2goY29udmVyc2F0aW9uLm1lZGlhLmRpc2FibGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGlzYWJsZVByb21pc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFwiZGVsZXRlU2Vzc2lvbjogXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ291dFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dvdXRSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVTZXNzaW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnc2Vzc2lvbjpzdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uX2lkID0gZXZlbnQuYm9keS5pZDtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5pby5vcHRzLnF1ZXJ5LnNlc3Npb25faWQgPSBldmVudC5ib2R5LmlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZnJvbSB0aGUgY2xvdWQuXG4gICAgICpcbiAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBjbG91ZC5cbiAgICAgKlxuICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogR2V0IGEgY29ubmVjdGl2aXR5IHJlcG9ydCBmb3IgYWxsIFZvbmFnZSBEQ3MgYW5kIE1lZGlhIFNlcnZlcnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gdGhlIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmUgdGhlIGNvbm5lY3Rpdml0eVJlcG9ydFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZGNMaXN0Q2FsbGJhY2sgLSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGVkaXQgdGhlIGxpc3Qgb2YgZGF0YWNlbnRlcnMgYmVmb3JlIGNvbm5lY3Rpdml0eSBjaGVja3NcbiAgICAgICAqIEByZXR1cm5zICB7UHJvbWlzZTxSZXBvcnQ+fVxuICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2V0IGEgY29ubmVjdGl2aXR5IHJlcG9ydDwvY2FwdGlvbj5cbiAgICAgKlxuICAgICAgICogIHJ0Yy5jb25uZWN0aXZpdHlSZXBvcnQodG9rZW4sIHtcbiAgICAgKiAgICBkY0xpc3RDYWxsYmFjazogKGRjTGlzdCkgPT4gey4uLmRjTGlzdCwgYWRkaXRpb25hbERjfVxuICAgICAqICB9KS50aGVuKChyZXBvcnQpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhyZXBvcnQpO1xuICAgICAqICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICogIH0pO1xuICAgICovXG4gICAgYXN5bmMgY29ubmVjdGl2aXR5UmVwb3J0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGlwID0gIXJ0Y19oZWxwZXJfMS5kZWZhdWx0LmlzTm9kZSgpID8gYXdhaXQgcHVibGljaXBfMS5kZWZhdWx0LnY0KCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IHtcbiAgICAgICAgICAgIG1hY2hpbmVJbmZvOiB7IGlwIH0sXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlSZXBvcnQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBhd2FpdCB1dGlsc18xLmRlZmF1bHQubmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHVybDogYCR7dGhpcy5jb25maWcubmV4bW9fYXBpX3VybH0vdjAuMy9kaXNjb3ZlcnkvYXBpYCxcbiAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZGNMaXN0ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRjTGlzdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZGNMaXN0ID0gb3B0aW9ucy5kY0xpc3RDYWxsYmFjayhkY0xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBkYyBpbiBkY0xpc3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGRjTGlzdFtkY10uZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBpVXJsID0gZGNMaXN0W2RjXS5odHRwcztcbiAgICAgICAgICAgICAgICBjb25zdCB3c1VybCA9IGRjTGlzdFtkY10ud3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHR0cFJlcyA9IGF3YWl0IHV0aWxzXzEuZGVmYXVsdC5fY2hlY2tIdHRwQ29ubmVjdGl2aXR5KGFwaVVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdzUmVzID0gYXdhaXQgdXRpbHNfMS5kZWZhdWx0Ll9jaGVja1dzQ29ubmVjdGl2aXR5KHdzVXJsLCB0aGlzLmNvbmZpZy5wYXRoLCB0aGlzLmNvbmZpZy5zb2NrZXRfaW8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZWRpYUNvbm5lY3Rpb25SZXBvcnQgPSBhd2FpdCB1dGlsc18xLmRlZmF1bHQuX2NoZWNrTWVkaWFTZXJ2ZXJzKHRva2VuLCBlbmRwb2ludCwgZGMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbENvbm5lY3Rpb25SZXBvcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwczogaHR0cFJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3czogd3NSZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFDb25uZWN0aW9uUmVwb3J0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydC5jb25uZWN0aXZpdHlSZXBvcnQucHVzaChyZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoYEVycm9yIGdlbmVyYXRpbmcgcmVwb3J0IGZvciAke2RjfWAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbmV4bW8gc2VydmVycyBpbmZvcm1hdGlvbmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgICogUmV0dXJuIGEgbGlzdCB3aXRoIHRoZSBjb25uZWN0aW9uIGhlYWx0aCBvZiB0aGUgbWVkaWEgc2VydmVycyBmb3IgYSBzcGVjaWZpYyBkYXRhY2VudGVyLlxuICAgICAgKiBAcmV0dXJucyAge1Byb21pc2U8TWVkaWFDb25uZWN0aW9uUmVwb3J0W10+fVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gdGhlIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4bW9fYXBpX3VybCAtIHVybCBvZiB0aGUgbmV4bW8gYXBpIHRvIGJlIGNhbGxlZFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFjZW50ZXIgLSBkYXRhY2VudGVyIG9mIGludGVyZXN0XG4gICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlJldHVybiBhIGxpc3Qgd2l0aCB0aGUgY29ubmVjdGlvbiBoZWFsdGggb2YgdGhlIG1lZGlhIHNlcnZlcnM8L2NhcHRpb24+XG4gICAgKlxuICAgICAgKiAgcnRjLmNoZWNrTWVkaWFTZXJ2ZXJzKCduZXhtby1hcGktdXJsJywnZGMnKS50aGVuKChyZXNwb25zZUFycmF5KSA9PiB7XG4gICAgICAqICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlQXJyYXkpO1xuICAgICAgKiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAqICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICogIH0pO1xuICAgICAqL1xuICAgIGFzeW5jIGNoZWNrTWVkaWFTZXJ2ZXJzKHRva2VuLCBuZXhtb19hcGlfdXJsLCBkYXRhY2VudGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB1dGlsc18xLmRlZmF1bHQuX2NoZWNrTWVkaWFTZXJ2ZXJzKHRva2VuLCBuZXhtb19hcGlfdXJsLCBkYXRhY2VudGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm4gdGhlIGNvbm5lY3Rpb24gaGVhbHRoIG9mIGEgc2luZ2xlIG1lZGlhIHNlcnZlciBpbmNsdWRpbmcgcG9zc2libGUgY29ubmVjdGlvblRpbWUgaW4gbXMuXG4gICAgKiBAcmV0dXJucyAge1Byb21pc2U8TWVkaWFDb25uZWN0aW9uUmVwb3J0Pn1cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBpcCAtIGlwIGFkZHJlc3Mgb2YgdGhlIE1lZGlhIFNlcnZlclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHBvcnQgLSBwb3J0IG51bWJlciBvZiB0aGUgTWVkaWEgU2VydmVyXG4gICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXR1cm4gdGhlIGNvbm5lY3Rpb24gaGVhbHRoIG9mIGEgc2luZ2xlIG1lZGlhIHNlcnZlcjwvY2FwdGlvbj5cbiAgICAqXG4gICAgKiAgcnRjLmNoZWNrTWVkaWFDb25uZWN0aXZpdHkoJ2lwLWFkZHJlc3MnLCcxJykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAqICAgIGNvbnNvbGUubG9nKGBJUCBBZGRyZXNzIG9mIG1lZGlhIHNlcnZlcjogJHtyZXNwb25zZS5pcH1gKTtcbiAgICAqICAgIGNvbnNvbGUubG9nKGBBYmxlIHRvIGNvbm5lY3Q6ICR7cmVzcG9uc2UuY2FuQ29ubmVjdH1gKTtcbiAgICAqICAgIGNvbnNvbGUubG9nKGBDb25uZWN0aW9uVGltZSBpbiBtczogJHtyZXNvbnNlLmNvbm5lY3Rpb25UaW1lfWApO1xuICAgICogIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICogICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICogIH0pO1xuICAgKi9cbiAgICBhc3luYyBjaGVja01lZGlhQ29ubmVjdGl2aXR5KGlwLCBwb3J0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB1dGlsc18xLmRlZmF1bHQuX2NoZWNrTWVkaWFDb25uZWN0aXZpdHkoaXAsIHBvcnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE5leG1vQ2xpZW50O1xuLyoqXG4gKiBFbnVtIGZvciBOZXhtb0NsaWVudCBkaXNjb25uZWN0aW9uIHJlYXNvbi5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqIEBhbGlhcyBOZXhtb0NsaWVudC5ESVNDT05ORUNUX1JFQVNPTlxuKi9cbk5leG1vQ2xpZW50LkRJU0NPTk5FQ1RfUkVBU09OID0ge1xuICAgIENsaWVudERpc2Nvbm5lY3RlZDogJ0NsaWVudERpc2Nvbm5lY3RlZCcsXG4gICAgVG9rZW5FeHBpcmVkOiAnVG9rZW5FeHBpcmVkJyxcbiAgICBDb25uZWN0aW9uRXJyb3I6ICdDb25uZWN0aW9uRXJyb3InXG59O1xubW9kdWxlLmV4cG9ydHMgPSBOZXhtb0NsaWVudDtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKiAgVXNlciBPYmplY3QgTW9kZWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE5leG1vIEluYy5cbiAqL1xuY29uc3QgV2lsZEVtaXR0ZXIgPSByZXF1aXJlKCd3aWxkZW1pdHRlcicpO1xuY2xhc3MgVXNlciB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24sIHBhcmFtcykge1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKTtcbiAgICAgICAgV2lsZEVtaXR0ZXIubWl4aW4oVXNlcik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVXNlcjtcbm1vZHVsZS5leHBvcnRzID0gVXNlcjtcbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBOZXhtbyBDbGllbnQgU0RLXG4gKiAgVXNlclNlc3Npb24gT2JqZWN0IE1vZGVsXG4gKlxuICogQ29weXJpZ2h0IChjKSBOZXhtbyBJbmMuXG4gKi9cbmNvbnN0IFdpbGRFbWl0dGVyID0gcmVxdWlyZSgnd2lsZGVtaXR0ZXInKTtcbmNsYXNzIFVzZXJTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5pZCA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgdGhpcy5fZW1iZWRkZWQgPSAoX2IgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuX2VtYmVkZGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICBXaWxkRW1pdHRlci5taXhpbihVc2VyU2Vzc2lvbik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVXNlclNlc3Npb247XG5tb2R1bGUuZXhwb3J0cyA9IFVzZXJTZXNzaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIE5leG1vIENsaWVudCBTREtcbiAqICBVdGlsaXR5IGZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgTmV4bW8gSW5jLlxuICovXG5jb25zdCB1dWlkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInV1aWRcIikpO1xuY29uc3Qgc29ja2V0X2lvX2NsaWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzb2NrZXQuaW8tY2xpZW50XCIpKTtcbmNvbnN0IGFwcGxpY2F0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBwbGljYXRpb25cIikpO1xuY29uc3QgTUVESUFfQ09OTkVDVElWSVRZX1RJTUVPVVQgPSA0MDAwMDsgLy8gNDBzIGlzIHRoZSBkZWZhdWx0IHRpbWVvdXQgZm9yIGljZSBjYW5kaWRhdGVzIGdhdGhlcmluZ1xuY29uc3QgV1NfQ09OTkVDVElWSVRZX1RJTUVPVVQgPSAyMDAwMDsgLy8gMjBzIGlzIHRoZSBkZWZhdWx0IHRpbWVvdXQgZm9yIHdzIGNvbm5lY3Rpb25cbi8qKlxuICogVXRpbGl0aWVzIGNsYXNzIGZvciB0aGUgU0RLLlxuICpcbiAqIEBjbGFzcyBVdGlsc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgVXRpbHMge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWVtYmVyIGZyb20gdGhlIHVzZXJuYW1lIG9mIGEgY29udmVyc2F0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgdGhlIHVzZXJuYW1lIG9mIHRoZSBtZW1iZXIgdG8gZ2V0XG4gICAgICogQHBhcmFtIHtDb252ZXJzYXRpb259IGNvbnZlcnNhdGlvbiB0aGUgQ29udmVyc2F0aW9uIHRvIHNlYXJjaCBpblxuICAgICAqIEByZXR1cm5zIHtNZW1iZXJ9IHRoZSByZXF1ZXN0ZWQgTWVtYmVyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNZW1iZXJGcm9tTmFtZU9yTnVsbChjb252ZXJzYXRpb24sIHVzZXJuYW1lKSB7XG4gICAgICAgIGlmICghY29udmVyc2F0aW9uIHx8ICF1c2VybmFtZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKGxldCBtZW1iZXIgb2YgY29udmVyc2F0aW9uLm1lbWJlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtZW1iZXIudXNlci5uYW1lID09PSB1c2VybmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWVtYmVyJ3MgbnVtYmVyIG9yIHVyaSBmcm9tIHRoZSBldmVudCdzIGNoYW5uZWwgZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFubmVsIHRoZSBldmVudCdzIGNoYW5uZWwgZmllbGRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVxdWVzdGVkIE1lbWJlciBudW1iZXIgb3IgdXJpXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNZW1iZXJOdW1iZXJGcm9tRXZlbnRPck51bGwoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBmcm9tID0gY2hhbm5lbCAmJiBjaGFubmVsLmZyb207XG4gICAgICAgIGlmIChmcm9tICYmIChmcm9tLm51bWJlciB8fCBmcm9tLnVyaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLm51bWJlciB8fCBmcm9tLnVyaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIG5ldHdvcmsgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVxT2JqZWN0IHRoZSBvYmplY3QgdGhhdCBoYXMgYWxsIHRoZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIHRoZSByZXF1ZXN0IHVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlPUdFVHxQT1NUfFBVVHxERUxFVEUgdGhlIHR5cGVzIG9mIHRoZSBuZXR3b3JrIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGFdIHRoZSBkYXRhIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHNlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc3BvbnNlVHlwZV0gdGhlIHJlc3BvbnNlIHR5cGUgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gdGhlIGp3dCB0b2tlbiBmb3IgdGhlIG5ldHdvcmsgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5ldHdvcmtSZXF1ZXN0UmVzcG9uc2U+fSB0aGUgTmV0d29ya1JlcXVlc3RSZXNwb25zZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV0d29ya1JlcXVlc3QocmVxT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcU9iamVjdC50b2tlbiAmJlxuICAgICAgICAgICAgICAgICFyZXFPYmplY3QudXJsLmluY2x1ZGVzKCdsb2dnaW5nJykgJiZcbiAgICAgICAgICAgICAgICAhcmVxT2JqZWN0LnVybC5pbmNsdWRlcygncGluZycpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yOnVzZXI6dG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICduZXR3b3JrIGVycm9yIG9uIHJlcXVlc3QuIFBsZWFzZSBjcmVhdGUgYSBuZXcgc2Vzc2lvbi4nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICB4aHIub3BlbihyZXFPYmplY3QudHlwZSwgcmVxT2JqZWN0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocmVxT2JqZWN0LnRva2VuKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyByZXFPYmplY3QudG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcU9iamVjdCAmJiByZXFPYmplY3QudXJsLmluY2x1ZGVzKCdpbWFnZScpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICcnO1xuICAgICAgICAgICAgICAgIGRhdGEgPSByZXFPYmplY3QuZGF0YTtcbiAgICAgICAgICAgICAgICB4aHIub25sb2Fkc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeGhyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlcU9iamVjdC5yZXNwb25zZVR5cGUgfHwgJ2pzb24nO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeShyZXFPYmplY3QuZGF0YSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCB8fCB4aHIuc3RhdHVzID09PSAyMDEgfHwgeGhyLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh4aHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLnNlbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgR0VUIG5ldHdvcmsgcmVxdWVzdCBmb3IgZmV0Y2hpbmcgcGFnaW5hdGVkIGNvbnZlcnNhdGlvbnMgYW5kIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgcmVxdWVzdCB1cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gbmV0d29yayByZXF1ZXN0IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmN1cnNvcl0gY3Vyc29yIHBhcmFtZXRlciB0byBhY2Nlc3MgdGhlIG5leHQgb3IgcHJldmlvdXMgcGFnZSBvZiBhIGRhdGEgc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMucGFnZV9zaXplXSB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyByZXR1cm5lZCBpbiBhIHNpbmdsZSByZXF1ZXN0IGxpc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5vcmRlcl0gJ2FzYycgb3IgJ2Rlc2MnIG9yZGVyaW5nIG9mIHJlc291cmNlcyAodXN1YWxseSBiYXNlZCBvbiBjcmVhdGlvbiB0aW1lKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmV2ZW50X3R5cGVdIHRoZSB0eXBlIG9mIGV2ZW50IHVzZWQgdG8gZmlsdGVyIGV2ZW50IHJlcXVlc3RzICgnbWVtYmVyOmpvaW5lZCcsICdhdWRpbzpkdG1mJywgZXRjKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiB0aGUgand0IHRva2VuIGZvciB0aGUgbmV0d29yayByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2ZXJzaW9uPUFwcGxpY2F0aW9uLkNPTlZFUlNBVElPTl9BUElfVkVSU0lPTi52MV0gdmVyc2lvbiBvZiBjb252ZXJzYXRpb24gc2VydmljZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSByZXF1ZXN0IChvbmUgb2YgdjEgYW5kIHYzKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8WE1MSHR0cFJlcXVlc3QucmVzcG9uc2U+fSB0aGUgWE1MSHR0cFJlcXVlc3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2VuZGluZyBhIG5leG1vIEdFVCByZXF1ZXN0PC9jYXB0aW9uPlxuICAgICAqICAgIHBhZ2luYXRpb25SZXF1ZXN0KHVybCwgcGFyYW1zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAqICAgICAgcmVzcG9uc2UuaXRlbXM6IHt9LFxuICAgICAqICAgICAgcmVzcG9uc2UuY3Vyc29yOiB7XG4gICAgICogICAgICAgICAgcHJldjogJycsXG4gICAgICogICAgICAgICAgbmV4dDogJycsXG4gICAgICogICAgICAgICAgc2VsZjogJydcbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICByZXNwb25zZS5wYWdlX3NpemU6IDEwLFxuICAgICAqICAgICAgcmVzcG9uc2Uub3JkZXI6ICdhc2MnLFxuICAgICAqICAgfSk7XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHBhZ2luYXRpb25SZXF1ZXN0KHVybCwgcGFyYW1zLCB0b2tlbiwgdmVyc2lvbiA9IGFwcGxpY2F0aW9uXzEuZGVmYXVsdC5DT05WRVJTQVRJT05fQVBJX1ZFUlNJT04udjEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHhociA9IGF3YWl0IFV0aWxzLm5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgICAgICB1cmw6IFV0aWxzLmFkZFVybFNlYXJjaFBhcmFtcyh1cmwsIHBhcmFtcyksXG4gICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlX3NpemUsIF9lbWJlZGRlZCwgX2xpbmtzIH0gPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZSA9IHVybC5zcGxpdCgnLycpLnBvcCgpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXRlbXM6ICh2ZXJzaW9uID09PSBhcHBsaWNhdGlvbl8xLmRlZmF1bHQuQ09OVkVSU0FUSU9OX0FQSV9WRVJTSU9OLnYxKSA/IF9lbWJlZGRlZC5kYXRhW3Jlc291cmNlXSA6IF9lbWJlZGRlZFtyZXNvdXJjZV0sXG4gICAgICAgICAgICAgICAgY3Vyc29yOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXY6IF9saW5rcy5wcmV2ID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhfbGlua3MucHJldi5ocmVmKS5nZXQoJ2N1cnNvcicpIDogJycsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IF9saW5rcy5uZXh0ID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhfbGlua3MubmV4dC5ocmVmKS5nZXQoJ2N1cnNvcicpIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHNlbGY6IF9saW5rcy5zZWxmID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhfbGlua3Muc2VsZi5ocmVmKS5nZXQoJ2N1cnNvcicpIDogJydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZ2Vfc2l6ZTogcGFnZV9zaXplLFxuICAgICAgICAgICAgICAgIG9yZGVyOiBwYXJhbXMub3JkZXIgfHwgJ2FzYycsXG4gICAgICAgICAgICAgICAgZXZlbnRfdHlwZTogcGFyYW1zLmV2ZW50X3R5cGUgfHwgbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoeyByZXNwb25zZSB9KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRfZXJyb3IgPSByZXNwb25zZSA/XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgOiB7IHR5cGU6ICdlcnJvcjpuZXR3b3JrOmdldC1yZXF1ZXN0JywgZGVzY3JpcHRpb246ICduZXR3b3JrIGVycm9yIG9uIG5leG1vIGdldCByZXF1ZXN0JyB9O1xuICAgICAgICAgICAgaWYgKHBhcnNlZF9lcnJvci52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkX2Vycm9yLmRlc2NyaXB0aW9uID0gcGFyc2VkX2Vycm9yLnZhbGlkYXRpb25bT2JqZWN0LmtleXMocGFyc2VkX2Vycm9yLnZhbGlkYXRpb24pWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHBhcnNlZF9lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIFNlYXJjaCBQYXJhbXMgb2YgYSB1cmxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXBwZW5kZWQgdXJsXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhZGRVcmxTZWFyY2hQYXJhbXModXJsLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYXBwZW5kZWRfdXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldICYmICEodHlwZW9mIHBhcmFtc1trZXldID09PSAnc3RyaW5nJyAmJiBwYXJhbXNba2V5XS5sZW5ndGggPCAxKSAmJiBwYXJhbXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFwcGVuZGVkX3VybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1zW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFwcGVuZGVkX3VybC5ocmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWVwIG1lcmdlcyB0d28gb2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBuZXcgbWVyZ2VkIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVlcE1lcmdlT2JqKG9iajEsIG9iajIpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT2JqID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmoxKSk7XG4gICAgICAgIC8vIE1lcmdlIHRoZSBvYmplY3QgaW50byB0aGUgbmV3IG1lcmdlZE9iamVjdFxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iajIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBhbiBvYmplY3QgdGhlbiBtZXJnZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iajJbcHJvcF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9ialtwcm9wXSA9IFV0aWxzLmRlZXBNZXJnZU9iaihtZXJnZWRPYmpbcHJvcF0sIG9iajJbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqW3Byb3BdID0gb2JqMltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkT2JqO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmplY3QgYSBzY3JpcHQgaW50byB0aGUgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIHNjcmlwdCBiZWluZyBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7cmVxdWVzdENhbGxiYWNrfSBjIHRoZSBjYWxsYmFjayBmaXJlZCBhZnRlciBzY3JpcHQgZXhlY3V0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGluamVjdFNjcmlwdCh1LCBjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgICAgICBsZXQgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgcy5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICBzLnNyYyA9IHU7XG4gICAgICAgICAgICBzLm9ubG9hZCA9IHMub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcy5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3Qocy5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBzLm9ubG9hZCA9IHMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaC5pbnNlcnRCZWZvcmUocywgaC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYWxsb2NhdGVVVUlEKCkge1xuICAgICAgICByZXR1cm4gdXVpZF8xLmRlZmF1bHQudjQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgZHRtZiBkaWdpdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVEVE1GKGRpZ2l0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGlnaXQgPT09ICdzdHJpbmcnID8gL15bXFxkYS1kQS1EIypwUF17MSw0NX0kJC8udGVzdChkaWdpdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXhtbyBidWdzbmFnIGFwaSBrZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0QnVnc25hZ0tleSgpIHtcbiAgICAgICAgcmV0dXJuICc3NjQ5OGZjMWNhOGQ5YjBhMTczYTQ0ZTJiODczZDdlZCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgbWVtYmVyIGxlZ3MgYXJyYXkgd2l0aCB0aGUgbmV3IG9uZSByZWNlaXZlZCBpbiB0aGUgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxlZ3MgdGhlIG1lbWJlciBsZWdzIGFycmF5XG4gICAgICogQHBhcmFtIHtOWE1FdmVudH0gZXZlbnQgdGhlIG1lbWJlciBldmVudCBob2xkaW5nIHRoZSBuZXcgbGVncyBhcnJheVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlTWVtYmVyTGVncyhsZWdzLCBldmVudCkge1xuICAgICAgICBpZiAobGVncykge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgbGVnIGluIHRoZSBsZWdzIGFycmF5IGlmIGV4aXN0c1xuICAgICAgICAgICAgY29uc3QgbGVnID0gbGVncy5maW5kKChsZWcpID0+IGxlZy5sZWdfaWQgPT09IGV2ZW50LmJvZHkubGVnX2lkKTtcbiAgICAgICAgICAgIGlmICghbGVnKSB7XG4gICAgICAgICAgICAgICAgbGVncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGVnX2lkOiBldmVudC5ib2R5LmxlZ19pZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBldmVudC5ib2R5LnN0YXR1c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVnLnN0YXR1cyAhPT0gZXZlbnQuYm9keS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdHVzIG9mIHRoZSBsZWcgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV2ZW50IHN0YXR1c1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbGVnIG9iamVjdCB3aXRoIHRoZSBuZXcgbGVnIHN0YXR1c1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGxlZ3MuaW5kZXhPZihsZWcpO1xuICAgICAgICAgICAgICAgIGxlZ3MuZmlsbChsZWcuc3RhdHVzID0gZXZlbnQuYm9keS5zdGF0dXMsIGluZGV4LCBpbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZ3MgPSBbe1xuICAgICAgICAgICAgICAgICAgICBsZWdfaWQ6IGV2ZW50LmJvZHkubGVnX2lkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LmJvZHkuc3RhdHVzXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBldmVudCBpcyByZWZlcmVuY2VkIHRvIGEgY2FsbCBvciBzaW1wbGUgY29udmVyc2F0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2lzQ2FsbEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY2hhbm5lbCwgbWVkaWEgfSA9IGV2ZW50LmJvZHk7XG4gICAgICAgIC8vIGluIGNhc2Ugd2UgaGF2ZSBhIHRyYW5zZmVyIHdlIHNob3VsZCBmZXRjaCB0aGUgY29udmVyc2F0aW9uXG4gICAgICAgIC8vIGluY2x1ZGluZyB0aGUgbmV3IG1lbWJlcnNoaXBcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwicnRjOnRyYW5zZmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gdGhpcyBjaGVjayBkaWZmZXJlbnRpYXRlcyB0aGUgY2FsbCBmbG93IHdpdGggdGhlIG5vbiBjYWxsXG4gICAgICAgIC8vIElQLVBTVE4gKG1lbWJlcjpqb2luZWQpIHNob3VsZCBoYXZlIGFuIGtub2NraW5nX2lkIGluc2lkZSB0aGUgY2hhbm5lbFxuICAgICAgICAvLyBQU1ROLUlQIGFuZCBJUC1JUCAobWVtYmVyOmludml0ZWQpIHNob3VsZCBoYXZlIGF1ZGlvX3NldHRpbmdzLmVuYWJsZWQgPSB0cnVlXG4gICAgICAgIGlmIChjaGFubmVsICYmICgobWVkaWEgJiYgbWVkaWEuYXVkaW9fc2V0dGluZ3MgJiYgbWVkaWEuYXVkaW9fc2V0dGluZ3MuZW5hYmxlZCkgfHxcbiAgICAgICAgICAgIChtZWRpYSAmJiBtZWRpYS5hdWRpbyAmJiBtZWRpYS5hdWRpby5lbmFibGVkKSB8fCBjaGFubmVsLmtub2NraW5nX2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbiBpbWFnZSBmcm9tIE1lZGlhIFNlcnZpY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBfZmV0Y2hJbWFnZSh1cmwsIHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IGF3YWl0IFV0aWxzLm5ldHdvcmtSZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQXJyYXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZSk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGludCBhcnJheSB0byBhIGJpbmFyeSBTdHJpbmdcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB1c2UgYXBwbHkoKSBhcyB3ZSBhcmUgY29udmVydGluZyBhbiAqYXJyYXkqXG4gICAgICAgIC8vIGFuZCBTdHJpbmcuZnJvbUNoYXJDb2RlKCkgdGFrZXMgb25lIG9yIG1vcmUgc2luZ2xlIHZhbHVlcywgbm90XG4gICAgICAgIC8vIGFuIGFycmF5LlxuICAgICAgICAvLyBzdXBwb3J0IGxhcmdlIGltYWdlIGZpbGVzIChDaHVua2luZylcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBjb25zdCBjaHVuayA9IDggKiAxMDI0O1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3BvbnNlQXJyYXkubGVuZ3RoIC8gY2h1bms7IGkrKykge1xuICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgcmVzcG9uc2VBcnJheS5zdWJhcnJheShpICogY2h1bmssIChpICsgMSkgKiBjaHVuaykpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHJlc3BvbnNlQXJyYXkuc3ViYXJyYXkoaSAqIGNodW5rKSk7XG4gICAgICAgIHJldHVybiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnICsgYnRvYShyZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBIVFRQIFVSTCBpcyByZWFjaGFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBfY2hlY2tIdHRwQ29ubmVjdGl2aXR5KHVybCkge1xuICAgICAgICBjb25zdCB0aW1lQmVmb3JlQ29ubmVjdGluZyA9IERhdGUubm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBVdGlscy5uZXR3b3JrUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25UaW1lID0gRGF0ZS5ub3coKSAtIHRpbWVCZWZvcmVDb25uZWN0aW5nO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJsLCBjYW5Db25uZWN0OiB0cnVlLCBjb25uZWN0aW9uVGltZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJsLCBjYW5Db25uZWN0OiBmYWxzZSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB3ZWJzb2NrZXQgVVJMIGlzIHJlYWNoYWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9jaGVja1dzQ29ubmVjdGl2aXR5KHdzX3VybCwgcGF0aCwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzb2NrZXRfaW9fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IHBhdGggfSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVCZWZvcmVDb25uZWN0aW5nID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBzb2NrZXRfaW9fY2xpZW50XzEuZGVmYXVsdC5jb25uZWN0KHdzX3VybCwgc29ja2V0X2lvX2NvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHsgdXJsOiB3c191cmwsIGNhbkNvbm5lY3Q6IGZhbHNlIH0pLCBXU19DT05ORUNUSVZJVFlfVElNRU9VVCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25UaW1lID0gRGF0ZS5ub3coKSAtIHRpbWVCZWZvcmVDb25uZWN0aW5nO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgdXJsOiB3c191cmwsIGNhbkNvbm5lY3Q6IHRydWUsIGNvbm5lY3Rpb25UaW1lIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgdXJsOiB3c191cmwsIGNhbkNvbm5lY3Q6IGZhbHNlLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbGlzdCB3aXRoIHRoZSBjb25uZWN0aW9uIGhlYWx0aCBvZiB0aGUgTWVkaWEgU2VydmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIF9jaGVja01lZGlhU2VydmVycyh0b2tlbiwgbmV4bW9fYXBpX3VybCwgZGF0YWNlbnRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyByZXNwb25zZSB9ID0gYXdhaXQgVXRpbHMubmV0d29ya1JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHVybDogYCR7bmV4bW9fYXBpX3VybH0vdjAuMy9kaXNjb3ZlcnkvbWVkaWEvJHtkYXRhY2VudGVyfWAsXG4gICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVxTGlzdCA9IHJlc3BvbnNlLm1hcCgoaG9zdCkgPT4gVXRpbHMuX2NoZWNrTWVkaWFDb25uZWN0aXZpdHkoaG9zdC5pcCwgaG9zdC5wb3J0KSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocmVxTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgY2FuIGVzdGFibGlzaCBhIHBlZXIgY29ubmVjdGlvbiB3aXRoIGEgc3BlY2lmaWMgTWVkaWEgU2VydmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgX2NoZWNrTWVkaWFDb25uZWN0aXZpdHkoaXAsIHBvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB7IGljZVNlcnZlcnM6IFt7IHVybHM6IGBzdHVuOiR7aXB9OiR7cG9ydH1gIH1dIH07XG4gICAgICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVCZWZvcmVDb25uZWN0aW5nID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoeyBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlIH0pO1xuICAgICAgICAgICAgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgaXAsIGNhbkNvbm5lY3Q6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSwgTUVESUFfQ09OTkVDVElWSVRZX1RJTUVPVVQpO1xuICAgICAgICAgICAgcGMub25pY2VjYW5kaWRhdGUgPSAoeyBjYW5kaWRhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlID09PSBudWxsIHx8IGNhbmRpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FuZGlkYXRlLnR5cGUpID09PSBcInNyZmx4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvblRpbWUgPSBEYXRlLm5vdygpIC0gdGltZUJlZm9yZUNvbm5lY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gZXN0YWJsaXNoZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGlwLCBjYW5Db25uZWN0OiB0cnVlLCBjb25uZWN0aW9uVGltZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGMub25pY2VjYW5kaWRhdGVlcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5lcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgaXAsIGNhbkNvbm5lY3Q6IGZhbHNlLCBlcnJvcjogZXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIHJlIGludml0ZWQgdG8gYW4gZXhpc3RpbmcgY29udmVyc2F0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NoZWNrSWZVc2VySXNSZUludml0ZWQoY29udmVyc2F0aW9ucywgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWNvbnZlcnNhdGlvbnMuaGFzKGV2ZW50LmNpZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghKGV2ZW50LnR5cGUgPT09ICdtZW1iZXI6aW52aXRlZCcgfHwgZXZlbnQudHlwZSA9PT0gJ21lbWJlcjpqb2luZWQnKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgbWUgPSAoX2EgPSBjb252ZXJzYXRpb25zLmdldChldmVudC5jaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWU7XG4gICAgICAgIGlmICghbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChtZS51c2VyLm5hbWUgPT09IGV2ZW50LmJvZHkudXNlci5uYW1lICYmIG1lLnN0YXRlID09PSAnTEVGVCcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFV0aWxzO1xubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcbiIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmJ1Z3NuYWcgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO1xuLy8gbWluaW1hbCBpbXBsZW1lbnRhdGlvbnMgb2YgdXNlZnVsIEVTIGZ1bmN0aW9uYWxpdHlcbi8vIGFsbCB3ZSByZWFsbHkgbmVlZCBmb3IgYXJyYXlzIGlzIHJlZHVjZSDigJMgZXZlcnl0aGluZyBlbHNlIGlzIGp1c3Qgc3VnYXIhXG4vLyBBcnJheSNyZWR1Y2VcbnZhciByZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBmbiwgYWNjdW0pIHtcbiAgdmFyIHZhbCA9IGFjY3VtO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YWwgPSBmbih2YWwsIGFycltpXSwgaSwgYXJyKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59OyAvLyBBcnJheSNmaWx0ZXJcblxuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgcmV0dXJuIHJlZHVjZShhcnIsIGZ1bmN0aW9uIChhY2N1bSwgaXRlbSwgaSwgYXJyKSB7XG4gICAgcmV0dXJuICFmbihpdGVtLCBpLCBhcnIpID8gYWNjdW0gOiBhY2N1bS5jb25jYXQoaXRlbSk7XG4gIH0sIFtdKTtcbn07IC8vIEFycmF5I21hcFxuXG5cbnZhciBtYXAgPSBmdW5jdGlvbiAoYXJyLCBmbikge1xuICByZXR1cm4gcmVkdWNlKGFyciwgZnVuY3Rpb24gKGFjY3VtLCBpdGVtLCBpLCBhcnIpIHtcbiAgICByZXR1cm4gYWNjdW0uY29uY2F0KGZuKGl0ZW0sIGksIGFycikpO1xuICB9LCBbXSk7XG59OyAvLyBBcnJheSNpbmNsdWRlc1xuXG5cbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIChhcnIsIHgpIHtcbiAgcmV0dXJuIHJlZHVjZShhcnIsIGZ1bmN0aW9uIChhY2N1bSwgaXRlbSwgaSwgYXJyKSB7XG4gICAgcmV0dXJuIGFjY3VtID09PSB0cnVlIHx8IGl0ZW0gPT09IHg7XG4gIH0sIGZhbHNlKTtcbn07XG5cbnZhciBfaGFzRG9udEVudW1CdWcgPSAhe1xuICB0b1N0cmluZzogbnVsbFxufS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcblxudmFyIF9kb250RW51bXMgPSBbJ3RvU3RyaW5nJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3ZhbHVlT2YnLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdjb25zdHJ1Y3RvciddOyAvLyBPYmplY3Qja2V5c1xuXG52YXIga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgLy8gc3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9LZXlzXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHByb3A7XG5cbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkgcmVzdWx0LnB1c2gocHJvcCk7XG4gIH1cblxuICBpZiAoIV9oYXNEb250RW51bUJ1ZykgcmV0dXJuIHJlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gX2RvbnRFbnVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBfZG9udEVudW1zW2ldKSkgcmVzdWx0LnB1c2goX2RvbnRFbnVtc1tpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gQXJyYXkjaXNBcnJheVxuXG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgX3BhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyBcIjBcIiArIG4gOiBuO1xufTsgLy8gRGF0ZSN0b0lTT1N0cmluZ1xuXG5cbnZhciBpc29EYXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmdcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICsgX3BhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIF9wYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICsgX3BhZChkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgX3BhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgKyBfcGFkKGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChkLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTAwMCkudG9GaXhlZCgzKS5zbGljZSgyLCA1KSArICdaJztcbn07XG5cbnZhciBfJGVzVXRpbHNfOCA9IHtcbiAgbWFwOiBtYXAsXG4gIHJlZHVjZTogcmVkdWNlLFxuICBmaWx0ZXI6IGZpbHRlcixcbiAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICBrZXlzOiBrZXlzLFxuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc29EYXRlOiBpc29EYXRlXG59O1xuXG52YXIgXyR2YWxpZGF0b3JzXzE1ID0ge307XG5fJHZhbGlkYXRvcnNfMTUuaW50UmFuZ2UgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluID0gMTtcbiAgfVxuXG4gIGlmIChtYXggPT09IHZvaWQgMCkge1xuICAgIG1heCA9IEluZmluaXR5O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHBhcnNlSW50KCcnICsgdmFsdWUsIDEwKSA9PT0gdmFsdWUgJiYgdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgfTtcbn07XG5cbl8kdmFsaWRhdG9yc18xNS5zdHJpbmdXaXRoTGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEhdmFsdWUubGVuZ3RoO1xufTtcblxudmFyIF8kY29uZmlnXzUgPSB7fTtcbnZhciBfX2ZpbHRlcl81ID0gXyRlc1V0aWxzXzguZmlsdGVyLFxuICAgIF9fcmVkdWNlXzUgPSBfJGVzVXRpbHNfOC5yZWR1Y2UsXG4gICAgX19rZXlzXzUgPSBfJGVzVXRpbHNfOC5rZXlzLFxuICAgIF9faXNBcnJheV81ID0gXyRlc1V0aWxzXzguaXNBcnJheSxcbiAgICBfX2luY2x1ZGVzXzUgPSBfJGVzVXRpbHNfOC5pbmNsdWRlcztcblxudmFyIGludFJhbmdlID0gXyR2YWxpZGF0b3JzXzE1LmludFJhbmdlLFxuICAgIHN0cmluZ1dpdGhMZW5ndGggPSBfJHZhbGlkYXRvcnNfMTUuc3RyaW5nV2l0aExlbmd0aDtcblxuXyRjb25maWdfNS5zY2hlbWEgPSB7XG4gIGFwaUtleToge1xuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnaXMgcmVxdWlyZWQnLFxuICAgIHZhbGlkYXRlOiBzdHJpbmdXaXRoTGVuZ3RoXG4gIH0sXG4gIGFwcFZlcnNpb246IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbWVzc2FnZTogJ3Nob3VsZCBiZSBhIHN0cmluZycsXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHN0cmluZ1dpdGhMZW5ndGgodmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgYXBwVHlwZToge1xuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIGEgc3RyaW5nJyxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgc3RyaW5nV2l0aExlbmd0aCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBhdXRvTm90aWZ5OiB7XG4gICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIG1lc3NhZ2U6ICdzaG91bGQgYmUgdHJ1ZXxmYWxzZScsXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVNlbmQ6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIG1lc3NhZ2U6ICdzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMnLFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgX19pc0FycmF5XzUodmFsdWUpICYmIF9fZmlsdGVyXzUodmFsdWUsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH0pLmxlbmd0aCA9PT0gdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfSxcbiAgZW5kcG9pbnRzOiB7XG4gICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub3RpZnk6ICdodHRwczovL25vdGlmeS5idWdzbmFnLmNvbScsXG4gICAgICAgIHNlc3Npb25zOiAnaHR0cHM6Ly9zZXNzaW9ucy5idWdzbmFnLmNvbSdcbiAgICAgIH07XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIGFuIG9iamVjdCBjb250YWluaW5nIGVuZHBvaW50IFVSTHMgeyBub3RpZnksIHNlc3Npb25zIH0uIHNlc3Npb25zIGlzIG9wdGlvbmFsIGlmIGF1dG9DYXB0dXJlU2Vzc2lvbnM9ZmFsc2UnLFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsLCBvYmopIHtcbiAgICAgIHJldHVybiAoLy8gZmlyc3QsIGVuc3VyZSBpdCdzIGFuIG9iamVjdFxuICAgICAgICB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgLy8gZW5kcG9pbnRzLm5vdGlmeSBtdXN0IGFsd2F5cyBiZSBzZXRcbiAgICAgICAgc3RyaW5nV2l0aExlbmd0aCh2YWwubm90aWZ5KSAmJiAoIC8vIGVuZHBvaW50cy5zZXNzaW9ucyBtdXN0IGJlIHNldCB1bmxlc3Mgc2Vzc2lvbiB0cmFja2luZyBpcyBleHBsaWNpdGx5IG9mZlxuICAgICAgICBvYmouYXV0b0NhcHR1cmVTZXNzaW9ucyA9PT0gZmFsc2UgfHwgc3RyaW5nV2l0aExlbmd0aCh2YWwuc2Vzc2lvbnMpKSAmJiAvLyBlbnN1cmUgbm8ga2V5cyBvdGhlciB0aGFuIG5vdGlmeS9zZXNzaW9uIGFyZSBzZXQgb24gZW5kcG9pbnRzIG9iamVjdFxuICAgICAgICBfX2ZpbHRlcl81KF9fa2V5c181KHZhbCksIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuICFfX2luY2x1ZGVzXzUoWydub3RpZnknLCAnc2Vzc2lvbnMnXSwgayk7XG4gICAgICAgIH0pLmxlbmd0aCA9PT0gMFxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGF1dG9DYXB0dXJlU2Vzc2lvbnM6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICh2YWwsIG9wdHMpIHtcbiAgICAgIHJldHVybiBvcHRzLmVuZHBvaW50cyA9PT0gdW5kZWZpbmVkIHx8ICEhb3B0cy5lbmRwb2ludHMgJiYgISFvcHRzLmVuZHBvaW50cy5zZXNzaW9ucztcbiAgICB9LFxuICAgIG1lc3NhZ2U6ICdzaG91bGQgYmUgdHJ1ZXxmYWxzZScsXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIG5vdGlmeVJlbGVhc2VTdGFnZXM6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbWVzc2FnZTogJ3Nob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzJyxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgX19pc0FycmF5XzUodmFsdWUpICYmIF9fZmlsdGVyXzUodmFsdWUsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZiA9PT0gJ3N0cmluZyc7XG4gICAgICB9KS5sZW5ndGggPT09IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gIH0sXG4gIHJlbGVhc2VTdGFnZToge1xuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICB9LFxuICAgIG1lc3NhZ2U6ICdzaG91bGQgYmUgYSBzdHJpbmcnLFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gIH0sXG4gIG1heEJyZWFkY3J1bWJzOiB7XG4gICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMjA7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIGEgbnVtYmVyIOKJpDQwJyxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW50UmFuZ2UoMCwgNDApKHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIGF1dG9CcmVhZGNydW1iczoge1xuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnLFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gIH0sXG4gIHVzZXI6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbWVzc2FnZTogJyhvYmplY3QpIHVzZXIgc2hvdWxkIGJlIGFuIG9iamVjdCcsXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICB9LFxuICBtZXRhRGF0YToge1xuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIGFuIG9iamVjdCcsXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICB9LFxuICBsb2dnZXI6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIG51bGwgb3IgYW4gb2JqZWN0IHdpdGggbWV0aG9kcyB7IGRlYnVnLCBpbmZvLCB3YXJuLCBlcnJvciB9JyxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlICYmIF9fcmVkdWNlXzUoWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSwgZnVuY3Rpb24gKGFjY3VtLCBtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtICYmIHR5cGVvZiB2YWx1ZVttZXRob2RdID09PSAnZnVuY3Rpb24nO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuICBmaWx0ZXJzOiB7XG4gICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWydwYXNzd29yZCddO1xuICAgIH0sXG4gICAgbWVzc2FnZTogJ3Nob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzfHJlZ2V4ZXMnLFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfX2lzQXJyYXlfNSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSBfX2ZpbHRlcl81KHZhbHVlLCBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnIHx8IHMgJiYgdHlwZW9mIHMudGVzdCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH0pLmxlbmd0aDtcbiAgICB9XG4gIH1cbn07XG5cbl8kY29uZmlnXzUubWVyZ2VEZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRzLCBzY2hlbWEpIHtcbiAgaWYgKCFvcHRzIHx8ICFzY2hlbWEpIHRocm93IG5ldyBFcnJvcignb3B0cyBhbmQgc2NoZW1hIG9iamVjdHMgYXJlIHJlcXVpcmVkJyk7XG4gIHJldHVybiBfX3JlZHVjZV81KF9fa2V5c181KHNjaGVtYSksIGZ1bmN0aW9uIChhY2N1bSwga2V5KSB7XG4gICAgYWNjdW1ba2V5XSA9IG9wdHNba2V5XSAhPT0gdW5kZWZpbmVkID8gb3B0c1trZXldIDogc2NoZW1hW2tleV0uZGVmYXVsdFZhbHVlKG9wdHNba2V5XSwgb3B0cyk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9LCB7fSk7XG59O1xuXG5fJGNvbmZpZ181LnZhbGlkYXRlID0gZnVuY3Rpb24gKG9wdHMsIHNjaGVtYSkge1xuICBpZiAoIW9wdHMgfHwgIXNjaGVtYSkgdGhyb3cgbmV3IEVycm9yKCdvcHRzIGFuZCBzY2hlbWEgb2JqZWN0cyBhcmUgcmVxdWlyZWQnKTtcbiAgdmFyIGVycm9ycyA9IF9fcmVkdWNlXzUoX19rZXlzXzUoc2NoZW1hKSwgZnVuY3Rpb24gKGFjY3VtLCBrZXkpIHtcbiAgICBpZiAoc2NoZW1hW2tleV0udmFsaWRhdGUob3B0c1trZXldLCBvcHRzKSkgcmV0dXJuIGFjY3VtO1xuICAgIHJldHVybiBhY2N1bS5jb25jYXQoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBtZXNzYWdlOiBzY2hlbWFba2V5XS5tZXNzYWdlLFxuICAgICAgdmFsdWU6IG9wdHNba2V5XVxuICAgIH0pO1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6ICFlcnJvcnMubGVuZ3RoLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG52YXIgc2NoZW1hID0gXyRjb25maWdfNS5zY2hlbWE7XG5cbnZhciBfX21hcF8xID0gXyRlc1V0aWxzXzgubWFwO1xuXG52YXIgX19zdHJpbmdXaXRoTGVuZ3RoXzEgPSBfJHZhbGlkYXRvcnNfMTUuc3RyaW5nV2l0aExlbmd0aDtcblxudmFyIF8kY29uZmlnXzEgPSB7XG4gIHJlbGVhc2VTdGFnZToge1xuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKC9ebG9jYWxob3N0KDpcXGQrKT8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0KSkgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICByZXR1cm4gJ3Byb2R1Y3Rpb24nO1xuICAgIH0sXG4gICAgbWVzc2FnZTogJ3Nob3VsZCBiZSBzZXQnLFxuICAgIHZhbGlkYXRlOiBfX3N0cmluZ1dpdGhMZW5ndGhfMVxuICB9LFxuICBsb2dnZXI6IF9leHRlbmRzKHt9LCBzY2hlbWEubG9nZ2VyLCB7XG4gICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKC8vIHNldCBsb2dnZXIgYmFzZWQgb24gYnJvd3NlciBjYXBhYmlsaXR5XG4gICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJyA/IGdldFByZWZpeGVkQ29uc29sZSgpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cbiAgfSlcbn07XG5cbnZhciBnZXRQcmVmaXhlZENvbnNvbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb2dnZXIgPSB7fTtcbiAgdmFyIGNvbnNvbGVMb2cgPSBjb25zb2xlWydsb2cnXTtcbiAgX19tYXBfMShbJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgdmFyIGNvbnNvbGVNZXRob2QgPSBjb25zb2xlW21ldGhvZF07XG4gICAgbG9nZ2VyW21ldGhvZF0gPSB0eXBlb2YgY29uc29sZU1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnNvbGVNZXRob2QuYmluZChjb25zb2xlLCAnW2J1Z3NuYWddJykgOiBjb25zb2xlTG9nLmJpbmQoY29uc29sZSwgJ1tidWdzbmFnXScpO1xuICB9KTtcbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG5cbnZhciBfX2lzb0RhdGVfMyA9IF8kZXNVdGlsc184Lmlzb0RhdGU7XG5cbnZhciBCdWdzbmFnQnJlYWRjcnVtYiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1Z3NuYWdCcmVhZGNydW1iKG5hbWUsIG1ldGFEYXRhLCB0eXBlLCB0aW1lc3RhbXApIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gJ1thbm9ueW1vdXNdJztcbiAgICB9XG5cbiAgICBpZiAobWV0YURhdGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YURhdGEgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0eXBlID0gJ21hbnVhbCc7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVzdGFtcCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lc3RhbXAgPSBfX2lzb0RhdGVfMygpO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1ldGFEYXRhID0gbWV0YURhdGE7XG4gICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQnVnc25hZ0JyZWFkY3J1bWIucHJvdG90eXBlO1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXAsXG4gICAgICBtZXRhRGF0YTogdGhpcy5tZXRhRGF0YVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEJ1Z3NuYWdCcmVhZGNydW1iO1xufSgpO1xuXG52YXIgXyRCdWdzbmFnQnJlYWRjcnVtYl8zID0gQnVnc25hZ0JyZWFkY3J1bWI7XG5cbi8vIFRoaXMgaXMgYSBoZWF2aWx5IG1vZGlmaWVkL3NpbXBsaWZpZWQgdmVyc2lvbiBvZlxuLy8gICBodHRwczovL2dpdGh1Yi5jb20vb3RoaXltMjMvYXN5bmMtc29tZVxuLy9cbi8vIFdlIGNhbid0IHVzZSB0aGF0IGJlY2F1c2U6XG4vLyAgIGEpIGl0IGluZmxhdGVzIHRoZSBidW5kbGUgc2l6ZSB0byBvdmVyIDEwa0Jcbi8vICAgYikgaXQgZGVwZW5kcyBvbiBhIG1vZHVsZSB0aGF0IHVzZXMgT2JqZWN0LmtleXMoKVxuLy8gICAgICAod2hpY2ggd2UgY2FuJ3QgdXNlIGR1ZSB0byBpZTggc3VwcG9ydClcbi8vIHJ1biB0aGUgYXN5bmNocm9ub3VzIHRlc3QgZnVuY3Rpb24gKGZuKSBvdmVyIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgKGFycilcbi8vIGluIHNlcmllcyB1bnRpbDpcbi8vICAgLSBmbihpdGVtLCBjYikgPT4gY2FsbHMgY2IobnVsbCwgdHJ1ZSlcbi8vICAgLSBvciB0aGUgZW5kIG9mIHRoZSBhcnJheSBpcyByZWFjaGVkXG4vLyB0aGUgY2FsbGJhY2sgKGNiKSB3aWxsIGJlIHBhc3NlZCB0cnVlIGlmIGFueSBvZiB0aGUgaXRlbXMgcmVzdWx0ZWQgaW4gYSB0cnVlXG4vLyBjYWxsYmFjaywgb3RoZXJ3aXNlIGZhbHNlXG52YXIgXyRhc3luY1NvbWVfNiA9IGZ1bmN0aW9uIChhcnIsIGZuLCBjYikge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSByZXR1cm4gY2IobnVsbCwgZmFsc2UpO1xuICAgIGZuKGFycltpbmRleF0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVyciwgZmFsc2UpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkgcmV0dXJuIGNiKG51bGwsIHRydWUpO1xuICAgICAgaW5kZXgrKztcbiAgICAgIG5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBuZXh0KCk7XG59O1xuXG52YXIgXyRpbmZlclJlbGVhc2VTdGFnZV8xMCA9IGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgcmV0dXJuIGNsaWVudC5hcHAgJiYgdHlwZW9mIGNsaWVudC5hcHAucmVsZWFzZVN0YWdlID09PSAnc3RyaW5nJyA/IGNsaWVudC5hcHAucmVsZWFzZVN0YWdlIDogY2xpZW50LmNvbmZpZy5yZWxlYXNlU3RhZ2U7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgaXNFcnJvcmAuXG4gKi9cbnZhciBfJGlzRXJyb3JfMjEgPSBpc0Vycm9yO1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYHZhbHVlYCBpcyBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ1tvYmplY3QgRXhjZXB0aW9uXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ1tvYmplY3QgRE9NRXhjZXB0aW9uXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbiAgfVxufVxuXG52YXIgXyRpc2Vycm9yXzExID0gXyRpc0Vycm9yXzIxO1xuXG52YXIgXyRydW5CZWZvcmVTZW5kXzE0ID0gZnVuY3Rpb24gKHJlcG9ydCwgb25FcnJvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCBjYikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHJldHVybiBjYihudWxsLCBmYWxzZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWYgZnVuY3Rpb24gYXBwZWFycyBzeW5j4oCmXG4gICAgICBpZiAoZm4ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHZhciByZXQgPSBmbihyZXBvcnQpOyAvLyBjaGVjayBpZiBpdCByZXR1cm5lZCBhIFwidGhlbmFibGVcIiAocHJvbWlzZSlcblxuICAgICAgICBpZiAocmV0ICYmIHR5cGVvZiByZXQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiByZXQudGhlbiggLy8gcmVzb2x2ZVxuICAgICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHNob3VsZFByZXZlbnRTZW5kKHJlcG9ydCwgdmFsKSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9LCAvLyByZWplY3RcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2IobnVsbCwgc2hvdWxkUHJldmVudFNlbmQocmVwb3J0LCByZXQpKTtcbiAgICAgIH0gLy8gaWYgZnVuY3Rpb24gaXMgYXN5bmPigKZcblxuXG4gICAgICBmbihyZXBvcnQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCBzaG91bGRQcmV2ZW50U2VuZChyZXBvcnQsIHJlc3VsdCkpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICAgIGNiKG51bGwsIGZhbHNlKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgc2hvdWxkUHJldmVudFNlbmQgPSBmdW5jdGlvbiAocmVwb3J0LCB2YWx1ZSkge1xuICByZXR1cm4gcmVwb3J0LmlzSWdub3JlZCgpIHx8IHZhbHVlID09PSBmYWxzZTtcbn07XG5cbnZhciBfJHN0YWNrZnJhbWVfMjMgPSB7fTtcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7IC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3N0YWNrZnJhbWUnLCBbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIF8kc3RhY2tmcmFtZV8yMyA9PT0gJ29iamVjdCcpIHtcbiAgICBfJHN0YWNrZnJhbWVfMjMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5TdGFja0ZyYW1lID0gZmFjdG9yeSgpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gIH1cblxuICBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXR0ZXIocCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1twXTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICB2YXIgbnVtZXJpY1Byb3BzID0gWydjb2x1bW5OdW1iZXInLCAnbGluZU51bWJlciddO1xuICB2YXIgc3RyaW5nUHJvcHMgPSBbJ2ZpbGVOYW1lJywgJ2Z1bmN0aW9uTmFtZScsICdzb3VyY2UnXTtcbiAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgdmFyIHByb3BzID0gYm9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsIHN0cmluZ1Byb3BzLCBhcnJheVByb3BzKTtcblxuICBmdW5jdGlvbiBTdGFja0ZyYW1lKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wc1tpXSkgJiYgb2JqW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpc1snc2V0JyArIF9jYXBpdGFsaXplKHByb3BzW2ldKV0ob2JqW3Byb3BzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBTdGFja0ZyYW1lLnByb3RvdHlwZSA9IHtcbiAgICBnZXRBcmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgIH0sXG4gICAgc2V0QXJnczogZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgfSxcbiAgICBnZXRFdmFsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmFsT3JpZ2luO1xuICAgIH0sXG4gICAgc2V0RXZhbE9yaWdpbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IG5ldyBTdGFja0ZyYW1lKHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpIHx8ICd7YW5vbnltb3VzfSc7XG4gICAgICB2YXIgYXJncyA9ICcoJyArICh0aGlzLmdldEFyZ3MoKSB8fCBbXSkuam9pbignLCcpICsgJyknO1xuICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpID8gJ0AnICsgdGhpcy5nZXRGaWxlTmFtZSgpIDogJyc7XG4gICAgICB2YXIgbGluZU51bWJlciA9IF9pc051bWJlcih0aGlzLmdldExpbmVOdW1iZXIoKSkgPyAnOicgKyB0aGlzLmdldExpbmVOdW1iZXIoKSA6ICcnO1xuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IF9pc051bWJlcih0aGlzLmdldENvbHVtbk51bWJlcigpKSA/ICc6JyArIHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkgOiAnJztcbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyBhcmdzICsgZmlsZU5hbWUgKyBsaW5lTnVtYmVyICsgY29sdW1uTnVtYmVyO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSBfZ2V0dGVyKGJvb2xlYW5Qcm9wc1tpXSk7XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzW3BdID0gQm9vbGVhbih2KTtcbiAgICAgIH07XG4gICAgfShib29sZWFuUHJvcHNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1lcmljUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gX2dldHRlcihudW1lcmljUHJvcHNbal0pO1xuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHAgKyAnIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbcF0gPSBOdW1iZXIodik7XG4gICAgICB9O1xuICAgIH0obnVtZXJpY1Byb3BzW2pdKTtcbiAgfVxuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3RyaW5nUHJvcHMubGVuZ3RoOyBrKyspIHtcbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBfZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKTtcblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpc1twXSA9IFN0cmluZyh2KTtcbiAgICAgIH07XG4gICAgfShzdHJpbmdQcm9wc1trXSk7XG4gIH1cblxuICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pO1xuXG52YXIgXyRlcnJvclN0YWNrUGFyc2VyXzIwID0ge307XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnOyAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdlcnJvci1zdGFjay1wYXJzZXInLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIF8kZXJyb3JTdGFja1BhcnNlcl8yMCA9PT0gJ29iamVjdCcpIHtcbiAgICBfJGVycm9yU3RhY2tQYXJzZXJfMjAgPSBmYWN0b3J5KF8kc3RhY2tmcmFtZV8yMyk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5FcnJvclN0YWNrUGFyc2VyID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrXFw6XFxkKy87XG4gIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTK1xcOlxcZCt8XFwobmF0aXZlXFwpKS9tO1xuICB2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVcXF0pPyQvO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG4gICAgICBpZiAodXJsTGlrZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzpcXDooXFxkKykpPyg/OlxcOihcXGQrKSk/JC87XG4gICAgICB2YXIgcGFydHMgPSByZWdFeHAuZXhlYyh1cmxMaWtlLnJlcGxhY2UoL1tcXChcXCldL2csICcnKSk7XG4gICAgICByZXR1cm4gW3BhcnRzWzFdLCBwYXJ0c1syXSB8fCB1bmRlZmluZWQsIHBhcnRzWzNdIHx8IHVuZGVmaW5lZF07XG4gICAgfSxcbiAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCAnZXZhbCcpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteXFwoKV0qKXwoXFwpXFwsLiokKS9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJyk7IC8vIGNhcHR1cmUgYW5kIHByZXNldmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gXCIoL2Zvby9teSBiYXIuanM6MTI6ODcpXCIgaW5cbiAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7IC8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuXG4gICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgJycpIDogc2FuaXRpemVkTGluZTtcbiAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTsgLy8gaWYgYSBsb2NhdGlvbiB3YXMgbWF0Y2hlZCwgcGFzcyBpdCB0byBleHRyYWN0TG9jYXRpb24oKSBvdGhlcndpc2UgcG9wIHRoZSBsYXN0IHRva2VuXG5cbiAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsb2NhdGlvbiA/IGxvY2F0aW9uWzFdIDogdG9rZW5zLnBvcCgpKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWxcXDpcXGQrXFw6XFxkKy9nLCAnOiQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZS5pbmRleE9mKCdAJykgPT09IC0xICYmIGxpbmUuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgIC8vIFNhZmFyaSBldmFsIGZyYW1lcyBvbmx5IGhhdmUgZnVuY3Rpb24gbmFtZXMgYW5kIG5vdGhpbmcgZWxzZVxuICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lUmVnZXggPSAvKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS87XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBsaW5lLm1hdGNoKGZ1bmN0aW9uTmFtZVJlZ2V4KTtcbiAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxpbmUucmVwbGFjZShmdW5jdGlvbk5hbWVSZWdleCwgJycpKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBwYXJzZU9wZXJhOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhKGUpIHtcbiAgICAgIGlmICghZS5zdGFja3RyYWNlIHx8IGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmIGUubWVzc2FnZS5zcGxpdCgnXFxuJykubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTkoZSk7XG4gICAgICB9IGVsc2UgaWYgKCFlLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlT3BlcmE5OiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhOShlKSB7XG4gICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcbiAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAyLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBwYXJzZU9wZXJhMTA6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMChlKSB7XG4gICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IG1hdGNoWzNdIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLy8gT3BlcmEgMTAuNjUrIEVycm9yLnN0YWNrIHZlcnkgc2ltaWxhciB0byBGRi9TYWZhcmlcbiAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkgJiYgIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICB2YXIgZnVuY3Rpb25DYWxsID0gdG9rZW5zLnNoaWZ0KCkgfHwgJyc7XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGwucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sICckMicpLnJlcGxhY2UoL1xcKFteXFwpXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFyZ3NSYXc7XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteXFwpXSopXFwpLykpIHtcbiAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXlxcKF0rXFwoKFteXFwpXSopXFwpJC8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nID8gdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9O1xufSk7XG5cbnZhciBfJGVycm9yU3RhY2tQYXJzZXJfNyA9IF8kZXJyb3JTdGFja1BhcnNlcl8yMDtcblxuLy8gR2l2ZW4gYGVycmAgd2hpY2ggbWF5IGJlIGFuIGVycm9yLCBkb2VzIGl0IGhhdmUgYSBzdGFjayBwcm9wZXJ0eSB3aGljaCBpcyBhIHN0cmluZz9cbnZhciBfJGhhc1N0YWNrXzkgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHJldHVybiAhIWVyciAmJiAoISFlcnIuc3RhY2sgfHwgISFlcnIuc3RhY2t0cmFjZSB8fCAhIWVyclsnb3BlcmEjc291cmNlbG9jJ10pICYmIHR5cGVvZiAoZXJyLnN0YWNrIHx8IGVyci5zdGFja3RyYWNlIHx8IGVyclsnb3BlcmEjc291cmNlbG9jJ10pID09PSAnc3RyaW5nJyAmJiBlcnIuc3RhY2sgIT09IGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2U7XG59O1xuXG52YXIgXyRqc1J1bnRpbWVfMTIgPSBcInllc1wiID8gJ2Jyb3dzZXJqcycgOiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyA/IHR5cGVvZiBFeHBvICE9PSAndW5kZWZpbmVkJyA/ICdleHBvanMnIDogJ3JlYWN0bmF0aXZlanMnIDogJ25vZGVqcyc7XG5cbnZhciBfJHN0YWNrR2VuZXJhdG9yXzIyID0ge307XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnOyAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdzdGFjay1nZW5lcmF0b3InLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIF8kc3RhY2tHZW5lcmF0b3JfMjIgPT09ICdvYmplY3QnKSB7XG4gICAgXyRzdGFja0dlbmVyYXRvcl8yMiA9IGZhY3RvcnkoXyRzdGFja2ZyYW1lXzIzKTtcbiAgfSBlbHNlIHtcbiAgICByb290LlN0YWNrR2VuZXJhdG9yID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoU3RhY2tGcmFtZSkge1xuICByZXR1cm4ge1xuICAgIGJhY2t0cmFjZTogZnVuY3Rpb24gU3RhY2tHZW5lcmF0b3IkJGJhY2t0cmFjZShvcHRzKSB7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBtYXhTdGFja1NpemUgPSAxMDtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0cy5tYXhTdGFja1NpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFN0YWNrU2l6ZSA9IG9wdHMubWF4U3RhY2tTaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VyciA9IGFyZ3VtZW50cy5jYWxsZWU7XG5cbiAgICAgIHdoaWxlIChjdXJyICYmIHN0YWNrLmxlbmd0aCA8IG1heFN0YWNrU2l6ZSAmJiBjdXJyWydhcmd1bWVudHMnXSkge1xuICAgICAgICAvLyBBbGxvdyBWOCBvcHRpbWl6YXRpb25zXG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGN1cnJbJ2FyZ3VtZW50cyddLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGN1cnJbJ2FyZ3VtZW50cyddW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9mdW5jdGlvbig/OlxccysoW1xcdyRdKykpK1xccypcXCgvLnRlc3QoY3Vyci50b1N0cmluZygpKSkge1xuICAgICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBSZWdFeHAuJDEgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGN1cnIgPSBjdXJyLmNhbGxlcjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG4gIH07XG59KTtcblxuZnVuY3Rpb24gX19fZXh0ZW5kc18yNCgpIHsgX19fZXh0ZW5kc18yNCA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfX19leHRlbmRzXzI0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuLyogcmVtb3ZlZDogdmFyIF8kZXJyb3JTdGFja1BhcnNlcl83ID0gcmVxdWlyZSgnLi9saWIvZXJyb3Itc3RhY2stcGFyc2VyJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRzdGFja0dlbmVyYXRvcl8yMiA9IHJlcXVpcmUoJ3N0YWNrLWdlbmVyYXRvcicpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kaGFzU3RhY2tfOSA9IHJlcXVpcmUoJy4vbGliL2hhcy1zdGFjaycpOyAqLztcblxudmFyIF9fcmVkdWNlXzI0ID0gXyRlc1V0aWxzXzgucmVkdWNlLFxuICAgIF9fZmlsdGVyXzI0ID0gXyRlc1V0aWxzXzguZmlsdGVyO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRqc1J1bnRpbWVfMTIgPSByZXF1aXJlKCcuL2xpYi9qcy1ydW50aW1lJyk7ICovO1xuXG52YXIgQnVnc25hZ1JlcG9ydCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1Z3NuYWdSZXBvcnQoZXJyb3JDbGFzcywgZXJyb3JNZXNzYWdlLCBzdGFja3RyYWNlLCBoYW5kbGVkU3RhdGUsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICBpZiAoc3RhY2t0cmFjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGFja3RyYWNlID0gW107XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZWRTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBoYW5kbGVkU3RhdGUgPSBkZWZhdWx0SGFuZGxlZFN0YXRlKCk7XG4gICAgfVxuXG4gICAgLy8gZHVjay10eXBpbmcgZnR3ID5fPFxuICAgIHRoaXMuX19pc0J1Z3NuYWdSZXBvcnQgPSB0cnVlO1xuICAgIHRoaXMuX2lnbm9yZWQgPSBmYWxzZTsgLy8gcHJpdmF0ZSAodW4paGFuZGxlZCBzdGF0ZVxuXG4gICAgdGhpcy5faGFuZGxlZFN0YXRlID0gaGFuZGxlZFN0YXRlOyAvLyBzZXRhYmxlIHByb3BzXG5cbiAgICB0aGlzLmFwcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJyZWFkY3J1bWJzID0gW107XG4gICAgdGhpcy5jb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGV2aWNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZXJyb3JDbGFzcyA9IHN0cmluZ09yRmFsbGJhY2soZXJyb3JDbGFzcywgJ1tubyBlcnJvciBjbGFzc10nKTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IHN0cmluZ09yRmFsbGJhY2soZXJyb3JNZXNzYWdlLCAnW25vIGVycm9yIG1lc3NhZ2VdJyk7XG4gICAgdGhpcy5ncm91cGluZ0hhc2ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tZXRhRGF0YSA9IHt9O1xuICAgIHRoaXMucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNldmVyaXR5ID0gdGhpcy5faGFuZGxlZFN0YXRlLnNldmVyaXR5O1xuICAgIHRoaXMuc3RhY2t0cmFjZSA9IF9fcmVkdWNlXzI0KHN0YWNrdHJhY2UsIGZ1bmN0aW9uIChhY2N1bSwgZnJhbWUpIHtcbiAgICAgIHZhciBmID0gZm9ybWF0U3RhY2tmcmFtZShmcmFtZSk7IC8vIGRvbid0IGluY2x1ZGUgYSBzdGFja2ZyYW1lIGlmIG5vbmUgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGRlZmluZWRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGYpID09PSAne30nKSByZXR1cm4gYWNjdW07XG4gICAgICAgIHJldHVybiBhY2N1bS5jb25jYXQoZik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdGhpcy51c2VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yOyAvLyBGbGFncy5cbiAgICAvLyBOb3RlIHRoZXNlIGFyZSBub3QgaW5pdGlhbGlzZWQgdW5sZXNzIHRoZXkgYXJlIHVzZWRcbiAgICAvLyB0byBzYXZlIHVubmVjZXNzYXJ5IGJ5dGVzIGluIHRoZSBicm93c2VyIGJ1bmRsZVxuXG4gICAgLyogdGhpcy5hdHRlbXB0SW1tZWRpYXRlRGVsaXZlcnksIGRlZmF1bHQ6IHRydWUgKi9cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCdWdzbmFnUmVwb3J0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaWdub3JlID0gZnVuY3Rpb24gaWdub3JlKCkge1xuICAgIHRoaXMuX2lnbm9yZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5pc0lnbm9yZWQgPSBmdW5jdGlvbiBpc0lnbm9yZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lnbm9yZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZU1ldGFEYXRhID0gZnVuY3Rpb24gdXBkYXRlTWV0YURhdGEoc2VjdGlvbikge1xuICAgIHZhciBfdXBkYXRlcztcblxuICAgIGlmICghc2VjdGlvbikgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHVwZGF0ZXM7IC8vIHVwZGF0ZU1ldGFEYXRhKFwic2VjdGlvblwiLCBudWxsKSAtPiByZW1vdmVzIHNlY3Rpb25cblxuICAgIGlmICgoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdKSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMucmVtb3ZlTWV0YURhdGEoc2VjdGlvbik7IC8vIHVwZGF0ZU1ldGFEYXRhKFwic2VjdGlvblwiLCBcInByb3BlcnR5XCIsIG51bGwpIC0+IHJlbW92ZXMgcHJvcGVydHkgZnJvbSBzZWN0aW9uXG5cbiAgICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSkgPT09IG51bGwpIHJldHVybiB0aGlzLnJlbW92ZU1ldGFEYXRhKHNlY3Rpb24sIGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTsgLy8gbm9ybWFsaXNlIHRoZSB0d28gc3VwcG9ydGVkIGlucHV0IHR5cGVzIGludG8gb2JqZWN0IGZvcm1cblxuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSkgPT09ICdvYmplY3QnKSB1cGRhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXSkgPT09ICdzdHJpbmcnKSB1cGRhdGVzID0gKF91cGRhdGVzID0ge30sIF91cGRhdGVzW2FyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXV0gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0sIF91cGRhdGVzKTsgLy8gZXhpdCBpZiB3ZSBkb24ndCBoYXZlIGFuIHVwZGF0ZXMgb2JqZWN0IGF0IHRoaXMgcG9pbnRcblxuICAgIGlmICghdXBkYXRlcykgcmV0dXJuIHRoaXM7IC8vIGVuc3VyZSBhIHNlY3Rpb24gd2l0aCB0aGlzIG5hbWUgZXhpc3RzXG5cbiAgICBpZiAoIXRoaXMubWV0YURhdGFbc2VjdGlvbl0pIHRoaXMubWV0YURhdGFbc2VjdGlvbl0gPSB7fTsgLy8gbWVyZ2UgdGhlIHVwZGF0ZXMgd2l0aCB0aGUgZXhpc3Rpbmcgc2VjdGlvblxuXG4gICAgdGhpcy5tZXRhRGF0YVtzZWN0aW9uXSA9IF9fX2V4dGVuZHNfMjQoe30sIHRoaXMubWV0YURhdGFbc2VjdGlvbl0sIHVwZGF0ZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVNZXRhRGF0YSA9IGZ1bmN0aW9uIHJlbW92ZU1ldGFEYXRhKHNlY3Rpb24sIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBzZWN0aW9uICE9PSAnc3RyaW5nJykgcmV0dXJuIHRoaXM7IC8vIHJlbW92ZSBhbiBlbnRpcmUgc2VjdGlvblxuXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgZGVsZXRlIHRoaXMubWV0YURhdGFbc2VjdGlvbl07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHJlbW92ZSBhIHNpbmdsZSBwcm9wZXJ0eSBmcm9tIGEgc2VjdGlvblxuXG5cbiAgICBpZiAodGhpcy5tZXRhRGF0YVtzZWN0aW9uXSkge1xuICAgICAgZGVsZXRlIHRoaXMubWV0YURhdGFbc2VjdGlvbl1bcHJvcGVydHldO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF5bG9hZFZlcnNpb246ICc0JyxcbiAgICAgIGV4Y2VwdGlvbnM6IFt7XG4gICAgICAgIGVycm9yQ2xhc3M6IHRoaXMuZXJyb3JDbGFzcyxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIHN0YWNrdHJhY2U6IHRoaXMuc3RhY2t0cmFjZSxcbiAgICAgICAgdHlwZTogXyRqc1J1bnRpbWVfMTJcbiAgICAgIH1dLFxuICAgICAgc2V2ZXJpdHk6IHRoaXMuc2V2ZXJpdHksXG4gICAgICB1bmhhbmRsZWQ6IHRoaXMuX2hhbmRsZWRTdGF0ZS51bmhhbmRsZWQsXG4gICAgICBzZXZlcml0eVJlYXNvbjogdGhpcy5faGFuZGxlZFN0YXRlLnNldmVyaXR5UmVhc29uLFxuICAgICAgYXBwOiB0aGlzLmFwcCxcbiAgICAgIGRldmljZTogdGhpcy5kZXZpY2UsXG4gICAgICBicmVhZGNydW1iczogdGhpcy5icmVhZGNydW1icyxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIHVzZXI6IHRoaXMudXNlcixcbiAgICAgIG1ldGFEYXRhOiB0aGlzLm1ldGFEYXRhLFxuICAgICAgZ3JvdXBpbmdIYXNoOiB0aGlzLmdyb3VwaW5nSGFzaCxcbiAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgIHNlc3Npb246IHRoaXMuc2Vzc2lvblxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEJ1Z3NuYWdSZXBvcnQ7XG59KCk7IC8vIHRha2VzIGEgc3RhY2t0cmFjZS5qcyBzdHlsZSBzdGFja2ZyYW1lIChodHRwczovL2dpdGh1Yi5jb20vc3RhY2t0cmFjZWpzL3N0YWNrZnJhbWUpXG4vLyBhbmQgcmV0dXJucyBhIEJ1Z3NuYWcgY29tcGF0aWJsZSBzdGFja2ZyYW1lIChodHRwczovL2RvY3MuYnVnc25hZy5jb20vYXBpL2Vycm9yLXJlcG9ydGluZy8janNvbi1wYXlsb2FkKVxuXG5cbnZhciBmb3JtYXRTdGFja2ZyYW1lID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gIHZhciBmID0ge1xuICAgIGZpbGU6IGZyYW1lLmZpbGVOYW1lLFxuICAgIG1ldGhvZDogbm9ybWFsaXNlRnVuY3Rpb25OYW1lKGZyYW1lLmZ1bmN0aW9uTmFtZSksXG4gICAgbGluZU51bWJlcjogZnJhbWUubGluZU51bWJlcixcbiAgICBjb2x1bW5OdW1iZXI6IGZyYW1lLmNvbHVtbk51bWJlcixcbiAgICBjb2RlOiB1bmRlZmluZWQsXG4gICAgaW5Qcm9qZWN0OiB1bmRlZmluZWQgLy8gU29tZSBpbnN0YW5jZXMgcmVzdWx0IGluIG5vIGZpbGU6XG4gICAgLy8gLSBjYWxsaW5nIG5vdGlmeSgpIGZyb20gY2hyb21lJ3MgdGVybWluYWwgcmVzdWx0cyBpbiBubyBmaWxlL21ldGhvZC5cbiAgICAvLyAtIG5vbi1lcnJvciBleGNlcHRpb24gdGhyb3duIGZyb20gZ2xvYmFsIGNvZGUgaW4gRkZcbiAgICAvLyBUaGlzIGFkZHMgb25lLlxuXG4gIH07XG5cbiAgaWYgKGYubGluZU51bWJlciA+IC0xICYmICFmLmZpbGUgJiYgIWYubWV0aG9kKSB7XG4gICAgZi5maWxlID0gJ2dsb2JhbCBjb2RlJztcbiAgfVxuXG4gIHJldHVybiBmO1xufTtcblxudmFyIG5vcm1hbGlzZUZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAvXmdsb2JhbCBjb2RlJC9pLnRlc3QobmFtZSkgPyAnZ2xvYmFsIGNvZGUnIDogbmFtZTtcbn07XG5cbnZhciBkZWZhdWx0SGFuZGxlZFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHVuaGFuZGxlZDogZmFsc2UsXG4gICAgc2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgICBzZXZlcml0eVJlYXNvbjoge1xuICAgICAgdHlwZTogJ2hhbmRsZWRFeGNlcHRpb24nXG4gICAgfVxuICB9O1xufTtcblxudmFyIHN0cmluZ09yRmFsbGJhY2sgPSBmdW5jdGlvbiAoc3RyLCBmYWxsYmFjaykge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyID8gc3RyIDogZmFsbGJhY2s7XG59OyAvLyBIZWxwZXJzXG5cblxuQnVnc25hZ1JlcG9ydC5nZXRTdGFja3RyYWNlID0gZnVuY3Rpb24gKGVycm9yLCBlcnJvckZyYW1lc1RvU2tpcCwgZ2VuZXJhdGVkRnJhbWVzVG9Ta2lwKSB7XG4gIGlmIChlcnJvckZyYW1lc1RvU2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgZXJyb3JGcmFtZXNUb1NraXAgPSAwO1xuICB9XG5cbiAgaWYgKGdlbmVyYXRlZEZyYW1lc1RvU2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdGVkRnJhbWVzVG9Ta2lwID0gMDtcbiAgfVxuXG4gIGlmIChfJGhhc1N0YWNrXzkoZXJyb3IpKSByZXR1cm4gXyRlcnJvclN0YWNrUGFyc2VyXzcucGFyc2UoZXJyb3IpLnNsaWNlKGVycm9yRnJhbWVzVG9Ta2lwKTsgLy8gaW4gSUUxMSBhIG5ldyBFcnJvcigpIGRvZXNuJ3QgaGF2ZSBhIHN0YWNrdHJhY2UgdW50aWwgeW91IHRocm93IGl0LCBzbyB0cnkgdGhhdCBoZXJlXG5cbiAgdHJ5IHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChfJGhhc1N0YWNrXzkoZSkpIHJldHVybiBfJGVycm9yU3RhY2tQYXJzZXJfNy5wYXJzZShlcnJvcikuc2xpY2UoMSArIGdlbmVyYXRlZEZyYW1lc1RvU2tpcCk7IC8vIGVycm9yIHdhc24ndCBwcm92aWRlZCBvciBkaWRuJ3QgaGF2ZSBhIHN0YWNrdHJhY2Ugc28gdHJ5IHRvIHdhbGsgdGhlIGNhbGxzdGFja1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBfX2ZpbHRlcl8yNChfJHN0YWNrR2VuZXJhdG9yXzIyLmJhY2t0cmFjZSgpLCBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIChmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrR2VuZXJhdG9yJCQnKSA9PT0gLTE7XG4gICAgICB9KS5zbGljZSgxICsgZ2VuZXJhdGVkRnJhbWVzVG9Ta2lwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59O1xuXG5CdWdzbmFnUmVwb3J0LmVuc3VyZVJlcG9ydCA9IGZ1bmN0aW9uIChyZXBvcnRPckVycm9yLCBlcnJvckZyYW1lc1RvU2tpcCwgZ2VuZXJhdGVkRnJhbWVzVG9Ta2lwKSB7XG4gIGlmIChlcnJvckZyYW1lc1RvU2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgZXJyb3JGcmFtZXNUb1NraXAgPSAwO1xuICB9XG5cbiAgaWYgKGdlbmVyYXRlZEZyYW1lc1RvU2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdGVkRnJhbWVzVG9Ta2lwID0gMDtcbiAgfVxuXG4gIC8vIG5vdGlmeSgpIGNhbiBiZSBjYWxsZWQgd2l0aCBhIFJlcG9ydCBvYmplY3QuIEluIHRoaXMgY2FzZSBubyBhY3Rpb24gaXMgcmVxdWlyZWRcbiAgaWYgKHJlcG9ydE9yRXJyb3IuX19pc0J1Z3NuYWdSZXBvcnQpIHJldHVybiByZXBvcnRPckVycm9yO1xuXG4gIHRyeSB7XG4gICAgdmFyIHN0YWNrdHJhY2UgPSBCdWdzbmFnUmVwb3J0LmdldFN0YWNrdHJhY2UocmVwb3J0T3JFcnJvciwgZXJyb3JGcmFtZXNUb1NraXAsIDEgKyBnZW5lcmF0ZWRGcmFtZXNUb1NraXApO1xuICAgIHJldHVybiBuZXcgQnVnc25hZ1JlcG9ydChyZXBvcnRPckVycm9yLm5hbWUsIHJlcG9ydE9yRXJyb3IubWVzc2FnZSwgc3RhY2t0cmFjZSwgdW5kZWZpbmVkLCByZXBvcnRPckVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgQnVnc25hZ1JlcG9ydChyZXBvcnRPckVycm9yLm5hbWUsIHJlcG9ydE9yRXJyb3IubWVzc2FnZSwgW10sIHVuZGVmaW5lZCwgcmVwb3J0T3JFcnJvcik7XG4gIH1cbn07XG5cbnZhciBfJEJ1Z3NuYWdSZXBvcnRfMjQgPSBCdWdzbmFnUmVwb3J0O1xuXG52YXIgXyRwYWRfMTggPSBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gIHZhciBzID0gJzAwMDAwMDAwMCcgKyBudW07XG4gIHJldHVybiBzLnN1YnN0cihzLmxlbmd0aCAtIHNpemUpO1xufTtcblxuLyogcmVtb3ZlZDogdmFyIF8kcGFkXzE4ID0gcmVxdWlyZSgnLi9wYWQuanMnKTsgKi87XG5cbnZhciBlbnYgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHNlbGY7XG52YXIgZ2xvYmFsQ291bnQgPSAwO1xuXG5mb3IgKHZhciBwcm9wIGluIGVudikge1xuICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZW52LCBwcm9wKSkgZ2xvYmFsQ291bnQrKztcbn1cblxudmFyIG1pbWVUeXBlc0xlbmd0aCA9IG5hdmlnYXRvci5taW1lVHlwZXMgPyBuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aCA6IDA7XG52YXIgY2xpZW50SWQgPSBfJHBhZF8xOCgobWltZVR5cGVzTGVuZ3RoICsgbmF2aWdhdG9yLnVzZXJBZ2VudC5sZW5ndGgpLnRvU3RyaW5nKDM2KSArIGdsb2JhbENvdW50LnRvU3RyaW5nKDM2KSwgNCk7XG5cbnZhciBfJGZpbmdlcnByaW50XzE3ID0gZnVuY3Rpb24gZmluZ2VycHJpbnQoKSB7XG4gIHJldHVybiBjbGllbnRJZDtcbn07XG5cbi8qKlxuICogY3VpZC5qc1xuICogQ29sbGlzaW9uLXJlc2lzdGFudCBVSUQgZ2VuZXJhdG9yIGZvciBicm93c2VycyBhbmQgbm9kZS5cbiAqIFNlcXVlbnRpYWwgZm9yIGZhc3QgZGIgbG9va3VwcyBhbmQgcmVjZW5jeSBzb3J0aW5nLlxuICogU2FmZSBmb3IgZWxlbWVudCBJRHMgYW5kIHNlcnZlci1zaWRlIGxvb2t1cHMuXG4gKlxuICogRXh0cmFjdGVkIGZyb20gQ0xDVFJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEVyaWMgRWxsaW90dCAyMDEyXG4gKiBNSVQgTGljZW5zZVxuICovXG4vKiByZW1vdmVkOiB2YXIgXyRmaW5nZXJwcmludF8xNyA9IHJlcXVpcmUoJy4vbGliL2ZpbmdlcnByaW50LmpzJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRwYWRfMTggPSByZXF1aXJlKCcuL2xpYi9wYWQuanMnKTsgKi87XG5cbnZhciBjID0gMCxcbiAgICBibG9ja1NpemUgPSA0LFxuICAgIGJhc2UgPSAzNixcbiAgICBkaXNjcmV0ZVZhbHVlcyA9IE1hdGgucG93KGJhc2UsIGJsb2NrU2l6ZSk7XG5cbmZ1bmN0aW9uIHJhbmRvbUJsb2NrKCkge1xuICByZXR1cm4gXyRwYWRfMTgoKE1hdGgucmFuZG9tKCkgKiBkaXNjcmV0ZVZhbHVlcyA8PCAwKS50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKTtcbn1cblxuZnVuY3Rpb24gc2FmZUNvdW50ZXIoKSB7XG4gIGMgPSBjIDwgZGlzY3JldGVWYWx1ZXMgPyBjIDogMDtcbiAgYysrOyAvLyB0aGlzIGlzIG5vdCBzdWJsaW1pbmFsXG5cbiAgcmV0dXJuIGMgLSAxO1xufVxuXG5mdW5jdGlvbiBjdWlkKCkge1xuICAvLyBTdGFydGluZyB3aXRoIGEgbG93ZXJjYXNlIGxldHRlciBtYWtlc1xuICAvLyBpdCBIVE1MIGVsZW1lbnQgSUQgZnJpZW5kbHkuXG4gIHZhciBsZXR0ZXIgPSAnYycsXG4gICAgICAvLyBoYXJkLWNvZGVkIGFsbG93cyBmb3Igc2VxdWVudGlhbCBhY2Nlc3NcbiAgLy8gdGltZXN0YW1wXG4gIC8vIHdhcm5pbmc6IHRoaXMgZXhwb3NlcyB0aGUgZXhhY3QgZGF0ZSBhbmQgdGltZVxuICAvLyB0aGF0IHRoZSB1aWQgd2FzIGNyZWF0ZWQuXG4gIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKGJhc2UpLFxuICAgICAgLy8gUHJldmVudCBzYW1lLW1hY2hpbmUgY29sbGlzaW9ucy5cbiAgY291bnRlciA9IF8kcGFkXzE4KHNhZmVDb3VudGVyKCkudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSksXG4gICAgICAvLyBBIGZldyBjaGFycyB0byBnZW5lcmF0ZSBkaXN0aW5jdCBpZHMgZm9yIGRpZmZlcmVudFxuICAvLyBjbGllbnRzIChzbyBkaWZmZXJlbnQgY29tcHV0ZXJzIGFyZSBmYXIgbGVzc1xuICAvLyBsaWtlbHkgdG8gZ2VuZXJhdGUgdGhlIHNhbWUgaWQpXG4gIHByaW50ID0gXyRmaW5nZXJwcmludF8xNygpLFxuICAgICAgLy8gR3JhYiBzb21lIG1vcmUgY2hhcnMgZnJvbSBNYXRoLnJhbmRvbSgpXG4gIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkgKyByYW5kb21CbG9jaygpO1xuICByZXR1cm4gbGV0dGVyICsgdGltZXN0YW1wICsgY291bnRlciArIHByaW50ICsgcmFuZG9tO1xufVxuXG5jdWlkLmZpbmdlcnByaW50ID0gXyRmaW5nZXJwcmludF8xNztcbnZhciBfJGN1aWRfMTYgPSBjdWlkO1xuXG52YXIgX19pc29EYXRlXzI1ID0gXyRlc1V0aWxzXzguaXNvRGF0ZTtcblxuLyogcmVtb3ZlZDogdmFyIF8kY3VpZF8xNiA9IHJlcXVpcmUoJ0BidWdzbmFnL2N1aWQnKTsgKi87XG5cbnZhciBTZXNzaW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Vzc2lvbigpIHtcbiAgICB0aGlzLmlkID0gXyRjdWlkXzE2KCk7XG4gICAgdGhpcy5zdGFydGVkQXQgPSBfX2lzb0RhdGVfMjUoKTtcbiAgICB0aGlzLl9oYW5kbGVkID0gMDtcbiAgICB0aGlzLl91bmhhbmRsZWQgPSAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNlc3Npb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc3RhcnRlZEF0OiB0aGlzLnN0YXJ0ZWRBdCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBoYW5kbGVkOiB0aGlzLl9oYW5kbGVkLFxuICAgICAgICB1bmhhbmRsZWQ6IHRoaXMuX3VuaGFuZGxlZFxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNrRXJyb3IgPSBmdW5jdGlvbiB0cmFja0Vycm9yKHJlcG9ydCkge1xuICAgIHRoaXNbcmVwb3J0Ll9oYW5kbGVkU3RhdGUudW5oYW5kbGVkID8gJ191bmhhbmRsZWQnIDogJ19oYW5kbGVkJ10gKz0gMTtcbiAgfTtcblxuICByZXR1cm4gU2Vzc2lvbjtcbn0oKTtcblxudmFyIF8kU2Vzc2lvbl8yNSA9IFNlc3Npb247XG5cbmZ1bmN0aW9uIF9fX2V4dGVuZHNfNCgpIHsgX19fZXh0ZW5kc180ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9fX2V4dGVuZHNfNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGNvbmZpZ181ID0gcmVxdWlyZSgnLi9jb25maWcnKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJEJ1Z3NuYWdSZXBvcnRfMjQgPSByZXF1aXJlKCcuL3JlcG9ydCcpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kQnVnc25hZ0JyZWFkY3J1bWJfMyA9IHJlcXVpcmUoJy4vYnJlYWRjcnVtYicpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kU2Vzc2lvbl8yNSA9IHJlcXVpcmUoJy4vc2Vzc2lvbicpOyAqLztcblxudmFyIF9fbWFwXzQgPSBfJGVzVXRpbHNfOC5tYXAsXG4gICAgX19pbmNsdWRlc180ID0gXyRlc1V0aWxzXzguaW5jbHVkZXMsXG4gICAgX19pc0FycmF5XzQgPSBfJGVzVXRpbHNfOC5pc0FycmF5O1xuXG4vKiByZW1vdmVkOiB2YXIgXyRpbmZlclJlbGVhc2VTdGFnZV8xMCA9IHJlcXVpcmUoJy4vbGliL2luZmVyLXJlbGVhc2Utc3RhZ2UnKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGlzZXJyb3JfMTEgPSByZXF1aXJlKCcuL2xpYi9pc2Vycm9yJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRhc3luY1NvbWVfNiA9IHJlcXVpcmUoJy4vbGliL2FzeW5jLXNvbWUnKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJHJ1bkJlZm9yZVNlbmRfMTQgPSByZXF1aXJlKCcuL2xpYi9ydW4tYmVmb3JlLXNlbmQnKTsgKi87XG5cbnZhciBMT0dfVVNBR0VfRVJSX1BSRUZJWCA9IFwiVXNhZ2UgZXJyb3IuXCI7XG52YXIgUkVQT1JUX1VTQUdFX0VSUl9QUkVGSVggPSBcIkJ1Z3NuYWcgdXNhZ2UgZXJyb3IuXCI7XG5cbnZhciBCdWdzbmFnQ2xpZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVnc25hZ0NsaWVudChub3RpZmllcikge1xuICAgIGlmICghbm90aWZpZXIgfHwgIW5vdGlmaWVyLm5hbWUgfHwgIW5vdGlmaWVyLnZlcnNpb24gfHwgIW5vdGlmaWVyLnVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbm90aWZpZXJgIGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgfSAvLyBub3RpZmllciBpZFxuXG5cbiAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7IC8vIGNvbmZpZ3VyZSgpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG5vdGlmeSgpXG5cbiAgICB0aGlzLl9jb25maWd1cmVkID0gZmFsc2U7IC8vIGludGlhbGlzZSBvcHRzIGFuZCBjb25maWdcblxuICAgIHRoaXMuX29wdHMgPSB7fTtcbiAgICB0aGlzLmNvbmZpZyA9IHt9OyAvLyAvLyBpL29cblxuICAgIHRoaXMuX2RlbGl2ZXJ5ID0ge1xuICAgICAgc2VuZFNlc3Npb246IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgc2VuZFJlcG9ydDogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIHRoaXMuX2xvZ2dlciA9IHtcbiAgICAgIGRlYnVnOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIGluZm86IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgd2FybjogZnVuY3Rpb24gKCkge30sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKCkge30gLy8gcGx1Z2luc1xuXG4gICAgfTtcbiAgICB0aGlzLl9wbHVnaW5zID0ge307XG4gICAgdGhpcy5fc2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5icmVhZGNydW1icyA9IFtdOyAvLyBzZXRhYmxlIHByb3BzXG5cbiAgICB0aGlzLmFwcCA9IHt9O1xuICAgIHRoaXMuY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRldmljZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1ldGFEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVzZXIgPSB7fTsgLy8gZXhwb3NlIGludGVybmFsIGNvbnN0cnVjdG9yc1xuXG4gICAgdGhpcy5CdWdzbmFnQ2xpZW50ID0gQnVnc25hZ0NsaWVudDtcbiAgICB0aGlzLkJ1Z3NuYWdSZXBvcnQgPSBfJEJ1Z3NuYWdSZXBvcnRfMjQ7XG4gICAgdGhpcy5CdWdzbmFnQnJlYWRjcnVtYiA9IF8kQnVnc25hZ0JyZWFkY3J1bWJfMztcbiAgICB0aGlzLkJ1Z3NuYWdTZXNzaW9uID0gXyRTZXNzaW9uXzI1O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbm90aWZ5ID0gdGhpcy5ub3RpZnk7XG5cbiAgICB0aGlzLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub3RpZnkuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJ1Z3NuYWdDbGllbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgdGhpcy5fb3B0cyA9IF9fX2V4dGVuZHNfNCh7fSwgdGhpcy5fb3B0cywgb3B0cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZShwYXJ0aWFsU2NoZW1hKSB7XG4gICAgaWYgKHBhcnRpYWxTY2hlbWEgPT09IHZvaWQgMCkge1xuICAgICAgcGFydGlhbFNjaGVtYSA9IF8kY29uZmlnXzUuc2NoZW1hO1xuICAgIH1cblxuICAgIHZhciBjb25mID0gXyRjb25maWdfNS5tZXJnZURlZmF1bHRzKHRoaXMuX29wdHMsIHBhcnRpYWxTY2hlbWEpO1xuICAgIHZhciB2YWxpZGl0eSA9IF8kY29uZmlnXzUudmFsaWRhdGUoY29uZiwgcGFydGlhbFNjaGVtYSk7XG4gICAgaWYgKCF2YWxpZGl0eS52YWxpZCA9PT0gdHJ1ZSkgdGhyb3cgbmV3IEVycm9yKGdlbmVyYXRlQ29uZmlnRXJyb3JNZXNzYWdlKHZhbGlkaXR5LmVycm9ycykpOyAvLyB1cGRhdGUgYW5kIGVsZXZhdGUgc29tZSBzcGVjaWFsIG9wdGlvbnMgaWYgdGhleSB3ZXJlIHBhc3NlZCBpbiBhdCB0aGlzIHBvaW50XG5cbiAgICBpZiAodHlwZW9mIGNvbmYuYmVmb3JlU2VuZCA9PT0gJ2Z1bmN0aW9uJykgY29uZi5iZWZvcmVTZW5kID0gW2NvbmYuYmVmb3JlU2VuZF07XG4gICAgaWYgKGNvbmYuYXBwVmVyc2lvbikgdGhpcy5hcHAudmVyc2lvbiA9IGNvbmYuYXBwVmVyc2lvbjtcbiAgICBpZiAoY29uZi5hcHBUeXBlKSB0aGlzLmFwcC50eXBlID0gY29uZi5hcHBUeXBlO1xuICAgIGlmIChjb25mLm1ldGFEYXRhKSB0aGlzLm1ldGFEYXRhID0gY29uZi5tZXRhRGF0YTtcbiAgICBpZiAoY29uZi51c2VyKSB0aGlzLnVzZXIgPSBjb25mLnVzZXI7XG4gICAgaWYgKGNvbmYubG9nZ2VyKSB0aGlzLmxvZ2dlcihjb25mLmxvZ2dlcik7IC8vIG1lcmdlIHdpdGggZXhpc3RpbmcgY29uZmlnXG5cbiAgICB0aGlzLmNvbmZpZyA9IF9fX2V4dGVuZHNfNCh7fSwgdGhpcy5jb25maWcsIGNvbmYpO1xuICAgIHRoaXMuX2NvbmZpZ3VyZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UocGx1Z2luKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWd1cmVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBub3QgY29uZmlndXJlZCcpO1xuICAgIGlmIChwbHVnaW4uY29uZmlnU2NoZW1hKSB0aGlzLmNvbmZpZ3VyZShwbHVnaW4uY29uZmlnU2NoZW1hKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBwbHVnaW4uaW5pdC5hcHBseShwbHVnaW4sIFt0aGlzXS5jb25jYXQoYXJncykpOyAvLyBKUyBvYmplY3RzIGFyZSBub3QgdGhlIHNhZmVzdCB3YXkgdG8gc3RvcmUgYXJiaXRyYXJpbHkga2V5ZWQgdmFsdWVzLFxuICAgIC8vIHNvIGJvb2tlbmQgdGhlIGtleSB3aXRoIHNvbWUgY2hhcmFjdGVycyB0aGF0IHByZXZlbnQgdGFtcGVyaW5nIHdpdGhcbiAgICAvLyBzdHVmZiBsaWtlIF9fcHJvdG9fXyBldGMuIChvbmx5IHN0b3JlIHRoZSByZXN1bHQgaWYgdGhlIHBsdWdpbiBoYWQgYVxuICAgIC8vIG5hbWUpXG5cbiAgICBpZiAocGx1Z2luLm5hbWUpIHRoaXMuX3BsdWdpbnNbXCJ+XCIgKyBwbHVnaW4ubmFtZSArIFwiflwiXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0UGx1Z2luID0gZnVuY3Rpb24gZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2luc1tcIn5cIiArIG5hbWUgKyBcIn5cIl07XG4gIH07XG5cbiAgX3Byb3RvLmRlbGl2ZXJ5ID0gZnVuY3Rpb24gZGVsaXZlcnkoZCkge1xuICAgIHRoaXMuX2RlbGl2ZXJ5ID0gZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ubG9nZ2VyID0gZnVuY3Rpb24gbG9nZ2VyKGwsIHNpZCkge1xuICAgIHRoaXMuX2xvZ2dlciA9IGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnNlc3Npb25EZWxlZ2F0ZSA9IGZ1bmN0aW9uIHNlc3Npb25EZWxlZ2F0ZShzKSB7XG4gICAgdGhpcy5fc2Vzc2lvbkRlbGVnYXRlID0gcztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRTZXNzaW9uID0gZnVuY3Rpb24gc3RhcnRTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5fc2Vzc2lvbkRlbGVnYXRlKSB7XG4gICAgICB0aGlzLl9sb2dnZXIud2FybignTm8gc2Vzc2lvbiBpbXBsZW1lbnRhdGlvbiBpcyBpbnN0YWxsZWQnKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZWxlZ2F0ZS5zdGFydFNlc3Npb24odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmxlYXZlQnJlYWRjcnVtYiA9IGZ1bmN0aW9uIGxlYXZlQnJlYWRjcnVtYihuYW1lLCBtZXRhRGF0YSwgdHlwZSwgdGltZXN0YW1wKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWd1cmVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBub3QgY29uZmlndXJlZCcpOyAvLyBjb2VyY2UgYmFkIHZhbHVlcyBzbyB0aGF0IHRoZSBkZWZhdWx0cyBnZXQgc2V0XG5cbiAgICBuYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG4gICAgdHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB1bmRlZmluZWQ7XG4gICAgdGltZXN0YW1wID0gdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ3N0cmluZycgPyB0aW1lc3RhbXAgOiB1bmRlZmluZWQ7XG4gICAgbWV0YURhdGEgPSB0eXBlb2YgbWV0YURhdGEgPT09ICdvYmplY3QnICYmIG1ldGFEYXRhICE9PSBudWxsID8gbWV0YURhdGEgOiB1bmRlZmluZWQ7IC8vIGlmIG5vIG5hbWUgYW5kIG5vIG1ldGFEYXRhLCB1c2VmdWxuZXNzIG9mIHRoaXMgY3J1bWIgaXMgcXVlc3Rpb25hYmxlIGF0IGJlc3Qgc28gZGlzY2FyZFxuXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyAmJiAhbWV0YURhdGEpIHJldHVybjtcbiAgICB2YXIgY3J1bWIgPSBuZXcgXyRCdWdzbmFnQnJlYWRjcnVtYl8zKG5hbWUsIG1ldGFEYXRhLCB0eXBlLCB0aW1lc3RhbXApOyAvLyBwdXNoIHRoZSB2YWxpZCBjcnVtYiBvbnRvIHRoZSBxdWV1ZSBhbmQgbWFpbnRhaW4gdGhlIGxlbmd0aFxuXG4gICAgdGhpcy5icmVhZGNydW1icy5wdXNoKGNydW1iKTtcblxuICAgIGlmICh0aGlzLmJyZWFkY3J1bWJzLmxlbmd0aCA+IHRoaXMuY29uZmlnLm1heEJyZWFkY3J1bWJzKSB7XG4gICAgICB0aGlzLmJyZWFkY3J1bWJzID0gdGhpcy5icmVhZGNydW1icy5zbGljZSh0aGlzLmJyZWFkY3J1bWJzLmxlbmd0aCAtIHRoaXMuY29uZmlnLm1heEJyZWFkY3J1bWJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KGVycm9yLCBvcHRzLCBjYikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGNiID09PSB2b2lkIDApIHtcbiAgICAgIGNiID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jb25maWd1cmVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBub3QgY29uZmlndXJlZCcpOyAvLyByZWxlYXNlU3RhZ2UgY2FuIGJlIHNldCB2aWEgY29uZmlnLnJlbGVhc2VTdGFnZSBvciBjbGllbnQuYXBwLnJlbGVhc2VTdGFnZVxuXG4gICAgdmFyIHJlbGVhc2VTdGFnZSA9IF8kaW5mZXJSZWxlYXNlU3RhZ2VfMTAodGhpcyk7IC8vIGVuc3VyZSB3ZSBoYXZlIGFuIGVycm9yIChvciBhIHJlYXNvbmFibGUgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGVycm9yKVxuXG4gICAgdmFyIF9ub3JtYWxpc2VFcnJvciA9IG5vcm1hbGlzZUVycm9yKGVycm9yLCBvcHRzLCB0aGlzLl9sb2dnZXIpLFxuICAgICAgICBlcnIgPSBfbm9ybWFsaXNlRXJyb3IuZXJyLFxuICAgICAgICBlcnJvckZyYW1lc1RvU2tpcCA9IF9ub3JtYWxpc2VFcnJvci5lcnJvckZyYW1lc1RvU2tpcCxcbiAgICAgICAgX29wdHMgPSBfbm9ybWFsaXNlRXJyb3IuX29wdHM7XG5cbiAgICBpZiAoX29wdHMpIG9wdHMgPSBfb3B0czsgLy8gZW5zdXJlIG9wdHMgaXMgYW4gb2JqZWN0XG5cbiAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8IG9wdHMgPT09IG51bGwpIG9wdHMgPSB7fTsgLy8gY3JlYXRlIGEgcmVwb3J0IGZyb20gdGhlIGVycm9yLCBpZiBpdCBpc24ndCBvbmUgYWxyZWFkeVxuXG4gICAgdmFyIHJlcG9ydCA9IF8kQnVnc25hZ1JlcG9ydF8yNC5lbnN1cmVSZXBvcnQoZXJyLCBlcnJvckZyYW1lc1RvU2tpcCwgMik7XG4gICAgcmVwb3J0LmFwcCA9IF9fX2V4dGVuZHNfNCh7fSwge1xuICAgICAgcmVsZWFzZVN0YWdlOiByZWxlYXNlU3RhZ2VcbiAgICB9LCByZXBvcnQuYXBwLCB0aGlzLmFwcCk7XG4gICAgcmVwb3J0LmNvbnRleHQgPSByZXBvcnQuY29udGV4dCB8fCBvcHRzLmNvbnRleHQgfHwgdGhpcy5jb250ZXh0IHx8IHVuZGVmaW5lZDtcbiAgICByZXBvcnQuZGV2aWNlID0gX19fZXh0ZW5kc180KHt9LCByZXBvcnQuZGV2aWNlLCB0aGlzLmRldmljZSwgb3B0cy5kZXZpY2UpO1xuICAgIHJlcG9ydC5yZXF1ZXN0ID0gX19fZXh0ZW5kc180KHt9LCByZXBvcnQucmVxdWVzdCwgdGhpcy5yZXF1ZXN0LCBvcHRzLnJlcXVlc3QpO1xuICAgIHJlcG9ydC51c2VyID0gX19fZXh0ZW5kc180KHt9LCByZXBvcnQudXNlciwgdGhpcy51c2VyLCBvcHRzLnVzZXIpO1xuICAgIHJlcG9ydC5tZXRhRGF0YSA9IF9fX2V4dGVuZHNfNCh7fSwgcmVwb3J0Lm1ldGFEYXRhLCB0aGlzLm1ldGFEYXRhLCBvcHRzLm1ldGFEYXRhKTtcbiAgICByZXBvcnQuYnJlYWRjcnVtYnMgPSB0aGlzLmJyZWFkY3J1bWJzLnNsaWNlKDApO1xuXG4gICAgaWYgKHRoaXMuX3Nlc3Npb24pIHtcbiAgICAgIHRoaXMuX3Nlc3Npb24udHJhY2tFcnJvcihyZXBvcnQpO1xuXG4gICAgICByZXBvcnQuc2Vzc2lvbiA9IHRoaXMuX3Nlc3Npb247XG4gICAgfSAvLyBzZXQgc2V2ZXJpdHkgaWYgc3VwcGxpZWRcblxuXG4gICAgaWYgKG9wdHMuc2V2ZXJpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVwb3J0LnNldmVyaXR5ID0gb3B0cy5zZXZlcml0eTtcbiAgICAgIHJlcG9ydC5faGFuZGxlZFN0YXRlLnNldmVyaXR5UmVhc29uID0ge1xuICAgICAgICB0eXBlOiAndXNlclNwZWNpZmllZFNldmVyaXR5J1xuICAgICAgfTtcbiAgICB9IC8vIGV4aXQgZWFybHkgaWYgdGhlIHJlcG9ydHMgc2hvdWxkIG5vdCBiZSBzZW50IG9uIHRoZSBjdXJyZW50IHJlbGVhc2VTdGFnZVxuXG5cbiAgICBpZiAoX19pc0FycmF5XzQodGhpcy5jb25maWcubm90aWZ5UmVsZWFzZVN0YWdlcykgJiYgIV9faW5jbHVkZXNfNCh0aGlzLmNvbmZpZy5ub3RpZnlSZWxlYXNlU3RhZ2VzLCByZWxlYXNlU3RhZ2UpKSB7XG4gICAgICB0aGlzLl9sb2dnZXIud2FybihcIlJlcG9ydCBub3Qgc2VudCBkdWUgdG8gcmVsZWFzZVN0YWdlL25vdGlmeVJlbGVhc2VTdGFnZXMgY29uZmlndXJhdGlvblwiKTtcblxuICAgICAgcmV0dXJuIGNiKG51bGwsIHJlcG9ydCk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsU2V2ZXJpdHkgPSByZXBvcnQuc2V2ZXJpdHk7XG4gICAgdmFyIGJlZm9yZVNlbmQgPSBbXS5jb25jYXQob3B0cy5iZWZvcmVTZW5kKS5jb25jYXQodGhpcy5jb25maWcuYmVmb3JlU2VuZCk7XG5cbiAgICB2YXIgb25CZWZvcmVTZW5kRXJyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihcIkVycm9yIG9jY3VycmVkIGluIGJlZm9yZVNlbmQgY2FsbGJhY2ssIGNvbnRpbnVpbmcgYW55d2F5XFx1MjAyNlwiKTtcblxuICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBfJGFzeW5jU29tZV82KGJlZm9yZVNlbmQsIF8kcnVuQmVmb3JlU2VuZF8xNChyZXBvcnQsIG9uQmVmb3JlU2VuZEVyciksIGZ1bmN0aW9uIChlcnIsIHByZXZlbnRTZW5kKSB7XG4gICAgICBpZiAoZXJyKSBvbkJlZm9yZVNlbmRFcnIoZXJyKTtcblxuICAgICAgaWYgKHByZXZlbnRTZW5kKSB7XG4gICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJSZXBvcnQgbm90IHNlbnQgZHVlIHRvIGJlZm9yZVNlbmQgY2FsbGJhY2tcIik7XG5cbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlcG9ydCk7XG4gICAgICB9IC8vIG9ubHkgbGVhdmUgYSBjcnVtYiBmb3IgdGhlIGVycm9yIGlmIGFjdHVhbGx5IGdvdCBzZW50XG5cblxuICAgICAgaWYgKF90aGlzLmNvbmZpZy5hdXRvQnJlYWRjcnVtYnMpIHtcbiAgICAgICAgX3RoaXMubGVhdmVCcmVhZGNydW1iKHJlcG9ydC5lcnJvckNsYXNzLCB7XG4gICAgICAgICAgZXJyb3JDbGFzczogcmVwb3J0LmVycm9yQ2xhc3MsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiByZXBvcnQuZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIHNldmVyaXR5OiByZXBvcnQuc2V2ZXJpdHlcbiAgICAgICAgfSwgJ2Vycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmlnaW5hbFNldmVyaXR5ICE9PSByZXBvcnQuc2V2ZXJpdHkpIHtcbiAgICAgICAgcmVwb3J0Ll9oYW5kbGVkU3RhdGUuc2V2ZXJpdHlSZWFzb24gPSB7XG4gICAgICAgICAgdHlwZTogJ3VzZXJDYWxsYmFja1NldFNldmVyaXR5J1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fZGVsaXZlcnkuc2VuZFJlcG9ydCh7XG4gICAgICAgIGFwaUtleTogcmVwb3J0LmFwaUtleSB8fCBfdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICBub3RpZmllcjogX3RoaXMubm90aWZpZXIsXG4gICAgICAgIGV2ZW50czogW3JlcG9ydF1cbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVyciwgcmVwb3J0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBCdWdzbmFnQ2xpZW50O1xufSgpO1xuXG52YXIgbm9ybWFsaXNlRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIG9wdHMsIGxvZ2dlcikge1xuICB2YXIgc3ludGhlc2l6ZWRFcnJvckZyYW1lc1RvU2tpcCA9IDM7XG5cbiAgdmFyIGNyZWF0ZUFuZExvZ1VzYWdlRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIG1zZyA9IGdlbmVyYXRlTm90aWZ5VXNhZ2VNZXNzYWdlKHJlYXNvbik7XG4gICAgbG9nZ2VyLndhcm4oTE9HX1VTQUdFX0VSUl9QUkVGSVggKyBcIiBcIiArIG1zZyk7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihSRVBPUlRfVVNBR0VfRVJSX1BSRUZJWCArIFwiIFwiICsgbXNnKTtcbiAgfTtcblxuICB2YXIgZXJyO1xuICB2YXIgZXJyb3JGcmFtZXNUb1NraXAgPSAwO1xuXG4gIHZhciBfb3B0cztcblxuICBzd2l0Y2ggKHR5cGVvZiBlcnJvcikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIOKJpHYzIHVzZWQgdG8gaGF2ZSBhIG5vdGlmeSgnRXJyb3JOYW1lJywgJ0Vycm9yIG1lc3NhZ2UnKSBpbnRlcmZhY2VcbiAgICAgICAgLy8gcmVwb3J0IHVzYWdlL2RlcHJlY2F0aW9uIGVycm9ycyBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBsaWtlIHRoYXRcbiAgICAgICAgZXJyID0gY3JlYXRlQW5kTG9nVXNhZ2VFcnJvcignc3RyaW5nL3N0cmluZycpO1xuICAgICAgICBfb3B0cyA9IHtcbiAgICAgICAgICBtZXRhRGF0YToge1xuICAgICAgICAgICAgbm90aWZpZXI6IHtcbiAgICAgICAgICAgICAgbm90aWZ5QXJnczogW2Vycm9yLCBvcHRzXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgZXJyb3JGcmFtZXNUb1NraXAgPSBzeW50aGVzaXplZEVycm9yRnJhbWVzVG9Ta2lwO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGVyciA9IGNyZWF0ZUFuZExvZ1VzYWdlRXJyb3IoJ2Z1bmN0aW9uJyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgKF8kaXNlcnJvcl8xMShlcnJvcikgfHwgZXJyb3IuX19pc0J1Z3NuYWdSZXBvcnQpKSB7XG4gICAgICAgIGVyciA9IGVycm9yO1xuICAgICAgfSBlbHNlIGlmIChlcnJvciAhPT0gbnVsbCAmJiBoYXNOZWNlc3NhcnlGaWVsZHMoZXJyb3IpKSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8IGVycm9yLmVycm9yTWVzc2FnZSk7XG4gICAgICAgIGVyci5uYW1lID0gZXJyb3IubmFtZSB8fCBlcnJvci5lcnJvckNsYXNzO1xuICAgICAgICBlcnJvckZyYW1lc1RvU2tpcCA9IHN5bnRoZXNpemVkRXJyb3JGcmFtZXNUb1NraXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBjcmVhdGVBbmRMb2dVc2FnZUVycm9yKGVycm9yID09PSBudWxsID8gJ251bGwnIDogJ3Vuc3VwcG9ydGVkIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnIgPSBjcmVhdGVBbmRMb2dVc2FnZUVycm9yKCdub3RoaW5nJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVycjogZXJyLFxuICAgIGVycm9yRnJhbWVzVG9Ta2lwOiBlcnJvckZyYW1lc1RvU2tpcCxcbiAgICBfb3B0czogX29wdHNcbiAgfTtcbn07XG5cbnZhciBoYXNOZWNlc3NhcnlGaWVsZHMgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgcmV0dXJuICh0eXBlb2YgZXJyb3IubmFtZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVycm9yLmVycm9yQ2xhc3MgPT09ICdzdHJpbmcnKSAmJiAodHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlcnJvci5lcnJvck1lc3NhZ2UgPT09ICdzdHJpbmcnKTtcbn07XG5cbnZhciBnZW5lcmF0ZUNvbmZpZ0Vycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgcmV0dXJuIFwiQnVnc25hZyBjb25maWd1cmF0aW9uIGVycm9yXFxuXCIgKyBfX21hcF80KGVycm9ycywgZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBcIlxcXCJcIiArIGVyci5rZXkgKyBcIlxcXCIgXCIgKyBlcnIubWVzc2FnZSArIFwiIFxcbiAgICBnb3QgXCIgKyBzdHJpbmdpZnkoZXJyLnZhbHVlKTtcbiAgfSkuam9pbignXFxuXFxuJyk7XG59O1xuXG52YXIgZ2VuZXJhdGVOb3RpZnlVc2FnZU1lc3NhZ2UgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gIHJldHVybiBcIm5vdGlmeSgpIGV4cGVjdGVkIGVycm9yL29wdHMgcGFyYW1ldGVycywgZ290IFwiICsgYWN0dWFsO1xufTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6IFN0cmluZyh2YWwpO1xufTtcblxudmFyIF8kQnVnc25hZ0NsaWVudF80ID0gQnVnc25hZ0NsaWVudDtcblxudmFyIF8kc2FmZUpzb25TdHJpbmdpZnlfMTkgPSBmdW5jdGlvbiAoZGF0YSwgcmVwbGFjZXIsIHNwYWNlLCBvcHRzKSB7XG4gIHZhciBmaWx0ZXJLZXlzID0gb3B0cyAmJiBvcHRzLmZpbHRlcktleXMgPyBvcHRzLmZpbHRlcktleXMgOiBbXTtcbiAgdmFyIGZpbHRlclBhdGhzID0gb3B0cyAmJiBvcHRzLmZpbHRlclBhdGhzID8gb3B0cy5maWx0ZXJQYXRocyA6IFtdO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJlcGFyZU9iakZvclNlcmlhbGl6YXRpb24oZGF0YSwgZmlsdGVyS2V5cywgZmlsdGVyUGF0aHMpLCByZXBsYWNlciwgc3BhY2UpO1xufTtcblxudmFyIE1BWF9ERVBUSCA9IDIwO1xudmFyIE1BWF9FREdFUyA9IDI1MDAwO1xudmFyIE1JTl9QUkVTRVJWRURfREVQVEggPSA4O1xudmFyIFJFUExBQ0VNRU5UX05PREUgPSAnLi4uJztcblxuZnVuY3Rpb24gX19pc0Vycm9yXzE5KG8pIHtcbiAgcmV0dXJuIG8gaW5zdGFuY2VvZiBFcnJvciB8fCAvXlxcW29iamVjdCAoRXJyb3J8KERvbSk/RXhjZXB0aW9uKVxcXSQvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dzTWVzc2FnZShlcnIpIHtcbiAgcmV0dXJuICdbVGhyb3dzOiAnICsgKGVyciA/IGVyci5tZXNzYWdlIDogJz8nKSArICddJztcbn1cblxuZnVuY3Rpb24gZmluZChoYXlzdGFjaywgbmVlZGxlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoYXlzdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChoYXlzdGFja1tpXSA9PT0gbmVlZGxlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgYHBhdGhgIHN0YXJ0cyB3aXRoIGFueSBvZiB0aGUgcHJvdmlkZWQgYHBhdGhzYFxuXG5cbmZ1bmN0aW9uIGlzRGVzY2VuZGVudChwYXRocywgcGF0aCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocGF0aC5pbmRleE9mKHBhdGhzW2ldKSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEZpbHRlcihwYXR0ZXJucywga2V5KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXR0ZXJucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybnNbaV0gPT09ICdzdHJpbmcnICYmIHBhdHRlcm5zW2ldID09PSBrZXkpIHJldHVybiB0cnVlO1xuICAgIGlmIChwYXR0ZXJuc1tpXSAmJiB0eXBlb2YgcGF0dGVybnNbaV0udGVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXR0ZXJuc1tpXS50ZXN0KGtleSkpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfX2lzQXJyYXlfMTkob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZnVuY3Rpb24gc2FmZWx5R2V0UHJvcChvYmosIHByb3ApIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqW3Byb3BdO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhyb3dzTWVzc2FnZShlcnIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVPYmpGb3JTZXJpYWxpemF0aW9uKG9iaiwgZmlsdGVyS2V5cywgZmlsdGVyUGF0aHMpIHtcbiAgdmFyIHNlZW4gPSBbXTsgLy8gc3RvcmUgcmVmZXJlbmNlcyB0byBvYmplY3RzIHdlIGhhdmUgc2VlbiBiZWZvcmVcblxuICB2YXIgZWRnZXMgPSAwO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG9iaiwgcGF0aCkge1xuICAgIGZ1bmN0aW9uIGVkZ2VzRXhjZWVkZWQoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBNSU5fUFJFU0VSVkVEX0RFUFRIICYmIGVkZ2VzID4gTUFYX0VER0VTO1xuICAgIH1cblxuICAgIGVkZ2VzKys7XG4gICAgaWYgKHBhdGgubGVuZ3RoID4gTUFYX0RFUFRIKSByZXR1cm4gUkVQTEFDRU1FTlRfTk9ERTtcbiAgICBpZiAoZWRnZXNFeGNlZWRlZCgpKSByZXR1cm4gUkVQTEFDRU1FTlRfTk9ERTtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gb2JqO1xuICAgIGlmIChmaW5kKHNlZW4sIG9iaikpIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgc2Vlbi5wdXNoKG9iaik7XG5cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHdlJ3JlIG5vdCBnb2luZyB0byBjb3VudCB0aGlzIGFzIGFuIGVkZ2UgYmVjYXVzZSBpdFxuICAgICAgICAvLyByZXBsYWNlcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnRseSB2aXNpdGVkIG9iamVjdFxuICAgICAgICBlZGdlcy0tO1xuICAgICAgICB2YXIgZlJlc3VsdCA9IHZpc2l0KG9iai50b0pTT04oKSwgcGF0aCk7XG4gICAgICAgIHNlZW4ucG9wKCk7XG4gICAgICAgIHJldHVybiBmUmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aHJvd3NNZXNzYWdlKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVyID0gX19pc0Vycm9yXzE5KG9iaik7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVkZ2VzLS07XG4gICAgICB2YXIgZVJlc3VsdCA9IHZpc2l0KHtcbiAgICAgICAgbmFtZTogb2JqLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IG9iai5tZXNzYWdlXG4gICAgICB9LCBwYXRoKTtcbiAgICAgIHNlZW4ucG9wKCk7XG4gICAgICByZXR1cm4gZVJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoX19pc0FycmF5XzE5KG9iaikpIHtcbiAgICAgIHZhciBhUmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGVkZ2VzRXhjZWVkZWQoKSkge1xuICAgICAgICAgIGFSZXN1bHQucHVzaChSRVBMQUNFTUVOVF9OT0RFKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGFSZXN1bHQucHVzaCh2aXNpdChvYmpbaV0sIHBhdGguY29uY2F0KCdbXScpKSk7XG4gICAgICB9XG5cbiAgICAgIHNlZW4ucG9wKCk7XG4gICAgICByZXR1cm4gYVJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKGlzRGVzY2VuZGVudChmaWx0ZXJQYXRocywgcGF0aC5qb2luKCcuJykpICYmIHNob3VsZEZpbHRlcihmaWx0ZXJLZXlzLCBwcm9wKSkge1xuICAgICAgICAgIHJlc3VsdFtwcm9wXSA9ICdbRmlsdGVyZWRdJztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlc0V4Y2VlZGVkKCkpIHtcbiAgICAgICAgICByZXN1bHRbcHJvcF0gPSBSRVBMQUNFTUVOVF9OT0RFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W3Byb3BdID0gdmlzaXQoc2FmZWx5R2V0UHJvcChvYmosIHByb3ApLCBwYXRoLmNvbmNhdChwcm9wKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHNlZW4ucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiB2aXNpdChvYmosIFtdKTtcbn1cblxudmFyIF8kanNvblBheWxvYWRfMTMgPSB7fTtcbi8qIHJlbW92ZWQ6IHZhciBfJHNhZmVKc29uU3RyaW5naWZ5XzE5ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvc2FmZS1qc29uLXN0cmluZ2lmeScpOyAqLztcblxudmFyIFJFUE9SVF9GSUxURVJfUEFUSFMgPSBbJ2V2ZW50cy5bXS5hcHAnLCAnZXZlbnRzLltdLm1ldGFEYXRhJywgJ2V2ZW50cy5bXS51c2VyJywgJ2V2ZW50cy5bXS5icmVhZGNydW1icycsICdldmVudHMuW10ucmVxdWVzdCcsICdldmVudHMuW10uZGV2aWNlJ107XG52YXIgU0VTU0lPTl9GSUxURVJfUEFUSFMgPSBbJ2RldmljZScsICdhcHAnLCAndXNlciddO1xuXG5fJGpzb25QYXlsb2FkXzEzLnJlcG9ydCA9IGZ1bmN0aW9uIChyZXBvcnQsIGZpbHRlcktleXMpIHtcbiAgdmFyIHBheWxvYWQgPSBfJHNhZmVKc29uU3RyaW5naWZ5XzE5KHJlcG9ydCwgbnVsbCwgbnVsbCwge1xuICAgIGZpbHRlclBhdGhzOiBSRVBPUlRfRklMVEVSX1BBVEhTLFxuICAgIGZpbHRlcktleXM6IGZpbHRlcktleXNcbiAgfSk7XG5cbiAgaWYgKHBheWxvYWQubGVuZ3RoID4gMTBlNSkge1xuICAgIGRlbGV0ZSByZXBvcnQuZXZlbnRzWzBdLm1ldGFEYXRhO1xuICAgIHJlcG9ydC5ldmVudHNbMF0ubWV0YURhdGEgPSB7XG4gICAgICBub3RpZmllcjogXCJXQVJOSU5HIVxcblNlcmlhbGl6ZWQgcGF5bG9hZCB3YXMgXCIgKyBwYXlsb2FkLmxlbmd0aCAvIDEwZTUgKyBcIk1CIChsaW1pdCA9IDFNQilcXG5tZXRhRGF0YSB3YXMgcmVtb3ZlZFwiXG4gICAgfTtcbiAgICBwYXlsb2FkID0gXyRzYWZlSnNvblN0cmluZ2lmeV8xOShyZXBvcnQsIG51bGwsIG51bGwsIHtcbiAgICAgIGZpbHRlclBhdGhzOiBSRVBPUlRfRklMVEVSX1BBVEhTLFxuICAgICAgZmlsdGVyS2V5czogZmlsdGVyS2V5c1xuICAgIH0pO1xuICAgIGlmIChwYXlsb2FkLmxlbmd0aCA+IDEwZTUpIHRocm93IG5ldyBFcnJvcigncGF5bG9hZCBleGNlZWRlZCAxTUIgbGltaXQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXlsb2FkO1xufTtcblxuXyRqc29uUGF5bG9hZF8xMy5zZXNzaW9uID0gZnVuY3Rpb24gKHJlcG9ydCwgZmlsdGVyS2V5cykge1xuICB2YXIgcGF5bG9hZCA9IF8kc2FmZUpzb25TdHJpbmdpZnlfMTkocmVwb3J0LCBudWxsLCBudWxsLCB7XG4gICAgZmlsdGVyUGF0aHM6IFNFU1NJT05fRklMVEVSX1BBVEhTLFxuICAgIGZpbHRlcktleXM6IGZpbHRlcktleXNcbiAgfSk7XG4gIGlmIChwYXlsb2FkLmxlbmd0aCA+IDEwZTUpIHRocm93IG5ldyBFcnJvcigncGF5bG9hZCBleGNlZWRlZCAxTUIgbGltaXQnKTtcbiAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG52YXIgXyRkZWxpdmVyeV8yNiA9IHt9O1xudmFyIF90aGlzID0gdGhpcztcblxuLyogcmVtb3ZlZDogdmFyIF8kanNvblBheWxvYWRfMTMgPSByZXF1aXJlKCdAYnVnc25hZy9jb3JlL2xpYi9qc29uLXBheWxvYWQnKTsgKi87XG5cbnZhciBfX2lzb0RhdGVfMjYgPSBfJGVzVXRpbHNfOC5pc29EYXRlO1xuXG5fJGRlbGl2ZXJ5XzI2ID0gZnVuY3Rpb24gKGNsaWVudCwgd2luKSB7XG4gIGlmICh3aW4gPT09IHZvaWQgMCkge1xuICAgIHdpbiA9IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VuZFJlcG9ydDogZnVuY3Rpb24gKHJlcG9ydCwgY2IpIHtcbiAgICAgIGlmIChjYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNiID0gZnVuY3Rpb24gKCkge307XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmwgPSBnZXRBcGlVcmwoY2xpZW50LmNvbmZpZywgJ25vdGlmeScsICc0Jywgd2luKTtcbiAgICAgIHZhciByZXEgPSBuZXcgd2luLlhEb21haW5SZXF1ZXN0KCk7XG5cbiAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiKG51bGwpO1xuICAgICAgfTtcblxuICAgICAgcmVxLm9wZW4oJ1BPU1QnLCB1cmwpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVxLnNlbmQoXyRqc29uUGF5bG9hZF8xMy5yZXBvcnQocmVwb3J0LCBjbGllbnQuY29uZmlnLmZpbHRlcnMpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNsaWVudC5fbG9nZ2VyLmVycm9yKGUpO1xuXG4gICAgICAgICAgY2IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0sXG4gICAgc2VuZFNlc3Npb246IGZ1bmN0aW9uIChzZXNzaW9uLCBjYikge1xuICAgICAgaWYgKGNiID09PSB2b2lkIDApIHtcbiAgICAgICAgY2IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybCA9IGdldEFwaVVybChjbGllbnQuY29uZmlnLCAnc2Vzc2lvbnMnLCAnMScsIHdpbik7XG4gICAgICB2YXIgcmVxID0gbmV3IHdpbi5YRG9tYWluUmVxdWVzdCgpO1xuXG4gICAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYihudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcS5vcGVuKCdQT1NUJywgdXJsKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcS5zZW5kKF8kanNvblBheWxvYWRfMTMuc2Vzc2lvbihzZXNzaW9uLCBjbGllbnQuY29uZmlnLmZpbHRlcnMpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZSk7XG5cbiAgICAgICAgICBjYihlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGdldEFwaVVybCA9IGZ1bmN0aW9uIChjb25maWcsIGVuZHBvaW50LCB2ZXJzaW9uLCB3aW4pIHtcbiAgcmV0dXJuIG1hdGNoUGFnZVByb3RvY29sKGNvbmZpZy5lbmRwb2ludHNbZW5kcG9pbnRdLCB3aW4ubG9jYXRpb24ucHJvdG9jb2wpICsgXCI/YXBpS2V5PVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hcGlLZXkpICsgXCImcGF5bG9hZFZlcnNpb249XCIgKyB2ZXJzaW9uICsgXCImc2VudEF0PVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KF9faXNvRGF0ZV8yNigpKTtcbn07XG5cbnZhciBtYXRjaFBhZ2VQcm90b2NvbCA9IF8kZGVsaXZlcnlfMjYuX21hdGNoUGFnZVByb3RvY29sID0gZnVuY3Rpb24gKGVuZHBvaW50LCBwYWdlUHJvdG9jb2wpIHtcbiAgcmV0dXJuIHBhZ2VQcm90b2NvbCA9PT0gJ2h0dHA6JyA/IGVuZHBvaW50LnJlcGxhY2UoL15odHRwczovLCAnaHR0cDonKSA6IGVuZHBvaW50O1xufTtcblxuLyogcmVtb3ZlZDogdmFyIF8kanNvblBheWxvYWRfMTMgPSByZXF1aXJlKCdAYnVnc25hZy9jb3JlL2xpYi9qc29uLXBheWxvYWQnKTsgKi87XG5cbnZhciBfX2lzb0RhdGVfMjcgPSBfJGVzVXRpbHNfOC5pc29EYXRlO1xuXG52YXIgXyRkZWxpdmVyeV8yNyA9IGZ1bmN0aW9uIChjbGllbnQsIHdpbikge1xuICBpZiAod2luID09PSB2b2lkIDApIHtcbiAgICB3aW4gPSB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNlbmRSZXBvcnQ6IGZ1bmN0aW9uIChyZXBvcnQsIGNiKSB7XG4gICAgICBpZiAoY2IgPT09IHZvaWQgMCkge1xuICAgICAgICBjYiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXJsID0gY2xpZW50LmNvbmZpZy5lbmRwb2ludHMubm90aWZ5O1xuICAgICAgICB2YXIgcmVxID0gbmV3IHdpbi5YTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSB3aW4uWE1MSHR0cFJlcXVlc3QuRE9ORSkgY2IobnVsbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxLm9wZW4oJ1BPU1QnLCB1cmwpO1xuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0J1Z3NuYWctQXBpLUtleScsIHJlcG9ydC5hcGlLZXkgfHwgY2xpZW50LmNvbmZpZy5hcGlLZXkpO1xuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQnVnc25hZy1QYXlsb2FkLVZlcnNpb24nLCAnNCcpO1xuICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQnVnc25hZy1TZW50LUF0JywgX19pc29EYXRlXzI3KCkpO1xuICAgICAgICByZXEuc2VuZChfJGpzb25QYXlsb2FkXzEzLnJlcG9ydChyZXBvcnQsIGNsaWVudC5jb25maWcuZmlsdGVycykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbGllbnQuX2xvZ2dlci5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbmRTZXNzaW9uOiBmdW5jdGlvbiAoc2Vzc2lvbiwgY2IpIHtcbiAgICAgIGlmIChjYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNiID0gZnVuY3Rpb24gKCkge307XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cmwgPSBjbGllbnQuY29uZmlnLmVuZHBvaW50cy5zZXNzaW9ucztcbiAgICAgICAgdmFyIHJlcSA9IG5ldyB3aW4uWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gd2luLlhNTEh0dHBSZXF1ZXN0LkRPTkUpIGNiKG51bGwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcS5vcGVuKCdQT1NUJywgdXJsKTtcbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdCdWdzbmFnLUFwaS1LZXknLCBjbGllbnQuY29uZmlnLmFwaUtleSk7XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdCdWdzbmFnLVBheWxvYWQtVmVyc2lvbicsICcxJyk7XG4gICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdCdWdzbmFnLVNlbnQtQXQnLCBfX2lzb0RhdGVfMjcoKSk7XG4gICAgICAgIHJlcS5zZW5kKF8kanNvblBheWxvYWRfMTMuc2Vzc2lvbihzZXNzaW9uLCBjbGllbnQuY29uZmlnLmZpbHRlcnMpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2xpZW50Ll9sb2dnZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLypcbiAqIFNldHMgdGhlIGRlZmF1bHQgY29udGV4dCB0byBiZSB0aGUgY3VycmVudCBVUkxcbiAqL1xudmFyIF8kY29udGV4dF8yOCA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKGNsaWVudCwgd2luKSB7XG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgfVxuXG4gICAgY2xpZW50LmNvbmZpZy5iZWZvcmVTZW5kLnVuc2hpZnQoZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgaWYgKHJlcG9ydC5jb250ZXh0KSByZXR1cm47XG4gICAgICByZXBvcnQuY29udGV4dCA9IHdpbi5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX19fZXh0ZW5kc18yOSgpIHsgX19fZXh0ZW5kc18yOSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfX19leHRlbmRzXzI5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxudmFyIF9faXNvRGF0ZV8yOSA9IF8kZXNVdGlsc184Lmlzb0RhdGU7XG4vKlxuICogQXV0b21hdGljYWxseSBkZXRlY3RzIGJyb3dzZXIgZGV2aWNlIGRldGFpbHNcbiAqL1xuXG5cbnZhciBfJGRldmljZV8yOSA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKGNsaWVudCwgbmF2KSB7XG4gICAgaWYgKG5hdiA9PT0gdm9pZCAwKSB7XG4gICAgICBuYXYgPSBuYXZpZ2F0b3I7XG4gICAgfVxuXG4gICAgdmFyIGRldmljZSA9IHtcbiAgICAgIGxvY2FsZTogbmF2LmJyb3dzZXJMYW5ndWFnZSB8fCBuYXYuc3lzdGVtTGFuZ3VhZ2UgfHwgbmF2LnVzZXJMYW5ndWFnZSB8fCBuYXYubGFuZ3VhZ2UsXG4gICAgICB1c2VyQWdlbnQ6IG5hdi51c2VyQWdlbnQgLy8gbWVyZ2Ugd2l0aCBhbnl0aGluZyBhbHJlYWR5IHNldCBvbiB0aGUgY2xpZW50XG5cbiAgICB9O1xuICAgIGNsaWVudC5kZXZpY2UgPSBfX19leHRlbmRzXzI5KHt9LCBkZXZpY2UsIGNsaWVudC5kZXZpY2UpOyAvLyBhZGQgdGltZSBqdXN0IGFzIHRoZSByZXBvcnQgaXMgc2VudFxuXG4gICAgY2xpZW50LmNvbmZpZy5iZWZvcmVTZW5kLnVuc2hpZnQoZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgcmVwb3J0LmRldmljZSA9IF9fX2V4dGVuZHNfMjkoe30sIHJlcG9ydC5kZXZpY2UsIHtcbiAgICAgICAgdGltZTogX19pc29EYXRlXzI5KClcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfX19leHRlbmRzXzMwKCkgeyBfX19leHRlbmRzXzMwID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9fX2V4dGVuZHNfMzAuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG4vKlxuICogU2V0cyB0aGUgcmVwb3J0IHJlcXVlc3Q6IHsgdXJsIH0gdG8gYmUgdGhlIGN1cnJlbnQgaHJlZlxuICovXG52YXIgXyRyZXF1ZXN0XzMwID0ge1xuICBpbml0OiBmdW5jdGlvbiAoY2xpZW50LCB3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9XG5cbiAgICBjbGllbnQuY29uZmlnLmJlZm9yZVNlbmQudW5zaGlmdChmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICBpZiAocmVwb3J0LnJlcXVlc3QgJiYgcmVwb3J0LnJlcXVlc3QudXJsKSByZXR1cm47XG4gICAgICByZXBvcnQucmVxdWVzdCA9IF9fX2V4dGVuZHNfMzAoe30sIHJlcG9ydC5yZXF1ZXN0LCB7XG4gICAgICAgIHVybDogd2luLmxvY2F0aW9uLmhyZWZcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfX19leHRlbmRzXzMxKCkgeyBfX19leHRlbmRzXzMxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9fX2V4dGVuZHNfMzEuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG52YXIgX19pc0FycmF5XzMxID0gXyRlc1V0aWxzXzguaXNBcnJheSxcbiAgICBfX2luY2x1ZGVzXzMxID0gXyRlc1V0aWxzXzguaW5jbHVkZXM7XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGluZmVyUmVsZWFzZVN0YWdlXzEwID0gcmVxdWlyZSgnQGJ1Z3NuYWcvY29yZS9saWIvaW5mZXItcmVsZWFzZS1zdGFnZScpOyAqLztcblxudmFyIF8kc2Vzc2lvbl8zMSA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuc2Vzc2lvbkRlbGVnYXRlKHNlc3Npb25EZWxlZ2F0ZSk7XG4gIH1cbn07XG52YXIgc2Vzc2lvbkRlbGVnYXRlID0ge1xuICBzdGFydFNlc3Npb246IGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICB2YXIgc2Vzc2lvbkNsaWVudCA9IGNsaWVudDtcbiAgICBzZXNzaW9uQ2xpZW50Ll9zZXNzaW9uID0gbmV3IGNsaWVudC5CdWdzbmFnU2Vzc2lvbigpO1xuICAgIHZhciByZWxlYXNlU3RhZ2UgPSBfJGluZmVyUmVsZWFzZVN0YWdlXzEwKHNlc3Npb25DbGllbnQpOyAvLyBleGl0IGVhcmx5IGlmIHRoZSByZXBvcnRzIHNob3VsZCBub3QgYmUgc2VudCBvbiB0aGUgY3VycmVudCByZWxlYXNlU3RhZ2VcblxuICAgIGlmIChfX2lzQXJyYXlfMzEoc2Vzc2lvbkNsaWVudC5jb25maWcubm90aWZ5UmVsZWFzZVN0YWdlcykgJiYgIV9faW5jbHVkZXNfMzEoc2Vzc2lvbkNsaWVudC5jb25maWcubm90aWZ5UmVsZWFzZVN0YWdlcywgcmVsZWFzZVN0YWdlKSkge1xuICAgICAgc2Vzc2lvbkNsaWVudC5fbG9nZ2VyLndhcm4oXCJTZXNzaW9uIG5vdCBzZW50IGR1ZSB0byByZWxlYXNlU3RhZ2Uvbm90aWZ5UmVsZWFzZVN0YWdlcyBjb25maWd1cmF0aW9uXCIpO1xuXG4gICAgICByZXR1cm4gc2Vzc2lvbkNsaWVudDtcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb25DbGllbnQuY29uZmlnLmVuZHBvaW50cy5zZXNzaW9ucykge1xuICAgICAgc2Vzc2lvbkNsaWVudC5fbG9nZ2VyLndhcm4oXCJTZXNzaW9uIG5vdCBzZW50IGR1ZSB0byBtaXNzaW5nIGVuZHBvaW50cy5zZXNzaW9ucyBjb25maWd1cmF0aW9uXCIpO1xuXG4gICAgICByZXR1cm4gc2Vzc2lvbkNsaWVudDtcbiAgICB9XG5cbiAgICBzZXNzaW9uQ2xpZW50Ll9kZWxpdmVyeS5zZW5kU2Vzc2lvbih7XG4gICAgICBub3RpZmllcjogc2Vzc2lvbkNsaWVudC5ub3RpZmllcixcbiAgICAgIGRldmljZTogc2Vzc2lvbkNsaWVudC5kZXZpY2UsXG4gICAgICBhcHA6IF9fX2V4dGVuZHNfMzEoe30sIHtcbiAgICAgICAgcmVsZWFzZVN0YWdlOiByZWxlYXNlU3RhZ2VcbiAgICAgIH0sIHNlc3Npb25DbGllbnQuYXBwKSxcbiAgICAgIHNlc3Npb25zOiBbe1xuICAgICAgICBpZDogc2Vzc2lvbkNsaWVudC5fc2Vzc2lvbi5pZCxcbiAgICAgICAgc3RhcnRlZEF0OiBzZXNzaW9uQ2xpZW50Ll9zZXNzaW9uLnN0YXJ0ZWRBdCxcbiAgICAgICAgdXNlcjogc2Vzc2lvbkNsaWVudC51c2VyXG4gICAgICB9XVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlc3Npb25DbGllbnQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9fX2V4dGVuZHNfMzIoKSB7IF9fX2V4dGVuZHNfMzIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX19fZXh0ZW5kc18zMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbi8qXG4gKiBQcmV2ZW50IGNvbGxlY3Rpb24gb2YgdXNlciBJUHNcbiAqL1xudmFyIF8kY2xpZW50SXBfMzIgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICBpZiAoY2xpZW50LmNvbmZpZy5jb2xsZWN0VXNlcklwKSByZXR1cm47XG4gICAgY2xpZW50LmNvbmZpZy5iZWZvcmVTZW5kLnB1c2goZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgLy8gSWYgdXNlci5pZCBpcyBleHBsaWNpdGx5IHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBtaXNzaW5nIGZyb20gdGhlIHBheWxvYWQuIEl0IG5lZWRzXG4gICAgICAvLyByZW1vdmluZyBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgbGluZSByZXBsYWNlcyBpdFxuICAgICAgaWYgKHJlcG9ydC51c2VyICYmIHR5cGVvZiByZXBvcnQudXNlci5pZCA9PT0gJ3VuZGVmaW5lZCcpIGRlbGV0ZSByZXBvcnQudXNlci5pZDtcbiAgICAgIHJlcG9ydC51c2VyID0gX19fZXh0ZW5kc18zMih7XG4gICAgICAgIGlkOiAnW05PVCBDT0xMRUNURURdJ1xuICAgICAgfSwgcmVwb3J0LnVzZXIpO1xuICAgICAgcmVwb3J0LnJlcXVlc3QgPSBfX19leHRlbmRzXzMyKHtcbiAgICAgICAgY2xpZW50SXA6ICdbTk9UIENPTExFQ1RFRF0nXG4gICAgICB9LCByZXBvcnQucmVxdWVzdCk7XG4gICAgfSk7XG4gIH0sXG4gIGNvbmZpZ1NjaGVtYToge1xuICAgIGNvbGxlY3RVc2VySXA6IHtcbiAgICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnLFxuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIF8kY29uc29sZUJyZWFkY3J1bWJzXzMzID0ge307XG52YXIgX19tYXBfMzMgPSBfJGVzVXRpbHNfOC5tYXAsXG4gICAgX19yZWR1Y2VfMzMgPSBfJGVzVXRpbHNfOC5yZWR1Y2UsXG4gICAgX19maWx0ZXJfMzMgPSBfJGVzVXRpbHNfOC5maWx0ZXI7XG4vKlxuICogTGVhdmVzIGJyZWFkY3J1bWJzIHdoZW4gY29uc29sZSBsb2cgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKi9cblxuXG5fJGNvbnNvbGVCcmVhZGNydW1ic18zMy5pbml0ID0gZnVuY3Rpb24gKGNsaWVudCkge1xuICB2YXIgaXNEZXYgPSAvXmRldihlbG9wbWVudCk/JC8udGVzdChjbGllbnQuY29uZmlnLnJlbGVhc2VTdGFnZSk7XG4gIHZhciBleHBsaWNpdGx5RGlzYWJsZWQgPSBjbGllbnQuY29uZmlnLmNvbnNvbGVCcmVhZGNydW1ic0VuYWJsZWQgPT09IGZhbHNlO1xuICB2YXIgaW1wbGljaXRseURpc2FibGVkID0gKGNsaWVudC5jb25maWcuYXV0b0JyZWFkY3J1bWJzID09PSBmYWxzZSB8fCBpc0RldikgJiYgY2xpZW50LmNvbmZpZy5jb25zb2xlQnJlYWRjcnVtYnNFbmFibGVkICE9PSB0cnVlO1xuICBpZiAoZXhwbGljaXRseURpc2FibGVkIHx8IGltcGxpY2l0bHlEaXNhYmxlZCkgcmV0dXJuO1xuICBfX21hcF8zMyhDT05TT0xFX0xPR19NRVRIT0RTLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gY29uc29sZVttZXRob2RdO1xuXG4gICAgY29uc29sZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGNsaWVudC5sZWF2ZUJyZWFkY3J1bWIoJ0NvbnNvbGUgb3V0cHV0JywgX19yZWR1Y2VfMzMoYXJncywgZnVuY3Rpb24gKGFjY3VtLCBhcmcsIGkpIHtcbiAgICAgICAgLy8gZG8gdGhlIGJlc3Qvc2ltcGxlc3Qgc3RyaW5naWZpY2F0aW9uIG9mIGVhY2ggYXJndW1lbnRcbiAgICAgICAgdmFyIHN0cmluZ2lmaWVkID0gJ1tVbmtub3duIHZhbHVlXSc7IC8vIHRoaXMgbWF5IGZhaWwgaWYgdGhlIGlucHV0IGlzOlxuICAgICAgICAvLyAtIGFuIG9iamVjdCB3aG9zZSBbW1Byb3RvdHlwZV1dIGlzIG51bGwgKG5vIHRvU3RyaW5nKVxuICAgICAgICAvLyAtIGFuIG9iamVjdCB3aXRoIGEgYnJva2VuIHRvU3RyaW5nIG9yIEBAdG9QcmltaXRpdmUgaW1wbGVtZW50YXRpb25cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmluZ2lmaWVkID0gU3RyaW5nKGFyZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGlmIGl0IHN0cmluZ2lmaWVzIHRvIFtvYmplY3QgT2JqZWN0XSBhdHRlbXB0IHRvIEpTT04gc3RyaW5naWZ5XG5cblxuICAgICAgICBpZiAoc3RyaW5naWZpZWQgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgLy8gY2F0Y2ggc3RyaW5naWZ5IGVycm9ycyBhbmQgZmFsbGJhY2sgdG8gW29iamVjdCBPYmplY3RdXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjdW1bXCJbXCIgKyBpICsgXCJdXCJdID0gc3RyaW5naWZpZWQ7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2V2ZXJpdHk6IG1ldGhvZC5pbmRleE9mKCdncm91cCcpID09PSAwID8gJ2xvZycgOiBtZXRob2RcbiAgICAgIH0pLCAnbG9nJyk7XG4gICAgICBvcmlnaW5hbC5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgY29uc29sZVttZXRob2RdLl9yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc29sZVttZXRob2RdID0gb3JpZ2luYWw7XG4gICAgfTtcbiAgfSk7XG59O1xuXG5fJGNvbnNvbGVCcmVhZGNydW1ic18zMy5jb25maWdTY2hlbWEgPSB7XG4gIGNvbnNvbGVCcmVhZGNydW1ic0VuYWJsZWQ6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnXG4gIH1cbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIF8kY29uc29sZUJyZWFkY3J1bWJzXzMzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIENPTlNPTEVfTE9HX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGVbbWV0aG9kXS5fcmVzdG9yZSA9PT0gJ2Z1bmN0aW9uJykgY29uc29sZVttZXRob2RdLl9yZXN0b3JlKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbnZhciBDT05TT0xFX0xPR19NRVRIT0RTID0gX19maWx0ZXJfMzMoWydsb2cnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZVttZXRob2RdID09PSAnZnVuY3Rpb24nO1xufSk7XG5cbnZhciBfX21hcF8zNCA9IF8kZXNVdGlsc184Lm1hcCxcbiAgICBfX3JlZHVjZV8zNCA9IF8kZXNVdGlsc184LnJlZHVjZSxcbiAgICBfX2ZpbHRlcl8zNCA9IF8kZXNVdGlsc184LmZpbHRlcjtcblxudmFyIE1BWF9MSU5FX0xFTkdUSCA9IDIwMDtcbnZhciBNQVhfU0NSSVBUX0xFTkdUSCA9IDUwMDAwMDtcbnZhciBfJGlubGluZVNjcmlwdENvbnRlbnRfMzQgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIChjbGllbnQsIGRvYywgd2luKSB7XG4gICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7XG4gICAgICBkb2MgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICBpZiAod2luID09PSB2b2lkIDApIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9XG5cbiAgICBpZiAoIWNsaWVudC5jb25maWcudHJhY2tJbmxpbmVTY3JpcHRzKSByZXR1cm47XG4gICAgdmFyIG9yaWdpbmFsTG9jYXRpb24gPSB3aW4ubG9jYXRpb24uaHJlZjtcbiAgICB2YXIgaHRtbCA9ICcnO1xuICAgIHZhciBET01Db250ZW50TG9hZGVkID0gZmFsc2U7XG5cbiAgICB2YXIgZ2V0SHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkb2MuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICB9OyAvLyBnZXQgd2hhdGV2ZXIgSFRNTCBleGlzdHMgYXQgdGhpcyBwb2ludCBpbiB0aW1lXG5cblxuICAgIGh0bWwgPSBnZXRIdG1sKCk7XG4gICAgdmFyIHByZXYgPSBkb2Mub25yZWFkeXN0YXRlY2hhbmdlOyAvLyB0aGVuIHVwZGF0ZSBpdCB3aGVuIHRoZSBET00gY29udGVudCBoYXMgbG9hZGVkXG5cbiAgICBkb2Mub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSUU4IGNvbXBhdGlibGUgYWx0ZXJuYXRpdmUgdG8gZG9jdW1lbnQjRE9NQ29udGVudExvYWRlZFxuICAgICAgaWYgKGRvYy5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XG4gICAgICAgIGh0bWwgPSBnZXRIdG1sKCk7XG4gICAgICAgIERPTUNvbnRlbnRMb2FkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwcmV2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH07XG5cbiAgICB2YXIgX2xhc3RTY3JpcHQgPSBudWxsO1xuXG4gICAgdmFyIHVwZGF0ZUxhc3RTY3JpcHQgPSBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgICBfbGFzdFNjcmlwdCA9IHNjcmlwdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2NyaXB0ID0gZG9jLmN1cnJlbnRTY3JpcHQgfHwgX2xhc3RTY3JpcHQ7XG5cbiAgICAgIGlmICghc2NyaXB0ICYmICFET01Db250ZW50TG9hZGVkKSB7XG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jLnNjcmlwdHMgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NyaXB0O1xuICAgIH07XG5cbiAgICB2YXIgYWRkU3Vycm91bmRpbmdDb2RlID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIpIHtcbiAgICAgIC8vIGdldCB3aGF0ZXZlciBodG1sIGhhcyByZW5kZXJlZCBhdCB0aGlzIHBvaW50XG4gICAgICBpZiAoIURPTUNvbnRlbnRMb2FkZWQgfHwgIWh0bWwpIGh0bWwgPSBnZXRIdG1sKCk7IC8vIHNpbXVsYXRlIHRoZSByYXcgaHRtbFxuXG4gICAgICB2YXIgaHRtbExpbmVzID0gWyc8IS0tIERPQyBTVEFSVCAtLT4nXS5jb25jYXQoaHRtbC5zcGxpdCgnXFxuJykpO1xuICAgICAgdmFyIHplcm9CYXNlZExpbmUgPSBsaW5lTnVtYmVyIC0gMTtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KHplcm9CYXNlZExpbmUgLSAzLCAwKTtcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbih6ZXJvQmFzZWRMaW5lICsgMywgaHRtbExpbmVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gX19yZWR1Y2VfMzQoaHRtbExpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLCBmdW5jdGlvbiAoYWNjdW0sIGxpbmUsIGkpIHtcbiAgICAgICAgYWNjdW1bc3RhcnQgKyAxICsgaV0gPSBsaW5lLmxlbmd0aCA8PSBNQVhfTElORV9MRU5HVEggPyBsaW5lIDogbGluZS5zdWJzdHIoMCwgTUFYX0xJTkVfTEVOR1RIKTtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgfSwge30pO1xuICAgIH07XG5cbiAgICBjbGllbnQuY29uZmlnLmJlZm9yZVNlbmQudW5zaGlmdChmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICAvLyByZW1vdmUgYW55IG9mIG91ciBvd24gZnJhbWVzIHRoYXQgbWF5IGJlIHBhcnQgdGhlIHN0YWNrIHRoaXNcbiAgICAgIC8vIGhhcHBlbnMgYmVmb3JlIHRoZSBpbmxpbmUgc2NyaXB0IGNoZWNrIGFzIGl0IGhhcHBlbnMgZm9yIGFsbCBlcnJvcnNcbiAgICAgIHJlcG9ydC5zdGFja3RyYWNlID0gX19maWx0ZXJfMzQocmVwb3J0LnN0YWNrdHJhY2UsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiAhL19fdHJhY2VfXyQvLnRlc3QoZi5tZXRob2QpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZnJhbWUgPSByZXBvcnQuc3RhY2t0cmFjZVswXTsgLy8gaWYgZnJhbWUuZmlsZSBleGlzdHMgYW5kIGlzIG5vdCB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIHBhZ2UsIHRoaXMgY2FuJ3QgYmUgYW4gaW5saW5lIHNjcmlwdFxuXG4gICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuZmlsZSAmJiBmcmFtZS5maWxlLnJlcGxhY2UoLyMuKiQvLCAnJykgIT09IG9yaWdpbmFsTG9jYXRpb24ucmVwbGFjZSgvIy4qJC8sICcnKSkgcmV0dXJuOyAvLyBncmFiIHRoZSBsYXN0IHNjcmlwdCBrbm93biB0byBoYXZlIHJ1blxuXG4gICAgICB2YXIgY3VycmVudFNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblxuICAgICAgaWYgKGN1cnJlbnRTY3JpcHQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBjdXJyZW50U2NyaXB0LmlubmVySFRNTDtcbiAgICAgICAgcmVwb3J0LnVwZGF0ZU1ldGFEYXRhKCdzY3JpcHQnLCAnY29udGVudCcsIGNvbnRlbnQubGVuZ3RoIDw9IE1BWF9TQ1JJUFRfTEVOR1RIID8gY29udGVudCA6IGNvbnRlbnQuc3Vic3RyKDAsIE1BWF9TQ1JJUFRfTEVOR1RIKSk7XG4gICAgICB9IC8vIG9ubHkgYXR0ZW1wdCB0byBncmFiIHNvbWUgc3Vycm91bmRpbmcgY29kZSBpZiB3ZSBoYXZlIGEgbGluZSBudW1iZXJcblxuXG4gICAgICBpZiAoIWZyYW1lIHx8ICFmcmFtZS5saW5lTnVtYmVyKSByZXR1cm47XG4gICAgICBmcmFtZS5jb2RlID0gYWRkU3Vycm91bmRpbmdDb2RlKGZyYW1lLmxpbmVOdW1iZXIpO1xuICAgIH0pOyAvLyBQcm94eSBhbGwgdGhlIHRpbWVyIGZ1bmN0aW9ucyB3aG9zZSBjYWxsYmFjayBpcyB0aGVpciAwdGggYXJndW1lbnQuXG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgc2V0VGltZW91dCBiZWNhdXNlIHdlIG5lZWQgaXQgbGF0ZXJcblxuICAgIHZhciBfbWFwID0gX19tYXBfMzQoWydzZXRUaW1lb3V0JywgJ3NldEludGVydmFsJywgJ3NldEltbWVkaWF0ZScsICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gX19wcm94eSh3aW4sIGZuLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIF9fdHJhY2VPcmlnaW5hbFNjcmlwdChvcmlnaW5hbCwgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICBhcmdzWzBdID0gZm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICAgICAgX3NldFRpbWVvdXQgPSBfbWFwWzBdOyAvLyBQcm94eSBhbGwgdGhlIGhvc3Qgb2JqZWN0cyB3aG9zZSBwcm90b3R5cGVzIGhhdmUgYW4gYWRkRXZlbnRMaXN0ZW5lciBmdW5jdGlvblxuXG5cbiAgICBfX21hcF8zNChbJ0V2ZW50VGFyZ2V0JywgJ1dpbmRvdycsICdOb2RlJywgJ0FwcGxpY2F0aW9uQ2FjaGUnLCAnQXVkaW9UcmFja0xpc3QnLCAnQ2hhbm5lbE1lcmdlck5vZGUnLCAnQ3J5cHRvT3BlcmF0aW9uJywgJ0V2ZW50U291cmNlJywgJ0ZpbGVSZWFkZXInLCAnSFRNTFVua25vd25FbGVtZW50JywgJ0lEQkRhdGFiYXNlJywgJ0lEQlJlcXVlc3QnLCAnSURCVHJhbnNhY3Rpb24nLCAnS2V5T3BlcmF0aW9uJywgJ01lZGlhQ29udHJvbGxlcicsICdNZXNzYWdlUG9ydCcsICdNb2RhbFdpbmRvdycsICdOb3RpZmljYXRpb24nLCAnU1ZHRWxlbWVudEluc3RhbmNlJywgJ1NjcmVlbicsICdUZXh0VHJhY2snLCAnVGV4dFRyYWNrQ3VlJywgJ1RleHRUcmFja0xpc3QnLCAnV2ViU29ja2V0JywgJ1dlYlNvY2tldFdvcmtlcicsICdXb3JrZXInLCAnWE1MSHR0cFJlcXVlc3QnLCAnWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCcsICdYTUxIdHRwUmVxdWVzdFVwbG9hZCddLCBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKCF3aW5bb10gfHwgIXdpbltvXS5wcm90b3R5cGUgfHwgIXdpbltvXS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgIXdpbltvXS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2FkZEV2ZW50TGlzdGVuZXInKSkgcmV0dXJuO1xuXG4gICAgICBfX3Byb3h5KHdpbltvXS5wcm90b3R5cGUsICdhZGRFdmVudExpc3RlbmVyJywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBfX3RyYWNlT3JpZ2luYWxTY3JpcHQob3JpZ2luYWwsIGV2ZW50VGFyZ2V0Q2FsbGJhY2tBY2Nlc3Nvcik7XG4gICAgICB9KTtcblxuICAgICAgX19wcm94eSh3aW5bb10ucHJvdG90eXBlLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gX190cmFjZU9yaWdpbmFsU2NyaXB0KG9yaWdpbmFsLCBldmVudFRhcmdldENhbGxiYWNrQWNjZXNzb3IsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBfX3RyYWNlT3JpZ2luYWxTY3JpcHQoZm4sIGNhbGxiYWNrQWNjZXNzb3IsIGFsc29DYWxsT3JpZ2luYWwpIHtcbiAgICAgIGlmIChhbHNvQ2FsbE9yaWdpbmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgYWxzb0NhbGxPcmlnaW5hbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIGZvciByZW1vdmVFdmVudExpc3RlbmVyIHRvIHJlbW92ZSBhbnl0aGluZyBhZGRlZCB3aXRoXG4gICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIgYmVmb3JlIHRoZSBmdW5jdGlvbnMgc3RhcnRlZCBiZWluZyB3cmFwcGVkIGJ5IEJ1Z3NuYWdcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNiYSA9IGNhbGxiYWNrQWNjZXNzb3IoYXJncyk7XG4gICAgICAgICAgdmFyIGNiID0gY2JhLmdldCgpO1xuICAgICAgICAgIGlmIChhbHNvQ2FsbE9yaWdpbmFsKSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoY2IuX190cmFjZV9fKSB7XG4gICAgICAgICAgICBjYmEucmVwbGFjZShjYi5fX3RyYWNlX18pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZ2V0Q3VycmVudFNjcmlwdCgpOyAvLyB0aGlzIGZ1bmN0aW9uIG11c3RuJ3QgYmUgYW5ub255bW91cyBkdWUgdG8gYSBidWcgaW4gdGhlIHN0YWNrXG4gICAgICAgICAgICAvLyBnZW5lcmF0aW9uIGxvZ2ljLCBtZWFuaW5nIGl0IGdldHMgdHJpcHBlZCB1cFxuICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vc3RhY2t0cmFjZWpzL3N0YWNrLWdlbmVyYXRvci9pc3N1ZXMvNlxuXG4gICAgICAgICAgICBjYi5fX3RyYWNlX18gPSBmdW5jdGlvbiBfX3RyYWNlX18oKSB7XG4gICAgICAgICAgICAgIC8vIHNldCB0aGUgc2NyaXB0IHRoYXQgY2FsbGVkIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgdXBkYXRlTGFzdFNjcmlwdChzY3JpcHQpOyAvLyBpbW1lZGlhdGVseSB1bnNldCB0aGUgY3VycmVudFNjcmlwdCBzeW5jaHJvbm91c2x5IGJlbG93LCBob3dldmVyXG4gICAgICAgICAgICAgIC8vIGlmIHRoaXMgY2IgdGhyb3dzIGFuIGVycm9yIHRoZSBsaW5lIGFmdGVyIHdpbGwgbm90IGdldCBydW4gc28gc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYW4gYWxtb3N0LWltbWVkaWF0ZSBheXNuYyB1cGRhdGUgdG9vXG5cbiAgICAgICAgICAgICAgX3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUxhc3RTY3JpcHQobnVsbCk7XG4gICAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICAgIHZhciByZXQgPSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB1cGRhdGVMYXN0U2NyaXB0KG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2IuX190cmFjZV9fLl9fdHJhY2VfXyA9IGNiLl9fdHJhY2VfXztcbiAgICAgICAgICAgIGNiYS5yZXBsYWNlKGNiLl9fdHJhY2VfXyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBzd2FsbG93IHRoZXNlIGVycm9ycyBvbiBTZWxlbml1bTpcbiAgICAgICAgLy8gUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5ICdfX3RyYWNlX18nXG4gICAgICAgIC8vIFdlYkRyaXZlckV4Y2VwdGlvbjogTWVzc2FnZTogUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5IFwiaGFuZGxlRXZlbnRcIlxuICAgICAgICAvLyBJRTggZG9lc24ndCBsZXQgeW91IGNhbGwgLmFwcGx5KCkgb24gc2V0VGltZW91dC9zZXRJbnRlcnZhbFxuXG5cbiAgICAgICAgaWYgKGZuLmFwcGx5KSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmbihhcmdzWzBdKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGNvbmZpZ1NjaGVtYToge1xuICAgIHRyYWNrSW5saW5lU2NyaXB0czoge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfX3Byb3h5KGhvc3QsIG5hbWUsIHJlcGxhY2VyKSB7XG4gIHZhciBvcmlnaW5hbCA9IGhvc3RbbmFtZV07XG4gIGlmICghb3JpZ2luYWwpIHJldHVybiBvcmlnaW5hbDtcbiAgdmFyIHJlcGxhY2VtZW50ID0gcmVwbGFjZXIob3JpZ2luYWwpO1xuICBob3N0W25hbWVdID0gcmVwbGFjZW1lbnQ7XG4gIHJldHVybiBvcmlnaW5hbDtcbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRDYWxsYmFja0FjY2Vzc29yKGFyZ3MpIHtcbiAgdmFyIGlzRXZlbnRIYW5kbGVyT2JqID0gISFhcmdzWzFdICYmIHR5cGVvZiBhcmdzWzFdLmhhbmRsZUV2ZW50ID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlzRXZlbnRIYW5kbGVyT2JqID8gYXJnc1sxXS5oYW5kbGVFdmVudCA6IGFyZ3NbMV07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmIChpc0V2ZW50SGFuZGxlck9iaikge1xuICAgICAgICBhcmdzWzFdLmhhbmRsZUV2ZW50ID0gZm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzWzFdID0gZm47XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKlxuICogTGVhdmVzIGJyZWFkY3J1bWJzIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIERPTVxuICovXG52YXIgXyRpbnRlcmFjdGlvbkJyZWFkY3J1bWJzXzM1ID0ge1xuICBpbml0OiBmdW5jdGlvbiAoY2xpZW50LCB3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9XG5cbiAgICBpZiAoISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gd2luKSkgcmV0dXJuO1xuICAgIHZhciBleHBsaWNpdGx5RGlzYWJsZWQgPSBjbGllbnQuY29uZmlnLmludGVyYWN0aW9uQnJlYWRjcnVtYnNFbmFibGVkID09PSBmYWxzZTtcbiAgICB2YXIgaW1wbGljaXRseURpc2FibGVkID0gY2xpZW50LmNvbmZpZy5hdXRvQnJlYWRjcnVtYnMgPT09IGZhbHNlICYmIGNsaWVudC5jb25maWcuaW50ZXJhY3Rpb25CcmVhZGNydW1ic0VuYWJsZWQgIT09IHRydWU7XG4gICAgaWYgKGV4cGxpY2l0bHlEaXNhYmxlZCB8fCBpbXBsaWNpdGx5RGlzYWJsZWQpIHJldHVybjtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXRUZXh0LCB0YXJnZXRTZWxlY3RvcjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGFyZ2V0VGV4dCA9IGdldE5vZGVUZXh0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRhcmdldFNlbGVjdG9yID0gZ2V0Tm9kZVNlbGVjdG9yKGV2ZW50LnRhcmdldCwgd2luKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGFyZ2V0VGV4dCA9ICdbaGlkZGVuXSc7XG4gICAgICAgIHRhcmdldFNlbGVjdG9yID0gJ1toaWRkZW5dJztcblxuICAgICAgICBjbGllbnQuX2xvZ2dlci5lcnJvcignQ3Jvc3MgZG9tYWluIGVycm9yIHdoZW4gdHJhY2tpbmcgY2xpY2sgZXZlbnQuIFNlZSBkb2NzOiBodHRwczovL3Rpbnl1cmwuY29tL3l5M3JuNjN6Jyk7XG4gICAgICB9XG5cbiAgICAgIGNsaWVudC5sZWF2ZUJyZWFkY3J1bWIoJ1VJIGNsaWNrJywge1xuICAgICAgICB0YXJnZXRUZXh0OiB0YXJnZXRUZXh0LFxuICAgICAgICB0YXJnZXRTZWxlY3RvcjogdGFyZ2V0U2VsZWN0b3JcbiAgICAgIH0sICd1c2VyJyk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIGNvbmZpZ1NjaGVtYToge1xuICAgIGludGVyYWN0aW9uQnJlYWRjcnVtYnNFbmFibGVkOiB7XG4gICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnXG4gICAgfVxuICB9IC8vIGV4dHJhY3QgdGV4dCBjb250ZW50IGZyb20gYSBlbGVtZW50XG5cbn07XG5cbnZhciBnZXROb2RlVGV4dCA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgdGV4dCA9IGVsLnRleHRDb250ZW50IHx8IGVsLmlubmVyVGV4dCB8fCAnJztcbiAgaWYgKCF0ZXh0ICYmIChlbC50eXBlID09PSAnc3VibWl0JyB8fCBlbC50eXBlID09PSAnYnV0dG9uJykpIHRleHQgPSBlbC52YWx1ZTtcbiAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyB0cmltIHdoaXRlc3BhY2VcblxuICByZXR1cm4gdHJ1bmNhdGUodGV4dCwgMTQwKTtcbn07IC8vIENyZWF0ZSBhIGxhYmVsIGZyb20gdGFnbmFtZSwgaWQgYW5kIGNzcyBjbGFzcyBvZiB0aGUgZWxlbWVudFxuXG5cbmZ1bmN0aW9uIGdldE5vZGVTZWxlY3RvcihlbCwgd2luKSB7XG4gIHZhciBwYXJ0cyA9IFtlbC50YWdOYW1lXTtcbiAgaWYgKGVsLmlkKSBwYXJ0cy5wdXNoKCcjJyArIGVsLmlkKTtcbiAgaWYgKGVsLmNsYXNzTmFtZSAmJiBlbC5jbGFzc05hbWUubGVuZ3RoKSBwYXJ0cy5wdXNoKFwiLlwiICsgZWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignLicpKTsgLy8gQ2FuJ3QgZ2V0IG11Y2ggbW9yZSBhZHZhbmNlZCB3aXRoIHRoZSBjdXJyZW50IGJyb3dzZXJcblxuICBpZiAoIXdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsIHx8ICFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuXG4gIHRyeSB7XG4gICAgaWYgKHdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcnRzLmpvaW4oJycpKS5sZW5ndGggPT09IDEpIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFNvbWV0aW1lcyB0aGUgcXVlcnkgc2VsZWN0b3IgY2FuIGJlIGludmFsaWQganVzdCByZXR1cm4gaXQgYXMtaXNcbiAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gIH0gLy8gdHJ5IHRvIGdldCBhIG1vcmUgc3BlY2lmaWMgc2VsZWN0b3IgaWYgdGhpcyBvbmUgbWF0Y2hlcyBtb3JlIHRoYW4gb25lIGVsZW1lbnRcblxuXG4gIGlmIChlbC5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgIHZhciBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZWwucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBlbCkgKyAxO1xuICAgIHBhcnRzLnB1c2goXCI6bnRoLWNoaWxkKFwiICsgaW5kZXggKyBcIilcIik7XG4gIH1cblxuICBpZiAod2luLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGFydHMuam9pbignJykpLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzLmpvaW4oJycpOyAvLyB0cnkgcHJlcGVuZGluZyB0aGUgcGFyZW50IG5vZGUgc2VsZWN0b3JcblxuICBpZiAoZWwucGFyZW50Tm9kZSkgcmV0dXJuIGdldE5vZGVTZWxlY3RvcihlbC5wYXJlbnROb2RlLCB3aW4pICsgXCIgPiBcIiArIHBhcnRzLmpvaW4oJycpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIG9tbWlzaW9uID0gJyguLi4pJztcbiAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA8PSBsZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKDAsIGxlbmd0aCAtIG9tbWlzaW9uLmxlbmd0aCkgKyBvbW1pc2lvbjtcbn1cblxudmFyIF8kbmF2aWdhdGlvbkJyZWFkY3J1bWJzXzM2ID0ge307XG4vKlxuICogTGVhdmVzIGJyZWFkY3J1bWJzIHdoZW4gbmF2aWdhdGlvbiBtZXRob2RzIGFyZSBjYWxsZWQgb3IgZXZlbnRzIGFyZSBlbWl0dGVkXG4gKi9cbl8kbmF2aWdhdGlvbkJyZWFkY3J1bWJzXzM2LmluaXQgPSBmdW5jdGlvbiAoY2xpZW50LCB3aW4pIHtcbiAgaWYgKHdpbiA9PT0gdm9pZCAwKSB7XG4gICAgd2luID0gd2luZG93O1xuICB9XG5cbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbikpIHJldHVybjtcbiAgdmFyIGV4cGxpY2l0bHlEaXNhYmxlZCA9IGNsaWVudC5jb25maWcubmF2aWdhdGlvbkJyZWFkY3J1bWJzRW5hYmxlZCA9PT0gZmFsc2U7XG4gIHZhciBpbXBsaWNpdGx5RGlzYWJsZWQgPSBjbGllbnQuY29uZmlnLmF1dG9CcmVhZGNydW1icyA9PT0gZmFsc2UgJiYgY2xpZW50LmNvbmZpZy5uYXZpZ2F0aW9uQnJlYWRjcnVtYnNFbmFibGVkICE9PSB0cnVlO1xuICBpZiAoZXhwbGljaXRseURpc2FibGVkIHx8IGltcGxpY2l0bHlEaXNhYmxlZCkgcmV0dXJuOyAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRyb3AgYSBicmVhZGNydW1iIHdpdGggYSBnaXZlbiBuYW1lXG5cbiAgdmFyIGRyb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2xpZW50LmxlYXZlQnJlYWRjcnVtYihuYW1lLCB7fSwgJ25hdmlnYXRpb24nKTtcbiAgICB9O1xuICB9OyAvLyBzaW1wbGUgZHJvcHMg4oCTIGp1c3QgbmFtZXMsIG5vIG1ldGFcblxuXG4gIHdpbi5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGRyb3AoJ1BhZ2UgaGlkZGVuJyksIHRydWUpO1xuICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBkcm9wKCdQYWdlIHNob3duJyksIHRydWUpO1xuICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGRyb3AoJ1BhZ2UgbG9hZGVkJyksIHRydWUpO1xuICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRyb3AoJ0RPTUNvbnRlbnRMb2FkZWQnKSwgdHJ1ZSk7IC8vIHNvbWUgYnJvd3NlcnMgbGlrZSB0byBlbWl0IHBvcHN0YXRlIHdoZW4gdGhlIHBhZ2UgbG9hZHMsIHNvIG9ubHkgYWRkIHRoZSBwb3BzdGF0ZSBsaXN0ZW5lciBhZnRlciB0aGF0XG5cbiAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdpbi5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGRyb3AoJ05hdmlnYXRlZCBiYWNrJyksIHRydWUpO1xuICB9KTsgLy8gaGFzaGNoYW5nZSBoYXMgc29tZSBtZXRhRGF0YSB0aGF0IHdlIGNhcmUgYWJvdXRcblxuICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBtZXRhRGF0YSA9IGV2ZW50Lm9sZFVSTCA/IHtcbiAgICAgIGZyb206IHJlbGF0aXZlTG9jYXRpb24oZXZlbnQub2xkVVJMLCB3aW4pLFxuICAgICAgdG86IHJlbGF0aXZlTG9jYXRpb24oZXZlbnQubmV3VVJMLCB3aW4pLFxuICAgICAgc3RhdGU6IGdldEN1cnJlbnRTdGF0ZSh3aW4pXG4gICAgfSA6IHtcbiAgICAgIHRvOiByZWxhdGl2ZUxvY2F0aW9uKHdpbi5sb2NhdGlvbi5ocmVmLCB3aW4pXG4gICAgfTtcbiAgICBjbGllbnQubGVhdmVCcmVhZGNydW1iKCdIYXNoIGNoYW5nZWQnLCBtZXRhRGF0YSwgJ25hdmlnYXRpb24nKTtcbiAgfSwgdHJ1ZSk7IC8vIHRoZSBvbmx5IHdheSB0byBrbm93IGFib3V0IHJlcGxhY2VTdGF0ZS9wdXNoU3RhdGUgaXMgdG8gd3JhcCB0aGVt4oCmID5fPFxuXG4gIGlmICh3aW4uaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHdyYXBIaXN0b3J5Rm4oY2xpZW50LCB3aW4uaGlzdG9yeSwgJ3JlcGxhY2VTdGF0ZScsIHdpbik7XG4gIGlmICh3aW4uaGlzdG9yeS5wdXNoU3RhdGUpIHdyYXBIaXN0b3J5Rm4oY2xpZW50LCB3aW4uaGlzdG9yeSwgJ3B1c2hTdGF0ZScsIHdpbik7XG4gIGNsaWVudC5sZWF2ZUJyZWFkY3J1bWIoJ0J1Z3NuYWcgbG9hZGVkJywge30sICduYXZpZ2F0aW9uJyk7XG59O1xuXG5fJG5hdmlnYXRpb25CcmVhZGNydW1ic18zNi5jb25maWdTY2hlbWEgPSB7XG4gIG5hdmlnYXRpb25CcmVhZGNydW1ic0VuYWJsZWQ6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnXG4gIH1cbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIF8kbmF2aWdhdGlvbkJyZWFkY3J1bWJzXzM2LmRlc3Ryb3kgPSBmdW5jdGlvbiAod2luKSB7XG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgfVxuXG4gICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlLl9yZXN0b3JlKCk7XG5cbiAgICB3aW4uaGlzdG9yeS5wdXNoU3RhdGUuX3Jlc3RvcmUoKTtcbiAgfTtcbn0gLy8gdGFrZXMgYSBmdWxsIHVybCBsaWtlIGh0dHA6Ly9mb28uY29tOjEyMzQvcGFnZXMvMDEuaHRtbD95ZXM9bm8jc2VjdGlvbi0yIGFuZCByZXR1cm5zXG4vLyBqdXN0IHRoZSBwYXRoIGFuZCBoYXNoIHBhcnRzLCBlLmcuIC9wYWdlcy8wMS5odG1sP3llcz1ubyNzZWN0aW9uLTJcblxuXG52YXIgcmVsYXRpdmVMb2NhdGlvbiA9IGZ1bmN0aW9uICh1cmwsIHdpbikge1xuICB2YXIgYSA9IHdpbi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdBJyk7XG4gIGEuaHJlZiA9IHVybDtcbiAgcmV0dXJuIFwiXCIgKyBhLnBhdGhuYW1lICsgYS5zZWFyY2ggKyBhLmhhc2g7XG59O1xuXG52YXIgc3RhdGVDaGFuZ2VUb01ldGFEYXRhID0gZnVuY3Rpb24gKHdpbiwgc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgdmFyIGN1cnJlbnRQYXRoID0gcmVsYXRpdmVMb2NhdGlvbih3aW4ubG9jYXRpb24uaHJlZiwgd2luKTtcbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogdGl0bGUsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIHByZXZTdGF0ZTogZ2V0Q3VycmVudFN0YXRlKHdpbiksXG4gICAgdG86IHVybCB8fCBjdXJyZW50UGF0aCxcbiAgICBmcm9tOiBjdXJyZW50UGF0aFxuICB9O1xufTtcblxudmFyIHdyYXBIaXN0b3J5Rm4gPSBmdW5jdGlvbiAoY2xpZW50LCB0YXJnZXQsIGZuLCB3aW4pIHtcbiAgdmFyIG9yaWcgPSB0YXJnZXRbZm5dO1xuXG4gIHRhcmdldFtmbl0gPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICBjbGllbnQubGVhdmVCcmVhZGNydW1iKFwiSGlzdG9yeSBcIiArIGZuLCBzdGF0ZUNoYW5nZVRvTWV0YURhdGEod2luLCBzdGF0ZSwgdGl0bGUsIHVybCksICduYXZpZ2F0aW9uJyk7IC8vIGlmIHRocm90dGxlIHBsdWdpbiBpcyBpbiB1c2UsIHJlZnJlc2ggdGhlIGV2ZW50IHNlbnQgY291bnRcblxuICAgIGlmICh0eXBlb2YgY2xpZW50LnJlZnJlc2ggPT09ICdmdW5jdGlvbicpIGNsaWVudC5yZWZyZXNoKCk7IC8vIGlmIHRoZSBjbGllbnQgaXMgb3BlcmF0aW5nIGluIGF1dG8gc2Vzc2lvbi1tb2RlLCBhIG5ldyByb3V0ZSBzaG91bGQgdHJpZ2dlciBhIG5ldyBzZXNzaW9uXG5cbiAgICBpZiAoY2xpZW50LmNvbmZpZy5hdXRvQ2FwdHVyZVNlc3Npb25zKSBjbGllbnQuc3RhcnRTZXNzaW9uKCk7IC8vIEludGVybmV0IEV4cGxvcmVyIHdpbGwgY29udmVydCBgdW5kZWZpbmVkYCB0byBhIHN0cmluZyB3aGVuIHBhc3NlZCwgY2F1c2luZyBhbiB1bmludGVuZGVkIHJlZGlyZWN0XG4gICAgLy8gdG8gJy91bmRlZmluZWQnLiB0aGVyZWZvcmUgd2Ugb25seSBwYXNzIHRoZSB1cmwgaWYgaXQncyBub3QgdW5kZWZpbmVkLlxuXG4gICAgb3JpZy5hcHBseSh0YXJnZXQsIFtzdGF0ZSwgdGl0bGVdLmNvbmNhdCh1cmwgIT09IHVuZGVmaW5lZCA/IHVybCA6IFtdKSk7XG4gIH07XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0YXJnZXRbZm5dLl9yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0W2ZuXSA9IG9yaWc7XG4gICAgfTtcbiAgfVxufTtcblxudmFyIGdldEN1cnJlbnRTdGF0ZSA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luLmhpc3Rvcnkuc3RhdGU7XG4gIH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgXyRuZXR3b3JrQnJlYWRjcnVtYnNfMzcgPSB7fTtcbnZhciBCUkVBRENSVU1CX1RZUEUgPSAncmVxdWVzdCc7IC8vIGtleXMgdG8gc2FmZWx5IHN0b3JlIG1ldGFkYXRhIG9uIHRoZSByZXF1ZXN0IG9iamVjdFxuXG52YXIgUkVRVUVTVF9TRVRVUF9LRVkgPSAnQlN+flMnO1xudmFyIFJFUVVFU1RfVVJMX0tFWSA9ICdCU35+VSc7XG52YXIgUkVRVUVTVF9NRVRIT0RfS0VZID0gJ0JTfn5NJztcblxudmFyIF9faW5jbHVkZXNfMzcgPSBfJGVzVXRpbHNfOC5pbmNsdWRlcztcblxudmFyIHJlc3RvcmVGdW5jdGlvbnMgPSBbXTtcbnZhciBjbGllbnQ7XG52YXIgd2luO1xudmFyIGdldElnbm9yZWRVcmxzO1xuXG52YXIgZGVmYXVsdElnbm9yZWRVcmxzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW2NsaWVudC5jb25maWcuZW5kcG9pbnRzLm5vdGlmeSwgY2xpZW50LmNvbmZpZy5lbmRwb2ludHMuc2Vzc2lvbnNdO1xufTtcbi8qXG4gKiBMZWF2ZXMgYnJlYWRjcnVtYnMgd2hlbiBuZXR3b3JrIHJlcXVlc3RzIG9jY3VyXG4gKi9cblxuXG5fJG5ldHdvcmtCcmVhZGNydW1ic18zNy5uYW1lID0gJ25ldHdvcmtCcmVhZGNydW1icyc7XG5cbl8kbmV0d29ya0JyZWFkY3J1bWJzXzM3LmluaXQgPSBmdW5jdGlvbiAoX2NsaWVudCwgX2dldElnbm9yZWRVcmxzLCBfd2luKSB7XG4gIGlmIChfZ2V0SWdub3JlZFVybHMgPT09IHZvaWQgMCkge1xuICAgIF9nZXRJZ25vcmVkVXJscyA9IGRlZmF1bHRJZ25vcmVkVXJscztcbiAgfVxuXG4gIGlmIChfd2luID09PSB2b2lkIDApIHtcbiAgICBfd2luID0gd2luZG93O1xuICB9XG5cbiAgdmFyIGV4cGxpY2l0bHlEaXNhYmxlZCA9IF9jbGllbnQuY29uZmlnLm5ldHdvcmtCcmVhZGNydW1ic0VuYWJsZWQgPT09IGZhbHNlO1xuICB2YXIgaW1wbGljaXRseURpc2FibGVkID0gX2NsaWVudC5jb25maWcuYXV0b0JyZWFkY3J1bWJzID09PSBmYWxzZSAmJiBfY2xpZW50LmNvbmZpZy5uZXR3b3JrQnJlYWRjcnVtYnNFbmFibGVkICE9PSB0cnVlO1xuICBpZiAoZXhwbGljaXRseURpc2FibGVkIHx8IGltcGxpY2l0bHlEaXNhYmxlZCkgcmV0dXJuO1xuICBjbGllbnQgPSBfY2xpZW50O1xuICB3aW4gPSBfd2luO1xuICBnZXRJZ25vcmVkVXJscyA9IF9nZXRJZ25vcmVkVXJscztcbiAgbW9ua2V5UGF0Y2hYTUxIdHRwUmVxdWVzdCgpO1xuICBtb25rZXlQYXRjaEZldGNoKCk7XG59O1xuXG5fJG5ldHdvcmtCcmVhZGNydW1ic18zNy5jb25maWdTY2hlbWEgPSB7XG4gIG5ldHdvcmtCcmVhZGNydW1ic0VuYWJsZWQ6IHtcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtZXNzYWdlOiAnc2hvdWxkIGJlIHRydWV8ZmFsc2UnXG4gIH1cbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIF8kbmV0d29ya0JyZWFkY3J1bWJzXzM3LmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZUZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSk7XG4gICAgcmVzdG9yZUZ1bmN0aW9ucyA9IFtdO1xuICB9O1xufSAvLyBYTUxIdHRwUmVxdWVzdCBtb25rZXkgcGF0Y2hcblxuXG52YXIgbW9ua2V5UGF0Y2hYTUxIdHRwUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbi5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpKSByZXR1cm47XG4gIHZhciBuYXRpdmVPcGVuID0gd2luLlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuOyAvLyBvdmVycmlkZSBuYXRpdmUgb3BlbigpXG5cbiAgd2luLlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbihtZXRob2QsIHVybCkge1xuICAgIC8vIHN0b3JlIHVybCBhbmQgSFRUUCBtZXRob2QgZm9yIGxhdGVyXG4gICAgdGhpc1tSRVFVRVNUX1VSTF9LRVldID0gdXJsO1xuICAgIHRoaXNbUkVRVUVTVF9NRVRIT0RfS0VZXSA9IG1ldGhvZDsgLy8gaWYgd2UgaGF2ZSBhbHJlYWR5IHNldHVwIGxpc3RlbmVycywgaXQgbWVhbnMgb3BlbigpIHdhcyBjYWxsZWQgdHdpY2UsIHdlIG5lZWQgdG8gcmVtb3ZlXG4gICAgLy8gdGhlIGxpc3RlbmVycyBhbmQgcmVjcmVhdGUgdGhlbVxuXG4gICAgaWYgKHRoaXNbUkVRVUVTVF9TRVRVUF9LRVldKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVYSFJMb2FkKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVYSFJFcnJvcik7XG4gICAgfSAvLyBhdHRhY2ggbG9hZCBldmVudCBsaXN0ZW5lclxuXG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVYSFJMb2FkKTsgLy8gYXR0YWNoIGVycm9yIGV2ZW50IGxpc3RlbmVyXG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlWEhSRXJyb3IpO1xuICAgIHRoaXNbUkVRVUVTVF9TRVRVUF9LRVldID0gdHJ1ZTtcbiAgICBuYXRpdmVPcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXN0b3JlRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgd2luLlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuID0gbmF0aXZlT3BlbjtcbiAgICB9KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlWEhSTG9hZCgpIHtcbiAgaWYgKF9faW5jbHVkZXNfMzcoZ2V0SWdub3JlZFVybHMoKSwgdGhpc1tSRVFVRVNUX1VSTF9LRVldKSkge1xuICAgIC8vIGRvbid0IGxlYXZlIGEgbmV0d29yayBicmVhZGNydW1iIGZyb20gYnVnc25hZyBub3RpZnkgY2FsbHNcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWV0YURhdGEgPSB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICByZXF1ZXN0OiB0aGlzW1JFUVVFU1RfTUVUSE9EX0tFWV0gKyBcIiBcIiArIHRoaXNbUkVRVUVTVF9VUkxfS0VZXVxuICB9O1xuXG4gIGlmICh0aGlzLnN0YXR1cyA+PSA0MDApIHtcbiAgICAvLyBjb250YWN0ZWQgc2VydmVyIGJ1dCBnb3QgYW4gZXJyb3IgcmVzcG9uc2VcbiAgICBjbGllbnQubGVhdmVCcmVhZGNydW1iKCdYTUxIdHRwUmVxdWVzdCBmYWlsZWQnLCBtZXRhRGF0YSwgQlJFQURDUlVNQl9UWVBFKTtcbiAgfSBlbHNlIHtcbiAgICBjbGllbnQubGVhdmVCcmVhZGNydW1iKCdYTUxIdHRwUmVxdWVzdCBzdWNjZWVkZWQnLCBtZXRhRGF0YSwgQlJFQURDUlVNQl9UWVBFKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVYSFJFcnJvcigpIHtcbiAgaWYgKF9faW5jbHVkZXNfMzcoZ2V0SWdub3JlZFVybHMsIHRoaXNbUkVRVUVTVF9VUkxfS0VZXSkpIHtcbiAgICAvLyBkb24ndCBsZWF2ZSBhIG5ldHdvcmsgYnJlYWRjcnVtYiBmcm9tIGJ1Z3NuYWcgbm90aWZ5IGNhbGxzXG4gICAgcmV0dXJuO1xuICB9IC8vIGZhaWxlZCB0byBjb250YWN0IHNlcnZlclxuXG5cbiAgY2xpZW50LmxlYXZlQnJlYWRjcnVtYignWE1MSHR0cFJlcXVlc3QgZXJyb3InLCB7XG4gICAgcmVxdWVzdDogdGhpc1tSRVFVRVNUX01FVEhPRF9LRVldICsgXCIgXCIgKyB0aGlzW1JFUVVFU1RfVVJMX0tFWV1cbiAgfSwgQlJFQURDUlVNQl9UWVBFKTtcbn0gLy8gd2luZG93LmZldGNoIG1vbmtleSBwYXRjaFxuXG5cbnZhciBtb25rZXlQYXRjaEZldGNoID0gZnVuY3Rpb24gKCkge1xuICAvLyBvbmx5IHBhdGNoIGl0IGlmIGl0IGV4aXN0cyBhbmQgaWYgaXQgaXMgbm90IGEgcG9seWZpbGwgKHBhdGNoaW5nIGEgcG9seWZpbGxlZFxuICAvLyBmZXRjaCgpIHJlc3VsdHMgaW4gZHVwbGljYXRlIGJyZWFkY3J1bWJzIGZvciB0aGUgc2FtZSByZXF1ZXN0IGJlY2F1c2UgdGhlXG4gIC8vIGltcGxlbWVudGF0aW9uIHVzZXMgWE1MSHR0cFJlcXVlc3Qgd2hpY2ggaXMgYWxzbyBwYXRjaGVkKVxuICBpZiAoISgnZmV0Y2gnIGluIHdpbikgfHwgd2luLmZldGNoLnBvbHlmaWxsKSByZXR1cm47XG4gIHZhciBvbGRGZXRjaCA9IHdpbi5mZXRjaDtcblxuICB3aW4uZmV0Y2ggPSBmdW5jdGlvbiBmZXRjaCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIHVybCA9IGFyZ3NbMF0sXG4gICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgIHZhciBtZXRob2QgPSAnR0VUJztcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWV0aG9kKSB7XG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gcGFzcyB0aHJvdWdoIHRvIG5hdGl2ZSBmZXRjaFxuICAgICAgb2xkRmV0Y2guYXBwbHkodm9pZCAwLCBhcmdzKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBoYW5kbGVGZXRjaFN1Y2Nlc3MocmVzcG9uc2UsIG1ldGhvZCwgdXJsKTtcbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBoYW5kbGVGZXRjaEVycm9yKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmVzdG9yZUZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbi5mZXRjaCA9IG9sZEZldGNoO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaGFuZGxlRmV0Y2hTdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBtZXRob2QsIHVybCkge1xuICB2YXIgbWV0YURhdGEgPSB7XG4gICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgcmVxdWVzdDogbWV0aG9kICsgXCIgXCIgKyB1cmxcbiAgfTtcblxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgIC8vIHdoZW4gdGhlIHJlcXVlc3QgY29tZXMgYmFjayB3aXRoIGEgNHh4IG9yIDV4eCBzdGF0dXMgaXQgZG9lcyBub3QgcmVqZWN0IHRoZSBmZXRjaCBwcm9taXNlLFxuICAgIGNsaWVudC5sZWF2ZUJyZWFkY3J1bWIoJ2ZldGNoKCkgZmFpbGVkJywgbWV0YURhdGEsIEJSRUFEQ1JVTUJfVFlQRSk7XG4gIH0gZWxzZSB7XG4gICAgY2xpZW50LmxlYXZlQnJlYWRjcnVtYignZmV0Y2goKSBzdWNjZWVkZWQnLCBtZXRhRGF0YSwgQlJFQURDUlVNQl9UWVBFKTtcbiAgfVxufTtcblxudmFyIGhhbmRsZUZldGNoRXJyb3IgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwpIHtcbiAgY2xpZW50LmxlYXZlQnJlYWRjcnVtYignZmV0Y2goKSBlcnJvcicsIHtcbiAgICByZXF1ZXN0OiBtZXRob2QgKyBcIiBcIiArIHVybFxuICB9LCBCUkVBRENSVU1CX1RZUEUpO1xufTtcblxudmFyIF9faW50UmFuZ2VfMzggPSBfJHZhbGlkYXRvcnNfMTUuaW50UmFuZ2U7XG4vKlxuICogVGhyb3R0bGVzIGFuZCBkZWR1cGVzIGVycm9yIHJlcG9ydHNcbiAqL1xuXG5cbnZhciBfJHRocm90dGxlXzM4ID0ge1xuICBpbml0OiBmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgLy8gdHJhY2sgc2VudCBldmVudHMgZm9yIGVhY2ggaW5pdCBvZiB0aGUgcGx1Z2luXG4gICAgdmFyIG4gPSAwOyAvLyBhZGQgYmVmb3JlU2VuZCBob29rXG5cbiAgICBjbGllbnQuY29uZmlnLmJlZm9yZVNlbmQucHVzaChmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICAvLyBoYXZlIG1heCBldmVudHMgYmVlbiBzZW50IGFscmVhZHk/XG4gICAgICBpZiAobiA+PSBjbGllbnQuY29uZmlnLm1heEV2ZW50cykgcmV0dXJuIHJlcG9ydC5pZ25vcmUoKTtcbiAgICAgIG4rKztcbiAgICB9KTtcblxuICAgIGNsaWVudC5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgbiA9IDA7XG4gICAgfTtcbiAgfSxcbiAgY29uZmlnU2NoZW1hOiB7XG4gICAgbWF4RXZlbnRzOiB7XG4gICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6ICdzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIOKJpDEwMCcsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gX19pbnRSYW5nZV8zOCgxLCAxMDApKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgXyRzdHJpcFF1ZXJ5U3RyaW5nXzM5ID0ge307XG5mdW5jdGlvbiBfX19leHRlbmRzXzM5KCkgeyBfX19leHRlbmRzXzM5ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9fX2V4dGVuZHNfMzkuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG4vKlxuICogUmVtb3ZlIHF1ZXJ5IHN0cmluZ3MgKGFuZCBmcmFnbWVudHMpIGZyb20gc3RhY2t0cmFjZXNcbiAqL1xudmFyIF9fbWFwXzM5ID0gXyRlc1V0aWxzXzgubWFwO1xuXG5fJHN0cmlwUXVlcnlTdHJpbmdfMzkgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICBjbGllbnQuY29uZmlnLmJlZm9yZVNlbmQucHVzaChmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICByZXBvcnQuc3RhY2t0cmFjZSA9IF9fbWFwXzM5KHJlcG9ydC5zdGFja3RyYWNlLCBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fX2V4dGVuZHNfMzkoe30sIGZyYW1lLCB7XG4gICAgICAgICAgZmlsZTogc3RyaXAoZnJhbWUuZmlsZSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIHN0cmlwID0gXyRzdHJpcFF1ZXJ5U3RyaW5nXzM5Ll9zdHJpcCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5yZXBsYWNlKC8jLiokLywgJycpIDogc3RyO1xufTtcblxuLypcbiAqIEF1dG9tYXRpY2FsbHkgbm90aWZpZXMgQnVnc25hZyB3aGVuIHdpbmRvdy5vbmVycm9yIGlzIGNhbGxlZFxuICovXG52YXIgXyRvbmVycm9yXzQwID0ge1xuICBpbml0OiBmdW5jdGlvbiAoY2xpZW50LCB3aW4pIHtcbiAgICBpZiAod2luID09PSB2b2lkIDApIHtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmVycm9yKG1lc3NhZ2VPckV2ZW50LCB1cmwsIGxpbmVObywgY2hhck5vLCBlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGVycm9ycyB3aXRoIG5vIGluZm8gZHVlIHRvIENPUlMgc2V0dGluZ3NcbiAgICAgIGlmIChsaW5lTm8gPT09IDAgJiYgL1NjcmlwdCBlcnJvclxcLj8vLnRlc3QobWVzc2FnZU9yRXZlbnQpKSB7XG4gICAgICAgIGNsaWVudC5fbG9nZ2VyLndhcm4oJ0lnbm9yaW5nIGNyb3NzLWRvbWFpbiBvciBldmFsIHNjcmlwdCBlcnJvci4gU2VlIGRvY3M6IGh0dHBzOi8vdGlueXVybC5jb20veXkzcm42M3onKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFueSBlcnJvciBzZW50IHRvIHdpbmRvdy5vbmVycm9yIGlzIHVuaGFuZGxlZCBhbmQgaGFzIHNldmVyaXR5PWVycm9yXG4gICAgICAgIHZhciBoYW5kbGVkU3RhdGUgPSB7XG4gICAgICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICAgICAgdW5oYW5kbGVkOiB0cnVlLFxuICAgICAgICAgIHNldmVyaXR5UmVhc29uOiB7XG4gICAgICAgICAgICB0eXBlOiAndW5oYW5kbGVkRXhjZXB0aW9uJ1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcG9ydDsgLy8gd2luZG93Lm9uZXJyb3IgY2FuIGJlIGNhbGxlZCBpbiBhIG51bWJlciBvZiB3YXlzLiBUaGlzIGJpZyBpZi1lbHNlIGlzIGhvdyB3ZVxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoaWNoIGFyZ3VtZW50cyB3ZXJlIHN1cHBsaWVkLCBhbmQgd2hhdCBraW5kIG9mIHZhbHVlcyBpdCByZWNlaXZlZC5cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbGFzdCBwYXJhbWV0ZXIgKGVycm9yKSB3YXMgc3VwcGxpZWQsIHRoaXMgaXMgYSBtb2Rlcm4gYnJvd3NlcidzXG4gICAgICAgICAgLy8gd2F5IG9mIHNheWluZyBcInRoaXMgdmFsdWUgd2FzIHRocm93biBhbmQgbm90IGNhdWdodFwiXG4gICAgICAgICAgaWYgKGVycm9yLm5hbWUgJiYgZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gaWYgaXQgbG9va3MgbGlrZSBhbiBlcnJvciwgY29uc3RydWN0IGEgcmVwb3J0IG9iamVjdCB1c2luZyBpdHMgc3RhY2tcbiAgICAgICAgICAgIHJlcG9ydCA9IG5ldyBjbGllbnQuQnVnc25hZ1JlcG9ydChlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlLCBkZWNvcmF0ZVN0YWNrKGNsaWVudC5CdWdzbmFnUmVwb3J0LmdldFN0YWNrdHJhY2UoZXJyb3IpLCB1cmwsIGxpbmVObywgY2hhck5vKSwgaGFuZGxlZFN0YXRlLCBlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgZm9yIG5vbiBlcnJvciB2YWx1ZXMgdGhhdCB3ZXJlIHRocm93biwgc3RyaW5naWZ5IGl0IGZvclxuICAgICAgICAgICAgLy8gdXNlIGFzIHRoZSBlcnJvciBtZXNzYWdlIGFuZCBnZXQvZ2VuZXJhdGUgYSBzdGFja3RyYWNlXG4gICAgICAgICAgICByZXBvcnQgPSBuZXcgY2xpZW50LkJ1Z3NuYWdSZXBvcnQoJ3dpbmRvdy5vbmVycm9yJywgU3RyaW5nKGVycm9yKSwgZGVjb3JhdGVTdGFjayhjbGllbnQuQnVnc25hZ1JlcG9ydC5nZXRTdGFja3RyYWNlKGVycm9yLCAxKSwgdXJsLCBsaW5lTm8sIGNoYXJObyksIGhhbmRsZWRTdGF0ZSwgZXJyb3IpOyAvLyBpbmNsdWRlIHRoZSByYXcgaW5wdXQgYXMgbWV0YWRhdGFcblxuICAgICAgICAgICAgcmVwb3J0LnVwZGF0ZU1ldGFEYXRhKCd3aW5kb3cgb25lcnJvcicsIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoaXMgY29tcGxleCBjYXNlIGRldGVjdHMgXCJlcnJvclwiIGV2ZW50cyB0aGF0IGFyZSB0eXBpY2FsbHkgc3ludGhlc2lzZWRcbiAgICAgICAgLy8gYnkganF1ZXJ5J3MgdHJpZ2dlciBtZXRob2QgKGFsdGhvdWdoIGNhbiBiZSBjcmVhdGVkIGluIG90aGVyIHdheXMpLiBJblxuICAgICAgICAvLyBvcmRlciB0byBkZXRlY3QgdGhpczpcbiAgICAgICAgLy8gLSB0aGUgZmlyc3QgYXJndW1lbnQgKG1lc3NhZ2UpIG11c3QgZXhpc3QgYW5kIGJlIGFuIG9iamVjdCAobW9zdCBsaWtlbHkgaXQncyBhIGpRdWVyeSBldmVudClcbiAgICAgICAgLy8gLSB0aGUgc2Vjb25kIGFyZ3VtZW50ICh1cmwpIG11c3QgZWl0aGVyIG5vdCBleGlzdCBvciBiZSBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIHN0cmluZyAoaWYgaXRcbiAgICAgICAgLy8gICAgZXhpc3RzIGFuZCBpcyBub3QgYSBzdHJpbmcsIGl0J2xsIGJlIHRoZSBleHRyYVBhcmFtZXRlcnMgYXJndW1lbnQgZnJvbSBqUXVlcnkncyB0cmlnZ2VyKClcbiAgICAgICAgLy8gICAgZnVuY3Rpb24pXG4gICAgICAgIC8vIC0gdGhlIHRoaXJkLCBmb3VydGggYW5kIGZpZnRoIGFyZ3VtZW50cyBtdXN0IG5vdCBleGlzdCAobGluZU5vLCBjaGFyTm8gYW5kIGVycm9yKVxuICAgICAgICB0eXBlb2YgbWVzc2FnZU9yRXZlbnQgPT09ICdvYmplY3QnICYmIG1lc3NhZ2VPckV2ZW50ICE9PSBudWxsICYmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSAmJiAhbGluZU5vICYmICFjaGFyTm8gJiYgIWVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGpRdWVyeSBldmVudCBtYXkgaGF2ZSBhIFwidHlwZVwiIHByb3BlcnR5LCBpZiBzbyB1c2UgaXQgYXMgcGFydCBvZiB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgIHZhciBuYW1lID0gbWVzc2FnZU9yRXZlbnQudHlwZSA/IFwiRXZlbnQ6IFwiICsgbWVzc2FnZU9yRXZlbnQudHlwZSA6ICd3aW5kb3cub25lcnJvcic7IC8vIGF0dGVtcHQgdG8gZmluZCBhIG1lc3NhZ2UgZnJvbSBvbmUgb2YgdGhlIGNvbnZlbnRpb25hbCBwcm9wZXJ0aWVzLCBidXRcbiAgICAgICAgICAvLyBkZWZhdWx0IHRvIGVtcHR5IHN0cmluZyAodGhlIHJlcG9ydCB3aWxsIGZpbGwgaXQgd2l0aCBhIHBsYWNlaG9sZGVyKVxuXG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlT3JFdmVudC5tZXNzYWdlIHx8IG1lc3NhZ2VPckV2ZW50LmRldGFpbCB8fCAnJztcbiAgICAgICAgICByZXBvcnQgPSBuZXcgY2xpZW50LkJ1Z3NuYWdSZXBvcnQobmFtZSwgbWVzc2FnZSwgY2xpZW50LkJ1Z3NuYWdSZXBvcnQuZ2V0U3RhY2t0cmFjZShuZXcgRXJyb3IoKSwgMSkuc2xpY2UoMSksIGhhbmRsZWRTdGF0ZSwgbWVzc2FnZU9yRXZlbnQpOyAvLyBpbmNsdWRlIHRoZSByYXcgaW5wdXQgYXMgbWV0YWRhdGEg4oCTIGl0IG1pZ2h0IGNvbnRhaW4gbW9yZSBpbmZvIHRoYW4gd2UgZXh0cmFjdGVkXG5cbiAgICAgICAgICByZXBvcnQudXBkYXRlTWV0YURhdGEoJ3dpbmRvdyBvbmVycm9yJywge1xuICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2VPckV2ZW50LFxuICAgICAgICAgICAgZXh0cmFQYXJhbWV0ZXJzOiB1cmxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMYXN0bHksIGlmIHRoZXJlIHdhcyBubyBcImVycm9yXCIgcGFyYW1ldGVyIHRoaXMgZXZlbnQgd2FzIHByb2JhYmx5IGZyb20gYW4gb2xkXG4gICAgICAgICAgLy8gYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCB0aGF0LiBJbnN0ZWFkIHdlIG5lZWQgdG8gZ2VuZXJhdGUgYSBzdGFja3RyYWNlLlxuICAgICAgICAgIHJlcG9ydCA9IG5ldyBjbGllbnQuQnVnc25hZ1JlcG9ydCgnd2luZG93Lm9uZXJyb3InLCBTdHJpbmcobWVzc2FnZU9yRXZlbnQpLCBkZWNvcmF0ZVN0YWNrKGNsaWVudC5CdWdzbmFnUmVwb3J0LmdldFN0YWNrdHJhY2UoZXJyb3IsIDEpLCB1cmwsIGxpbmVObywgY2hhck5vKSwgaGFuZGxlZFN0YXRlLCBtZXNzYWdlT3JFdmVudCk7IC8vIGluY2x1ZGUgdGhlIHJhdyBpbnB1dCBhcyBtZXRhZGF0YSDigJMgaXQgbWlnaHQgY29udGFpbiBtb3JlIGluZm8gdGhhbiB3ZSBleHRyYWN0ZWRcblxuICAgICAgICAgIHJlcG9ydC51cGRhdGVNZXRhRGF0YSgnd2luZG93IG9uZXJyb3InLCB7XG4gICAgICAgICAgICBldmVudDogbWVzc2FnZU9yRXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWVudC5ub3RpZnkocmVwb3J0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwcmV2T25FcnJvciA9PT0gJ2Z1bmN0aW9uJykgcHJldk9uRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldk9uRXJyb3IgPSB3aW4ub25lcnJvcjtcbiAgICB3aW4ub25lcnJvciA9IG9uZXJyb3I7XG4gIH0gLy8gU29tZXRpbWVzIHRoZSBzdGFja3RyYWNlIGhhcyBsZXNzIGluZm9ybWF0aW9uIHRoYW4gd2FzIHBhc3NlZCB0byB3aW5kb3cub25lcnJvci5cbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGF1Z21lbnQgdGhlIGZpcnN0IHN0YWNrZnJhbWUgd2l0aCBhbnkgdXNlZnVsIGluZm8gdGhhdCB3YXNcbiAgLy8gcmVjZWl2ZWQgYXMgYXJndW1lbnRzIHRvIHRoZSBvbmVycm9yIGNhbGxiYWNrLlxuXG59O1xuXG52YXIgZGVjb3JhdGVTdGFjayA9IGZ1bmN0aW9uIChzdGFjaywgdXJsLCBsaW5lTm8sIGNoYXJObykge1xuICB2YXIgY3VscHJpdCA9IHN0YWNrWzBdO1xuICBpZiAoIWN1bHByaXQpIHJldHVybiBzdGFjaztcbiAgaWYgKCFjdWxwcml0LmZpbGVOYW1lICYmIHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSBjdWxwcml0LnNldEZpbGVOYW1lKHVybCk7XG4gIGlmICghY3VscHJpdC5saW5lTnVtYmVyICYmIGlzQWN0dWFsTnVtYmVyKGxpbmVObykpIGN1bHByaXQuc2V0TGluZU51bWJlcihsaW5lTm8pO1xuXG4gIGlmICghY3VscHJpdC5jb2x1bW5OdW1iZXIpIHtcbiAgICBpZiAoaXNBY3R1YWxOdW1iZXIoY2hhck5vKSkge1xuICAgICAgY3VscHJpdC5zZXRDb2x1bW5OdW1iZXIoY2hhck5vKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5ldmVudCAmJiBpc0FjdHVhbE51bWJlcih3aW5kb3cuZXZlbnQuZXJyb3JDaGFyYWN0ZXIpKSB7XG4gICAgICBjdWxwcml0LnNldENvbHVtbk51bWJlcih3aW5kb3cuZXZlbnQuZXJyb3JDaGFyYWN0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGFjaztcbn07XG5cbnZhciBpc0FjdHVhbE51bWJlciA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgU3RyaW5nLmNhbGwobikgIT09ICdOYU4nO1xufTtcblxudmFyIF8kdW5oYW5kbGVkUmVqZWN0aW9uXzQxID0ge307XG4vKiByZW1vdmVkOiB2YXIgXyRoYXNTdGFja185ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvY29yZS9saWIvaGFzLXN0YWNrJyk7ICovO1xuXG52YXIgX19yZWR1Y2VfNDEgPSBfJGVzVXRpbHNfOC5yZWR1Y2U7XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGVycm9yU3RhY2tQYXJzZXJfNyA9IHJlcXVpcmUoJ0BidWdzbmFnL2NvcmUvbGliL2Vycm9yLXN0YWNrLXBhcnNlcicpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kaXNlcnJvcl8xMSA9IHJlcXVpcmUoJ0BidWdzbmFnL2NvcmUvbGliL2lzZXJyb3InKTsgKi87XG4vKlxuICogQXV0b21hdGljYWxseSBub3RpZmllcyBCdWdzbmFnIHdoZW4gd2luZG93Lm9udW5oYW5kbGVkcmVqZWN0aW9uIGlzIGNhbGxlZFxuICovXG5cblxudmFyIF9saXN0ZW5lcjtcblxuXyR1bmhhbmRsZWRSZWplY3Rpb25fNDEuaW5pdCA9IGZ1bmN0aW9uIChjbGllbnQsIHdpbikge1xuICBpZiAod2luID09PSB2b2lkIDApIHtcbiAgICB3aW4gPSB3aW5kb3c7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZXJyb3IgPSBldmVudC5yZWFzb247XG4gICAgdmFyIGlzQmx1ZWJpcmQgPSBmYWxzZTsgLy8gYWNjZXNzaW5nIHByb3BlcnRpZXMgb24gZXZlbnQuZGV0YWlsIGNhbiB0aHJvdyBlcnJvcnMgKHNlZSAjMzk0KVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnJlYXNvbikge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmRldGFpbC5yZWFzb247XG4gICAgICAgIGlzQmx1ZWJpcmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB2YXIgaGFuZGxlZFN0YXRlID0ge1xuICAgICAgc2V2ZXJpdHk6ICdlcnJvcicsXG4gICAgICB1bmhhbmRsZWQ6IHRydWUsXG4gICAgICBzZXZlcml0eVJlYXNvbjoge1xuICAgICAgICB0eXBlOiAndW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbidcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZXBvcnQ7XG5cbiAgICBpZiAoZXJyb3IgJiYgXyRoYXNTdGFja185KGVycm9yKSkge1xuICAgICAgLy8gaWYgaXQgcXVhY2tzIGxpa2UgYW4gRXJyb3LigKZcbiAgICAgIHJlcG9ydCA9IG5ldyBjbGllbnQuQnVnc25hZ1JlcG9ydChlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlLCBfJGVycm9yU3RhY2tQYXJzZXJfNy5wYXJzZShlcnJvciksIGhhbmRsZWRTdGF0ZSwgZXJyb3IpO1xuXG4gICAgICBpZiAoaXNCbHVlYmlyZCkge1xuICAgICAgICByZXBvcnQuc3RhY2t0cmFjZSA9IF9fcmVkdWNlXzQxKHJlcG9ydC5zdGFja3RyYWNlLCBmaXhCbHVlYmlyZFN0YWNrdHJhY2UoZXJyb3IpLCBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGl0IGRvZXNuJ3TigKZcbiAgICAgIHZhciBtc2cgPSAnUmVqZWN0aW9uIHJlYXNvbiB3YXMgbm90IGFuIEVycm9yLiBTZWUgXCJQcm9taXNlXCIgdGFiIGZvciBtb3JlIGRldGFpbC4nO1xuICAgICAgcmVwb3J0ID0gbmV3IGNsaWVudC5CdWdzbmFnUmVwb3J0KGVycm9yICYmIGVycm9yLm5hbWUgPyBlcnJvci5uYW1lIDogJ1VuaGFuZGxlZFJlamVjdGlvbicsIGVycm9yICYmIGVycm9yLm1lc3NhZ2UgPyBlcnJvci5tZXNzYWdlIDogbXNnLCBbXSwgaGFuZGxlZFN0YXRlLCBlcnJvcik7IC8vIHN0dWZmIHRoZSByZWplY3Rpb24gcmVhc29uIGludG8gbWV0YURhdGEsIGl0IGNvdWxkIGJlIHVzZWZ1bFxuXG4gICAgICByZXBvcnQudXBkYXRlTWV0YURhdGEoJ3Byb21pc2UnLCAncmVqZWN0aW9uIHJlYXNvbicsIHNlcmlhbGl6YWJsZVJlYXNvbihlcnJvcikpO1xuICAgIH1cblxuICAgIGNsaWVudC5ub3RpZnkocmVwb3J0KTtcbiAgfTtcblxuICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbikge1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgd2luLm9udW5oYW5kbGVkcmVqZWN0aW9uID0gZnVuY3Rpb24gKHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBfbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIF8kdW5oYW5kbGVkUmVqZWN0aW9uXzQxLmRlc3Ryb3kgPSBmdW5jdGlvbiAod2luKSB7XG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgfVxuXG4gICAgaWYgKF9saXN0ZW5lcikge1xuICAgICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiB3aW4pIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIF9saXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4ub251bmhhbmRsZWRyZWplY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saXN0ZW5lciA9IG51bGw7XG4gIH07XG59XG5cbnZhciBzZXJpYWxpemFibGVSZWFzb24gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmIChlcnIgPT09IG51bGwgfHwgZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCAob3IgbnVsbCknO1xuICB9IGVsc2UgaWYgKF8kaXNlcnJvcl8xMShlcnIpKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpXSA9IHtcbiAgICAgIG5hbWU6IGVyci5uYW1lLFxuICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnIuY29kZSxcbiAgICAgIHN0YWNrOiBlcnIuc3RhY2tcbiAgICB9LCBfcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn07IC8vIFRoZSBzdGFjayBwYXJzZXIgb24gYmx1ZWJpcmQgc3RhY2tzIGluIEZGIGdldCBhIHN1cHJpb3VzIGZpcnN0IGZyYW1lOlxuLy9cbi8vIEVycm9yOiBkZXJwXG4vLyAgIGJAaHR0cDovL2xvY2FsaG9zdDo1MDAwL2JsdWViaXJkLmh0bWw6MjI6MjRcbi8vICAgYUBodHRwOi8vbG9jYWxob3N0OjUwMDAvYmx1ZWJpcmQuaHRtbDoxODo5XG4vLyAgIEBodHRwOi8vbG9jYWxob3N0OjUwMDAvYmx1ZWJpcmQuaHRtbDoxNDo5XG4vL1xuLy8gcmVzdWx0cyBpblxuLy8gICBb4oCmXVxuLy8gICAgIDA6IE9iamVjdCB7IGZpbGU6IFwiRXJyb3I6IGRlcnBcIiwgbWV0aG9kOiB1bmRlZmluZWQsIGxpbmVOdW1iZXI6IHVuZGVmaW5lZCwg4oCmIH1cbi8vICAgICAxOiBPYmplY3QgeyBmaWxlOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9ibHVlYmlyZC5odG1sXCIsIG1ldGhvZDogXCJiXCIsIGxpbmVOdW1iZXI6IDIyLCDigKYgfVxuLy8gICAgIDI6IE9iamVjdCB7IGZpbGU6IFwiaHR0cDovL2xvY2FsaG9zdDo1MDAwL2JsdWViaXJkLmh0bWxcIiwgbWV0aG9kOiBcImFcIiwgbGluZU51bWJlcjogMTgsIOKApiB9XG4vLyAgICAgMzogT2JqZWN0IHsgZmlsZTogXCJodHRwOi8vbG9jYWxob3N0OjUwMDAvYmx1ZWJpcmQuaHRtbFwiLCBsaW5lTnVtYmVyOiAxNCwgY29sdW1uTnVtYmVyOiA5LCDigKYgfVxuLy9cbi8vIHNvIHRoZSBmb2xsb3dpbmcgcmVkdWNlL2FjY3VtdWxhdG9yIGZ1bmN0aW9uIHJlbW92ZXMgc3VjaCBmcmFtZXNcbi8vXG4vLyBCbHVlYmlyZCBwYWRzIG1ldGhvZCBuYW1lcyB3aXRoIHNwYWNlcyBzbyB0cmltIHRoYXQgdG9v4oCmXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL2Jsb2IvYjdmMjEzOTk4MTZkMDJmOTc5ZmU0MzQ1ODUzMzRjZTkwMWRjYWY0NC9zcmMvZGVidWdnYWJpbGl0eS5qcyNMNTY4LUw1NzFcblxuXG52YXIgZml4Qmx1ZWJpcmRTdGFja3RyYWNlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYWNjdW0sIGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLmZpbGUgPT09IGVycm9yLnRvU3RyaW5nKCkpIHJldHVybiBhY2N1bTtcblxuICAgIGlmIChmcmFtZS5tZXRob2QpIHtcbiAgICAgIGZyYW1lLm1ldGhvZCA9IGZyYW1lLm1ldGhvZC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdW0uY29uY2F0KGZyYW1lKTtcbiAgfTtcbn07XG5cbnZhciBfJG5vdGlmaWVyXzIgPSB7fTtcbmZ1bmN0aW9uIF9fX2V4dGVuZHNfMigpIHsgX19fZXh0ZW5kc18yID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9fX2V4dGVuZHNfMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbnZhciBuYW1lID0gJ0J1Z3NuYWcgSmF2YVNjcmlwdCc7XG52YXIgdmVyc2lvbiA9ICc2LjQuMyc7XG52YXIgdXJsID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9idWdzbmFnL2J1Z3NuYWctanMnO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRCdWdzbmFnQ2xpZW50XzQgPSByZXF1aXJlKCdAYnVnc25hZy9jb3JlL2NsaWVudCcpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kQnVnc25hZ1JlcG9ydF8yNCA9IHJlcXVpcmUoJ0BidWdzbmFnL2NvcmUvcmVwb3J0Jyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRTZXNzaW9uXzI1ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvY29yZS9zZXNzaW9uJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRCdWdzbmFnQnJlYWRjcnVtYl8zID0gcmVxdWlyZSgnQGJ1Z3NuYWcvY29yZS9icmVhZGNydW1iJyk7ICovOyAvLyBleHRlbmQgdGhlIGJhc2UgY29uZmlnIHNjaGVtYSB3aXRoIHNvbWUgYnJvd3Nlci1zcGVjaWZpYyBvcHRpb25zXG5cblxudmFyIF9fc2NoZW1hXzIgPSBfX19leHRlbmRzXzIoe30sIF8kY29uZmlnXzUuc2NoZW1hLCBfJGNvbmZpZ18xKTtcblxuLyogcmVtb3ZlZDogdmFyIF8kb25lcnJvcl80MCA9IHJlcXVpcmUoJ0BidWdzbmFnL3BsdWdpbi13aW5kb3ctb25lcnJvcicpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kdW5oYW5kbGVkUmVqZWN0aW9uXzQxID0gcmVxdWlyZSgnQGJ1Z3NuYWcvcGx1Z2luLXdpbmRvdy11bmhhbmRsZWQtcmVqZWN0aW9uJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRkZXZpY2VfMjkgPSByZXF1aXJlKCdAYnVnc25hZy9wbHVnaW4tYnJvd3Nlci1kZXZpY2UnKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGNvbnRleHRfMjggPSByZXF1aXJlKCdAYnVnc25hZy9wbHVnaW4tYnJvd3Nlci1jb250ZXh0Jyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRyZXF1ZXN0XzMwID0gcmVxdWlyZSgnQGJ1Z3NuYWcvcGx1Z2luLWJyb3dzZXItcmVxdWVzdCcpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kdGhyb3R0bGVfMzggPSByZXF1aXJlKCdAYnVnc25hZy9wbHVnaW4tc2ltcGxlLXRocm90dGxlJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRjb25zb2xlQnJlYWRjcnVtYnNfMzMgPSByZXF1aXJlKCdAYnVnc25hZy9wbHVnaW4tY29uc29sZS1icmVhZGNydW1icycpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kbmV0d29ya0JyZWFkY3J1bWJzXzM3ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvcGx1Z2luLW5ldHdvcmstYnJlYWRjcnVtYnMnKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJG5hdmlnYXRpb25CcmVhZGNydW1ic18zNiA9IHJlcXVpcmUoJ0BidWdzbmFnL3BsdWdpbi1uYXZpZ2F0aW9uLWJyZWFkY3J1bWJzJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRpbnRlcmFjdGlvbkJyZWFkY3J1bWJzXzM1ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvcGx1Z2luLWludGVyYWN0aW9uLWJyZWFkY3J1bWJzJyk7ICovO1xuXG4vKiByZW1vdmVkOiB2YXIgXyRpbmxpbmVTY3JpcHRDb250ZW50XzM0ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvcGx1Z2luLWlubGluZS1zY3JpcHQtY29udGVudCcpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kc2Vzc2lvbl8zMSA9IHJlcXVpcmUoJ0BidWdzbmFnL3BsdWdpbi1icm93c2VyLXNlc3Npb24nKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGNsaWVudElwXzMyID0gcmVxdWlyZSgnQGJ1Z3NuYWcvcGx1Z2luLWNsaWVudC1pcCcpOyAqLztcblxuLyogcmVtb3ZlZDogdmFyIF8kc3RyaXBRdWVyeVN0cmluZ18zOSA9IHJlcXVpcmUoJ0BidWdzbmFnL3BsdWdpbi1zdHJpcC1xdWVyeS1zdHJpbmcnKTsgKi87IC8vIGRlbGl2ZXJ5IG1lY2hhbmlzbXNcblxuXG4vKiByZW1vdmVkOiB2YXIgXyRkZWxpdmVyeV8yNiA9IHJlcXVpcmUoJ0BidWdzbmFnL2RlbGl2ZXJ5LXgtZG9tYWluLXJlcXVlc3QnKTsgKi87XG5cbi8qIHJlbW92ZWQ6IHZhciBfJGRlbGl2ZXJ5XzI3ID0gcmVxdWlyZSgnQGJ1Z3NuYWcvZGVsaXZlcnkteG1sLWh0dHAtcmVxdWVzdCcpOyAqLztcblxuXyRub3RpZmllcl8yID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8gaGFuZGxlIHZlcnkgc2ltcGxlIHVzZSBjYXNlIHdoZXJlIHVzZXIgc3VwcGxpZXMganVzdCB0aGUgYXBpIGtleSBhcyBhIHN0cmluZ1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSBvcHRzID0ge1xuICAgIGFwaUtleTogb3B0cyAvLyBzdXBwb3J0IHJlbmFtZWQvZGVwcmVjYXRlZCBvcHRpb25zXG5cbiAgfTtcbiAgdmFyIHdhcm5pbmdNZXNzYWdlID0gJyc7XG5cbiAgaWYgKG9wdHMuZW5kcG9pbnRzICYmIG9wdHMuZW5kcG9pbnRzLm5vdGlmeSAmJiAhb3B0cy5lbmRwb2ludHMuc2Vzc2lvbnMpIHtcbiAgICB3YXJuaW5nTWVzc2FnZSArPSAnbm90aWZ5IGVuZHBvaW50IGlzIHNldCBidXQgc2Vzc2lvbnMgZW5kcG9pbnQgaXMgbm90LiBObyBzZXNzaW9ucyB3aWxsIGJlIHNlbnQuJztcbiAgfVxuXG4gIHZhciBidWdzbmFnID0gbmV3IF8kQnVnc25hZ0NsaWVudF80KHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgdXJsOiB1cmxcbiAgfSk7XG4gIGJ1Z3NuYWcuc2V0T3B0aW9ucyhvcHRzKTsgLy8gc2V0IGRlbGl2ZXJ5IGJhc2VkIG9uIGJyb3dzZXIgY2FwYWJpbGl0eSAoSUUgOCs5IGhhdmUgYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0KVxuXG4gIGJ1Z3NuYWcuZGVsaXZlcnkod2luZG93LlhEb21haW5SZXF1ZXN0ID8gXyRkZWxpdmVyeV8yNiA6IF8kZGVsaXZlcnlfMjcpOyAvLyBjb25maWd1cmUgd2l0aCB1c2VyIHN1cHBsaWVkIG9wdGlvbnNcbiAgLy8gZXJyb3JzIGNhbiBiZSB0aHJvd24gaGVyZSB0aGF0IHByZXZlbnQgdGhlIGxpYiBmcm9tIGJlaW5nIGluIGEgdXNlYWJsZSBzdGF0ZVxuXG4gIGJ1Z3NuYWcuY29uZmlndXJlKF9fc2NoZW1hXzIpO1xuICBpZiAod2FybmluZ01lc3NhZ2UpIGJ1Z3NuYWcuX2xvZ2dlci53YXJuKHdhcm5pbmdNZXNzYWdlKTsgLy8gYWx3YXlzLW9uIGJyb3dzZXItc3BlY2lmaWMgcGx1Z2luc1xuXG4gIGJ1Z3NuYWcudXNlKF8kZGV2aWNlXzI5KTtcbiAgYnVnc25hZy51c2UoXyRjb250ZXh0XzI4KTtcbiAgYnVnc25hZy51c2UoXyRyZXF1ZXN0XzMwKTtcbiAgYnVnc25hZy51c2UoXyR0aHJvdHRsZV8zOCk7XG4gIGJ1Z3NuYWcudXNlKF8kc2Vzc2lvbl8zMSk7XG4gIGJ1Z3NuYWcudXNlKF8kY2xpZW50SXBfMzIpO1xuICBidWdzbmFnLnVzZShfJHN0cmlwUXVlcnlTdHJpbmdfMzkpOyAvLyBvcHRpb25hbCBicm93c2VyLXNwZWNpZmljIHBsdWdpbnNcblxuICBpZiAoYnVnc25hZy5jb25maWcuYXV0b05vdGlmeSAhPT0gZmFsc2UpIHtcbiAgICBidWdzbmFnLnVzZShfJG9uZXJyb3JfNDApO1xuICAgIGJ1Z3NuYWcudXNlKF8kdW5oYW5kbGVkUmVqZWN0aW9uXzQxKTtcbiAgfVxuXG4gIGJ1Z3NuYWcudXNlKF8kbmF2aWdhdGlvbkJyZWFkY3J1bWJzXzM2KTtcbiAgYnVnc25hZy51c2UoXyRpbnRlcmFjdGlvbkJyZWFkY3J1bWJzXzM1KTtcbiAgYnVnc25hZy51c2UoXyRuZXR3b3JrQnJlYWRjcnVtYnNfMzcpO1xuICBidWdzbmFnLnVzZShfJGNvbnNvbGVCcmVhZGNydW1ic18zMyk7IC8vIHRoaXMgb25lIGFkZGVkIGxhc3QgdG8gYXZvaWQgd3JhcHBpbmcgZnVuY3Rpb25hbGl0eSBiZWZvcmUgYnVnc25hZyB1c2VzIGl0XG5cbiAgYnVnc25hZy51c2UoXyRpbmxpbmVTY3JpcHRDb250ZW50XzM0KTtcblxuICBidWdzbmFnLl9sb2dnZXIuZGVidWcoXCJMb2FkZWQhXCIpO1xuXG4gIHJldHVybiBidWdzbmFnLmNvbmZpZy5hdXRvQ2FwdHVyZVNlc3Npb25zID8gYnVnc25hZy5zdGFydFNlc3Npb24oKSA6IGJ1Z3NuYWc7XG59OyAvLyBBbmd1bGFyJ3MgREkgc3lzdGVtIG5lZWRzIHRoaXMgaW50ZXJmYWNlIHRvIG1hdGNoIHdoYXQgaXMgZXhwb3NlZFxuLy8gaW4gdGhlIHR5cGUgZGVmaW5pdGlvbiBmaWxlICh0eXBlcy9idWdzbmFnLmQudHMpXG5cblxuXyRub3RpZmllcl8yLkJ1Z3NuYWcgPSB7XG4gIENsaWVudDogXyRCdWdzbmFnQ2xpZW50XzQsXG4gIFJlcG9ydDogXyRCdWdzbmFnUmVwb3J0XzI0LFxuICBTZXNzaW9uOiBfJFNlc3Npb25fMjUsXG4gIEJyZWFkY3J1bWI6IF8kQnVnc25hZ0JyZWFkY3J1bWJfMyAvLyBFeHBvcnQgYSBcImRlZmF1bHRcIiBwcm9wZXJ0eSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEVTTSBpbXBvcnRzXG5cbn07XG5fJG5vdGlmaWVyXzJbJ2RlZmF1bHQnXSA9IF8kbm90aWZpZXJfMjtcblxucmV0dXJuIF8kbm90aWZpZXJfMjtcblxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWdzbmFnLmpzLm1hcFxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdAYnVnc25hZy9icm93c2VyJylcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIH1cblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGFsaWFzIHVzZWQgZm9yIHJlc2VydmVkIGV2ZW50cyAocHJvdGVjdGVkIG1ldGhvZClcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXRSZXNlcnZlZCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IGVuYWJsZU92ZXJyaWRlID09PSBudWxsID8gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpIDogZW5hYmxlT3ZlcnJpZGUsXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnJvd3NlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZm8obmFtZSwgdmVyc2lvbiwgb3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5vcyA9IG9zO1xuICAgIH1cbiAgICByZXR1cm4gQnJvd3NlckluZm87XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VySW5mbyA9IEJyb3dzZXJJbmZvO1xudmFyIE5vZGVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVJbmZvKHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICB9XG4gICAgcmV0dXJuIE5vZGVJbmZvO1xufSgpKTtcbmV4cG9ydHMuTm9kZUluZm8gPSBOb2RlSW5mbztcbnZhciBCb3RJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdEluZm8oKSB7XG4gICAgICAgIHRoaXMuYm90ID0gdHJ1ZTsgLy8gTk9URTogZGVwcmVjYXRlZCB0ZXN0IG5hbWUgaW5zdGVhZFxuICAgICAgICB0aGlzLm5hbWUgPSAnYm90JztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCb3RJbmZvO1xufSgpKTtcbmV4cG9ydHMuQm90SW5mbyA9IEJvdEluZm87XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG52YXIgU0VBUkNIQk9YX1VBX1JFR0VYID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvO1xudmFyIFNFQVJDSEJPVF9PU19SRUdFWCA9IC8obnVoayl8KEdvb2dsZWJvdCl8KFlhbW15Ym90KXwoT3BlbmJvdCl8KFNsdXJwKXwoTVNOQm90KXwoQXNrIEplZXZlc1xcL1Rlb21hKXwoaWFfYXJjaGl2ZXIpLztcbnZhciBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTID0gMztcbnZhciB1c2VyQWdlbnRSdWxlcyA9IFtcbiAgICBbJ2FvbCcsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2VkZ2UnLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZS1pb3MnLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sXG4gICAgWyd5YW5kZXhicm93c2VyJywgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsndml2YWxkaScsIC9WaXZhbGRpXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2tha2FvdGFsaycsIC9LQUtBT1RBTEtcXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnc2Ftc3VuZycsIC9TYW1zdW5nQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gICAgWydzaWxrJywgL1xcYlNpbGtcXC8oWzAtOS5fLV0rKVxcYi9dLFxuICAgIFsnbWl1aScsIC9NaXVpQnJvd3NlclxcLyhbMC05XFwuXSspJC9dLFxuICAgIFsnYmVha2VyJywgL0JlYWtlckJyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnZWRnZS1jaHJvbWl1bScsIC9FZGdcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFtcbiAgICAgICAgJ2Nocm9taXVtLXdlYnZpZXcnLFxuICAgICAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS8sXG4gICAgXSxcbiAgICBbJ2Nocm9tZScsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ3BoYW50b21qcycsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnY3Jpb3MnLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnZmlyZWZveCcsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ2Z4aW9zJywgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhLW1pbmknLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYScsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydvcGVyYScsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnaWUnLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoN1xcLjApL10sXG4gICAgWydiYjEwJywgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnYW5kcm9pZCcsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gICAgWydzYWZhcmknLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gICAgWydmYWNlYm9vaycsIC9GQkFWXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2luc3RhZ3JhbScsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgICBbJ3NlYXJjaGJvdCcsIFNFQVJDSEJPWF9VQV9SRUdFWF0sXG5dO1xudmFyIG9wZXJhdGluZ1N5c3RlbVJ1bGVzID0gW1xuICAgIFsnaU9TJywgL2lQKGhvbmV8b2R8YWQpL10sXG4gICAgWydBbmRyb2lkIE9TJywgL0FuZHJvaWQvXSxcbiAgICBbJ0JsYWNrQmVycnkgT1MnLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gICAgWydXaW5kb3dzIE1vYmlsZScsIC9JRU1vYmlsZS9dLFxuICAgIFsnQW1hem9uIE9TJywgL0tpbmRsZS9dLFxuICAgIFsnV2luZG93cyAzLjExJywgL1dpbjE2L10sXG4gICAgWydXaW5kb3dzIDk1JywgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICAgIFsnV2luZG93cyA5OCcsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICAgIFsnV2luZG93cyAyMDAwJywgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgICBbJ1dpbmRvd3MgWFAnLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgICBbJ1dpbmRvd3MgU2VydmVyIDIwMDMnLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICAgIFsnV2luZG93cyBWaXN0YScsIC8oV2luZG93cyBOVCA2LjApL10sXG4gICAgWydXaW5kb3dzIDcnLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICAgIFsnV2luZG93cyA4JywgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgICBbJ1dpbmRvd3MgOC4xJywgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgICBbJ1dpbmRvd3MgMTAnLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgICBbJ1dpbmRvd3MgTUUnLCAvV2luZG93cyBNRS9dLFxuICAgIFsnT3BlbiBCU0QnLCAvT3BlbkJTRC9dLFxuICAgIFsnU3VuIE9TJywgL1N1bk9TL10sXG4gICAgWydDaHJvbWUgT1MnLCAvQ3JPUy9dLFxuICAgIFsnTGludXgnLCAvKExpbnV4KXwoWDExKS9dLFxuICAgIFsnTWFjIE9TJywgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgICBbJ1FOWCcsIC9RTlgvXSxcbiAgICBbJ0JlT1MnLCAvQmVPUy9dLFxuICAgIFsnT1MvMicsIC9PU1xcLzIvXSxcbiAgICBbJ1NlYXJjaCBCb3QnLCBTRUFSQ0hCT1RfT1NfUkVHRVhdLFxuXTtcbmZ1bmN0aW9uIGRldGVjdCh1c2VyQWdlbnQpIHtcbiAgICBpZiAoISF1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXNlckFnZW50KHVzZXJBZ2VudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb2RlVmVyc2lvbigpO1xufVxuZXhwb3J0cy5kZXRlY3QgPSBkZXRlY3Q7XG5mdW5jdGlvbiBwYXJzZVVzZXJBZ2VudCh1YSkge1xuICAgIC8vIG9wdGVkIGZvciB1c2luZyByZWR1Y2UgaGVyZSByYXRoZXIgdGhhbiBBcnJheSNmaXJzdCB3aXRoIGEgcmVnZXgudGVzdCBjYWxsXG4gICAgLy8gdGhpcyBpcyBwcmltYXJpbHkgYmVjYXVzZSB1c2luZyB0aGUgcmVkdWNlIHdlIG9ubHkgcGVyZm9ybSB0aGUgcmVnZXhcbiAgICAvLyBleGVjdXRpb24gb25jZSByYXRoZXIgdGhhbiBvbmNlIGZvciB0aGUgdGVzdCBhbmQgZm9yIHRoZSBleGVjIGFnYWluIGJlbG93XG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHRoYXQgbmVlZHMgdG8gYmUgYmVuY2htYXJrZWQgdGhvdWdoXG4gICAgdmFyIG1hdGNoZWRSdWxlID0gdWEgIT09ICcnICYmXG4gICAgICAgIHVzZXJBZ2VudFJ1bGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hlZCwgX2EpIHtcbiAgICAgICAgICAgIHZhciBicm93c2VyID0gX2FbMF0sIHJlZ2V4ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVhTWF0Y2ggPSByZWdleC5leGVjKHVhKTtcbiAgICAgICAgICAgIHJldHVybiAhIXVhTWF0Y2ggJiYgW2Jyb3dzZXIsIHVhTWF0Y2hdO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgaWYgKCFtYXRjaGVkUnVsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBtYXRjaGVkUnVsZVswXSwgbWF0Y2ggPSBtYXRjaGVkUnVsZVsxXTtcbiAgICBpZiAobmFtZSA9PT0gJ3NlYXJjaGJvdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3RJbmZvKCk7XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uUGFydHMgPSBtYXRjaFsxXSAmJiBtYXRjaFsxXS5zcGxpdCgvWy5fXS8pLnNsaWNlKDAsIDMpO1xuICAgIGlmICh2ZXJzaW9uUGFydHMpIHtcbiAgICAgICAgaWYgKHZlcnNpb25QYXJ0cy5sZW5ndGggPCBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTKSB7XG4gICAgICAgICAgICB2ZXJzaW9uUGFydHMgPSBfX3NwcmVhZEFycmF5cyh2ZXJzaW9uUGFydHMsIGNyZWF0ZVZlcnNpb25QYXJ0cyhSRVFVSVJFRF9WRVJTSU9OX1BBUlRTIC0gdmVyc2lvblBhcnRzLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2ZXJzaW9uUGFydHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uUGFydHMuam9pbignLicpLCBkZXRlY3RPUyh1YSkpO1xufVxuZXhwb3J0cy5wYXJzZVVzZXJBZ2VudCA9IHBhcnNlVXNlckFnZW50O1xuZnVuY3Rpb24gZGV0ZWN0T1ModWEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGNvdW50ID0gb3BlcmF0aW5nU3lzdGVtUnVsZXMubGVuZ3RoOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzW2lpXSwgb3MgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXgudGVzdCh1YSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5kZXRlY3RPUyA9IGRldGVjdE9TO1xuZnVuY3Rpb24gZ2V0Tm9kZVZlcnNpb24oKSB7XG4gICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb247XG4gICAgcmV0dXJuIGlzTm9kZSA/IG5ldyBOb2RlSW5mbyhwcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkpIDogbnVsbDtcbn1cbmV4cG9ydHMuZ2V0Tm9kZVZlcnNpb24gPSBnZXROb2RlVmVyc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25QYXJ0cyhjb3VudCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY291bnQ7IGlpKyspIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNDT1JTID0gdm9pZCAwO1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L2hhcy1jb3JzXG5sZXQgdmFsdWUgPSBmYWxzZTtcbnRyeSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufVxuY2F0Y2ggKGVycikge1xuICAgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbn1cbmV4cG9ydHMuaGFzQ09SUyA9IHZhbHVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9xdWVyeXN0cmluZ1xuLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVuY29kZShvYmopIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcmJztcbiAgICAgICAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShxcykge1xuICAgIGxldCBxcnkgPSB7fTtcbiAgICBsZXQgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGxldCBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgfVxuICAgIHJldHVybiBxcnk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IHZvaWQgMDtcbi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dhbGtuL3BhcnNldXJpXG4vKipcbiAqIFBhcnNlcyBhIFVSSVxuICpcbiAqIE5vdGU6IHdlIGNvdWxkIGFsc28gaGF2ZSB1c2VkIHRoZSBidWlsdC1pbiBVUkwgb2JqZWN0LCBidXQgaXQgaXNuJ3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMuXG4gKlxuICogU2VlOlxuICogLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJMXG4gKiAtIGh0dHBzOi8vY2FuaXVzZS5jb20vdXJsXG4gKiAtIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMzOTg2I2FwcGVuZGl4LUJcbiAqXG4gKiBIaXN0b3J5IG9mIHRoZSBwYXJzZSgpIG1ldGhvZDpcbiAqIC0gZmlyc3QgY29tbWl0OiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vc29ja2V0LmlvLWNsaWVudC9jb21taXQvNGVlMWQ1ZDk0YjM5MDZhOWMwNTJiNDU5ZjFhODE4YjE1ZjM4ZjkxY1xuICogLSBleHBvcnQgaW50byBpdHMgb3duIG1vZHVsZTogaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL2VuZ2luZS5pby1jbGllbnQvY29tbWl0L2RlMmM1NjFlNDU2NGVmZWI3OGYxYmRiMWJhMzllZjgxYjI4MjJjYjNcbiAqIC0gcmVpbXBvcnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tY2xpZW50L2NvbW1pdC9kZjMyMjc3YzNmNmQ2MjJlZWM1ZWQwOWY0OTNjYWUzZjMzOTFkMjQyXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmNvbnN0IHJlID0gL14oPzooPyFbXjpAXFwvPyNdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXFwvPyNdKikoPzo6KFteOkBcXC8/I10qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5jb25zdCBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBjb25zdCBzcmMgPSBzdHIsIGIgPSBzdHIuaW5kZXhPZignWycpLCBlID0gc3RyLmluZGV4T2YoJ10nKTtcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBtID0gcmUuZXhlYyhzdHIgfHwgJycpLCB1cmkgPSB7fSwgaSA9IDE0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuICAgIHVyaS5wYXRoTmFtZXMgPSBwYXRoTmFtZXModXJpLCB1cmlbJ3BhdGgnXSk7XG4gICAgdXJpLnF1ZXJ5S2V5ID0gcXVlcnlLZXkodXJpLCB1cmlbJ3F1ZXJ5J10pO1xuICAgIHJldHVybiB1cmk7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gICAgY29uc3QgcmVneCA9IC9cXC97Miw5fS9nLCBuYW1lcyA9IHBhdGgucmVwbGFjZShyZWd4LCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXRoLnNsaWNlKDAsIDEpID09ICcvJyB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBuYW1lcy5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PSAnLycpIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKG5hbWVzLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBxdWVyeUtleSh1cmksIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIHF1ZXJ5LnJlcGxhY2UoLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgICAgICBpZiAoJDEpIHtcbiAgICAgICAgICAgIGRhdGFbJDFdID0gJDI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbiIsIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Vuc2hpZnRpby95ZWFzdFxuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy55ZWFzdCA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJyksIGxlbmd0aCA9IDY0LCBtYXAgPSB7fTtcbmxldCBzZWVkID0gMCwgaSA9IDAsIHByZXY7XG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gICAgbGV0IGVuY29kZWQgPSAnJztcbiAgICBkbyB7XG4gICAgICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgIHJldHVybiBlbmNvZGVkO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgbGV0IGRlY29kZWQgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgICBjb25zdCBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuICAgIGlmIChub3cgIT09IHByZXYpXG4gICAgICAgIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgICByZXR1cm4gbm93ICsgJy4nICsgZW5jb2RlKHNlZWQrKyk7XG59XG5leHBvcnRzLnllYXN0ID0geWVhc3Q7XG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdsb2JhbFRoaXNTaGltID0gdm9pZCAwO1xuZXhwb3J0cy5nbG9iYWxUaGlzU2hpbSA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICAgIH1cbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLnBhcnNlID0gZXhwb3J0cy5pbnN0YWxsVGltZXJGdW5jdGlvbnMgPSBleHBvcnRzLnRyYW5zcG9ydHMgPSBleHBvcnRzLlRyYW5zcG9ydCA9IGV4cG9ydHMucHJvdG9jb2wgPSBleHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9qc18xID0gcmVxdWlyZShcIi4vc29ja2V0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfanNfMS5Tb2NrZXQ7IH0gfSk7XG5leHBvcnRzLnByb3RvY29sID0gc29ja2V0X2pzXzEuU29ja2V0LnByb3RvY29sO1xudmFyIHRyYW5zcG9ydF9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNwb3J0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRfanNfMS5UcmFuc3BvcnQ7IH0gfSk7XG52YXIgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmFuc3BvcnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLnRyYW5zcG9ydHM7IH0gfSk7XG52YXIgdXRpbF9qc18xID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluc3RhbGxUaW1lckZ1bmN0aW9uc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF9qc18xLmluc3RhbGxUaW1lckZ1bmN0aW9uczsgfSB9KTtcbnZhciBwYXJzZXVyaV9qc18xID0gcmVxdWlyZShcIi4vY29udHJpYi9wYXJzZXVyaS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXVyaV9qc18xLnBhcnNlOyB9IH0pO1xudmFyIHdlYnNvY2tldF9jb25zdHJ1Y3Rvcl9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy93ZWJzb2NrZXQtY29uc3RydWN0b3IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuZXh0VGlja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2Vic29ja2V0X2NvbnN0cnVjdG9yX2pzXzEubmV4dFRpY2s7IH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvaW5kZXguanNcIik7XG5jb25zdCB1dGlsX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xuY29uc3QgcGFyc2Vxc19qc18xID0gcmVxdWlyZShcIi4vY29udHJpYi9wYXJzZXFzLmpzXCIpO1xuY29uc3QgcGFyc2V1cmlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyaWIvcGFyc2V1cmkuanNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7IC8vIGRlYnVnKClcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IGVuZ2luZV9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZS5pby1jbGllbnQ6c29ja2V0XCIpOyAvLyBkZWJ1ZygpXG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBjb21wb25lbnRfZW1pdHRlcl8xLkVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIC0gdXJpIG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmksIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgIGlmICh1cmkgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVyaSkge1xuICAgICAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgICAgIHVyaSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgICAgdXJpID0gKDAsIHBhcnNldXJpX2pzXzEucGFyc2UpKHVyaSk7XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgICAgICAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwc1wiIHx8IHVyaS5wcm90b2NvbCA9PT0gXCJ3c3NcIjtcbiAgICAgICAgICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgICAgICAgICAgaWYgKHVyaS5xdWVyeSlcbiAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSA9ICgwLCBwYXJzZXVyaV9qc18xLnBhcnNlKShvcHRzLmhvc3QpLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV0aWxfanNfMS5pbnN0YWxsVGltZXJGdW5jdGlvbnMpKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnNlY3VyZSA9XG4gICAgICAgICAgICBudWxsICE9IG9wdHMuc2VjdXJlXG4gICAgICAgICAgICAgICAgPyBvcHRzLnNlY3VyZVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgICAgICAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogXCJsb2NhbGhvc3RcIik7XG4gICAgICAgIHRoaXMucG9ydCA9XG4gICAgICAgICAgICBvcHRzLnBvcnQgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCI0NDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjgwXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgW1wicG9sbGluZ1wiLCBcIndlYnNvY2tldFwiXTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBhdGg6IFwiL2VuZ2luZS5pb1wiLFxuICAgICAgICAgICAgYWdlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAgICAgICB0aW1lc3RhbXBQYXJhbTogXCJ0XCIsXG4gICAgICAgICAgICByZW1lbWJlclVwZ3JhZGU6IGZhbHNlLFxuICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdHJ1ZSxcbiAgICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDI0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgY2xvc2VPbkJlZm9yZXVubG9hZDogdHJ1ZSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIHRoaXMub3B0cy5wYXRoID1cbiAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0cy5hZGRUcmFpbGluZ1NsYXNoID8gXCIvXCIgOiBcIlwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5xdWVyeSA9ICgwLCBwYXJzZXFzX2pzXzEuZGVjb2RlKSh0aGlzLm9wdHMucXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNsb3NlT25CZWZvcmV1bmxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNsb3NlcyB0aGUgY29ubmVjdGlvbiB3aGVuIHRoZSBcImJlZm9yZXVubG9hZFwiIGV2ZW50IGlzIGVtaXR0ZWQgYnV0IG5vdCBDaHJvbWUuIFRoaXMgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmVzIGV2ZXJ5IGJyb3dzZXIgYmVoYXZlcyB0aGUgc2FtZSAobm8gXCJkaXNjb25uZWN0XCIgZXZlbnQgYXQgdGhlIFNvY2tldC5JTyBsZXZlbCB3aGVuIHRoZSBwYWdlIGlzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VkL3JlbG9hZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaWxlbnRseSBjbG9zZSB0aGUgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmbGluZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBjbG9zZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJuZXR3b3JrIGNvbm5lY3Rpb24gbG9zdFwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHRoaXMub2ZmbGluZUV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRyYW5zcG9ydCBuYW1lXG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNwb3J0KG5hbWUpIHtcbiAgICAgICAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMucXVlcnkpO1xuICAgICAgICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgICAgICAgcXVlcnkuRUlPID0gZW5naW5lX2lvX3BhcnNlcl8xLnByb3RvY29sO1xuICAgICAgICAvLyB0cmFuc3BvcnQgbmFtZVxuICAgICAgICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuICAgICAgICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgICAgICAgaWYgKHRoaXMuaWQpXG4gICAgICAgICAgICBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0sIHRoaXMub3B0cywge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBzb2NrZXQ6IHRoaXMsXG4gICAgICAgICAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICAgICAgICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhcIm9wdGlvbnM6ICVqXCIsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzEudHJhbnNwb3J0c1tuYW1lXShvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICBsZXQgdHJhbnNwb3J0O1xuICAgICAgICBpZiAodGhpcy5vcHRzLnJlbWVtYmVyVXBncmFkZSAmJlxuICAgICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBcIndlYnNvY2tldFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIGNyZWF0aW5nIHRyYW5zcG9ydDogJXNcIiwgZSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgICAgIGRlYnVnKFwic2V0dGluZyB0cmFuc3BvcnQgJXNcIiwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzXCIsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICAub24oXCJkcmFpblwiLCB0aGlzLm9uRHJhaW4uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5vbihcInBhY2tldFwiLCB0aGlzLm9uUGFja2V0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5vbihcImNsb3NlXCIsIChyZWFzb24pID0+IHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBjbG9zZVwiLCByZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0cmFuc3BvcnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvYmUobmFtZSkge1xuICAgICAgICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gICAgICAgIGxldCB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lKTtcbiAgICAgICAgbGV0IGZhaWxlZCA9IGZhbHNlO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG9uVHJhbnNwb3J0T3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcInBpbmdcIiwgZGF0YTogXCJwcm9iZVwiIH1dKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbmNlKFwicGFja2V0XCIsIChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKFwicG9uZ1wiID09PSBtc2cudHlwZSAmJiBcInByb2JlXCIgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IFwid2Vic29ja2V0XCIgPT09IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucGF1c2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwidXBncmFkZVwiIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZVwiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcInByb2JlIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRlRXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICAgICAgICBjb25zdCBvbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJwcm9iZSBlcnJvcjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVFcnJvclwiLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKSB7XG4gICAgICAgICAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgICAgICAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gICAgICAgIGZ1bmN0aW9uIG9udXBncmFkZSh0bykge1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICAgICAgICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICAgICAgICB0aGlzLm9mZihcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub25jZShcIm9wZW5cIiwgb25UcmFuc3BvcnRPcGVuKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICAgIHRoaXMub25jZShcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgICB0cmFuc3BvcnQub3BlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IG9wZW5cIik7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gXCJ3ZWJzb2NrZXRcIiA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgICAgICAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLm9wdHMudXBncmFkZSkge1xuICAgICAgICAgICAgZGVidWcoXCJzdGFydGluZyB1cGdyYWRlIHByb2Jlc1wiKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgICAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb25nXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwic2VydmVyIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm1lc3NhZ2VcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBoYW5kc2hha2Ugb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkhhbmRzaGFrZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiaGFuZHNoYWtlXCIsIGRhdGEpO1xuICAgICAgICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICAgICAgICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gICAgICAgIHRoaXMubWF4UGF5bG9hZCA9IGRhdGEubWF4UGF5bG9hZDtcbiAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbmQgcmVzZXRzIHBpbmcgdGltZW91dCB0aW1lciBiYXNlZCBvbiBzZXJ2ZXIgcGluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbCArIHRoaXMucGluZ1RpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmF1dG9VbnJlZikge1xuICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EcmFpbigpIHtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcbiAgICAgICAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAgICAgICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgICAgICAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgICAgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMudXBncmFkaW5nICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0cyA9IHRoaXMuZ2V0V3JpdGFibGVQYWNrZXRzKCk7XG4gICAgICAgICAgICBkZWJ1ZyhcImZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0XCIsIHBhY2tldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQocGFja2V0cyk7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgICAgICAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICAgICAgICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJmbHVzaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIGVuY29kZWQgc2l6ZSBvZiB0aGUgd3JpdGVCdWZmZXIgaXMgYmVsb3cgdGhlIG1heFBheWxvYWQgdmFsdWUgc2VudCBieSB0aGUgc2VydmVyIChvbmx5IGZvciBIVFRQXG4gICAgICogbG9uZy1wb2xsaW5nKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRXcml0YWJsZVBhY2tldHMoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrUGF5bG9hZFNpemUgPSB0aGlzLm1heFBheWxvYWQgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm5hbWUgPT09IFwicG9sbGluZ1wiICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA+IDE7XG4gICAgICAgIGlmICghc2hvdWxkQ2hlY2tQYXlsb2FkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBheWxvYWRTaXplID0gMTsgLy8gZmlyc3QgcGFja2V0IHR5cGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy53cml0ZUJ1ZmZlcltpXS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSAoMCwgdXRpbF9qc18xLmJ5dGVMZW5ndGgpKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHBheWxvYWRTaXplID4gdGhpcy5tYXhQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJvbmx5IHNlbmQgJWQgb3V0IG9mICVkIHBhY2tldHNcIiwgaSwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gMjsgLy8gc2VwYXJhdG9yICsgcGFja2V0IHR5cGVcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInBheWxvYWQgc2l6ZSBpcyAlZCAobWF4OiAlZClcIiwgcGF5bG9hZFNpemUsIHRoaXMubWF4UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB3cml0ZShtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgbXNnLCBvcHRpb25zLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZW5kKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGU6IHBhY2tldCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0Q3JlYXRlXCIsIHBhY2tldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJmbHVzaFwiLCBmbik7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgICAgIGRlYnVnKFwic29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBBbmRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkZVwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRGb3JVcGdyYWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVFcnJvclwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGVycm9yICVqXCIsIGVycik7XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgICAgICAgICAvLyBjbGVhciB0aW1lcnNcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLmJlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCB0aGlzLm9mZmxpbmVFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgICAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHVwZ3JhZGVzIC0gc2VydmVyIHVwZ3JhZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaWx0ZXJVcGdyYWRlcyh1cGdyYWRlcykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgaiA9IHVwZ3JhZGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh+dGhpcy50cmFuc3BvcnRzLmluZGV4T2YodXBncmFkZXNbaV0pKVxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQucHJvdG9jb2wgPSBlbmdpbmVfaW9fcGFyc2VyXzEucHJvdG9jb2w7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3QgZW5naW5lX2lvX3BhcnNlcl8xID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBjb21wb25lbnRfZW1pdHRlcl8xID0gcmVxdWlyZShcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIik7XG5jb25zdCB1dGlsX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lLmlvLWNsaWVudDp0cmFuc3BvcnRcIik7IC8vIGRlYnVnKClcbmNsYXNzIFRyYW5zcG9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocmVhc29uKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gICAgfVxufVxuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgY29tcG9uZW50X2VtaXR0ZXJfMS5FbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICgwLCB1dGlsX2pzXzEuaW5zdGFsbFRpbWVyRnVuY3Rpb25zKSh0aGlzLCBvcHRzKTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gdGhlIGVycm9yIGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkVycm9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgbmV3IFRyYW5zcG9ydEVycm9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIHRoaXMuZG9PcGVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhcHBlbiBpZiB0aGUgdHJhbnNwb3J0IHdhcyBzaWxlbnRseSBjbG9zZWQgaW4gdGhlIGJlZm9yZXVubG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBpcyBub3Qgb3BlbiwgZGlzY2FyZGluZyBwYWNrZXRzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIG9wZW5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9ICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuZGVjb2RlUGFja2V0KShkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZShkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIGRldGFpbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHRyYW5zcG9ydCwgaW4gb3JkZXIgbm90IHRvIGxvc2UgcGFja2V0cyBkdXJpbmcgYW4gdXBncmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvblBhdXNlXG4gICAgICovXG4gICAgcGF1c2Uob25QYXVzZSkgeyB9XG59XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50cmFuc3BvcnRzID0gdm9pZCAwO1xuY29uc3QgcG9sbGluZ19qc18xID0gcmVxdWlyZShcIi4vcG9sbGluZy5qc1wiKTtcbmNvbnN0IHdlYnNvY2tldF9qc18xID0gcmVxdWlyZShcIi4vd2Vic29ja2V0LmpzXCIpO1xuZXhwb3J0cy50cmFuc3BvcnRzID0ge1xuICAgIHdlYnNvY2tldDogd2Vic29ja2V0X2pzXzEuV1MsXG4gICAgcG9sbGluZzogcG9sbGluZ19qc18xLlBvbGxpbmcsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcXVlc3QgPSBleHBvcnRzLlBvbGxpbmcgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfanNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnQuanNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7IC8vIGRlYnVnKClcbmNvbnN0IHllYXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vY29udHJpYi95ZWFzdC5qc1wiKTtcbmNvbnN0IHBhcnNlcXNfanNfMSA9IHJlcXVpcmUoXCIuLi9jb250cmliL3BhcnNlcXMuanNcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IHhtbGh0dHByZXF1ZXN0X2pzXzEgPSByZXF1aXJlKFwiLi94bWxodHRwcmVxdWVzdC5qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuY29uc3QgZ2xvYmFsVGhpc19qc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbFRoaXMuanNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nXCIpOyAvLyBkZWJ1ZygpXG5mdW5jdGlvbiBlbXB0eSgpIHsgfVxuY29uc3QgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IHhtbGh0dHByZXF1ZXN0X2pzXzEuWEhSKHtcbiAgICAgICAgeGRvbWFpbjogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5jbGFzcyBQb2xsaW5nIGV4dGVuZHMgdHJhbnNwb3J0X2pzXzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgaXNTU0wgPSBcImh0dHBzOlwiID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgIGxldCBwb3J0ID0gbG9jYXRpb24ucG9ydDtcbiAgICAgICAgICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICAgICAgICAgIGlmICghcG9ydCkge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBpc1NTTCA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnhkID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgICAgICAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBmb3JjZUJhc2U2NCA9IG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGhhc1hIUjIgJiYgIWZvcmNlQmFzZTY0O1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicG9sbGluZ1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gICAgICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9PcGVuKCkge1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHBvbGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblBhdXNlIC0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBwYXVzZShvblBhdXNlKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwicGF1c2luZ1wiO1xuICAgICAgICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwicGF1c2VkXCIpO1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzZWRcIjtcbiAgICAgICAgICAgIG9uUGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIndlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2VcIik7XG4gICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJwb2xsQ29tcGxldGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIndlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2VcIik7XG4gICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvbGwoKSB7XG4gICAgICAgIGRlYnVnKFwicG9sbGluZ1wiKTtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb1BvbGwoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb2xsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBkZWJ1ZyhcInBvbGxpbmcgZ290IGRhdGEgJXNcIiwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgICAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgcGFja2V0LnR5cGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHsgZGVzY3JpcHRpb246IFwidHJhbnNwb3J0IGNsb3NlZCBieSB0aGUgc2VydmVyXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWNvZGUgcGF5bG9hZFxuICAgICAgICAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmRlY29kZVBheWxvYWQpKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgICAgICAgICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBvbGxDb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nXCIpO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgICAgICAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJvcGVuXCIsIGNsb3NlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzIC0gZGF0YSBwYWNrZXRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdyaXRlKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmVuY29kZVBheWxvYWQpKHBhY2tldHMsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgICAgICBsZXQgcG9ydCA9IFwiXCI7XG4gICAgICAgIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gICAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgICAgICAgICBxdWVyeVt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0gKDAsIHllYXN0X2pzXzEueWVhc3QpKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wb3J0ICYmXG4gICAgICAgICAgICAoKFwiaHR0cHNcIiA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgICAgICAgICAgICAoXCJodHRwXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgICAgICAgICBwb3J0ID0gXCI6XCIgKyB0aGlzLm9wdHMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkUXVlcnkgPSAoMCwgcGFyc2Vxc19qc18xLmVuY29kZSkocXVlcnkpO1xuICAgICAgICBjb25zdCBpcHY2ID0gdGhpcy5vcHRzLmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIChzY2hlbWEgK1xuICAgICAgICAgICAgXCI6Ly9cIiArXG4gICAgICAgICAgICAoaXB2NiA/IFwiW1wiICsgdGhpcy5vcHRzLmhvc3RuYW1lICsgXCJdXCIgOiB0aGlzLm9wdHMuaG9zdG5hbWUpICtcbiAgICAgICAgICAgIHBvcnQgK1xuICAgICAgICAgICAgdGhpcy5vcHRzLnBhdGggK1xuICAgICAgICAgICAgKGVuY29kZWRRdWVyeS5sZW5ndGggPyBcIj9cIiArIGVuY29kZWRRdWVyeSA6IFwiXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZXF1ZXN0KG9wdHMgPSB7fSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHsgeGQ6IHRoaXMueGQsIHhzOiB0aGlzLnhzIH0sIHRoaXMub3B0cyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLnVyaSgpLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIGZuKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbihcInN1Y2Nlc3NcIiwgZm4pO1xuICAgICAgICByZXEub24oXCJlcnJvclwiLCAoeGhyU3RhdHVzLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ4aHIgcG9zdCBlcnJvclwiLCB4aHJTdGF0dXMsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Qb2xsKCkge1xuICAgICAgICBkZWJ1ZyhcInhociBwb2xsXCIpO1xuICAgICAgICBjb25zdCByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9uKFwiZGF0YVwiLCB0aGlzLm9uRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKHhoclN0YXR1cywgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwieGhyIHBvbGwgZXJyb3JcIiwgeGhyU3RhdHVzLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9sbFhociA9IHJlcTtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmcgPSBQb2xsaW5nO1xuY2xhc3MgUmVxdWVzdCBleHRlbmRzIGNvbXBvbmVudF9lbWl0dGVyXzEuRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAoMCwgdXRpbF9qc18xLmluc3RhbGxUaW1lckZ1bmN0aW9ucykodGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgXCJHRVRcIjtcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgICAgICAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICAgICAgICB0aGlzLmNyZWF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxfanNfMS5waWNrKSh0aGlzLm9wdHMsIFwiYWdlbnRcIiwgXCJwZnhcIiwgXCJrZXlcIiwgXCJwYXNzcGhyYXNlXCIsIFwiY2VydFwiLCBcImNhXCIsIFwiY2lwaGVyc1wiLCBcInJlamVjdFVuYXV0aG9yaXplZFwiLCBcImF1dG9VbnJlZlwiKTtcbiAgICAgICAgb3B0cy54ZG9tYWluID0gISF0aGlzLm9wdHMueGQ7XG4gICAgICAgIG9wdHMueHNjaGVtZSA9ICEhdGhpcy5vcHRzLnhzO1xuICAgICAgICBjb25zdCB4aHIgPSAodGhpcy54aHIgPSBuZXcgeG1saHR0cHJlcXVlc3RfanNfMS5YSFIob3B0cykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVidWcoXCJ4aHIgb3BlbiAlczogJXNcIiwgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICAgICAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMub3B0cy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWYgKFwiUE9TVFwiID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiKi8qXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gaWU2IGNoZWNrXG4gICAgICAgICAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy5vcHRzLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB4aHIudGltZW91dCA9IHRoaXMub3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IodHlwZW9mIHhoci5zdGF0dXMgPT09IFwibnVtYmVyXCIgPyB4aHIuc3RhdHVzIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1ZyhcInhociBkYXRhICVzXCIsIHRoaXMuZGF0YSk7XG4gICAgICAgICAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGUpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgICAgICAgICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyLCB0aGlzLnhocik7XG4gICAgICAgIHRoaXMuY2xlYW51cCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGhvdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbGVhbnVwKGZyb21FcnJvcikge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gICAgICAgIGlmIChmcm9tRXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhociA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGxvYWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uTG9hZCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgYXR0YWNoRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25FdmVudCA9IFwib25wYWdlaGlkZVwiIGluIGdsb2JhbFRoaXNfanNfMS5nbG9iYWxUaGlzU2hpbSA/IFwicGFnZWhpZGVcIiA6IFwidW5sb2FkXCI7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIodGVybWluYXRpb25FdmVudCwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gICAgZm9yIChsZXQgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdEJpbmFyeVR5cGUgPSBleHBvcnRzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IGV4cG9ydHMuV2ViU29ja2V0ID0gZXhwb3J0cy5uZXh0VGljayA9IHZvaWQgMDtcbmNvbnN0IGdsb2JhbFRoaXNfanNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxUaGlzLmpzXCIpO1xuZXhwb3J0cy5uZXh0VGljayA9ICgoKSA9PiB7XG4gICAgY29uc3QgaXNQcm9taXNlQXZhaWxhYmxlID0gdHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgUHJvbWlzZS5yZXNvbHZlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgaWYgKGlzUHJvbWlzZUF2YWlsYWJsZSkge1xuICAgICAgICByZXR1cm4gKGNiKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoY2IsIHNldFRpbWVvdXRGbikgPT4gc2V0VGltZW91dEZuKGNiLCAwKTtcbiAgICB9XG59KSgpO1xuZXhwb3J0cy5XZWJTb2NrZXQgPSBnbG9iYWxUaGlzX2pzXzEuZ2xvYmFsVGhpc1NoaW0uV2ViU29ja2V0IHx8IGdsb2JhbFRoaXNfanNfMS5nbG9iYWxUaGlzU2hpbS5Nb3pXZWJTb2NrZXQ7XG5leHBvcnRzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHRCaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldTID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0LmpzXCIpO1xuY29uc3QgcGFyc2Vxc19qc18xID0gcmVxdWlyZShcIi4uL2NvbnRyaWIvcGFyc2Vxcy5qc1wiKTtcbmNvbnN0IHllYXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vY29udHJpYi95ZWFzdC5qc1wiKTtcbmNvbnN0IHV0aWxfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xuY29uc3Qgd2Vic29ja2V0X2NvbnN0cnVjdG9yX2pzXzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXQtY29uc3RydWN0b3IuanNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7IC8vIGRlYnVnKClcbmNvbnN0IGVuZ2luZV9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0XCIpOyAvLyBkZWJ1ZygpXG4vLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcInN0cmluZ1wiICYmXG4gICAgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gXCJyZWFjdG5hdGl2ZVwiO1xuY2xhc3MgV1MgZXh0ZW5kcyB0cmFuc3BvcnRfanNfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIGNvbm5lY3Rpb24gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gIW9wdHMuZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgICAgICAgICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSB0aGlzLnVyaSgpO1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSB0aGlzLm9wdHMucHJvdG9jb2xzO1xuICAgICAgICAvLyBSZWFjdCBOYXRpdmUgb25seSBzdXBwb3J0cyB0aGUgJ2hlYWRlcnMnIG9wdGlvbiwgYW5kIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIGFueXRoaW5nIGVsc2UgaXMgcGFzc2VkXG4gICAgICAgIGNvbnN0IG9wdHMgPSBpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6ICgwLCB1dGlsX2pzXzEucGljaykodGhpcy5vcHRzLCBcImFnZW50XCIsIFwicGVyTWVzc2FnZURlZmxhdGVcIiwgXCJwZnhcIiwgXCJrZXlcIiwgXCJwYXNzcGhyYXNlXCIsIFwiY2VydFwiLCBcImNhXCIsIFwiY2lwaGVyc1wiLCBcInJlamVjdFVuYXV0aG9yaXplZFwiLCBcImxvY2FsQWRkcmVzc1wiLCBcInByb3RvY29sVmVyc2lvblwiLCBcIm9yaWdpblwiLCBcIm1heFBheWxvYWRcIiwgXCJmYW1pbHlcIiwgXCJjaGVja1NlcnZlcklkZW50aXR5XCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gdGhpcy5vcHRzLmV4dHJhSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cyA9XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0X2NvbnN0cnVjdG9yX2pzXzEudXNpbmdCcm93c2VyV2ViU29ja2V0ICYmICFpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICAgICAgICAgID8gcHJvdG9jb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyB3ZWJzb2NrZXRfY29uc3RydWN0b3JfanNfMS5XZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyB3ZWJzb2NrZXRfY29uc3RydWN0b3JfanNfMS5XZWJTb2NrZXQodXJpKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyB3ZWJzb2NrZXRfY29uc3RydWN0b3JfanNfMS5XZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSB8fCB3ZWJzb2NrZXRfY29uc3RydWN0b3JfanNfMS5kZWZhdWx0QmluYXJ5VHlwZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cy5fc29ja2V0LnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoY2xvc2VFdmVudCkgPT4gdGhpcy5vbkNsb3NlKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIndlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogY2xvc2VFdmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLm9uRGF0YShldi5kYXRhKTtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gKGUpID0+IHRoaXMub25FcnJvcihcIndlYnNvY2tldCBlcnJvclwiLCBlKTtcbiAgICB9XG4gICAgd3JpdGUocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gICAgICAgIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhY2tldCA9IGkgPT09IHBhY2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICgwLCBlbmdpbmVfaW9fcGFyc2VyXzEuZW5jb2RlUGFja2V0KShwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKCF3ZWJzb2NrZXRfY29uc3RydWN0b3JfanNfMS51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuIDwgdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vic29ja2V0X2NvbnN0cnVjdG9yX2pzXzEudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwid2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFrZSBkcmFpblxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICgwLCB3ZWJzb2NrZXRfY29uc3RydWN0b3JfanNfMS5uZXh0VGljaykoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9DbG9zZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLndzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cmkoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMub3B0cy5zZWN1cmUgPyBcIndzc1wiIDogXCJ3c1wiO1xuICAgICAgICBsZXQgcG9ydCA9IFwiXCI7XG4gICAgICAgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gICAgICAgIGlmICh0aGlzLm9wdHMucG9ydCAmJlxuICAgICAgICAgICAgKChcIndzc1wiID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMub3B0cy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAgICAgICAgICAgIChcIndzXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgICAgICAgICBwb3J0ID0gXCI6XCIgKyB0aGlzLm9wdHMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICAgICAgICBpZiAodGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgICAgICAgICBxdWVyeVt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0gKDAsIHllYXN0X2pzXzEueWVhc3QpKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcXVlcnkuYjY0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkUXVlcnkgPSAoMCwgcGFyc2Vxc19qc18xLmVuY29kZSkocXVlcnkpO1xuICAgICAgICBjb25zdCBpcHY2ID0gdGhpcy5vcHRzLmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIChzY2hlbWEgK1xuICAgICAgICAgICAgXCI6Ly9cIiArXG4gICAgICAgICAgICAoaXB2NiA/IFwiW1wiICsgdGhpcy5vcHRzLmhvc3RuYW1lICsgXCJdXCIgOiB0aGlzLm9wdHMuaG9zdG5hbWUpICtcbiAgICAgICAgICAgIHBvcnQgK1xuICAgICAgICAgICAgdGhpcy5vcHRzLnBhdGggK1xuICAgICAgICAgICAgKGVuY29kZWRRdWVyeS5sZW5ndGggPyBcIj9cIiArIGVuY29kZWRRdWVyeSA6IFwiXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIHJldHVybiAhIXdlYnNvY2tldF9jb25zdHJ1Y3Rvcl9qc18xLldlYlNvY2tldDtcbiAgICB9XG59XG5leHBvcnRzLldTID0gV1M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlhIUiA9IHZvaWQgMDtcbmNvbnN0IGhhc19jb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vY29udHJpYi9oYXMtY29ycy5qc1wiKTtcbmNvbnN0IGdsb2JhbFRoaXNfanNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxUaGlzLmpzXCIpO1xuZnVuY3Rpb24gWEhSKG9wdHMpIHtcbiAgICBjb25zdCB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICAgIHRyeSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc19jb3JzX2pzXzEuaGFzQ09SUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgaWYgKCF4ZG9tYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdsb2JhbFRoaXNfanNfMS5nbG9iYWxUaGlzU2hpbVtbXCJBY3RpdmVcIl0uY29uY2F0KFwiT2JqZWN0XCIpLmpvaW4oXCJYXCIpXShcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG59XG5leHBvcnRzLlhIUiA9IFhIUjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlTGVuZ3RoID0gZXhwb3J0cy5pbnN0YWxsVGltZXJGdW5jdGlvbnMgPSBleHBvcnRzLnBpY2sgPSB2b2lkIDA7XG5jb25zdCBnbG9iYWxUaGlzX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxUaGlzLmpzXCIpO1xuZnVuY3Rpb24gcGljayhvYmosIC4uLmF0dHIpIHtcbiAgICByZXR1cm4gYXR0ci5yZWR1Y2UoKGFjYywgaykgPT4ge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICBhY2Nba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5leHBvcnRzLnBpY2sgPSBwaWNrO1xuLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcmVhbCB0aW1lb3V0IGZ1bmN0aW9ucyBzbyB0aGV5IGNhbiBiZSB1c2VkIHdoZW4gb3ZlcnJpZGRlblxuY29uc3QgTkFUSVZFX1NFVF9USU1FT1VUID0gZ2xvYmFsVGhpc19qc18xLmdsb2JhbFRoaXNTaGltLnNldFRpbWVvdXQ7XG5jb25zdCBOQVRJVkVfQ0xFQVJfVElNRU9VVCA9IGdsb2JhbFRoaXNfanNfMS5nbG9iYWxUaGlzU2hpbS5jbGVhclRpbWVvdXQ7XG5mdW5jdGlvbiBpbnN0YWxsVGltZXJGdW5jdGlvbnMob2JqLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMudXNlTmF0aXZlVGltZXJzKSB7XG4gICAgICAgIG9iai5zZXRUaW1lb3V0Rm4gPSBOQVRJVkVfU0VUX1RJTUVPVVQuYmluZChnbG9iYWxUaGlzX2pzXzEuZ2xvYmFsVGhpc1NoaW0pO1xuICAgICAgICBvYmouY2xlYXJUaW1lb3V0Rm4gPSBOQVRJVkVfQ0xFQVJfVElNRU9VVC5iaW5kKGdsb2JhbFRoaXNfanNfMS5nbG9iYWxUaGlzU2hpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmouc2V0VGltZW91dEZuID0gZ2xvYmFsVGhpc19qc18xLmdsb2JhbFRoaXNTaGltLnNldFRpbWVvdXQuYmluZChnbG9iYWxUaGlzX2pzXzEuZ2xvYmFsVGhpc1NoaW0pO1xuICAgICAgICBvYmouY2xlYXJUaW1lb3V0Rm4gPSBnbG9iYWxUaGlzX2pzXzEuZ2xvYmFsVGhpc1NoaW0uY2xlYXJUaW1lb3V0LmJpbmQoZ2xvYmFsVGhpc19qc18xLmdsb2JhbFRoaXNTaGltKTtcbiAgICB9XG59XG5leHBvcnRzLmluc3RhbGxUaW1lckZ1bmN0aW9ucyA9IGluc3RhbGxUaW1lckZ1bmN0aW9ucztcbi8vIGJhc2U2NCBlbmNvZGVkIGJ1ZmZlcnMgYXJlIGFib3V0IDMzJSBiaWdnZXIgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NClcbmNvbnN0IEJBU0U2NF9PVkVSSEVBRCA9IDEuMzM7XG4vLyB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCBgbmV3IEJsb2IoW29ial0pLnNpemVgLCBidXQgaXQgaXNuJ3Qgc3VwcG9ydGVkIGluIElFOVxuZnVuY3Rpb24gYnl0ZUxlbmd0aChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXRmOExlbmd0aChvYmopO1xuICAgIH1cbiAgICAvLyBhcnJheWJ1ZmZlciBvciBibG9iXG4gICAgcmV0dXJuIE1hdGguY2VpbCgob2JqLmJ5dGVMZW5ndGggfHwgb2JqLnNpemUpICogQkFTRTY0X09WRVJIRUFEKTtcbn1cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xuICAgIGxldCBjID0gMCwgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVSUk9SX1BBQ0tFVCA9IGV4cG9ydHMuUEFDS0VUX1RZUEVTX1JFVkVSU0UgPSBleHBvcnRzLlBBQ0tFVF9UWVBFUyA9IHZvaWQgMDtcbmNvbnN0IFBBQ0tFVF9UWVBFUyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIG5vIE1hcCA9IG5vIHBvbHlmaWxsXG5leHBvcnRzLlBBQ0tFVF9UWVBFUyA9IFBBQ0tFVF9UWVBFUztcblBBQ0tFVF9UWVBFU1tcIm9wZW5cIl0gPSBcIjBcIjtcblBBQ0tFVF9UWVBFU1tcImNsb3NlXCJdID0gXCIxXCI7XG5QQUNLRVRfVFlQRVNbXCJwaW5nXCJdID0gXCIyXCI7XG5QQUNLRVRfVFlQRVNbXCJwb25nXCJdID0gXCIzXCI7XG5QQUNLRVRfVFlQRVNbXCJtZXNzYWdlXCJdID0gXCI0XCI7XG5QQUNLRVRfVFlQRVNbXCJ1cGdyYWRlXCJdID0gXCI1XCI7XG5QQUNLRVRfVFlQRVNbXCJub29wXCJdID0gXCI2XCI7XG5jb25zdCBQQUNLRVRfVFlQRVNfUkVWRVJTRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnRzLlBBQ0tFVF9UWVBFU19SRVZFUlNFID0gUEFDS0VUX1RZUEVTX1JFVkVSU0U7XG5PYmplY3Qua2V5cyhQQUNLRVRfVFlQRVMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBQQUNLRVRfVFlQRVNfUkVWRVJTRVtQQUNLRVRfVFlQRVNba2V5XV0gPSBrZXk7XG59KTtcbmNvbnN0IEVSUk9SX1BBQ0tFVCA9IHsgdHlwZTogXCJlcnJvclwiLCBkYXRhOiBcInBhcnNlciBlcnJvclwiIH07XG5leHBvcnRzLkVSUk9SX1BBQ0tFVCA9IEVSUk9SX1BBQ0tFVDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuY29uc3QgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG5jb25zdCBlbmNvZGUgPSAoYXJyYXlidWZmZXIpID0+IHtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG4gICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xufTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuY29uc3QgZGVjb2RlID0gKGJhc2U2NCkgPT4ge1xuICAgIGxldCBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSwgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG59O1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbnNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbnMuanNcIik7XG5jb25zdCBiYXNlNjRfYXJyYXlidWZmZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyaWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBkZWNvZGVQYWNrZXQgPSAoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZW5jb2RlZFBhY2tldCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBkYXRhOiBtYXBCaW5hcnkoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IGVuY29kZWRQYWNrZXQuY2hhckF0KDApO1xuICAgIGlmICh0eXBlID09PSBcImJcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVCYXNlNjRQYWNrZXQoZW5jb2RlZFBhY2tldC5zdWJzdHJpbmcoMSksIGJpbmFyeVR5cGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhY2tldFR5cGUgPSBjb21tb25zX2pzXzEuUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV07XG4gICAgaWYgKCFwYWNrZXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb21tb25zX2pzXzEuRVJST1JfUEFDS0VUO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZFBhY2tldC5sZW5ndGggPiAxXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogY29tbW9uc19qc18xLlBBQ0tFVF9UWVBFU19SRVZFUlNFW3R5cGVdLFxuICAgICAgICAgICAgZGF0YTogZW5jb2RlZFBhY2tldC5zdWJzdHJpbmcoMSlcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHR5cGU6IGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXVxuICAgICAgICB9O1xufTtcbmNvbnN0IGRlY29kZUJhc2U2NFBhY2tldCA9IChkYXRhLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlcikge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gKDAsIGJhc2U2NF9hcnJheWJ1ZmZlcl9qc18xLmRlY29kZSkoZGF0YSk7XG4gICAgICAgIHJldHVybiBtYXBCaW5hcnkoZGVjb2RlZCwgYmluYXJ5VHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBiYXNlNjQ6IHRydWUsIGRhdGEgfTsgLy8gZmFsbGJhY2sgZm9yIG9sZCBicm93c2Vyc1xuICAgIH1cbn07XG5jb25zdCBtYXBCaW5hcnkgPSAoZGF0YSwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIHN3aXRjaCAoYmluYXJ5VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBCbG9iKFtkYXRhXSkgOiBkYXRhO1xuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkYXRhOyAvLyBhc3N1bWluZyB0aGUgZGF0YSBpcyBhbHJlYWR5IGFuIEFycmF5QnVmZmVyXG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlY29kZVBhY2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbW9uc19qc18xID0gcmVxdWlyZShcIi4vY29tbW9ucy5qc1wiKTtcbmNvbnN0IHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQmxvYikgPT09IFwiW29iamVjdCBCbG9iQ29uc3RydWN0b3JdXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG4vLyBBcnJheUJ1ZmZlci5pc1ZpZXcgbWV0aG9kIGlzIG5vdCBkZWZpbmVkIGluIElFMTBcbmNvbnN0IGlzVmlldyA9IG9iaiA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IEFycmF5QnVmZmVyLmlzVmlldyhvYmopXG4gICAgICAgIDogb2JqICYmIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5jb25zdCBlbmNvZGVQYWNrZXQgPSAoeyB0eXBlLCBkYXRhIH0sIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh3aXRoTmF0aXZlQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBpZiAoc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVCbG9iQXNCYXNlNjQoZGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJlxuICAgICAgICAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhkYXRhKSkpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlQmxvYkFzQmFzZTY0KG5ldyBCbG9iKFtkYXRhXSksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwbGFpbiBzdHJpbmdcbiAgICByZXR1cm4gY2FsbGJhY2soY29tbW9uc19qc18xLlBBQ0tFVF9UWVBFU1t0eXBlXSArIChkYXRhIHx8IFwiXCIpKTtcbn07XG5jb25zdCBlbmNvZGVCbG9iQXNCYXNlNjQgPSAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZpbGVSZWFkZXIucmVzdWx0LnNwbGl0KFwiLFwiKVsxXTtcbiAgICAgICAgY2FsbGJhY2soXCJiXCIgKyBjb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZGF0YSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZW5jb2RlUGFja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBleHBvcnRzLmRlY29kZVBhY2tldCA9IGV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZXhwb3J0cy5wcm90b2NvbCA9IHZvaWQgMDtcbmNvbnN0IGVuY29kZVBhY2tldF9qc18xID0gcmVxdWlyZShcIi4vZW5jb2RlUGFja2V0LmpzXCIpO1xuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBlbmNvZGVQYWNrZXRfanNfMS5kZWZhdWx0O1xuY29uc3QgZGVjb2RlUGFja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9kZWNvZGVQYWNrZXQuanNcIik7XG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGRlY29kZVBhY2tldF9qc18xLmRlZmF1bHQ7XG5jb25zdCBTRVBBUkFUT1IgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgZW5jb2RlUGF5bG9hZCA9IChwYWNrZXRzLCBjYWxsYmFjaykgPT4ge1xuICAgIC8vIHNvbWUgcGFja2V0cyBtYXkgYmUgYWRkZWQgdG8gdGhlIGFycmF5IHdoaWxlIGVuY29kaW5nLCBzbyB0aGUgaW5pdGlhbCBsZW5ndGggbXVzdCBiZSBzYXZlZFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhY2tldHMubGVuZ3RoO1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBwYWNrZXRzLmZvckVhY2goKHBhY2tldCwgaSkgPT4ge1xuICAgICAgICAvLyBmb3JjZSBiYXNlNjQgZW5jb2RpbmcgZm9yIGJpbmFyeSBwYWNrZXRzXG4gICAgICAgICgwLCBlbmNvZGVQYWNrZXRfanNfMS5kZWZhdWx0KShwYWNrZXQsIGZhbHNlLCBlbmNvZGVkUGFja2V0ID0+IHtcbiAgICAgICAgICAgIGVuY29kZWRQYWNrZXRzW2ldID0gZW5jb2RlZFBhY2tldDtcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbmNvZGVkUGFja2V0cy5qb2luKFNFUEFSQVRPUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBlbmNvZGVQYXlsb2FkO1xuY29uc3QgZGVjb2RlUGF5bG9hZCA9IChlbmNvZGVkUGF5bG9hZCwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gZW5jb2RlZFBheWxvYWQuc3BsaXQoU0VQQVJBVE9SKTtcbiAgICBjb25zdCBwYWNrZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWNvZGVkUGFja2V0ID0gKDAsIGRlY29kZVBhY2tldF9qc18xLmRlZmF1bHQpKGVuY29kZWRQYWNrZXRzW2ldLCBiaW5hcnlUeXBlKTtcbiAgICAgICAgcGFja2V0cy5wdXNoKGRlY29kZWRQYWNrZXQpO1xuICAgICAgICBpZiAoZGVjb2RlZFBhY2tldC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWNrZXRzO1xufTtcbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGRlY29kZVBheWxvYWQ7XG5leHBvcnRzLnByb3RvY29sID0gNDtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHdvcmQgPSAnW2EtZkEtRlxcXFxkOl0nO1xuY29uc3QgYiA9IG9wdGlvbnMgPT4gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVCb3VuZGFyaWVzID9cblx0YCg/Oig/PD1cXFxcc3xeKSg/PSR7d29yZH0pfCg/PD0ke3dvcmR9KSg/PVxcXFxzfCQpKWAgOlxuXHQnJztcblxuY29uc3QgdjQgPSAnKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M30nO1xuXG5jb25zdCB2NnNlZyA9ICdbYS1mQS1GXFxcXGRdezEsNH0nO1xuY29uc3QgdjYgPSBgXG4oPzpcbig/OiR7djZzZWd9Oil7N30oPzoke3Y2c2VnfXw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6Njo3OjogIDE6MjozOjQ6NTo2Ojc6OFxuKD86JHt2NnNlZ306KXs2fSg/OiR7djR9fDoke3Y2c2VnfXw6KXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6MjozOjQ6NTo2OjogICAgMToyOjM6NDo1OjY6OjggICAxOjI6Mzo0OjU6Njo6OCAgMToyOjM6NDo1OjY6OjEuMi4zLjRcbig/OiR7djZzZWd9Oil7NX0oPzo6JHt2NH18KD86OiR7djZzZWd9KXsxLDJ9fDopfCAgICAgICAgICAgICAgICAgICAvLyAxOjI6Mzo0OjU6OiAgICAgIDE6MjozOjQ6NTo6Nzo4ICAgMToyOjM6NDo1Ojo4ICAgIDE6MjozOjQ6NTo6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezR9KD86KD86OiR7djZzZWd9KXswLDF9OiR7djR9fCg/Ojoke3Y2c2VnfSl7MSwzfXw6KXwgLy8gMToyOjM6NDo6ICAgICAgICAxOjI6Mzo0Ojo2Ojc6OCAgIDE6MjozOjQ6OjggICAgICAxOjI6Mzo0Ojo2Ojc6MS4yLjMuNFxuKD86JHt2NnNlZ306KXszfSg/Oig/Ojoke3Y2c2VnfSl7MCwyfToke3Y0fXwoPzo6JHt2NnNlZ30pezEsNH18Oil8IC8vIDE6MjozOjogICAgICAgICAgMToyOjM6OjU6Njo3OjggICAxOjI6Mzo6OCAgICAgICAgMToyOjM6OjU6Njo3OjEuMi4zLjRcbig/OiR7djZzZWd9Oil7Mn0oPzooPzo6JHt2NnNlZ30pezAsM306JHt2NH18KD86OiR7djZzZWd9KXsxLDV9fDopfCAvLyAxOjI6OiAgICAgICAgICAgIDE6Mjo6NDo1OjY6Nzo4ICAgMToyOjo4ICAgICAgICAgIDE6Mjo6NDo1OjY6NzoxLjIuMy40XG4oPzoke3Y2c2VnfTopezF9KD86KD86OiR7djZzZWd9KXswLDR9OiR7djR9fCg/Ojoke3Y2c2VnfSl7MSw2fXw6KXwgLy8gMTo6ICAgICAgICAgICAgICAxOjozOjQ6NTo2Ojc6OCAgIDE6OjggICAgICAgICAgICAxOjozOjQ6NTo2Ojc6MS4yLjMuNFxuKD86Oig/Oig/Ojoke3Y2c2VnfSl7MCw1fToke3Y0fXwoPzo6JHt2NnNlZ30pezEsN318OikpICAgICAgICAgICAgIC8vIDo6MjozOjQ6NTo2Ojc6OCAgOjoyOjM6NDo1OjY6Nzo4ICA6OjggICAgICAgICAgICAgOjoxLjIuMy40XG4pKD86JVswLTlhLXpBLVpdezEsfSk/ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJWV0aDAgICAgICAgICAgICAlMVxuYC5yZXBsYWNlKC9cXHMqXFwvXFwvLiokL2dtLCAnJykucmVwbGFjZSgvXFxuL2csICcnKS50cmltKCk7XG5cbi8vIFByZS1jb21waWxlIG9ubHkgdGhlIGV4YWN0IHJlZ2V4ZXMgYmVjYXVzZSBhZGRpbmcgYSBnbG9iYWwgZmxhZyBtYWtlIHJlZ2V4ZXMgc3RhdGVmdWxcbmNvbnN0IHY0NkV4YWN0ID0gbmV3IFJlZ0V4cChgKD86XiR7djR9JCl8KD86XiR7djZ9JClgKTtcbmNvbnN0IHY0ZXhhY3QgPSBuZXcgUmVnRXhwKGBeJHt2NH0kYCk7XG5jb25zdCB2NmV4YWN0ID0gbmV3IFJlZ0V4cChgXiR7djZ9JGApO1xuXG5jb25zdCBpcCA9IG9wdGlvbnMgPT4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID9cblx0djQ2RXhhY3QgOlxuXHRuZXcgUmVnRXhwKGAoPzoke2Iob3B0aW9ucyl9JHt2NH0ke2Iob3B0aW9ucyl9KXwoPzoke2Iob3B0aW9ucyl9JHt2Nn0ke2Iob3B0aW9ucyl9KWAsICdnJyk7XG5cbmlwLnY0ID0gb3B0aW9ucyA9PiBvcHRpb25zICYmIG9wdGlvbnMuZXhhY3QgPyB2NGV4YWN0IDogbmV3IFJlZ0V4cChgJHtiKG9wdGlvbnMpfSR7djR9JHtiKG9wdGlvbnMpfWAsICdnJyk7XG5pcC52NiA9IG9wdGlvbnMgPT4gb3B0aW9ucyAmJiBvcHRpb25zLmV4YWN0ID8gdjZleGFjdCA6IG5ldyBSZWdFeHAoYCR7YihvcHRpb25zKX0ke3Y2fSR7YihvcHRpb25zKX1gLCAnZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXBSZWdleCA9IHJlcXVpcmUoJ2lwLXJlZ2V4Jyk7XG5cbmNvbnN0IGlzSXAgPSBzdHJpbmcgPT4gaXBSZWdleCh7ZXhhY3Q6IHRydWV9KS50ZXN0KHN0cmluZyk7XG5pc0lwLnY0ID0gc3RyaW5nID0+IGlwUmVnZXgudjQoe2V4YWN0OiB0cnVlfSkudGVzdChzdHJpbmcpO1xuaXNJcC52NiA9IHN0cmluZyA9PiBpcFJlZ2V4LnY2KHtleGFjdDogdHJ1ZX0pLnRlc3Qoc3RyaW5nKTtcbmlzSXAudmVyc2lvbiA9IHN0cmluZyA9PiBpc0lwKHN0cmluZykgPyAoaXNJcC52NChzdHJpbmcpID8gNCA6IDYpIDogdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXA7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QucHJlZml4ID0gZmFjdG9yeShyb290KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAocm9vdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgdGVtcGxhdGU6ICdbJXRdICVsOicsXG4gICAgbGV2ZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgcmV0dXJuIGxldmVsLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBuYW1lRm9ybWF0dGVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgfHwgJ3Jvb3QnO1xuICAgIH0sXG4gICAgdGltZXN0YW1wRm9ybWF0dGVyOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUudG9UaW1lU3RyaW5nKCkucmVwbGFjZSgvLiooXFxkezJ9OlxcZHsyfTpcXGR7Mn0pLiovLCAnJDEnKTtcbiAgICB9LFxuICAgIGZvcm1hdDogdW5kZWZpbmVkXG4gIH07XG5cbiAgdmFyIGxvZ2xldmVsO1xuICB2YXIgY29uZmlncyA9IHt9O1xuXG4gIHZhciByZWcgPSBmdW5jdGlvbiAocm9vdExvZ2dlcikge1xuICAgIGlmICghcm9vdExvZ2dlciB8fCAhcm9vdExvZ2dlci5nZXRMb2dnZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIHJvb3QgbG9nZ2VyJyk7XG4gICAgfVxuICAgIGxvZ2xldmVsID0gcm9vdExvZ2dlcjtcbiAgfTtcblxuICB2YXIgYXBwbHkgPSBmdW5jdGlvbiAobG9nZ2VyLCBjb25maWcpIHtcbiAgICBpZiAoIWxvZ2dlciB8fCAhbG9nZ2VyLnNldExldmVsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBsb2dnZXInKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YXJzLW9uLXRvcCAqL1xuICAgIHZhciBvcmlnaW5hbEZhY3RvcnkgPSBsb2dnZXIubWV0aG9kRmFjdG9yeTtcbiAgICB2YXIgbmFtZSA9IGxvZ2dlci5uYW1lIHx8ICcnO1xuICAgIHZhciBwYXJlbnQgPSBjb25maWdzW25hbWVdIHx8IGNvbmZpZ3NbJyddIHx8IGRlZmF1bHRzO1xuICAgIC8qIGVzbGludC1lbmFibGUgdmFycy1vbi10b3AgKi9cblxuICAgIGZ1bmN0aW9uIG1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbG9nTGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBsb2dMZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IGNvbmZpZ3NbbG9nZ2VyTmFtZV0gfHwgY29uZmlnc1snJ107XG5cbiAgICAgIHZhciBoYXNUaW1lc3RhbXAgPSBvcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJyV0JykgIT09IC0xO1xuICAgICAgdmFyIGhhc0xldmVsID0gb3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCclbCcpICE9PSAtMTtcbiAgICAgIHZhciBoYXNOYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCclbicpICE9PSAtMTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICB2YXIga2V5ID0gMDtcbiAgICAgICAgZm9yICg7IGtleSA8IGxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBhcmdzW2tleV0gPSBhcmd1bWVudHNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgdGhlIHJvb3QgbWV0aG9kIGZvciBjaGlsZCBsb2dnZXJzIHRvIHByZXZlbnQgZHVwbGljYXRlIGxvZ2ljXG4gICAgICAgIGlmIChuYW1lIHx8ICFjb25maWdzW2xvZ2dlck5hbWVdKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgdmFycy1vbi10b3AgKi9cbiAgICAgICAgICB2YXIgdGltZXN0YW1wID0gb3B0aW9ucy50aW1lc3RhbXBGb3JtYXR0ZXIobmV3IERhdGUoKSk7XG4gICAgICAgICAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbEZvcm1hdHRlcihtZXRob2ROYW1lKTtcbiAgICAgICAgICB2YXIgbG5hbWUgPSBvcHRpb25zLm5hbWVGb3JtYXR0ZXIobG9nZ2VyTmFtZSk7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSB2YXJzLW9uLXRvcCAqL1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IG9wdGlvbnMuZm9ybWF0KGxldmVsLCBsbmFtZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCArPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKGhhc1RpbWVzdGFtcCkge1xuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8ldC8sIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTGV2ZWwpIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyVsLywgbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGhhc05hbWUpIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyVuLywgbG5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGNvbmNhdCBwcmVmaXggd2l0aCBmaXJzdCBhcmd1bWVudCB0byBzdXBwb3J0IHN0cmluZyBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICBhcmdzWzBdID0gY29udGVudCArICcgJyArIGFyZ3NbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZ3NbbmFtZV0pIHtcbiAgICAgIGxvZ2dlci5tZXRob2RGYWN0b3J5ID0gbWV0aG9kRmFjdG9yeTtcbiAgICB9XG5cbiAgICAvLyBmb3IgcmVtb3ZlIGluaGVyaXRlZCBmb3JtYXQgb3B0aW9uIGlmIHRlbXBsYXRlIG9wdGlvbiBwcmVzZXRcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgaWYgKGNvbmZpZy50ZW1wbGF0ZSkgY29uZmlnLmZvcm1hdCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbmZpZ3NbbmFtZV0gPSBtZXJnZSh7fSwgcGFyZW50LCBjb25maWcpO1xuXG4gICAgbG9nZ2VyLnNldExldmVsKGxvZ2dlci5nZXRMZXZlbCgpKTtcblxuICAgIGlmICghbG9nbGV2ZWwpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAnSXQgaXMgbmVjZXNzYXJ5IHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHJlZygpIG9mIGxvZ2xldmVsLXBsdWdpbi1wcmVmaXggYmVmb3JlIGNhbGxpbmcgYXBwbHkuIEZyb20gdGhlIG5leHQgcmVsZWFzZSwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci4gU2VlIG1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9rdXR1bHVrL2xvZ2xldmVsLXBsdWdpbi1wcmVmaXgvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nZ2VyO1xuICB9O1xuXG4gIHZhciBhcGkgPSB7XG4gICAgcmVnOiByZWcsXG4gICAgYXBwbHk6IGFwcGx5XG4gIH07XG5cbiAgdmFyIHNhdmU7XG5cbiAgaWYgKHJvb3QpIHtcbiAgICBzYXZlID0gcm9vdC5wcmVmaXg7XG4gICAgYXBpLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocm9vdC5wcmVmaXggPT09IGFwaSkge1xuICAgICAgICByb290LnByZWZpeCA9IHNhdmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gYXBpO1xufSkpO1xuIiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiY29uc3QgeyBpdGVyYXRlUmVwb3J0cyB9ID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1vcyhyZXBvcnRzKSB7XG4gIGxldCBqaXR0ZXJfdGltZSA9IDA7XG4gIGxldCByZWN2X3BrdHMgPSAwO1xuICBsZXQgbG9zdF9wa3RzID0gMDtcbiAgbGV0IGF2ZXJhZ2UgPSAxMDAuMDtcbiAgbGV0IHBhY2tldF9sb3NzID0gMC4wO1xuICBsZXQgZWZmZWN0aXZlX2xhdGVuY3k7XG4gIGxldCByX3ZhbHVlO1xuICBsZXQgbW9zO1xuXG4gIGl0ZXJhdGVSZXBvcnRzKHJlcG9ydHMsIChyZXBvcnQpID0+IHtcbiAgICBpZiAocmVwb3J0LnR5cGUgPT09IFwiaW5ib3VuZC1ydHBcIikge1xuICAgICAgaml0dGVyX3RpbWUgPSByZXBvcnQuaml0dGVyO1xuICAgICAgbG9zdF9wa3RzID0gcmVwb3J0LnBhY2tldHNMb3N0O1xuICAgICAgcmVjdl9wa3RzID0gcmVwb3J0LnBhY2tldHNSZWNlaXZlZDtcbiAgICB9XG4gIH0pXG5cbiAgaWYgKHJlY3ZfcGt0cyArIGxvc3RfcGt0cyA+IDApIHtcbiAgICBwYWNrZXRfbG9zcyA9IDEwMC4wICogKGxvc3RfcGt0cyAvIChyZWN2X3BrdHMgKyBsb3N0X3BrdHMpKTtcbiAgfVxuICBlZmZlY3RpdmVfbGF0ZW5jeSA9IGF2ZXJhZ2UgKyBqaXR0ZXJfdGltZSAqIDIgKyAxMDtcbiAgaWYgKGVmZmVjdGl2ZV9sYXRlbmN5IDwgMTYwKSB7XG4gICAgcl92YWx1ZSA9IDkzLjIgLSBlZmZlY3RpdmVfbGF0ZW5jeSAvIDQwO1xuICB9IGVsc2Uge1xuICAgIHJfdmFsdWUgPSA5My4yIC0gKGVmZmVjdGl2ZV9sYXRlbmN5IC0gMTIwKSAvIDEwO1xuICB9XG4gIHJfdmFsdWUgPSByX3ZhbHVlIC0gcGFja2V0X2xvc3MgKiAyLjU7XG5cbiAgaWYgKHJfdmFsdWUgPCAxKSB7XG4gICAgcl92YWx1ZSA9IDE7XG4gIH1cbiAgbW9zID1cbiAgICAxICsgMC4wMzUgKiByX3ZhbHVlICsgMC4wMDAwMDcgKiByX3ZhbHVlICogKHJfdmFsdWUgLSA2MCkgKiAoMTAwIC0gcl92YWx1ZSk7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQobW9zKS50b0ZpeGVkKDYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbGN1bGF0ZU1vcztcbiIsImNvbnN0IHsgaXRlcmF0ZVJlcG9ydHMgfSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgeyBwYXJzZXJzIH0gPSByZXF1aXJlKFwiLi9wYXJzZXJzL25ldy1hcGlcIik7XG5jb25zdCBjYWxjdWxhdGVNb3MgPSByZXF1aXJlKFwiLi9jYWxjdWxhdGUtbW9zXCIpO1xuXG5mdW5jdGlvbiBwYXJzZShyZXBvcnRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIGl0ZXJhdGVSZXBvcnRzKHJlcG9ydHMsIChyZXBvcnQpID0+IHtcbiAgICBpZiAocmVwb3J0LnR5cGUgaW4gcGFyc2Vycykge1xuICAgICAgY29uc3QgbWFwcGVkUmVwb3J0ID0gcGFyc2Vyc1tyZXBvcnQudHlwZV0ocmVwb3J0KTtcblxuICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIG1hcHBlZFJlcG9ydCk7XG4gICAgfVxuICB9KTtcblxuICByZXN1bHQubmV0d29ya01vcyA9IHBhcnNlRmxvYXQoY2FsY3VsYXRlTW9zKHJlcG9ydHMpKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuIiwiLyoqXG4gKiBSdWxlcyB0byBtYXAgZGlmZmVyZW50IHR5cGVzIG9mIHJlcG9ydHMgY29tYmluZWQgYnkgcmVwb3J0IG5hbWVcbiAqIE9uIHRoZSBsZWZ0IC0gbmFtZSBvZiB0aGUgZmllbGQgaW4gYSByZXBvcnRcbiAqIE9uIHRoZSByaXJnaCAtIG5ldyBuYW1lXG4gKi9cbmNvbnN0IHJ1bGVzID0ge1xuICBcIm91dGJvdW5kLXJ0cFwiOiB7XG4gICAgcGFja2V0c1NlbnQ6IFwiYXVkaW9TZW50UGFja2V0c1wiLFxuICAgIGJ5dGVzU2VudDogXCJhdWRpb1NlbnRCeXRlc1wiLFxuICB9LFxuICBcImluYm91bmQtcnRwXCI6IHtcbiAgICBwYWNrZXRzUmVjZWl2ZWQ6IFwiYXVkaW9SZWN2UGFja2V0c1wiLFxuICAgIHBhY2tldHNMb3N0OiBcImF1ZGlvUmVjdlBhY2tldHNMb3N0XCIsXG4gICAgYnl0ZXNSZWNlaXZlZDogXCJhdWRpb1JlY3ZCeXRlc1wiLFxuICAgIGppdHRlcjogXCJhdWRpb1JlY3ZKaXR0ZXJcIlxuICB9LFxuICBcInJlbW90ZS1pbmJvdW5kLXJ0cFwiOiB7XG4gICAgcGFja2V0c0xvc3Q6IFwiYXVkaW9TZW50UGFja2V0c0xvc3RcIixcbiAgICByb3VuZFRyaXBUaW1lOiBcImF1ZGlvUnR0XCIsXG4gICAgaml0dGVyOiBcImF1ZGlvU2VudEppdHRlclwiXG4gIH0sXG59O1xuXG4vLyBBZGRpdGlvbmFsIGxvZ2ljIHRvIHBhcnNlIHZhbHVlcyBjYW4gYmUgZG9uZSBoZXJlXG5jb25zdCBwYXJzZXJzID0ge1xuICBcInJlbW90ZS1jYW5kaWRhdGVcIjogZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgIHJldHVybiBtYXBLZXlzKHJlcG9ydCk7XG4gIH0sXG4gIFwiaW5ib3VuZC1ydHBcIjogZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgIHJldHVybiBtYXBLZXlzKHJlcG9ydCk7XG4gIH0sXG4gIFwib3V0Ym91bmQtcnRwXCI6IGZ1bmN0aW9uIChyZXBvcnQpIHtcbiAgICByZXR1cm4gbWFwS2V5cyhyZXBvcnQpO1xuICB9LFxuICBcInJlbW90ZS1pbmJvdW5kLXJ0cFwiOiBmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgcmV0dXJuIG1hcEtleXMocmVwb3J0KTtcbiAgfSxcbn07XG5cbmNvbnN0IG1hcEtleXMgPSAocmVwb3J0KSA9PiB7XG4gIGNvbnN0IHsgdHlwZSB9ID0gcmVwb3J0O1xuICBjb25zdCBtYXBwaW5nID0gcnVsZXNbdHlwZV07XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIGZvciAobGV0IGZpZWxkIGluIG1hcHBpbmcpIHtcbiAgICBpZiAoZmllbGQgaW4gcmVwb3J0KSB7XG4gICAgICBsZXQgbWFwcGVkTmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nW2ZpZWxkXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1hcHBlZE5hbWUgPSBtYXBwaW5nW2ZpZWxkXShyZXBvcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkTmFtZSA9IG1hcHBpbmdbZmllbGRdO1xuICAgICAgfVxuICAgICAgcmVzdWx0W21hcHBlZE5hbWVdID0gcmVwb3J0W2ZpZWxkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W21hcHBpbmdbZmllbGRdXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBydWxlcyxcbiAgcGFyc2Vycyxcbn07XG4iLCJmdW5jdGlvbiBpdGVyYXRlUmVwb3J0cyhzdGF0cywgZm4pIHtcbiAgaWYgKHR5cGVvZiBzdGF0c1tTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHN0YXRzKSB7XG4gICAgICBjb25zdCByZXBvcnQgPSBBcnJheS5pc0FycmF5KGVsKSA/IGVsWzFdIDogZWw7XG4gICAgICBmbihyZXBvcnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0cykge1xuICAgICAgaWYgKHN0YXRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVwb3J0ID0gc3RhdHNba2V5XTtcbiAgICAgICAgZm4ocmVwb3J0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXRlcmF0ZVJlcG9ydHNcbn0iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNyBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFNEUFV0aWxzID0gcmVxdWlyZSgnc2RwJyk7XG5cbmZ1bmN0aW9uIGZpeFN0YXRzVHlwZShzdGF0KSB7XG4gIHJldHVybiB7XG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgY2FuZGlkYXRlcGFpcjogJ2NhbmRpZGF0ZS1wYWlyJyxcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgfVtzdGF0LnR5cGVdIHx8IHN0YXQudHlwZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIsIGNhcHMsIHR5cGUsIHN0cmVhbSwgZHRsc1JvbGUpIHtcbiAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24odHJhbnNjZWl2ZXIua2luZCwgY2Fwcyk7XG5cbiAgLy8gTWFwIElDRSBwYXJhbWV0ZXJzICh1ZnJhZywgcHdkKSB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMoXG4gICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5nZXRMb2NhbFBhcmFtZXRlcnMoKSk7XG5cbiAgLy8gTWFwIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzKFxuICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5nZXRMb2NhbFBhcmFtZXRlcnMoKSxcbiAgICAgIHR5cGUgPT09ICdvZmZlcicgPyAnYWN0cGFzcycgOiBkdGxzUm9sZSB8fCAnYWN0aXZlJyk7XG5cbiAgc2RwICs9ICdhPW1pZDonICsgdHJhbnNjZWl2ZXIubWlkICsgJ1xcclxcbic7XG5cbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1zZW5kcmVjdlxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRvbmx5XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1yZWN2b25seVxcclxcbic7XG4gIH0gZWxzZSB7XG4gICAgc2RwICs9ICdhPWluYWN0aXZlXFxyXFxuJztcbiAgfVxuXG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICB2YXIgdHJhY2tJZCA9IHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5faW5pdGlhbFRyYWNrSWQgfHxcbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnRyYWNrLmlkO1xuICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5faW5pdGlhbFRyYWNrSWQgPSB0cmFja0lkO1xuICAgIC8vIHNwZWMuXG4gICAgdmFyIG1zaWQgPSAnbXNpZDonICsgKHN0cmVhbSA/IHN0cmVhbS5pZCA6ICctJykgKyAnICcgK1xuICAgICAgICB0cmFja0lkICsgJ1xcclxcbic7XG4gICAgc2RwICs9ICdhPScgKyBtc2lkO1xuICAgIC8vIGZvciBDaHJvbWUuIExlZ2FjeSBzaG91bGQgbm8gbG9uZ2VyIGJlIHJlcXVpcmVkLlxuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgICAnICcgKyBtc2lkO1xuXG4gICAgLy8gUlRYXG4gICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJyAnICsgbXNpZDtcbiAgICAgIHNkcCArPSAnYT1zc3JjLWdyb3VwOkZJRCAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgKyAnICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuICAvLyBGSVhNRTogdGhpcyBzaG91bGQgYmUgd3JpdHRlbiBieSB3cml0ZVJ0cERlc2NyaXB0aW9uLlxuICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59XG5cbi8vIEVkZ2UgZG9lcyBub3QgbGlrZVxuLy8gMSkgc3R1bjogZmlsdGVyZWQgYWZ0ZXIgMTQzOTMgdW5sZXNzID90cmFuc3BvcnQ9dWRwIGlzIHByZXNlbnRcbi8vIDIpIHR1cm46IHRoYXQgZG9lcyBub3QgaGF2ZSBhbGwgb2YgdHVybjpob3N0OnBvcnQ/dHJhbnNwb3J0PXVkcFxuLy8gMykgdHVybjogd2l0aCBpcHY2IGFkZHJlc3Nlc1xuLy8gNCkgdHVybjogb2NjdXJyaW5nIG11bGlwbGUgdGltZXNcbmZ1bmN0aW9uIGZpbHRlckljZVNlcnZlcnMoaWNlU2VydmVycywgZWRnZVZlcnNpb24pIHtcbiAgdmFyIGhhc1R1cm4gPSBmYWxzZTtcbiAgaWNlU2VydmVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWNlU2VydmVycykpO1xuICByZXR1cm4gaWNlU2VydmVycy5maWx0ZXIoZnVuY3Rpb24oc2VydmVyKSB7XG4gICAgaWYgKHNlcnZlciAmJiAoc2VydmVyLnVybHMgfHwgc2VydmVyLnVybCkpIHtcbiAgICAgIHZhciB1cmxzID0gc2VydmVyLnVybHMgfHwgc2VydmVyLnVybDtcbiAgICAgIGlmIChzZXJ2ZXIudXJsICYmICFzZXJ2ZXIudXJscykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1JUQ0ljZVNlcnZlci51cmwgaXMgZGVwcmVjYXRlZCEgVXNlIHVybHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiB1cmxzID09PSAnc3RyaW5nJztcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB1cmxzID0gW3VybHNdO1xuICAgICAgfVxuICAgICAgdXJscyA9IHVybHMuZmlsdGVyKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgdmFsaWRUdXJuID0gdXJsLmluZGV4T2YoJ3R1cm46JykgPT09IDAgJiZcbiAgICAgICAgICAgIHVybC5pbmRleE9mKCd0cmFuc3BvcnQ9dWRwJykgIT09IC0xICYmXG4gICAgICAgICAgICB1cmwuaW5kZXhPZigndHVybjpbJykgPT09IC0xICYmXG4gICAgICAgICAgICAhaGFzVHVybjtcblxuICAgICAgICBpZiAodmFsaWRUdXJuKSB7XG4gICAgICAgICAgaGFzVHVybiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC5pbmRleE9mKCdzdHVuOicpID09PSAwICYmIGVkZ2VWZXJzaW9uID49IDE0MzkzICYmXG4gICAgICAgICAgICB1cmwuaW5kZXhPZignP3RyYW5zcG9ydD11ZHAnKSA9PT0gLTE7XG4gICAgICB9KTtcblxuICAgICAgZGVsZXRlIHNlcnZlci51cmw7XG4gICAgICBzZXJ2ZXIudXJscyA9IGlzU3RyaW5nID8gdXJsc1swXSA6IHVybHM7XG4gICAgICByZXR1cm4gISF1cmxzLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBEZXRlcm1pbmVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgbG9jYWwgYW5kIHJlbW90ZSBjYXBhYmlsaXRpZXMuXG5mdW5jdGlvbiBnZXRDb21tb25DYXBhYmlsaXRpZXMobG9jYWxDYXBhYmlsaXRpZXMsIHJlbW90ZUNhcGFiaWxpdGllcykge1xuICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW11cbiAgfTtcblxuICB2YXIgZmluZENvZGVjQnlQYXlsb2FkVHlwZSA9IGZ1bmN0aW9uKHB0LCBjb2RlY3MpIHtcbiAgICBwdCA9IHBhcnNlSW50KHB0LCAxMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjb2RlY3NbaV0ucGF5bG9hZFR5cGUgPT09IHB0IHx8XG4gICAgICAgICAgY29kZWNzW2ldLnByZWZlcnJlZFBheWxvYWRUeXBlID09PSBwdCkge1xuICAgICAgICByZXR1cm4gY29kZWNzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcnR4Q2FwYWJpbGl0eU1hdGNoZXMgPSBmdW5jdGlvbihsUnR4LCByUnR4LCBsQ29kZWNzLCByQ29kZWNzKSB7XG4gICAgdmFyIGxDb2RlYyA9IGZpbmRDb2RlY0J5UGF5bG9hZFR5cGUobFJ0eC5wYXJhbWV0ZXJzLmFwdCwgbENvZGVjcyk7XG4gICAgdmFyIHJDb2RlYyA9IGZpbmRDb2RlY0J5UGF5bG9hZFR5cGUoclJ0eC5wYXJhbWV0ZXJzLmFwdCwgckNvZGVjcyk7XG4gICAgcmV0dXJuIGxDb2RlYyAmJiByQ29kZWMgJiZcbiAgICAgICAgbENvZGVjLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gckNvZGVjLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihsQ29kZWMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByQ29kZWMgPSByZW1vdGVDYXBhYmlsaXRpZXMuY29kZWNzW2ldO1xuICAgICAgaWYgKGxDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IHJDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICBsQ29kZWMuY2xvY2tSYXRlID09PSByQ29kZWMuY2xvY2tSYXRlKSB7XG4gICAgICAgIGlmIChsQ29kZWMubmFtZS50b0xvd2VyQ2FzZSgpID09PSAncnR4JyAmJlxuICAgICAgICAgICAgbENvZGVjLnBhcmFtZXRlcnMgJiYgckNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICAgICAgLy8gZm9yIFJUWCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGxvY2FsIHJ0eCB0aGF0IGhhcyBhIGFwdFxuICAgICAgICAgIC8vIHdoaWNoIHBvaW50cyB0byB0aGUgc2FtZSBsb2NhbCBjb2RlYyBhcyB0aGUgcmVtb3RlIG9uZS5cbiAgICAgICAgICBpZiAoIXJ0eENhcGFiaWxpdHlNYXRjaGVzKGxDb2RlYywgckNvZGVjLFxuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MsIHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3MpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgckNvZGVjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyQ29kZWMpKTsgLy8gZGVlcGNvcHlcbiAgICAgICAgLy8gbnVtYmVyIG9mIGNoYW5uZWxzIGlzIHRoZSBoaWdoZXN0IGNvbW1vbiBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgICAgckNvZGVjLm51bUNoYW5uZWxzID0gTWF0aC5taW4obENvZGVjLm51bUNoYW5uZWxzLFxuICAgICAgICAgICAgckNvZGVjLm51bUNoYW5uZWxzKTtcbiAgICAgICAgLy8gcHVzaCByQ29kZWMgc28gd2UgcmVwbHkgd2l0aCBvZmZlcmVyIHBheWxvYWQgdHlwZVxuICAgICAgICBjb21tb25DYXBhYmlsaXRpZXMuY29kZWNzLnB1c2gockNvZGVjKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgY29tbW9uIGZlZWRiYWNrIG1lY2hhbmlzbXNcbiAgICAgICAgckNvZGVjLnJ0Y3BGZWVkYmFjayA9IHJDb2RlYy5ydGNwRmVlZGJhY2suZmlsdGVyKGZ1bmN0aW9uKGZiKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsQ29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobENvZGVjLnJ0Y3BGZWVkYmFja1tqXS50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgICAgICAgbENvZGVjLnJ0Y3BGZWVkYmFja1tqXS5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRklYTUU6IGFsc28gbmVlZCB0byBkZXRlcm1pbmUgLnBhcmFtZXRlcnNcbiAgICAgICAgLy8gIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnBlZXIvb3J0Yy9pc3N1ZXMvNTY5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbG9jYWxDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGxIZWFkZXJFeHRlbnNpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zLmxlbmd0aDtcbiAgICAgICAgIGkrKykge1xuICAgICAgdmFyIHJIZWFkZXJFeHRlbnNpb24gPSByZW1vdGVDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9uc1tpXTtcbiAgICAgIGlmIChsSGVhZGVyRXh0ZW5zaW9uLnVyaSA9PT0gckhlYWRlckV4dGVuc2lvbi51cmkpIHtcbiAgICAgICAgY29tbW9uQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMucHVzaChySGVhZGVyRXh0ZW5zaW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBGSVhNRTogZmVjTWVjaGFuaXNtc1xuICByZXR1cm4gY29tbW9uQ2FwYWJpbGl0aWVzO1xufVxuXG4vLyBpcyBhY3Rpb249c2V0TG9jYWxEZXNjcmlwdGlvbiB3aXRoIHR5cGUgYWxsb3dlZCBpbiBzaWduYWxpbmdTdGF0ZVxuZnVuY3Rpb24gaXNBY3Rpb25BbGxvd2VkSW5TaWduYWxpbmdTdGF0ZShhY3Rpb24sIHR5cGUsIHNpZ25hbGluZ1N0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgb2ZmZXI6IHtcbiAgICAgIHNldExvY2FsRGVzY3JpcHRpb246IFsnc3RhYmxlJywgJ2hhdmUtbG9jYWwtb2ZmZXInXSxcbiAgICAgIHNldFJlbW90ZURlc2NyaXB0aW9uOiBbJ3N0YWJsZScsICdoYXZlLXJlbW90ZS1vZmZlciddXG4gICAgfSxcbiAgICBhbnN3ZXI6IHtcbiAgICAgIHNldExvY2FsRGVzY3JpcHRpb246IFsnaGF2ZS1yZW1vdGUtb2ZmZXInLCAnaGF2ZS1sb2NhbC1wcmFuc3dlciddLFxuICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb246IFsnaGF2ZS1sb2NhbC1vZmZlcicsICdoYXZlLXJlbW90ZS1wcmFuc3dlciddXG4gICAgfVxuICB9W3R5cGVdW2FjdGlvbl0uaW5kZXhPZihzaWduYWxpbmdTdGF0ZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBtYXliZUFkZENhbmRpZGF0ZShpY2VUcmFuc3BvcnQsIGNhbmRpZGF0ZSkge1xuICAvLyBFZGdlJ3MgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gYWRkcyBzb21lIGZpZWxkcyB0aGVyZWZvcmVcbiAgLy8gbm90IGFsbCBmaWVsZNGVIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gIHZhciBhbHJlYWR5QWRkZWQgPSBpY2VUcmFuc3BvcnQuZ2V0UmVtb3RlQ2FuZGlkYXRlcygpXG4gICAgICAuZmluZChmdW5jdGlvbihyZW1vdGVDYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZS5mb3VuZGF0aW9uID09PSByZW1vdGVDYW5kaWRhdGUuZm91bmRhdGlvbiAmJlxuICAgICAgICAgICAgY2FuZGlkYXRlLmlwID09PSByZW1vdGVDYW5kaWRhdGUuaXAgJiZcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5wb3J0ID09PSByZW1vdGVDYW5kaWRhdGUucG9ydCAmJlxuICAgICAgICAgICAgY2FuZGlkYXRlLnByaW9yaXR5ID09PSByZW1vdGVDYW5kaWRhdGUucHJpb3JpdHkgJiZcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gcmVtb3RlQ2FuZGlkYXRlLnByb3RvY29sICYmXG4gICAgICAgICAgICBjYW5kaWRhdGUudHlwZSA9PT0gcmVtb3RlQ2FuZGlkYXRlLnR5cGU7XG4gICAgICB9KTtcbiAgaWYgKCFhbHJlYWR5QWRkZWQpIHtcbiAgICBpY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gIH1cbiAgcmV0dXJuICFhbHJlYWR5QWRkZWQ7XG59XG5cblxuZnVuY3Rpb24gbWFrZUVycm9yKG5hbWUsIGRlc2NyaXB0aW9uKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKGRlc2NyaXB0aW9uKTtcbiAgZS5uYW1lID0gbmFtZTtcbiAgLy8gbGVnYWN5IGVycm9yIGNvZGVzIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICBlLmNvZGUgPSB7XG4gICAgTm90U3VwcG9ydGVkRXJyb3I6IDksXG4gICAgSW52YWxpZFN0YXRlRXJyb3I6IDExLFxuICAgIEludmFsaWRBY2Nlc3NFcnJvcjogMTUsXG4gICAgVHlwZUVycm9yOiB1bmRlZmluZWQsXG4gICAgT3BlcmF0aW9uRXJyb3I6IHVuZGVmaW5lZFxuICB9W25hbWVdO1xuICByZXR1cm4gZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3aW5kb3csIGVkZ2VWZXJzaW9uKSB7XG4gIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tZWRpYWNhcHR1cmUtbWFpbi8jbWVkaWFzdHJlYW1cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFkZCB0aGUgdHJhY2sgdG8gdGhlIHN0cmVhbSBhbmRcbiAgLy8gZGlzcGF0Y2ggdGhlIGV2ZW50IG91cnNlbHZlcy5cbiAgZnVuY3Rpb24gYWRkVHJhY2tUb1N0cmVhbUFuZEZpcmVFdmVudCh0cmFjaywgc3RyZWFtKSB7XG4gICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICBzdHJlYW0uZGlzcGF0Y2hFdmVudChuZXcgd2luZG93Lk1lZGlhU3RyZWFtVHJhY2tFdmVudCgnYWRkdHJhY2snLFxuICAgICAgICB7dHJhY2s6IHRyYWNrfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhY2tGcm9tU3RyZWFtQW5kRmlyZUV2ZW50KHRyYWNrLCBzdHJlYW0pIHtcbiAgICBzdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIHN0cmVhbS5kaXNwYXRjaEV2ZW50KG5ldyB3aW5kb3cuTWVkaWFTdHJlYW1UcmFja0V2ZW50KCdyZW1vdmV0cmFjaycsXG4gICAgICAgIHt0cmFjazogdHJhY2t9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlQWRkVHJhY2socGMsIHRyYWNrLCByZWNlaXZlciwgc3RyZWFtcykge1xuICAgIHZhciB0cmFja0V2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgIHRyYWNrRXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICB0cmFja0V2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdHJhY2tFdmVudC50cmFuc2NlaXZlciA9IHtyZWNlaXZlcjogcmVjZWl2ZXJ9O1xuICAgIHRyYWNrRXZlbnQuc3RyZWFtcyA9IHN0cmVhbXM7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBwYy5fZGlzcGF0Y2hFdmVudCgndHJhY2snLCB0cmFja0V2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBSVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBwYyA9IHRoaXM7XG5cbiAgICB2YXIgX2V2ZW50VGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIFsnYWRkRXZlbnRMaXN0ZW5lcicsICdyZW1vdmVFdmVudExpc3RlbmVyJywgJ2Rpc3BhdGNoRXZlbnQnXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICBwY1ttZXRob2RdID0gX2V2ZW50VGFyZ2V0W21ldGhvZF0uYmluZChfZXZlbnRUYXJnZXQpO1xuICAgICAgICB9KTtcblxuICAgIHRoaXMuY2FuVHJpY2tsZUljZUNhbmRpZGF0ZXMgPSBudWxsO1xuXG4gICAgdGhpcy5uZWVkTmVnb3RpYXRpb24gPSBmYWxzZTtcblxuICAgIHRoaXMubG9jYWxTdHJlYW1zID0gW107XG4gICAgdGhpcy5yZW1vdGVTdHJlYW1zID0gW107XG5cbiAgICB0aGlzLl9sb2NhbERlc2NyaXB0aW9uID0gbnVsbDtcbiAgICB0aGlzLl9yZW1vdGVEZXNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLnNpZ25hbGluZ1N0YXRlID0gJ3N0YWJsZSc7XG4gICAgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUgPSAnbmV3JztcbiAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZSA9ICduZXcnO1xuICAgIHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPSAnbmV3JztcblxuICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uZmlnIHx8IHt9KSk7XG5cbiAgICB0aGlzLnVzaW5nQnVuZGxlID0gY29uZmlnLmJ1bmRsZVBvbGljeSA9PT0gJ21heC1idW5kbGUnO1xuICAgIGlmIChjb25maWcucnRjcE11eFBvbGljeSA9PT0gJ25lZ290aWF0ZScpIHtcbiAgICAgIHRocm93KG1ha2VFcnJvcignTm90U3VwcG9ydGVkRXJyb3InLFxuICAgICAgICAgICdydGNwTXV4UG9saWN5IFxcJ25lZ290aWF0ZVxcJyBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5ydGNwTXV4UG9saWN5KSB7XG4gICAgICBjb25maWcucnRjcE11eFBvbGljeSA9ICdyZXF1aXJlJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICBjYXNlICdyZWxheSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSA9ICdhbGwnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbmZpZy5idW5kbGVQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcbiAgICAgIGNhc2UgJ21heC1jb21wYXQnOlxuICAgICAgY2FzZSAnbWF4LWJ1bmRsZSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uZmlnLmJ1bmRsZVBvbGljeSA9ICdiYWxhbmNlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbmZpZy5pY2VTZXJ2ZXJzID0gZmlsdGVySWNlU2VydmVycyhjb25maWcuaWNlU2VydmVycyB8fCBbXSwgZWRnZVZlcnNpb24pO1xuXG4gICAgdGhpcy5faWNlR2F0aGVyZXJzID0gW107XG4gICAgaWYgKGNvbmZpZy5pY2VDYW5kaWRhdGVQb29sU2l6ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IGNvbmZpZy5pY2VDYW5kaWRhdGVQb29sU2l6ZTsgaSA+IDA7IGktLSkge1xuICAgICAgICB0aGlzLl9pY2VHYXRoZXJlcnMucHVzaChuZXcgd2luZG93LlJUQ0ljZUdhdGhlcmVyKHtcbiAgICAgICAgICBpY2VTZXJ2ZXJzOiBjb25maWcuaWNlU2VydmVycyxcbiAgICAgICAgICBnYXRoZXJQb2xpY3k6IGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3lcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcuaWNlQ2FuZGlkYXRlUG9vbFNpemUgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcblxuICAgIC8vIHBlci10cmFjayBpY2VHYXRoZXJzLCBpY2VUcmFuc3BvcnRzLCBkdGxzVHJhbnNwb3J0cywgcnRwU2VuZGVycywgLi4uXG4gICAgLy8gZXZlcnl0aGluZyB0aGF0IGlzIG5lZWRlZCB0byBkZXNjcmliZSBhIFNEUCBtLWxpbmUuXG4gICAgdGhpcy50cmFuc2NlaXZlcnMgPSBbXTtcblxuICAgIHRoaXMuX3NkcFNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgdGhpcy5fc2RwU2Vzc2lvblZlcnNpb24gPSAwO1xuXG4gICAgdGhpcy5fZHRsc1JvbGUgPSB1bmRlZmluZWQ7IC8vIHJvbGUgZm9yIGE9c2V0dXAgdG8gdXNlIGluIGFuc3dlcnMuXG5cbiAgICB0aGlzLl9pc0Nsb3NlZCA9IGZhbHNlO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsRGVzY3JpcHRpb247XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3JlbW90ZURlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZURlc2NyaXB0aW9uO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gc2V0IHVwIGV2ZW50IGhhbmRsZXJzIG9uIHByb3RvdHlwZVxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub25pY2VjYW5kaWRhdGUgPSBudWxsO1xuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub25hZGRzdHJlYW0gPSBudWxsO1xuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub250cmFjayA9IG51bGw7XG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5vbnJlbW92ZXN0cmVhbSA9IG51bGw7XG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5vbmRhdGFjaGFubmVsID0gbnVsbDtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgdGhpc1snb24nICsgbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbJ29uJyArIG5hbWVdKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9lbWl0R2F0aGVyaW5nU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2ljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJyk7XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCBldmVudCk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0cmVhbXM7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVTdHJlYW1zO1xuICB9O1xuXG4gIC8vIGludGVybmFsIGhlbHBlciB0byBjcmVhdGUgYSB0cmFuc2NlaXZlciBvYmplY3QuXG4gIC8vICh3aGljaCBpcyBub3QgeWV0IHRoZSBzYW1lIGFzIHRoZSBXZWJSVEMgMS4wIHRyYW5zY2VpdmVyKVxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZVRyYW5zY2VpdmVyID0gZnVuY3Rpb24oa2luZCwgZG9Ob3RBZGQpIHtcbiAgICB2YXIgaGFzQnVuZGxlVHJhbnNwb3J0ID0gdGhpcy50cmFuc2NlaXZlcnMubGVuZ3RoID4gMDtcbiAgICB2YXIgdHJhbnNjZWl2ZXIgPSB7XG4gICAgICB0cmFjazogbnVsbCxcbiAgICAgIGljZUdhdGhlcmVyOiBudWxsLFxuICAgICAgaWNlVHJhbnNwb3J0OiBudWxsLFxuICAgICAgZHRsc1RyYW5zcG9ydDogbnVsbCxcbiAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzOiBudWxsLFxuICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzOiBudWxsLFxuICAgICAgcnRwU2VuZGVyOiBudWxsLFxuICAgICAgcnRwUmVjZWl2ZXI6IG51bGwsXG4gICAgICBraW5kOiBraW5kLFxuICAgICAgbWlkOiBudWxsLFxuICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVyczogbnVsbCxcbiAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM6IG51bGwsXG4gICAgICBzdHJlYW06IG51bGwsXG4gICAgICBhc3NvY2lhdGVkUmVtb3RlTWVkaWFTdHJlYW1zOiBbXSxcbiAgICAgIHdhbnRSZWNlaXZlOiB0cnVlXG4gICAgfTtcbiAgICBpZiAodGhpcy51c2luZ0J1bmRsZSAmJiBoYXNCdW5kbGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydCA9IHRoaXMudHJhbnNjZWl2ZXJzWzBdLmljZVRyYW5zcG9ydDtcbiAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQgPSB0aGlzLnRyYW5zY2VpdmVyc1swXS5kdGxzVHJhbnNwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHJhbnNwb3J0cyA9IHRoaXMuX2NyZWF0ZUljZUFuZER0bHNUcmFuc3BvcnRzKCk7XG4gICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQgPSB0cmFuc3BvcnRzLmljZVRyYW5zcG9ydDtcbiAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQgPSB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQ7XG4gICAgfVxuICAgIGlmICghZG9Ob3RBZGQpIHtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLnB1c2godHJhbnNjZWl2ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24odHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgJ0F0dGVtcHRlZCB0byBjYWxsIGFkZFRyYWNrIG9uIGEgY2xvc2VkIHBlZXJjb25uZWN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5RXhpc3RzID0gdGhpcy50cmFuc2NlaXZlcnMuZmluZChmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgfSk7XG5cbiAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgdGhyb3cgbWFrZUVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3InLCAnVHJhY2sgYWxyZWFkeSBleGlzdHMuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zY2VpdmVyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2NlaXZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy50cmFuc2NlaXZlcnNbaV0udHJhY2sgJiZcbiAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVyc1tpXS5raW5kID09PSB0cmFjay5raW5kKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyID0gdGhpcy50cmFuc2NlaXZlcnNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgIHRyYW5zY2VpdmVyID0gdGhpcy5fY3JlYXRlVHJhbnNjZWl2ZXIodHJhY2sua2luZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWF5YmVGaXJlTmVnb3RpYXRpb25OZWVkZWQoKTtcblxuICAgIGlmICh0aGlzLmxvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgfVxuXG4gICAgdHJhbnNjZWl2ZXIudHJhY2sgPSB0cmFjaztcbiAgICB0cmFuc2NlaXZlci5zdHJlYW0gPSBzdHJlYW07XG4gICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyID0gbmV3IHdpbmRvdy5SVENSdHBTZW5kZXIodHJhY2ssXG4gICAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQpO1xuICAgIHJldHVybiB0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBwYyA9IHRoaXM7XG4gICAgaWYgKGVkZ2VWZXJzaW9uID49IDE1MDI1KSB7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICBwYy5hZGRUcmFjayh0cmFjaywgc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbG9uZSBpcyBuZWNlc3NhcnkgZm9yIGxvY2FsIGRlbW9zIG1vc3RseSwgYXR0YWNoaW5nIGRpcmVjdGx5XG4gICAgICAvLyB0byB0d28gZGlmZmVyZW50IHNlbmRlcnMgZG9lcyBub3Qgd29yayAoYnVpbGQgMTA1NDcpLlxuICAgICAgLy8gRml4ZWQgaW4gMTUwMjUgKG9yIGVhcmxpZXIpXG4gICAgICB2YXIgY2xvbmVkU3RyZWFtID0gc3RyZWFtLmNsb25lKCk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaywgaWR4KSB7XG4gICAgICAgIHZhciBjbG9uZWRUcmFjayA9IGNsb25lZFN0cmVhbS5nZXRUcmFja3MoKVtpZHhdO1xuICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBjbG9uZWRUcmFjay5lbmFibGVkID0gZXZlbnQuZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lZFN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgIHBjLmFkZFRyYWNrKHRyYWNrLCBjbG9uZWRTdHJlYW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uKHNlbmRlcikge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgJ0F0dGVtcHRlZCB0byBjYWxsIHJlbW92ZVRyYWNrIG9uIGEgY2xvc2VkIHBlZXJjb25uZWN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICghKHNlbmRlciBpbnN0YW5jZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCAxIG9mIFJUQ1BlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrICcgK1xuICAgICAgICAgICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNjZWl2ZXIgPSB0aGlzLnRyYW5zY2VpdmVycy5maW5kKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0LnJ0cFNlbmRlciA9PT0gc2VuZGVyO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgdGhyb3cgbWFrZUVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3InLFxuICAgICAgICAgICdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nKTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbSA9IHRyYW5zY2VpdmVyLnN0cmVhbTtcblxuICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5zdG9wKCk7XG4gICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyID0gbnVsbDtcbiAgICB0cmFuc2NlaXZlci50cmFjayA9IG51bGw7XG4gICAgdHJhbnNjZWl2ZXIuc3RyZWFtID0gbnVsbDtcblxuICAgIC8vIHJlbW92ZSB0aGUgc3RyZWFtIGZyb20gdGhlIHNldCBvZiBsb2NhbCBzdHJlYW1zXG4gICAgdmFyIGxvY2FsU3RyZWFtcyA9IHRoaXMudHJhbnNjZWl2ZXJzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdC5zdHJlYW07XG4gICAgfSk7XG4gICAgaWYgKGxvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPT09IC0xICYmXG4gICAgICAgIHRoaXMubG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+IC0xKSB7XG4gICAgICB0aGlzLmxvY2FsU3RyZWFtcy5zcGxpY2UodGhpcy5sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pLCAxKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXliZUZpcmVOZWdvdGlhdGlvbk5lZWRlZCgpO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICB2YXIgc2VuZGVyID0gcGMuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcGMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zY2VpdmVycy5maWx0ZXIoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIHJldHVybiAhIXRyYW5zY2VpdmVyLnJ0cFNlbmRlcjtcbiAgICB9KVxuICAgIC5tYXAoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gICAgfSk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zY2VpdmVycy5maWx0ZXIoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIHJldHVybiAhIXRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgIH0pXG4gICAgLm1hcChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVJY2VHYXRoZXJlciA9IGZ1bmN0aW9uKHNkcE1MaW5lSW5kZXgsXG4gICAgICB1c2luZ0J1bmRsZSkge1xuICAgIHZhciBwYyA9IHRoaXM7XG4gICAgaWYgKHVzaW5nQnVuZGxlICYmIHNkcE1MaW5lSW5kZXggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2NlaXZlcnNbMF0uaWNlR2F0aGVyZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pY2VHYXRoZXJlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWNlR2F0aGVyZXJzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHZhciBpY2VHYXRoZXJlciA9IG5ldyB3aW5kb3cuUlRDSWNlR2F0aGVyZXIoe1xuICAgICAgaWNlU2VydmVyczogdGhpcy5fY29uZmlnLmljZVNlcnZlcnMsXG4gICAgICBnYXRoZXJQb2xpY3k6IHRoaXMuX2NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3lcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaWNlR2F0aGVyZXIsICdzdGF0ZScsXG4gICAgICAgIHt2YWx1ZTogJ25ldycsIHdyaXRhYmxlOiB0cnVlfVxuICAgICk7XG5cbiAgICB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5idWZmZXJlZENhbmRpZGF0ZUV2ZW50cyA9IFtdO1xuICAgIHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmJ1ZmZlckNhbmRpZGF0ZXMgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGVuZCA9ICFldmVudC5jYW5kaWRhdGUgfHwgT2JqZWN0LmtleXMoZXZlbnQuY2FuZGlkYXRlKS5sZW5ndGggPT09IDA7XG4gICAgICAvLyBwb2x5ZmlsbCBzaW5jZSBSVENJY2VHYXRoZXJlci5zdGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQgaW5cbiAgICAgIC8vIEVkZ2UgMTA1NDcgeWV0LlxuICAgICAgaWNlR2F0aGVyZXIuc3RhdGUgPSBlbmQgPyAnY29tcGxldGVkJyA6ICdnYXRoZXJpbmcnO1xuICAgICAgaWYgKHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5idWZmZXJlZENhbmRpZGF0ZUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uYnVmZmVyZWRDYW5kaWRhdGVFdmVudHMucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpY2VHYXRoZXJlci5hZGRFdmVudExpc3RlbmVyKCdsb2NhbGNhbmRpZGF0ZScsXG4gICAgICB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5idWZmZXJDYW5kaWRhdGVzKTtcbiAgICByZXR1cm4gaWNlR2F0aGVyZXI7XG4gIH07XG5cbiAgLy8gc3RhcnQgZ2F0aGVyaW5nIGZyb20gYW4gUlRDSWNlR2F0aGVyZXIuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fZ2F0aGVyID0gZnVuY3Rpb24obWlkLCBzZHBNTGluZUluZGV4KSB7XG4gICAgdmFyIHBjID0gdGhpcztcbiAgICB2YXIgaWNlR2F0aGVyZXIgPSB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5pY2VHYXRoZXJlcjtcbiAgICBpZiAoaWNlR2F0aGVyZXIub25sb2NhbGNhbmRpZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyZWRDYW5kaWRhdGVFdmVudHMgPVxuICAgICAgdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uYnVmZmVyZWRDYW5kaWRhdGVFdmVudHM7XG4gICAgdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uYnVmZmVyZWRDYW5kaWRhdGVFdmVudHMgPSBudWxsO1xuICAgIGljZUdhdGhlcmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvY2FsY2FuZGlkYXRlJyxcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmJ1ZmZlckNhbmRpZGF0ZXMpO1xuICAgIGljZUdhdGhlcmVyLm9ubG9jYWxjYW5kaWRhdGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChwYy51c2luZ0J1bmRsZSAmJiBzZHBNTGluZUluZGV4ID4gMCkge1xuICAgICAgICAvLyBpZiB3ZSBrbm93IHRoYXQgd2UgdXNlIGJ1bmRsZSB3ZSBjYW4gZHJvcCBjYW5kaWRhdGVzIHdpdGhcbiAgICAgICAgLy8g0ZVkcE1MaW5lSW5kZXggPiAwLiBJZiB3ZSBkb24ndCBkbyB0aGlzIHRoZW4gb3VyIHN0YXRlIGdldHNcbiAgICAgICAgLy8gY29uZnVzZWQgc2luY2Ugd2UgZGlzcG9zZSB0aGUgZXh0cmEgaWNlIGdhdGhlcmVyLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpO1xuICAgICAgZXZlbnQuY2FuZGlkYXRlID0ge3NkcE1pZDogbWlkLCBzZHBNTGluZUluZGV4OiBzZHBNTGluZUluZGV4fTtcblxuICAgICAgdmFyIGNhbmQgPSBldnQuY2FuZGlkYXRlO1xuICAgICAgLy8gRWRnZSBlbWl0cyBhbiBlbXB0eSBvYmplY3QgZm9yIFJUQ0ljZUNhbmRpZGF0ZUNvbXBsZXRl4oClXG4gICAgICB2YXIgZW5kID0gIWNhbmQgfHwgT2JqZWN0LmtleXMoY2FuZCkubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICAvLyBwb2x5ZmlsbCBzaW5jZSBSVENJY2VHYXRoZXJlci5zdGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQgaW5cbiAgICAgICAgLy8gRWRnZSAxMDU0NyB5ZXQuXG4gICAgICAgIGlmIChpY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ25ldycgfHwgaWNlR2F0aGVyZXIuc3RhdGUgPT09ICdnYXRoZXJpbmcnKSB7XG4gICAgICAgICAgaWNlR2F0aGVyZXIuc3RhdGUgPSAnY29tcGxldGVkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGljZUdhdGhlcmVyLnN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgIGljZUdhdGhlcmVyLnN0YXRlID0gJ2dhdGhlcmluZyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUlRDSWNlQ2FuZGlkYXRlIGRvZXNuJ3QgaGF2ZSBhIGNvbXBvbmVudCwgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICAgICAgY2FuZC5jb21wb25lbnQgPSAxO1xuICAgICAgICAvLyBhbHNvIHRoZSB1c2VybmFtZUZyYWdtZW50LiBUT0RPOiB1cGRhdGUgU0RQIHRvIHRha2UgYm90aCB2YXJpYW50cy5cbiAgICAgICAgY2FuZC51ZnJhZyA9IGljZUdhdGhlcmVyLmdldExvY2FsUGFyYW1ldGVycygpLnVzZXJuYW1lRnJhZ21lbnQ7XG5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRDYW5kaWRhdGUgPSBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgZXZlbnQuY2FuZGlkYXRlID0gT2JqZWN0LmFzc2lnbihldmVudC5jYW5kaWRhdGUsXG4gICAgICAgICAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShzZXJpYWxpemVkQ2FuZGlkYXRlKSk7XG5cbiAgICAgICAgZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSA9IHNlcmlhbGl6ZWRDYW5kaWRhdGU7XG4gICAgICAgIGV2ZW50LmNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FuZGlkYXRlOiBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2RwTWlkOiBldmVudC5jYW5kaWRhdGUuc2RwTWlkLFxuICAgICAgICAgICAgc2RwTUxpbmVJbmRleDogZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBldmVudC5jYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBsb2NhbCBkZXNjcmlwdGlvbi5cbiAgICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMocGMuX2xvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgIGlmICghZW5kKSB7XG4gICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4XSArPVxuICAgICAgICAgICAgJ2E9JyArIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgKyAnXFxyXFxuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4XSArPVxuICAgICAgICAgICAgJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcGMuX2xvY2FsRGVzY3JpcHRpb24uc2RwID1cbiAgICAgICAgICBTRFBVdGlscy5nZXREZXNjcmlwdGlvbihwYy5fbG9jYWxEZXNjcmlwdGlvbi5zZHApICtcbiAgICAgICAgICBzZWN0aW9ucy5qb2luKCcnKTtcbiAgICAgIHZhciBjb21wbGV0ZSA9IHBjLnRyYW5zY2VpdmVycy5ldmVyeShmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLnN0YXRlID09PSAnY29tcGxldGVkJztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGMuaWNlR2F0aGVyaW5nU3RhdGUgIT09ICdnYXRoZXJpbmcnKSB7XG4gICAgICAgIHBjLmljZUdhdGhlcmluZ1N0YXRlID0gJ2dhdGhlcmluZyc7XG4gICAgICAgIHBjLl9lbWl0R2F0aGVyaW5nU3RhdGVDaGFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW1pdCBjYW5kaWRhdGUuIEFsc28gZW1pdCBudWxsIGNhbmRpZGF0ZSB3aGVuIGFsbCBnYXRoZXJlcnMgYXJlXG4gICAgICAvLyBjb21wbGV0ZS5cbiAgICAgIGlmICghZW5kKSB7XG4gICAgICAgIHBjLl9kaXNwYXRjaEV2ZW50KCdpY2VjYW5kaWRhdGUnLCBldmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgcGMuX2Rpc3BhdGNoRXZlbnQoJ2ljZWNhbmRpZGF0ZScsIG5ldyBFdmVudCgnaWNlY2FuZGlkYXRlJykpO1xuICAgICAgICBwYy5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdjb21wbGV0ZSc7XG4gICAgICAgIHBjLl9lbWl0R2F0aGVyaW5nU3RhdGVDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZW1pdCBhbHJlYWR5IGdhdGhlcmVkIGNhbmRpZGF0ZXMuXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBidWZmZXJlZENhbmRpZGF0ZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWNlR2F0aGVyZXIub25sb2NhbGNhbmRpZGF0ZShlKTtcbiAgICAgIH0pO1xuICAgIH0sIDApO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBJQ0UgdHJhbnNwb3J0IGFuZCBEVExTIHRyYW5zcG9ydC5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVJY2VBbmREdGxzVHJhbnNwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYyA9IHRoaXM7XG4gICAgdmFyIGljZVRyYW5zcG9ydCA9IG5ldyB3aW5kb3cuUlRDSWNlVHJhbnNwb3J0KG51bGwpO1xuICAgIGljZVRyYW5zcG9ydC5vbmljZXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBwYy5fdXBkYXRlSWNlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgICBwYy5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgfTtcblxuICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gbmV3IHdpbmRvdy5SVENEdGxzVHJhbnNwb3J0KGljZVRyYW5zcG9ydCk7XG4gICAgZHRsc1RyYW5zcG9ydC5vbmR0bHNzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGMuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgIH07XG4gICAgZHRsc1RyYW5zcG9ydC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBvbmVycm9yIGRvZXMgbm90IHNldCBzdGF0ZSB0byBmYWlsZWQgYnkgaXRzZWxmLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGR0bHNUcmFuc3BvcnQsICdzdGF0ZScsXG4gICAgICAgICAge3ZhbHVlOiAnZmFpbGVkJywgd3JpdGFibGU6IHRydWV9KTtcbiAgICAgIHBjLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGljZVRyYW5zcG9ydDogaWNlVHJhbnNwb3J0LFxuICAgICAgZHRsc1RyYW5zcG9ydDogZHRsc1RyYW5zcG9ydFxuICAgIH07XG4gIH07XG5cbiAgLy8gRGVzdHJveSBJQ0UgZ2F0aGVyZXIsIElDRSB0cmFuc3BvcnQgYW5kIERUTFMgdHJhbnNwb3J0LlxuICAvLyBXaXRob3V0IHRyaWdnZXJpbmcgdGhlIGNhbGxiYWNrcy5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9kaXNwb3NlSWNlQW5kRHRsc1RyYW5zcG9ydHMgPSBmdW5jdGlvbihcbiAgICAgIHNkcE1MaW5lSW5kZXgpIHtcbiAgICB2YXIgaWNlR2F0aGVyZXIgPSB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5pY2VHYXRoZXJlcjtcbiAgICBpZiAoaWNlR2F0aGVyZXIpIHtcbiAgICAgIGRlbGV0ZSBpY2VHYXRoZXJlci5vbmxvY2FsY2FuZGlkYXRlO1xuICAgICAgZGVsZXRlIHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmljZUdhdGhlcmVyO1xuICAgIH1cbiAgICB2YXIgaWNlVHJhbnNwb3J0ID0gdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uaWNlVHJhbnNwb3J0O1xuICAgIGlmIChpY2VUcmFuc3BvcnQpIHtcbiAgICAgIGRlbGV0ZSBpY2VUcmFuc3BvcnQub25pY2VzdGF0ZWNoYW5nZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5pY2VUcmFuc3BvcnQ7XG4gICAgfVxuICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uZHRsc1RyYW5zcG9ydDtcbiAgICBpZiAoZHRsc1RyYW5zcG9ydCkge1xuICAgICAgZGVsZXRlIGR0bHNUcmFuc3BvcnQub25kdGxzc3RhdGVjaGFuZ2U7XG4gICAgICBkZWxldGUgZHRsc1RyYW5zcG9ydC5vbmVycm9yO1xuICAgICAgZGVsZXRlIHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmR0bHNUcmFuc3BvcnQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIFN0YXJ0IHRoZSBSVFAgU2VuZGVyIGFuZCBSZWNlaXZlciBmb3IgYSB0cmFuc2NlaXZlci5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl90cmFuc2NlaXZlID0gZnVuY3Rpb24odHJhbnNjZWl2ZXIsXG4gICAgICBzZW5kLCByZWN2KSB7XG4gICAgdmFyIHBhcmFtcyA9IGdldENvbW1vbkNhcGFiaWxpdGllcyh0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzKTtcbiAgICBpZiAoc2VuZCAmJiB0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgcGFyYW1zLnJ0Y3AgPSB7XG4gICAgICAgIGNuYW1lOiBTRFBVdGlscy5sb2NhbENOYW1lLFxuICAgICAgICBjb21wb3VuZDogdHJhbnNjZWl2ZXIucnRjcFBhcmFtZXRlcnMuY29tcG91bmRcbiAgICAgIH07XG4gICAgICBpZiAodHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLnJ0Y3Auc3NyYyA9IHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYztcbiAgICAgIH1cbiAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5zZW5kKHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChyZWN2ICYmIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyICYmIHBhcmFtcy5jb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgLy8gcmVtb3ZlIFJUWCBmaWVsZCBpbiBFZGdlIDE0OTQyXG4gICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ3ZpZGVvJ1xuICAgICAgICAgICYmIHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgICAgICAmJiBlZGdlVmVyc2lvbiA8IDE1MDE5KSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVsZXRlIHAucnR4O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBbe31dO1xuICAgICAgfVxuICAgICAgcGFyYW1zLnJ0Y3AgPSB7XG4gICAgICAgIGNvbXBvdW5kOiB0cmFuc2NlaXZlci5ydGNwUGFyYW1ldGVycy5jb21wb3VuZFxuICAgICAgfTtcbiAgICAgIGlmICh0cmFuc2NlaXZlci5ydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgICAgICBwYXJhbXMucnRjcC5jbmFtZSA9IHRyYW5zY2VpdmVyLnJ0Y3BQYXJhbWV0ZXJzLmNuYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5ydGNwLnNzcmMgPSB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmM7XG4gICAgICB9XG4gICAgICB0cmFuc2NlaXZlci5ydHBSZWNlaXZlci5yZWNlaXZlKHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuXG4gICAgLy8gTm90ZTogcHJhbnN3ZXIgaXMgbm90IHN1cHBvcnRlZC5cbiAgICBpZiAoWydvZmZlcicsICdhbnN3ZXInXS5pbmRleE9mKGRlc2NyaXB0aW9uLnR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcignVHlwZUVycm9yJyxcbiAgICAgICAgICAnVW5zdXBwb3J0ZWQgdHlwZSBcIicgKyBkZXNjcmlwdGlvbi50eXBlICsgJ1wiJykpO1xuICAgIH1cblxuICAgIGlmICghaXNBY3Rpb25BbGxvd2VkSW5TaWduYWxpbmdTdGF0ZSgnc2V0TG9jYWxEZXNjcmlwdGlvbicsXG4gICAgICAgIGRlc2NyaXB0aW9uLnR5cGUsIHBjLnNpZ25hbGluZ1N0YXRlKSB8fCBwYy5faXNDbG9zZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yJyxcbiAgICAgICAgICAnQ2FuIG5vdCBzZXQgbG9jYWwgJyArIGRlc2NyaXB0aW9uLnR5cGUgK1xuICAgICAgICAgICcgaW4gc3RhdGUgJyArIHBjLnNpZ25hbGluZ1N0YXRlKSk7XG4gICAgfVxuXG4gICAgdmFyIHNlY3Rpb25zO1xuICAgIHZhciBzZXNzaW9ucGFydDtcbiAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgLy8gVkVSWSBsaW1pdGVkIHN1cHBvcnQgZm9yIFNEUCBtdW5naW5nLiBMaW1pdGVkIHRvOlxuICAgICAgLy8gKiBjaGFuZ2luZyB0aGUgb3JkZXIgb2YgY29kZWNzXG4gICAgICBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgIHNlc3Npb25wYXJ0ID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgIHZhciBjYXBzID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5sb2NhbENhcGFiaWxpdGllcyA9IGNhcHM7XG4gICAgICB9KTtcblxuICAgICAgcGMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgcGMuX2dhdGhlcih0cmFuc2NlaXZlci5taWQsIHNkcE1MaW5lSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHBjLl9yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgc2Vzc2lvbnBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgdmFyIGlzSWNlTGl0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICdhPWljZS1saXRlJykubGVuZ3RoID4gMDtcbiAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgdmFyIGljZUdhdGhlcmVyID0gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXI7XG4gICAgICAgIHZhciBpY2VUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQ7XG4gICAgICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG4gICAgICAgIHZhciByZW1vdGVDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgLy8gdHJlYXQgYnVuZGxlLW9ubHkgYXMgbm90LXJlamVjdGVkLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBTRFBVdGlscy5pc1JlamVjdGVkKG1lZGlhU2VjdGlvbikgJiZcbiAgICAgICAgICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9YnVuZGxlLW9ubHknKS5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKCFyZWplY3RlZCAmJiAhdHJhbnNjZWl2ZXIucmVqZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgcmVtb3RlSWNlUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMoXG4gICAgICAgICAgICAgIG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgIHZhciByZW1vdGVEdGxzUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICBtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICBpZiAoaXNJY2VMaXRlKSB7XG4gICAgICAgICAgICByZW1vdGVEdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFwYy51c2luZ0J1bmRsZSB8fCBzZHBNTGluZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBwYy5fZ2F0aGVyKHRyYW5zY2VpdmVyLm1pZCwgc2RwTUxpbmVJbmRleCk7XG4gICAgICAgICAgICBpZiAoaWNlVHJhbnNwb3J0LnN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQuc3RhcnQoaWNlR2F0aGVyZXIsIHJlbW90ZUljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICBpc0ljZUxpdGUgPyAnY29udHJvbGxpbmcnIDogJ2NvbnRyb2xsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkdGxzVHJhbnNwb3J0LnN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0LnN0YXJ0KHJlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIG9mIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICB2YXIgcGFyYW1zID0gZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKGxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXMpO1xuXG4gICAgICAgICAgLy8gU3RhcnQgdGhlIFJUQ1J0cFNlbmRlci4gVGhlIFJUQ1J0cFJlY2VpdmVyIGZvciB0aGlzXG4gICAgICAgICAgLy8gdHJhbnNjZWl2ZXIgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkIGluIHNldFJlbW90ZURlc2NyaXB0aW9uLlxuICAgICAgICAgIHBjLl90cmFuc2NlaXZlKHRyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICBwYXJhbXMuY29kZWNzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGMuX2xvY2FsRGVzY3JpcHRpb24gPSB7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwOiBkZXNjcmlwdGlvbi5zZHBcbiAgICB9O1xuICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICBwYy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2hhdmUtbG9jYWwtb2ZmZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdzdGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuXG4gICAgLy8gTm90ZTogcHJhbnN3ZXIgaXMgbm90IHN1cHBvcnRlZC5cbiAgICBpZiAoWydvZmZlcicsICdhbnN3ZXInXS5pbmRleE9mKGRlc2NyaXB0aW9uLnR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcignVHlwZUVycm9yJyxcbiAgICAgICAgICAnVW5zdXBwb3J0ZWQgdHlwZSBcIicgKyBkZXNjcmlwdGlvbi50eXBlICsgJ1wiJykpO1xuICAgIH1cblxuICAgIGlmICghaXNBY3Rpb25BbGxvd2VkSW5TaWduYWxpbmdTdGF0ZSgnc2V0UmVtb3RlRGVzY3JpcHRpb24nLFxuICAgICAgICBkZXNjcmlwdGlvbi50eXBlLCBwYy5zaWduYWxpbmdTdGF0ZSkgfHwgcGMuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgJ0NhbiBub3Qgc2V0IHJlbW90ZSAnICsgZGVzY3JpcHRpb24udHlwZSArXG4gICAgICAgICAgJyBpbiBzdGF0ZSAnICsgcGMuc2lnbmFsaW5nU3RhdGUpKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyZWFtcyA9IHt9O1xuICAgIHBjLnJlbW90ZVN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHN0cmVhbXNbc3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICB9KTtcbiAgICB2YXIgcmVjZWl2ZXJMaXN0ID0gW107XG4gICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgIHZhciBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgdmFyIGlzSWNlTGl0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAnYT1pY2UtbGl0ZScpLmxlbmd0aCA+IDA7XG4gICAgdmFyIHVzaW5nQnVuZGxlID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoc2Vzc2lvbnBhcnQsXG4gICAgICAgICdhPWdyb3VwOkJVTkRMRSAnKS5sZW5ndGggPiAwO1xuICAgIHBjLnVzaW5nQnVuZGxlID0gdXNpbmdCdW5kbGU7XG4gICAgdmFyIGljZU9wdGlvbnMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChzZXNzaW9ucGFydCxcbiAgICAgICAgJ2E9aWNlLW9wdGlvbnM6JylbMF07XG4gICAgaWYgKGljZU9wdGlvbnMpIHtcbiAgICAgIHBjLmNhblRyaWNrbGVJY2VDYW5kaWRhdGVzID0gaWNlT3B0aW9ucy5zdWJzdHIoMTQpLnNwbGl0KCcgJylcbiAgICAgICAgICAuaW5kZXhPZigndHJpY2tsZScpID49IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBjLmNhblRyaWNrbGVJY2VDYW5kaWRhdGVzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIHZhciBraW5kID0gU0RQVXRpbHMuZ2V0S2luZChtZWRpYVNlY3Rpb24pO1xuICAgICAgLy8gdHJlYXQgYnVuZGxlLW9ubHkgYXMgbm90LXJlamVjdGVkLlxuICAgICAgdmFyIHJlamVjdGVkID0gU0RQVXRpbHMuaXNSZWplY3RlZChtZWRpYVNlY3Rpb24pICYmXG4gICAgICAgICAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1idW5kbGUtb25seScpLmxlbmd0aCA9PT0gMDtcbiAgICAgIHZhciBwcm90b2NvbCA9IGxpbmVzWzBdLnN1YnN0cigyKS5zcGxpdCgnICcpWzJdO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuICAgICAgdmFyIHJlbW90ZU1zaWQgPSBTRFBVdGlscy5wYXJzZU1zaWQobWVkaWFTZWN0aW9uKTtcblxuICAgICAgdmFyIG1pZCA9IFNEUFV0aWxzLmdldE1pZChtZWRpYVNlY3Rpb24pIHx8IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4gICAgICAvLyBSZWplY3QgZGF0YWNoYW5uZWxzIHdoaWNoIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAgaWYgKHJlamVjdGVkIHx8IChraW5kID09PSAnYXBwbGljYXRpb24nICYmIChwcm90b2NvbCA9PT0gJ0RUTFMvU0NUUCcgfHxcbiAgICAgICAgICBwcm90b2NvbCA9PT0gJ1VEUC9EVExTL1NDVFAnKSkpIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBkYW5nZXJvdXMgaW4gdGhlIGNhc2Ugd2hlcmUgYSBub24tcmVqZWN0ZWQgbS1saW5lXG4gICAgICAgIC8vICAgICBiZWNvbWVzIHJlamVjdGVkLlxuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0gPSB7XG4gICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgICAgICAgcmVqZWN0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlamVjdGVkICYmIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSAmJlxuICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5yZWplY3RlZCkge1xuICAgICAgICAvLyByZWN5Y2xlIGEgcmVqZWN0ZWQgdHJhbnNjZWl2ZXIuXG4gICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSA9IHBjLl9jcmVhdGVUcmFuc2NlaXZlcihraW5kLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zY2VpdmVyO1xuICAgICAgdmFyIGljZUdhdGhlcmVyO1xuICAgICAgdmFyIGljZVRyYW5zcG9ydDtcbiAgICAgIHZhciBkdGxzVHJhbnNwb3J0O1xuICAgICAgdmFyIHJ0cFJlY2VpdmVyO1xuICAgICAgdmFyIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICB2YXIgcmVjdkVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgIHZhciBsb2NhbENhcGFiaWxpdGllcztcblxuICAgICAgdmFyIHRyYWNrO1xuICAgICAgLy8gRklYTUU6IGVuc3VyZSB0aGUgbWVkaWFTZWN0aW9uIGhhcyBydGNwLW11eCBzZXQuXG4gICAgICB2YXIgcmVtb3RlQ2FwYWJpbGl0aWVzID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICB2YXIgcmVtb3RlSWNlUGFyYW1ldGVycztcbiAgICAgIHZhciByZW1vdGVEdGxzUGFyYW1ldGVycztcbiAgICAgIGlmICghcmVqZWN0ZWQpIHtcbiAgICAgICAgcmVtb3RlSWNlUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMobWVkaWFTZWN0aW9uLFxuICAgICAgICAgICAgc2Vzc2lvbnBhcnQpO1xuICAgICAgICByZW1vdGVEdGxzUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgcmVtb3RlRHRsc1BhcmFtZXRlcnMucm9sZSA9ICdjbGllbnQnO1xuICAgICAgfVxuICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVycyA9XG4gICAgICAgICAgU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcblxuICAgICAgdmFyIHJ0Y3BQYXJhbWV0ZXJzID0gU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuXG4gICAgICB2YXIgaXNDb21wbGV0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAnYT1lbmQtb2YtY2FuZGlkYXRlcycsIHNlc3Npb25wYXJ0KS5sZW5ndGggPiAwO1xuICAgICAgdmFyIGNhbmRzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1jYW5kaWRhdGU6JylcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbmQuY29tcG9uZW50ID09PSAxO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gdXNlIEJVTkRMRSBhbmQgZGlzcG9zZSB0cmFuc3BvcnRzLlxuICAgICAgaWYgKChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInIHx8IGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSAmJlxuICAgICAgICAgICFyZWplY3RlZCAmJiB1c2luZ0J1bmRsZSAmJiBzZHBNTGluZUluZGV4ID4gMCAmJlxuICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSkge1xuICAgICAgICBwYy5fZGlzcG9zZUljZUFuZER0bHNUcmFuc3BvcnRzKHNkcE1MaW5lSW5kZXgpO1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uaWNlR2F0aGVyZXIgPVxuICAgICAgICAgICAgcGMudHJhbnNjZWl2ZXJzWzBdLmljZUdhdGhlcmVyO1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uaWNlVHJhbnNwb3J0ID1cbiAgICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1swXS5pY2VUcmFuc3BvcnQ7XG4gICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5kdGxzVHJhbnNwb3J0ID1cbiAgICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1swXS5kdGxzVHJhbnNwb3J0O1xuICAgICAgICBpZiAocGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLnJ0cFNlbmRlcikge1xuICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5ydHBTZW5kZXIuc2V0VHJhbnNwb3J0KFxuICAgICAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbMF0uZHRsc1RyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5ydHBSZWNlaXZlcikge1xuICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5ydHBSZWNlaXZlci5zZXRUcmFuc3BvcnQoXG4gICAgICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1swXS5kdGxzVHJhbnNwb3J0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyID0gcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdIHx8XG4gICAgICAgICAgICBwYy5fY3JlYXRlVHJhbnNjZWl2ZXIoa2luZCk7XG4gICAgICAgIHRyYW5zY2VpdmVyLm1pZCA9IG1pZDtcblxuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyLmljZUdhdGhlcmVyKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIgPSBwYy5fY3JlYXRlSWNlR2F0aGVyZXIoc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICAgICAgdXNpbmdCdW5kbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbmRzLmxlbmd0aCAmJiB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuc3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgaWYgKGlzQ29tcGxldGUgJiYgKCF1c2luZ0J1bmRsZSB8fCBzZHBNTGluZUluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnNldFJlbW90ZUNhbmRpZGF0ZXMoY2FuZHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICBtYXliZUFkZENhbmRpZGF0ZSh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbENhcGFiaWxpdGllcyA9IHdpbmRvdy5SVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoa2luZCk7XG5cbiAgICAgICAgLy8gZmlsdGVyIFJUWCB1bnRpbCBhZGRpdGlvbmFsIHN0dWZmIG5lZWRlZCBmb3IgUlRYIGlzIGltcGxlbWVudGVkXG4gICAgICAgIC8vIGluIGFkYXB0ZXIuanNcbiAgICAgICAgaWYgKGVkZ2VWZXJzaW9uIDwgMTUwMTkpIHtcbiAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MgPSBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKFxuICAgICAgICAgICAgICBmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYy5uYW1lICE9PSAncnR4JztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycyB8fCBbe1xuICAgICAgICAgIHNzcmM6ICgyICogc2RwTUxpbmVJbmRleCArIDIpICogMTAwMVxuICAgICAgICB9XTtcblxuICAgICAgICAvLyBUT0RPOiByZXdyaXRlIHRvIHVzZSBodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtcGMvI3NldC1hc3NvY2lhdGVkLXJlbW90ZS1zdHJlYW1zXG4gICAgICAgIHZhciBpc05ld1RyYWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKSB7XG4gICAgICAgICAgaXNOZXdUcmFjayA9ICF0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgICBydHBSZWNlaXZlciA9IHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyIHx8XG4gICAgICAgICAgICAgIG5ldyB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIodHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydCwga2luZCk7XG5cbiAgICAgICAgICBpZiAoaXNOZXdUcmFjaykge1xuICAgICAgICAgICAgdmFyIHN0cmVhbTtcbiAgICAgICAgICAgIHRyYWNrID0gcnRwUmVjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgICAvLyBGSVhNRTogZG9lcyBub3Qgd29yayB3aXRoIFBsYW4gQi5cbiAgICAgICAgICAgIGlmIChyZW1vdGVNc2lkICYmIHJlbW90ZU1zaWQuc3RyZWFtID09PSAnLScpIHtcbiAgICAgICAgICAgICAgLy8gbm8tb3AuIGEgc3RyZWFtIGlkIG9mICctJyBtZWFuczogbm8gYXNzb2NpYXRlZCBzdHJlYW0uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZU1zaWQpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbcmVtb3RlTXNpZC5zdHJlYW1dID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXSwgJ2lkJywge1xuICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZU1zaWQuc3RyZWFtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFjaywgJ2lkJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlTXNpZC50cmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzdHJlYW0gPSBzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghc3RyZWFtcy5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtcy5kZWZhdWx0ID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cmVhbSA9IHN0cmVhbXMuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgYWRkVHJhY2tUb1N0cmVhbUFuZEZpcmVFdmVudCh0cmFjaywgc3RyZWFtKTtcbiAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuYXNzb2NpYXRlZFJlbW90ZU1lZGlhU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNlaXZlckxpc3QucHVzaChbdHJhY2ssIHJ0cFJlY2VpdmVyLCBzdHJlYW1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIgJiYgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIudHJhY2spIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5hc3NvY2lhdGVkUmVtb3RlTWVkaWFTdHJlYW1zLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVRyYWNrID0gcy5nZXRUcmFja3MoKS5maW5kKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQuaWQgPT09IHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnRyYWNrLmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobmF0aXZlVHJhY2spIHtcbiAgICAgICAgICAgICAgcmVtb3ZlVHJhY2tGcm9tU3RyZWFtQW5kRmlyZUV2ZW50KG5hdGl2ZVRyYWNrLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2NlaXZlci5hc3NvY2lhdGVkUmVtb3RlTWVkaWFTdHJlYW1zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyA9IGxvY2FsQ2FwYWJpbGl0aWVzO1xuICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMgPSByZW1vdGVDYXBhYmlsaXRpZXM7XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyID0gcnRwUmVjZWl2ZXI7XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0Y3BQYXJhbWV0ZXJzID0gcnRjcFBhcmFtZXRlcnM7XG4gICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgPSBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzID0gcmVjdkVuY29kaW5nUGFyYW1ldGVycztcblxuICAgICAgICAvLyBTdGFydCB0aGUgUlRDUnRwUmVjZWl2ZXIgbm93LiBUaGUgUlRQU2VuZGVyIGlzIHN0YXJ0ZWQgaW5cbiAgICAgICAgLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5cbiAgICAgICAgcGMuX3RyYW5zY2VpdmUocGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBpc05ld1RyYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyID0gcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdO1xuICAgICAgICBpY2VHYXRoZXJlciA9IHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyO1xuICAgICAgICBpY2VUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQ7XG4gICAgICAgIGR0bHNUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0O1xuICAgICAgICBydHBSZWNlaXZlciA9IHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcztcblxuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucmVjdkVuY29kaW5nUGFyYW1ldGVycyA9XG4gICAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucmVtb3RlQ2FwYWJpbGl0aWVzID1cbiAgICAgICAgICAgIHJlbW90ZUNhcGFiaWxpdGllcztcbiAgICAgICAgcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLnJ0Y3BQYXJhbWV0ZXJzID0gcnRjcFBhcmFtZXRlcnM7XG5cbiAgICAgICAgaWYgKGNhbmRzLmxlbmd0aCAmJiBpY2VUcmFuc3BvcnQuc3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgaWYgKChpc0ljZUxpdGUgfHwgaXNDb21wbGV0ZSkgJiZcbiAgICAgICAgICAgICAgKCF1c2luZ0J1bmRsZSB8fCBzZHBNTGluZUluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnNldFJlbW90ZUNhbmRpZGF0ZXMoY2FuZHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICBtYXliZUFkZENhbmRpZGF0ZSh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVzaW5nQnVuZGxlIHx8IHNkcE1MaW5lSW5kZXggPT09IDApIHtcbiAgICAgICAgICBpZiAoaWNlVHJhbnNwb3J0LnN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnN0YXJ0KGljZUdhdGhlcmVyLCByZW1vdGVJY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICdjb250cm9sbGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZHRsc1RyYW5zcG9ydC5zdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQuc3RhcnQocmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBvZmZlciBjb250YWluZWQgUlRYIGJ1dCB0aGUgYW5zd2VyIGRpZCBub3QsXG4gICAgICAgIC8vIHJlbW92ZSBSVFggZnJvbSBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzLlxuICAgICAgICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0gZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKFxuICAgICAgICAgIHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcyk7XG5cbiAgICAgICAgdmFyIGhhc1J0eCA9IGNvbW1vbkNhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdydHgnO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgIGlmICghaGFzUnR4ICYmIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICAgICAgZGVsZXRlIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4O1xuICAgICAgICB9XG5cbiAgICAgICAgcGMuX3RyYW5zY2VpdmUodHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAncmVjdm9ubHknLFxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5Jyk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3cml0ZSB0byB1c2UgaHR0cDovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNzZXQtYXNzb2NpYXRlZC1yZW1vdGUtc3RyZWFtc1xuICAgICAgICBpZiAocnRwUmVjZWl2ZXIgJiZcbiAgICAgICAgICAgIChkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKSkge1xuICAgICAgICAgIHRyYWNrID0gcnRwUmVjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgaWYgKHJlbW90ZU1zaWQpIHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtc1tyZW1vdGVNc2lkLnN0cmVhbV0pIHtcbiAgICAgICAgICAgICAgc3RyZWFtc1tyZW1vdGVNc2lkLnN0cmVhbV0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRUcmFja1RvU3RyZWFtQW5kRmlyZUV2ZW50KHRyYWNrLCBzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXSk7XG4gICAgICAgICAgICByZWNlaXZlckxpc3QucHVzaChbdHJhY2ssIHJ0cFJlY2VpdmVyLCBzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbXMuZGVmYXVsdCkge1xuICAgICAgICAgICAgICBzdHJlYW1zLmRlZmF1bHQgPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRUcmFja1RvU3RyZWFtQW5kRmlyZUV2ZW50KHRyYWNrLCBzdHJlYW1zLmRlZmF1bHQpO1xuICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LnB1c2goW3RyYWNrLCBydHBSZWNlaXZlciwgc3RyZWFtcy5kZWZhdWx0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZJWE1FOiBhY3R1YWxseSB0aGUgcmVjZWl2ZXIgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXIuXG4gICAgICAgICAgZGVsZXRlIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGMuX2R0bHNSb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBjLl9kdGxzUm9sZSA9IGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicgPyAnYWN0aXZlJyA6ICdwYXNzaXZlJztcbiAgICB9XG5cbiAgICBwYy5fcmVtb3RlRGVzY3JpcHRpb24gPSB7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwOiBkZXNjcmlwdGlvbi5zZHBcbiAgICB9O1xuICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICBwYy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2hhdmUtcmVtb3RlLW9mZmVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBjLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnc3RhYmxlJyk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHN0cmVhbXMpLmZvckVhY2goZnVuY3Rpb24oc2lkKSB7XG4gICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1tzaWRdO1xuICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBjLnJlbW90ZVN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID09PSAtMSkge1xuICAgICAgICAgIHBjLnJlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGMuX2Rpc3BhdGNoRXZlbnQoJ2FkZHN0cmVhbScsIGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY2VpdmVyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSBpdGVtWzBdO1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGl0ZW1bMV07XG4gICAgICAgICAgaWYgKHN0cmVhbS5pZCAhPT0gaXRlbVsyXS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJlQWRkVHJhY2socGMsIHRyYWNrLCByZWNlaXZlciwgW3N0cmVhbV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWNlaXZlckxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaXJlQWRkVHJhY2socGMsIGl0ZW1bMF0sIGl0ZW1bMV0sIFtdKTtcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgYWRkSWNlQ2FuZGlkYXRlKHt9KSB3YXMgY2FsbGVkIHdpdGhpbiBmb3VyIHNlY29uZHMgYWZ0ZXJcbiAgICAvLyBzZXRSZW1vdGVEZXNjcmlwdGlvbi5cbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmICghKHBjICYmIHBjLnRyYW5zY2VpdmVycykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydCAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0YXRlID09PSAnbmV3JyAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LmdldFJlbW90ZUNhbmRpZGF0ZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUaW1lb3V0IGZvciBhZGRSZW1vdGVDYW5kaWRhdGUuIENvbnNpZGVyIHNlbmRpbmcgJyArXG4gICAgICAgICAgICAgICdhbiBlbmQtb2YtY2FuZGlkYXRlcyBub3RpZmljYXRpb24nKTtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgNDAwMCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgLyogbm90IHlldFxuICAgICAgaWYgKHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICAqL1xuICAgICAgaWYgKHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydCkge1xuICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5zdG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIuc3RvcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEZJWE1FOiBjbGVhbiB1cCB0cmFja3MsIGxvY2FsIHN0cmVhbXMsIHJlbW90ZSBzdHJlYW1zLCBldGNcbiAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2Nsb3NlZCcpO1xuICB9O1xuXG4gIC8vIFVwZGF0ZSB0aGUgc2lnbmFsaW5nIHN0YXRlLlxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICB0aGlzLnNpZ25hbGluZ1N0YXRlID0gbmV3U3RhdGU7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdzaWduYWxpbmdzdGF0ZWNoYW5nZScpO1xuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJywgZXZlbnQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIHRvIGZpcmUgdGhlIG5lZ290aWF0aW9ubmVlZGVkIGV2ZW50LlxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBjID0gdGhpcztcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZScgfHwgdGhpcy5uZWVkTmVnb3RpYXRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHBjLm5lZWROZWdvdGlhdGlvbikge1xuICAgICAgICBwYy5uZWVkTmVnb3RpYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpO1xuICAgICAgICBwYy5fZGlzcGF0Y2hFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnLCBldmVudCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG5cbiAgLy8gVXBkYXRlIHRoZSBpY2UgY29ubmVjdGlvbiBzdGF0ZS5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVJY2VDb25uZWN0aW9uU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3U3RhdGU7XG4gICAgdmFyIHN0YXRlcyA9IHtcbiAgICAgICduZXcnOiAwLFxuICAgICAgY2xvc2VkOiAwLFxuICAgICAgY2hlY2tpbmc6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBjb21wbGV0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBmYWlsZWQ6IDBcbiAgICB9O1xuICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQgJiYgIXRyYW5zY2VpdmVyLnJlamVjdGVkKSB7XG4gICAgICAgIHN0YXRlc1t0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuc3RhdGVdKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBuZXdTdGF0ZSA9ICduZXcnO1xuICAgIGlmIChzdGF0ZXMuZmFpbGVkID4gMCkge1xuICAgICAgbmV3U3RhdGUgPSAnZmFpbGVkJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlcy5jaGVja2luZyA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ2NoZWNraW5nJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlcy5kaXNjb25uZWN0ZWQgPiAwKSB7XG4gICAgICBuZXdTdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGVzLm5ldyA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ25ldyc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZXMuY29ubmVjdGVkID4gMCkge1xuICAgICAgbmV3U3RhdGUgPSAnY29ubmVjdGVkJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlcy5jb21wbGV0ZWQgPiAwKSB7XG4gICAgICBuZXdTdGF0ZSA9ICdjb21wbGV0ZWQnO1xuICAgIH1cblxuICAgIGlmIChuZXdTdGF0ZSAhPT0gdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgIHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVcGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdGUuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlQ29ubmVjdGlvblN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5ld1N0YXRlO1xuICAgIHZhciBzdGF0ZXMgPSB7XG4gICAgICAnbmV3JzogMCxcbiAgICAgIGNsb3NlZDogMCxcbiAgICAgIGNvbm5lY3Rpbmc6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBjb21wbGV0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBmYWlsZWQ6IDBcbiAgICB9O1xuICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQgJiYgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydCAmJlxuICAgICAgICAgICF0cmFuc2NlaXZlci5yZWplY3RlZCkge1xuICAgICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0YXRlXSsrO1xuICAgICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5zdGF0ZV0rKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBJQ0VUcmFuc3BvcnQuY29tcGxldGVkIGFuZCBjb25uZWN0ZWQgYXJlIHRoZSBzYW1lIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgc3RhdGVzLmNvbm5lY3RlZCArPSBzdGF0ZXMuY29tcGxldGVkO1xuXG4gICAgbmV3U3RhdGUgPSAnbmV3JztcbiAgICBpZiAoc3RhdGVzLmZhaWxlZCA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ2ZhaWxlZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZXMuY29ubmVjdGluZyA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGVzLmRpc2Nvbm5lY3RlZCA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZXMubmV3ID4gMCkge1xuICAgICAgbmV3U3RhdGUgPSAnbmV3JztcbiAgICB9IGVsc2UgaWYgKHN0YXRlcy5jb25uZWN0ZWQgPiAwKSB7XG4gICAgICBuZXdTdGF0ZSA9ICdjb25uZWN0ZWQnO1xuICAgIH1cblxuICAgIGlmIChuZXdTdGF0ZSAhPT0gdGhpcy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuXG4gICAgaWYgKHBjLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLFxuICAgICAgICAgICdDYW4gbm90IGNhbGwgY3JlYXRlT2ZmZXIgYWZ0ZXIgY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgdmFyIG51bUF1ZGlvVHJhY2tzID0gcGMudHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdC5raW5kID09PSAnYXVkaW8nO1xuICAgIH0pLmxlbmd0aDtcbiAgICB2YXIgbnVtVmlkZW9UcmFja3MgPSBwYy50cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0LmtpbmQgPT09ICd2aWRlbyc7XG4gICAgfSkubGVuZ3RoO1xuXG4gICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHdlIG5lZWQgdG8gc2VuZC9yZWN2LlxuICAgIHZhciBvZmZlck9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgLy8gUmVqZWN0IENocm9tZSBsZWdhY3kgY29uc3RyYWludHMuXG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm1hbmRhdG9yeSB8fCBvZmZlck9wdGlvbnMub3B0aW9uYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdMZWdhY3kgbWFuZGF0b3J5L29wdGlvbmFsIGNvbnN0cmFpbnRzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IHRydWUpIHtcbiAgICAgICAgICBudW1BdWRpb1RyYWNrcyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgbnVtQXVkaW9UcmFja3MgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bUF1ZGlvVHJhY2tzID0gb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG51bVZpZGVvVHJhY2tzID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBudW1WaWRlb1RyYWNrcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtVmlkZW9UcmFja3MgPSBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBjLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBudW1BdWRpb1RyYWNrcy0tO1xuICAgICAgICBpZiAobnVtQXVkaW9UcmFja3MgPCAwKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIud2FudFJlY2VpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgIG51bVZpZGVvVHJhY2tzLS07XG4gICAgICAgIGlmIChudW1WaWRlb1RyYWNrcyA8IDApIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci53YW50UmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgTS1saW5lcyBmb3IgcmVjdm9ubHkgc3RyZWFtcy5cbiAgICB3aGlsZSAobnVtQXVkaW9UcmFja3MgPiAwIHx8IG51bVZpZGVvVHJhY2tzID4gMCkge1xuICAgICAgaWYgKG51bUF1ZGlvVHJhY2tzID4gMCkge1xuICAgICAgICBwYy5fY3JlYXRlVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgIG51bUF1ZGlvVHJhY2tzLS07XG4gICAgICB9XG4gICAgICBpZiAobnVtVmlkZW9UcmFja3MgPiAwKSB7XG4gICAgICAgIHBjLl9jcmVhdGVUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgbnVtVmlkZW9UcmFja3MtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUocGMuX3NkcFNlc3Npb25JZCxcbiAgICAgICAgcGMuX3NkcFNlc3Npb25WZXJzaW9uKyspO1xuICAgIHBjLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAvLyBGb3IgZWFjaCB0cmFjaywgY3JlYXRlIGFuIGljZSBnYXRoZXJlciwgaWNlIHRyYW5zcG9ydCxcbiAgICAgIC8vIGR0bHMgdHJhbnNwb3J0LCBwb3RlbnRpYWxseSBydHBzZW5kZXIgYW5kIHJ0cHJlY2VpdmVyLlxuICAgICAgdmFyIHRyYWNrID0gdHJhbnNjZWl2ZXIudHJhY2s7XG4gICAgICB2YXIga2luZCA9IHRyYW5zY2VpdmVyLmtpbmQ7XG4gICAgICB2YXIgbWlkID0gdHJhbnNjZWl2ZXIubWlkIHx8IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuICAgICAgdHJhbnNjZWl2ZXIubWlkID0gbWlkO1xuXG4gICAgICBpZiAoIXRyYW5zY2VpdmVyLmljZUdhdGhlcmVyKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyID0gcGMuX2NyZWF0ZUljZUdhdGhlcmVyKHNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgICBwYy51c2luZ0J1bmRsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2NhbENhcGFiaWxpdGllcyA9IHdpbmRvdy5SVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuICAgICAgLy8gZmlsdGVyIFJUWCB1bnRpbCBhZGRpdGlvbmFsIHN0dWZmIG5lZWRlZCBmb3IgUlRYIGlzIGltcGxlbWVudGVkXG4gICAgICAvLyBpbiBhZGFwdGVyLmpzXG4gICAgICBpZiAoZWRnZVZlcnNpb24gPCAxNTAxOSkge1xuICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MgPSBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKFxuICAgICAgICAgICAgZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLm5hbWUgIT09ICdydHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAvLyB3b3JrIGFyb3VuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjU1MlxuICAgICAgICAvLyBieSBhZGRpbmcgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MVxuICAgICAgICBpZiAoY29kZWMubmFtZSA9PT0gJ0gyNjQnICYmXG4gICAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddID0gJzEnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIHN1YnNlcXVlbnQgb2ZmZXJzLCB3ZSBtaWdodCBoYXZlIHRvIHJlLXVzZSB0aGUgcGF5bG9hZFxuICAgICAgICAvLyB0eXBlIG9mIHRoZSBsYXN0IG9mZmVyLlxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKHJlbW90ZUNvZGVjKSB7XG4gICAgICAgICAgICBpZiAoY29kZWMubmFtZS50b0xvd2VyQ2FzZSgpID09PSByZW1vdGVDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICBjb2RlYy5jbG9ja1JhdGUgPT09IHJlbW90ZUNvZGVjLmNsb2NrUmF0ZSkge1xuICAgICAgICAgICAgICBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSA9IHJlbW90ZUNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihoZHJFeHQpIHtcbiAgICAgICAgdmFyIHJlbW90ZUV4dGVuc2lvbnMgPSB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zIHx8IFtdO1xuICAgICAgICByZW1vdGVFeHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24ockhkckV4dCkge1xuICAgICAgICAgIGlmIChoZHJFeHQudXJpID09PSBySGRyRXh0LnVyaSkge1xuICAgICAgICAgICAgaGRyRXh0LmlkID0gckhkckV4dC5pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGFuIHNzcmMgbm93LCB0byBiZSB1c2VkIGxhdGVyIGluIHJ0cFNlbmRlci5zZW5kXG4gICAgICB2YXIgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgfHwgW3tcbiAgICAgICAgc3NyYzogKDIgKiBzZHBNTGluZUluZGV4ICsgMSkgKiAxMDAxXG4gICAgICB9XTtcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAvLyBhZGQgUlRYXG4gICAgICAgIGlmIChlZGdlVmVyc2lvbiA+PSAxNTAxOSAmJiBraW5kID09PSAndmlkZW8nICYmXG4gICAgICAgICAgICAhc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCA9IHtcbiAgICAgICAgICAgIHNzcmM6IHNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArIDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2NlaXZlci53YW50UmVjZWl2ZSkge1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBSZWNlaXZlciA9IG5ldyB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIoXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0LCBraW5kKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMgPSBsb2NhbENhcGFiaWxpdGllcztcbiAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgPSBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgIH0pO1xuXG4gICAgLy8gYWx3YXlzIG9mZmVyIEJVTkRMRSBhbmQgZGlzcG9zZSBvbiByZXR1cm4gaWYgbm90IHN1cHBvcnRlZC5cbiAgICBpZiAocGMuX2NvbmZpZy5idW5kbGVQb2xpY3kgIT09ICdtYXgtY29tcGF0Jykge1xuICAgICAgc2RwICs9ICdhPWdyb3VwOkJVTkRMRSAnICsgcGMudHJhbnNjZWl2ZXJzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Lm1pZDtcbiAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgIH1cbiAgICBzZHAgKz0gJ2E9aWNlLW9wdGlvbnM6dHJpY2tsZVxcclxcbic7XG5cbiAgICBwYy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlciwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgc2RwICs9IHdyaXRlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLCB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAnb2ZmZXInLCB0cmFuc2NlaXZlci5zdHJlYW0sIHBjLl9kdGxzUm9sZSk7XG4gICAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG5cbiAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VHYXRoZXJlciAmJiBwYy5pY2VHYXRoZXJpbmdTdGF0ZSAhPT0gJ25ldycgJiZcbiAgICAgICAgICAoc2RwTUxpbmVJbmRleCA9PT0gMCB8fCAhcGMudXNpbmdCdW5kbGUpKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLmdldExvY2FsQ2FuZGlkYXRlcygpLmZvckVhY2goZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgIGNhbmQuY29tcG9uZW50ID0gMTtcbiAgICAgICAgICBzZHAgKz0gJ2E9JyArIFNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlKGNhbmQpICsgJ1xcclxcbic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICBzZHAgKz0gJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZGVzYyA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICBzZHA6IHNkcFxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzYyk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYyA9IHRoaXM7XG5cbiAgICBpZiAocGMuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgJ0NhbiBub3QgY2FsbCBjcmVhdGVBbnN3ZXIgYWZ0ZXIgY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgaWYgKCEocGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLXJlbW90ZS1vZmZlcicgfHxcbiAgICAgICAgcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLXByYW5zd2VyJykpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yJyxcbiAgICAgICAgICAnQ2FuIG5vdCBjYWxsIGNyZWF0ZUFuc3dlciBpbiBzaWduYWxpbmdTdGF0ZSAnICsgcGMuc2lnbmFsaW5nU3RhdGUpKTtcbiAgICB9XG5cbiAgICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUocGMuX3NkcFNlc3Npb25JZCxcbiAgICAgICAgcGMuX3NkcFNlc3Npb25WZXJzaW9uKyspO1xuICAgIGlmIChwYy51c2luZ0J1bmRsZSkge1xuICAgICAgc2RwICs9ICdhPWdyb3VwOkJVTkRMRSAnICsgcGMudHJhbnNjZWl2ZXJzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Lm1pZDtcbiAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgIH1cbiAgICBzZHAgKz0gJ2E9aWNlLW9wdGlvbnM6dHJpY2tsZVxcclxcbic7XG5cbiAgICB2YXIgbWVkaWFTZWN0aW9uc0luT2ZmZXIgPSBTRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zKFxuICAgICAgICBwYy5fcmVtb3RlRGVzY3JpcHRpb24uc2RwKS5sZW5ndGg7XG4gICAgcGMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgIGlmIChzZHBNTGluZUluZGV4ICsgMSA+IG1lZGlhU2VjdGlvbnNJbk9mZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2NlaXZlci5yZWplY3RlZCkge1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5wcm90b2NvbCA9PT0gJ0RUTFMvU0NUUCcpIHsgLy8gbGVnYWN5IGZtdFxuICAgICAgICAgICAgc2RwICs9ICdtPWFwcGxpY2F0aW9uIDAgRFRMUy9TQ1RQIDUwMDBcXHJcXG4nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZHAgKz0gJ209YXBwbGljYXRpb24gMCAnICsgdHJhbnNjZWl2ZXIucHJvdG9jb2wgK1xuICAgICAgICAgICAgICAgICcgd2VicnRjLWRhdGFjaGFubmVsXFxyXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHNkcCArPSAnbT1hdWRpbyAwIFVEUC9UTFMvUlRQL1NBVlBGIDBcXHJcXG4nICtcbiAgICAgICAgICAgICAgJ2E9cnRwbWFwOjAgUENNVS84MDAwXFxyXFxuJztcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgc2RwICs9ICdtPXZpZGVvIDAgVURQL1RMUy9SVFAvU0FWUEYgMTIwXFxyXFxuJyArXG4gICAgICAgICAgICAgICdhPXJ0cG1hcDoxMjAgVlA4LzkwMDAwXFxyXFxuJztcbiAgICAgICAgfVxuICAgICAgICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nICtcbiAgICAgICAgICAgICdhPWluYWN0aXZlXFxyXFxuJyArXG4gICAgICAgICAgICAnYT1taWQ6JyArIHRyYW5zY2VpdmVyLm1pZCArICdcXHJcXG4nO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZJWE1FOiBsb29rIGF0IGRpcmVjdGlvbi5cbiAgICAgIGlmICh0cmFuc2NlaXZlci5zdHJlYW0pIHtcbiAgICAgICAgdmFyIGxvY2FsVHJhY2s7XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgbG9jYWxUcmFjayA9IHRyYW5zY2VpdmVyLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLmtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBsb2NhbFRyYWNrID0gdHJhbnNjZWl2ZXIuc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsVHJhY2spIHtcbiAgICAgICAgICAvLyBhZGQgUlRYXG4gICAgICAgICAgaWYgKGVkZ2VWZXJzaW9uID49IDE1MDE5ICYmIHRyYW5zY2VpdmVyLmtpbmQgPT09ICd2aWRlbycgJiZcbiAgICAgICAgICAgICAgIXRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCA9IHtcbiAgICAgICAgICAgICAgc3NyYzogdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICsgMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBvZiBjYXBhYmlsaXRpZXMuXG4gICAgICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0gZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKFxuICAgICAgICAgIHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcyk7XG5cbiAgICAgIHZhciBoYXNSdHggPSBjb21tb25DYXBhYmlsaXRpZXMuY29kZWNzLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBjLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3J0eCc7XG4gICAgICB9KS5sZW5ndGg7XG4gICAgICBpZiAoIWhhc1J0eCAmJiB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgICAgICBkZWxldGUgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHg7XG4gICAgICB9XG5cbiAgICAgIHNkcCArPSB3cml0ZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlciwgY29tbW9uQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICdhbnN3ZXInLCB0cmFuc2NlaXZlci5zdHJlYW0sIHBjLl9kdGxzUm9sZSk7XG4gICAgICBpZiAodHJhbnNjZWl2ZXIucnRjcFBhcmFtZXRlcnMgJiZcbiAgICAgICAgICB0cmFuc2NlaXZlci5ydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSkge1xuICAgICAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZGVzYyA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6ICdhbnN3ZXInLFxuICAgICAgc2RwOiBzZHBcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2MpO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuICAgIHZhciBzZWN0aW9ucztcbiAgICBpZiAoY2FuZGlkYXRlICYmICEoY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXggIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBjYW5kaWRhdGUuc2RwTWlkKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ3NkcE1MaW5lSW5kZXggb3Igc2RwTWlkIHJlcXVpcmVkJykpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG5lZWRzIHRvIGdvIGludG8gb3BzIHF1ZXVlLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICghcGMuX3JlbW90ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgICAnQ2FuIG5vdCBhZGQgSUNFIGNhbmRpZGF0ZSB3aXRob3V0IGEgcmVtb3RlIGRlc2NyaXB0aW9uJykpO1xuICAgICAgfSBlbHNlIGlmICghY2FuZGlkYXRlIHx8IGNhbmRpZGF0ZS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGMudHJhbnNjZWl2ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHBjLnRyYW5zY2VpdmVyc1tqXS5yZWplY3RlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1tqXS5pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcbiAgICAgICAgICBzZWN0aW9ucyA9IFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMocGMuX3JlbW90ZURlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgc2VjdGlvbnNbal0gKz0gJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgICAgIHBjLl9yZW1vdGVEZXNjcmlwdGlvbi5zZHAgPVxuICAgICAgICAgICAgICBTRFBVdGlscy5nZXREZXNjcmlwdGlvbihwYy5fcmVtb3RlRGVzY3JpcHRpb24uc2RwKSArXG4gICAgICAgICAgICAgIHNlY3Rpb25zLmpvaW4oJycpO1xuICAgICAgICAgIGlmIChwYy51c2luZ0J1bmRsZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2RwTUxpbmVJbmRleCA9IGNhbmRpZGF0ZS5zZHBNTGluZUluZGV4O1xuICAgICAgICBpZiAoY2FuZGlkYXRlLnNkcE1pZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGMudHJhbnNjZWl2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGMudHJhbnNjZWl2ZXJzW2ldLm1pZCA9PT0gY2FuZGlkYXRlLnNkcE1pZCkge1xuICAgICAgICAgICAgICBzZHBNTGluZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2FuZCA9IE9iamVjdC5rZXlzKGNhbmRpZGF0ZS5jYW5kaWRhdGUpLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kaWRhdGUuY2FuZGlkYXRlKSA6IHt9O1xuICAgICAgICAgIC8vIElnbm9yZSBDaHJvbWUncyBpbnZhbGlkIGNhbmRpZGF0ZXMgc2luY2UgRWRnZSBkb2VzIG5vdCBsaWtlIHRoZW0uXG4gICAgICAgICAgaWYgKGNhbmQucHJvdG9jb2wgPT09ICd0Y3AnICYmIChjYW5kLnBvcnQgPT09IDAgfHwgY2FuZC5wb3J0ID09PSA5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWdub3JlIFJUQ1AgY2FuZGlkYXRlcywgd2UgYXNzdW1lIFJUQ1AtTVVYLlxuICAgICAgICAgIGlmIChjYW5kLmNvbXBvbmVudCAmJiBjYW5kLmNvbXBvbmVudCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2hlbiB1c2luZyBidW5kbGUsIGF2b2lkIGFkZGluZyBjYW5kaWRhdGVzIHRvIHRoZSB3cm9uZ1xuICAgICAgICAgIC8vIGljZSB0cmFuc3BvcnQuIEFuZCBhdm9pZCBhZGRpbmcgY2FuZGlkYXRlcyBhZGRlZCBpbiB0aGUgU0RQLlxuICAgICAgICAgIGlmIChzZHBNTGluZUluZGV4ID09PSAwIHx8IChzZHBNTGluZUluZGV4ID4gMCAmJlxuICAgICAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQgIT09IHBjLnRyYW5zY2VpdmVyc1swXS5pY2VUcmFuc3BvcnQpKSB7XG4gICAgICAgICAgICBpZiAoIW1heWJlQWRkQ2FuZGlkYXRlKHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydCwgY2FuZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChtYWtlRXJyb3IoJ09wZXJhdGlvbkVycm9yJyxcbiAgICAgICAgICAgICAgICAgICdDYW4gbm90IGFkZCBJQ0UgY2FuZGlkYXRlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcmVtb3RlRGVzY3JpcHRpb24uXG4gICAgICAgICAgdmFyIGNhbmRpZGF0ZVN0cmluZyA9IGNhbmRpZGF0ZS5jYW5kaWRhdGUudHJpbSgpO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGVTdHJpbmcuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgICAgICAgY2FuZGlkYXRlU3RyaW5nID0gY2FuZGlkYXRlU3RyaW5nLnN1YnN0cigyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VjdGlvbnMgPSBTRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zKHBjLl9yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgIHNlY3Rpb25zW3NkcE1MaW5lSW5kZXhdICs9ICdhPScgK1xuICAgICAgICAgICAgICAoY2FuZC50eXBlID8gY2FuZGlkYXRlU3RyaW5nIDogJ2VuZC1vZi1jYW5kaWRhdGVzJylcbiAgICAgICAgICAgICAgKyAnXFxyXFxuJztcbiAgICAgICAgICBwYy5fcmVtb3RlRGVzY3JpcHRpb24uc2RwID1cbiAgICAgICAgICAgICAgU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24ocGMuX3JlbW90ZURlc2NyaXB0aW9uLnNkcCkgK1xuICAgICAgICAgICAgICBzZWN0aW9ucy5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG1ha2VFcnJvcignT3BlcmF0aW9uRXJyb3InLFxuICAgICAgICAgICAgICAnQ2FuIG5vdCBhZGQgSUNFIGNhbmRpZGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgaWYgKHNlbGVjdG9yICYmIHNlbGVjdG9yIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIHZhciBzZW5kZXJPclJlY2VpdmVyID0gbnVsbDtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJlxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnRyYWNrID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgIHNlbmRlck9yUmVjZWl2ZXIgPSB0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnRyYWNrID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgIHNlbmRlck9yUmVjZWl2ZXIgPSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXNlbmRlck9yUmVjZWl2ZXIpIHtcbiAgICAgICAgdGhyb3cgbWFrZUVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3InLCAnSW52YWxpZCBzZWxlY3Rvci4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kZXJPclJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgWydydHBTZW5kZXInLCAncnRwUmVjZWl2ZXInLCAnaWNlR2F0aGVyZXInLCAnaWNlVHJhbnNwb3J0JyxcbiAgICAgICAgICAnZHRsc1RyYW5zcG9ydCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXJbbWV0aG9kXSkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRyYW5zY2VpdmVyW21ldGhvZF0uZ2V0U3RhdHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFsbFN0YXRzKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgIGFsbFN0YXRzLmZvckVhY2goZnVuY3Rpb24oc3RhdHMpIHtcbiAgICAgICAgc3RhdHMuZm9yRWFjaChmdW5jdGlvbihzdGF0KSB7XG4gICAgICAgICAgcmVzdWx0cy5zZXQoc3RhdC5pZCwgc3RhdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcbiAgfTtcblxuICAvLyBmaXggbG93LWxldmVsIHN0YXQgbmFtZXMgYW5kIHJldHVybiBNYXAgaW5zdGVhZCBvZiBvYmplY3QuXG4gIHZhciBvcnRjT2JqZWN0cyA9IFsnUlRDUnRwU2VuZGVyJywgJ1JUQ1J0cFJlY2VpdmVyJywgJ1JUQ0ljZUdhdGhlcmVyJyxcbiAgICAnUlRDSWNlVHJhbnNwb3J0JywgJ1JUQ0R0bHNUcmFuc3BvcnQnXTtcbiAgb3J0Y09iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvcnRjT2JqZWN0TmFtZSkge1xuICAgIHZhciBvYmogPSB3aW5kb3dbb3J0Y09iamVjdE5hbWVdO1xuICAgIGlmIChvYmogJiYgb2JqLnByb3RvdHlwZSAmJiBvYmoucHJvdG90eXBlLmdldFN0YXRzKSB7XG4gICAgICB2YXIgbmF0aXZlR2V0c3RhdHMgPSBvYmoucHJvdG90eXBlLmdldFN0YXRzO1xuICAgICAgb2JqLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlR2V0c3RhdHMuYXBwbHkodGhpcylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24obmF0aXZlU3RhdHMpIHtcbiAgICAgICAgICB2YXIgbWFwU3RhdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgT2JqZWN0LmtleXMobmF0aXZlU3RhdHMpLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIG5hdGl2ZVN0YXRzW2lkXS50eXBlID0gZml4U3RhdHNUeXBlKG5hdGl2ZVN0YXRzW2lkXSk7XG4gICAgICAgICAgICBtYXBTdGF0cy5zZXQoaWQsIG5hdGl2ZVN0YXRzW2lkXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG1hcFN0YXRzO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBsZWdhY3kgY2FsbGJhY2sgc2hpbXMuIFNob3VsZCBiZSBtb3ZlZCB0byBhZGFwdGVyLmpzIHNvbWUgZGF5cy5cbiAgdmFyIG1ldGhvZHMgPSBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddO1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdmFyIG5hdGl2ZU1ldGhvZCA9IFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgIHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7IC8vIGxlZ2FjeVxuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFthcmd1bWVudHNbMl1dKVxuICAgICAgICAudGhlbihmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY3JpcHRpb25dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIFtlcnJvcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgbWV0aG9kcyA9IFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHZhciBuYXRpdmVNZXRob2QgPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICB0eXBlb2YgYXJnc1syXSA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBsZWdhY3lcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhcmdzWzJdLmFwcGx5KG51bGwsIFtlcnJvcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZ2V0U3RhdHMgaXMgc3BlY2lhbC4gSXQgZG9lc24ndCBoYXZlIGEgc3BlYyBsZWdhY3kgbWV0aG9kIHlldCB3ZSBzdXBwb3J0XG4gIC8vIGdldFN0YXRzKHNvbWV0aGluZywgY2IpIHdpdGhvdXQgZXJyb3IgY2FsbGJhY2tzLlxuICBbJ2dldFN0YXRzJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICB2YXIgbmF0aXZlTWV0aG9kID0gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gUlRDUGVlckNvbm5lY3Rpb247XG59O1xuIiwidmFyIGdyYW1tYXIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdjogW3tcbiAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgcmVnOiAvXihcXGQqKSQvXG4gIH1dLFxuICBvOiBbe1xuICAgIC8vIG89LSAyMDUxOCAwIElOIElQNCAyMDMuMC4xMTMuMVxuICAgIC8vIE5COiBzZXNzaW9uSWQgd2lsbCBiZSBhIFN0cmluZyBpbiBtb3N0IGNhc2VzIGJlY2F1c2UgaXQgaXMgaHVnZVxuICAgIG5hbWU6ICdvcmlnaW4nLFxuICAgIHJlZzogL14oXFxTKikgKFxcZCopIChcXGQqKSAoXFxTKikgSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3VzZXJuYW1lJywgJ3Nlc3Npb25JZCcsICdzZXNzaW9uVmVyc2lvbicsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xuICB9XSxcbiAgLy8gZGVmYXVsdCBwYXJzaW5nIG9mIHRoZXNlIG9ubHkgKHRob3VnaCBzb21lIG9mIHRoZXNlIGZlZWwgb3V0ZGF0ZWQpXG4gIHM6IFt7IG5hbWU6ICduYW1lJyB9XSxcbiAgaTogW3sgbmFtZTogJ2Rlc2NyaXB0aW9uJyB9XSxcbiAgdTogW3sgbmFtZTogJ3VyaScgfV0sXG4gIGU6IFt7IG5hbWU6ICdlbWFpbCcgfV0sXG4gIHA6IFt7IG5hbWU6ICdwaG9uZScgfV0sXG4gIHo6IFt7IG5hbWU6ICd0aW1lem9uZXMnIH1dLCAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li4uXG4gIHI6IFt7IG5hbWU6ICdyZXBlYXRzJyB9XSwgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWxzbyBiZSBwYXJzZWQgcHJvcGVybHlcbiAgLy8gazogW3t9XSwgLy8gb3V0ZGF0ZWQgdGhpbmcgaWdub3JlZFxuICB0OiBbe1xuICAgIC8vIHQ9MCAwXG4gICAgbmFtZTogJ3RpbWluZycsXG4gICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxuICAgIG5hbWVzOiBbJ3N0YXJ0JywgJ3N0b3AnXSxcbiAgICBmb3JtYXQ6ICclZCAlZCdcbiAgfV0sXG4gIGM6IFt7XG4gICAgLy8gYz1JTiBJUDQgMTAuNDcuMTk3LjI2XG4gICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxuICAgIHJlZzogL15JTiBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndmVyc2lvbicsICdpcCddLFxuICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXG4gIH1dLFxuICBiOiBbe1xuICAgIC8vIGI9QVM6NDAwMFxuICAgIHB1c2g6ICdiYW5kd2lkdGgnLFxuICAgIHJlZzogL14oVElBU3xBU3xDVHxSUnxSUyk6KFxcZCopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXG4gICAgZm9ybWF0OiAnJXM6JXMnXG4gIH1dLFxuICBtOiBbe1xuICAgIC8vIG09dmlkZW8gNTE3NDQgUlRQL0FWUCAxMjYgOTcgOTggMzQgMzFcbiAgICAvLyBOQjogc3BlY2lhbCAtIHB1c2hlcyB0byBzZXNzaW9uXG4gICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xuICAgIHJlZzogL14oXFx3KikgKFxcZCopIChbXFx3L10qKSg/OiAoLiopKT8vLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAncG9ydCcsICdwcm90b2NvbCcsICdwYXlsb2FkcyddLFxuICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xuICB9XSxcbiAgYTogW1xuICAgIHtcbiAgICAgIC8vIGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgICAgIHB1c2g6ICdydHAnLFxuICAgICAgcmVnOiAvXnJ0cG1hcDooXFxkKikgKFtcXHdcXC0uXSopKD86XFxzKlxcLyhcXGQqKSg/OlxccypcXC8oXFxTKikpPyk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uZW5jb2RpbmcpXG4gICAgICAgICAgPyAncnRwbWFwOiVkICVzLyVzLyVzJ1xuICAgICAgICAgIDogby5yYXRlXG4gICAgICAgICAgICA/ICdydHBtYXA6JWQgJXMvJXMnXG4gICAgICAgICAgICA6ICdydHBtYXA6JWQgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgICAvLyBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgICAgcHVzaDogJ2ZtdHAnLFxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbnRyb2w6c3RyZWFtaWQ9MFxuICAgICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgICAgcmVnOiAvXmNvbnRyb2w6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwOjY1MTc5IElOIElQNCAxOTMuODQuNzcuMTk0XG4gICAgICBuYW1lOiAncnRjcCcsXG4gICAgICByZWc6IC9ecnRjcDooXFxkKikoPzogKFxcUyopIElQKFxcZCkgKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsncG9ydCcsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLmFkZHJlc3MgIT0gbnVsbClcbiAgICAgICAgICA/ICdydGNwOiVkICVzIElQJWQgJXMnXG4gICAgICAgICAgOiAncnRjcDolZCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggdHJyLWludCAxMDBcbiAgICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSB0cnItaW50IChcXGQqKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdydGNwLWZiOiVkIHRyci1pbnQgJWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgICBwdXNoOiAncnRjcEZiJyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnN1YnR5cGUgIT0gbnVsbClcbiAgICAgICAgICA/ICdydGNwLWZiOiVzICVzICVzJ1xuICAgICAgICAgIDogJ3J0Y3AtZmI6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgICAvLyBhPWV4dG1hcDoxL3JlY3Zvbmx5IFVSSS1ncHMtc3RyaW5nXG4gICAgICAvLyBhPWV4dG1hcDozIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c21wdGUtdGMgMjVANjAwLzI0XG4gICAgICBwdXNoOiAnZXh0JyxcbiAgICAgIHJlZzogL15leHRtYXA6KFxcZCspKD86XFwvKFxcdyspKT8oPzogKHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQpKT8gKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJywgJ2RpcmVjdGlvbicsICdlbmNyeXB0LXVyaScsICd1cmknLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJ2V4dG1hcDolZCcgK1xuICAgICAgICAgIChvLmRpcmVjdGlvbiA/ICcvJXMnIDogJyV2JykgK1xuICAgICAgICAgIChvWydlbmNyeXB0LXVyaSddID8gJyAlcycgOiAnJXYnKSArXG4gICAgICAgICAgJyAlcycgK1xuICAgICAgICAgIChvLmNvbmZpZyA/ICcgJXMnIDogJycpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxuICAgICAgbmFtZTogJ2V4dG1hcEFsbG93TWl4ZWQnLFxuICAgICAgcmVnOiAvXihleHRtYXAtYWxsb3ctbWl4ZWQpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcbiAgICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgICAgcmVnOiAvXmNyeXB0bzooXFxkKikgKFtcXHdfXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsKVxuICAgICAgICAgID8gJ2NyeXB0bzolZCAlcyAlcyAlcydcbiAgICAgICAgICA6ICdjcnlwdG86JWQgJXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zZXR1cDphY3RwYXNzXG4gICAgICBuYW1lOiAnc2V0dXAnLFxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXG4gICAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29ubmVjdGlvbjpuZXdcbiAgICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXG4gICAgICByZWc6IC9eY29ubmVjdGlvbjoobmV3fGV4aXN0aW5nKS8sXG4gICAgICBmb3JtYXQ6ICdjb25uZWN0aW9uOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1taWQ6MVxuICAgICAgbmFtZTogJ21pZCcsXG4gICAgICByZWc6IC9ebWlkOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICdtaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgICAgbmFtZTogJ21zaWQnLFxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1wdGltZToyMFxuICAgICAgbmFtZTogJ3B0aW1lJyxcbiAgICAgIHJlZzogL15wdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAncHRpbWU6JWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1heHB0aW1lOjYwXG4gICAgICBuYW1lOiAnbWF4cHRpbWUnLFxuICAgICAgcmVnOiAvXm1heHB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdtYXhwdGltZTolZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2VuZHJlY3ZcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1saXRlXG4gICAgICBuYW1lOiAnaWNlbGl0ZScsXG4gICAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLXVmcmFnOkY3Z0lcbiAgICAgIG5hbWU6ICdpY2VVZnJhZycsXG4gICAgICByZWc6IC9eaWNlLXVmcmFnOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtdWZyYWc6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgICAgbmFtZTogJ2ljZVB3ZCcsXG4gICAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICAgIG5hbWU6ICdmaW5nZXJwcmludCcsXG4gICAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICAgIGZvcm1hdDogJ2ZpbmdlcnByaW50OiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jYW5kaWRhdGU6MCAxIFVEUCAyMTEzNjY3MzI3IDIwMy4wLjExMy4xIDU0NDAwIHR5cCBob3N0XG4gICAgICAvLyBhPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjIyOTgxNTYyMCAxIHRjcCAxNTE4MjgwNDQ3IDE5Mi4xNjguMTUwLjE5IDYwMDE3IHR5cCBob3N0IHRjcHR5cGUgYWN0aXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIHB1c2g6J2NhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcblxuICAgICAgICBzdHIgKz0gKG8ucmFkZHIgIT0gbnVsbCkgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcblxuICAgICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBzdHIgKz0gKG8udGNwdHlwZSAhPSBudWxsKSA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuXG4gICAgICAgIGlmIChvLmdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWlkJ10gIT0gbnVsbCkgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsKSA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWVuZC1vZi1jYW5kaWRhdGVzIChrZWVwIGFmdGVyIHRoZSBjYW5kaWRhdGVzIGxpbmUgZm9yIHJlYWRhYmlsaXR5KVxuICAgICAgbmFtZTogJ2VuZE9mQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgICAgbmFtZTogJ3JlbW90ZUNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICAgIG5hbWU6ICdpY2VPcHRpb25zJyxcbiAgICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXG4gICAgICBwdXNoOiAnc3NyY3MnLFxuICAgICAgcmVnOiAvXnNzcmM6KFxcZCopIChbXFx3Xy1dKikoPzo6KC4qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ3NzcmM6JWQnO1xuICAgICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnICVzJztcbiAgICAgICAgICBpZiAoby52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJzolcyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDIDEgMlxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcbiAgICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAgIC8vIHRva2VuLWNoYXIgPSAleDIxIC8gJXgyMy0yNyAvICV4MkEtMkIgLyAleDJELTJFIC8gJXgzMC0zOSAvICV4NDEtNUEgLyAleDVFLTdFXG4gICAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgICBmb3JtYXQ6ICdzc3JjLWdyb3VwOiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tc2lkLXNlbWFudGljOiBXTVMgSnZsYW01WDNTWDFPUDZwbjIweldvZ3ZhS0p6NUhqZjlPbmxWXG4gICAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcbiAgICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljJywgJ3Rva2VuJ10sXG4gICAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWdyb3VwOkJVTkRMRSBhdWRpbyB2aWRlb1xuICAgICAgcHVzaDogJ2dyb3VwcycsXG4gICAgICByZWc6IC9eZ3JvdXA6KFxcdyopICguKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdtaWRzJ10sXG4gICAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1tdXhcbiAgICAgIG5hbWU6ICdydGNwTXV4JyxcbiAgICAgIHJlZzogL14ocnRjcC1tdXgpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLXJzaXplXG4gICAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICAgIHJlZzogL14ocnRjcC1yc2l6ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNjdHBtYXA6NTAwMCB3ZWJydGMtZGF0YWNoYW5uZWwgMTAyNFxuICAgICAgbmFtZTogJ3NjdHBtYXAnLFxuICAgICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnc2N0cG1hcE51bWJlcicsICdhcHAnLCAnbWF4TWVzc2FnZVNpemUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLm1heE1lc3NhZ2VTaXplICE9IG51bGwpXG4gICAgICAgICAgPyAnc2N0cG1hcDolcyAlcyAlcydcbiAgICAgICAgICA6ICdzY3RwbWFwOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9eC1nb29nbGUtZmxhZzpjb25mZXJlbmNlXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ3gtZ29vZ2xlLWZsYWc6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJpZDoxIHNlbmQgbWF4LXdpZHRoPTEyODA7bWF4LWhlaWdodD03MjA7bWF4LWZwcz0zMDtkZXBlbmQ9MFxuICAgICAgcHVzaDogJ3JpZHMnLFxuICAgICAgcmVnOiAvXnJpZDooW1xcZFxcd10rKSAoXFx3KykoPzogKFtcXFN8IF0qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2RpcmVjdGlvbicsICdwYXJhbXMnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnBhcmFtcykgPyAncmlkOiVzICVzICVzJyA6ICdyaWQ6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgICAgLy8gYT1pbWFnZWF0dHI6MTAwIHJlY3YgW3g9MzIwLHk9MjQwXVxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvLyBhPWltYWdlYXR0cjo5N1xuICAgICAgICAnXmltYWdlYXR0cjooXFxcXGQrfFxcXFwqKScgK1xuICAgICAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgICAgICdbXFxcXHNcXFxcdF0rKHNlbmR8cmVjdilbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKScgK1xuICAgICAgICAvLyByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nXG4gICAgICApLFxuICAgICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZWF0dHI6JXMgJXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zaW11bGNhc3Q6c2VuZCAxLDIsMzt+NCx+NSByZWN2IDY7fjcsfjhcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3QnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvLyBhPXNpbXVsY2FzdDpcbiAgICAgICAgJ15zaW11bGNhc3Q6JyArXG4gICAgICAgIC8vIHNlbmQgMSwyLDM7fjQsfjVcbiAgICAgICAgJyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspJyArXG4gICAgICAgIC8vIHNwYWNlICsgcmVjdiA2O343LH44XG4gICAgICAgICcoPzpcXFxccz8oc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKSk/JyArXG4gICAgICAgIC8vIGVuZFxuICAgICAgICAnJCdcbiAgICAgICksXG4gICAgICBuYW1lczogWydkaXIxJywgJ2xpc3QxJywgJ2RpcjInLCAnbGlzdDInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdzaW11bGNhc3Q6JXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiByZWN2IHB0PTk3Ozk4IHNlbmQgcHQ9OTdcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICAgIHJlZzogL15zaW11bGNhc3Q6W1xcc1xcdF0rKFtcXFMrXFxzXFx0XSspJC8sXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI1XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyOS45N1xuICAgICAgbmFtZTogJ2ZyYW1lcmF0ZScsXG4gICAgICByZWc6IC9eZnJhbWVyYXRlOihcXGQrKD86JHxcXC5cXGQrKSkvLFxuICAgICAgZm9ybWF0OiAnZnJhbWVyYXRlOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNDU3MFxuICAgICAgLy8gYT1zb3VyY2UtZmlsdGVyOiBpbmNsIElOIElQNCAyMzkuNS4yLjMxIDEwLjEuMTUuNVxuICAgICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXG4gICAgICByZWc6IC9ec291cmNlLWZpbHRlcjogKihleGNsfGluY2wpIChcXFMqKSAoSVA0fElQNnxcXCopIChcXFMqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ2ZpbHRlck1vZGUnLCAnbmV0VHlwZScsICdhZGRyZXNzVHlwZXMnLCAnZGVzdEFkZHJlc3MnLCAnc3JjTGlzdCddLFxuICAgICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgICBuYW1lOiAnYnVuZGxlT25seScsXG4gICAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bGFiZWw6MVxuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIHJlZzogL15sYWJlbDooLispLyxcbiAgICAgIGZvcm1hdDogJ2xhYmVsOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XG4gICAgICBuYW1lOiAnc2N0cFBvcnQnLFxuICAgICAgcmVnOiAvXnNjdHAtcG9ydDooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNlxuICAgICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcbiAgICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnbWF4LW1lc3NhZ2Utc2l6ZTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9dHMtcmVmY2xrOnB0cD1JRUVFMTU4OC0yMDA4OjM5LUE3LTk0LUZGLUZFLTA3LUNCLUQwOjM3XG4gICAgICBwdXNoOid0c1JlZkNsb2NrcycsXG4gICAgICByZWc6IC9edHMtcmVmY2xrOihbXlxccz1dKikoPzo9KFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3RzLXJlZmNsazolcycgKyAoby5jbGtzcmNFeHQgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT1tZWRpYWNsazpkaXJlY3Q9OTYzMjE0NDI0XG4gICAgICBuYW1lOidtZWRpYUNsaycsXG4gICAgICByZWc6IC9ebWVkaWFjbGs6KD86aWQ9KFxcUyopKT8gKihbXlxccz1dKikoPzo9KFxcUyopKT8oPzogKnJhdGU9KFxcZCspXFwvKFxcZCspKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbWVkaWFDbG9ja05hbWUnLCAnbWVkaWFDbG9ja1ZhbHVlJywgJ3JhdGVOdW1lcmF0b3InLCAncmF0ZURlbm9taW5hdG9yJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnbWVkaWFjbGs6JztcbiAgICAgICAgc3RyICs9IChvLmlkICE9IG51bGwgPyAnaWQ9JXMgJXMnIDogJyV2JXMnKTtcbiAgICAgICAgc3RyICs9IChvLm1lZGlhQ2xvY2tWYWx1ZSAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICAgIHN0ciArPSAoby5yYXRlTnVtZXJhdG9yICE9IG51bGwgPyAnIHJhdGU9JXMnIDogJycpO1xuICAgICAgICBzdHIgKz0gKG8ucmF0ZURlbm9taW5hdG9yICE9IG51bGwgPyAnLyVzJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXG4gICAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgICAgcmVnOiAvXmtleXdkczooLispJC8sXG4gICAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbnRlbnQ6bWFpblxuICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgcmVnOiAvXmNvbnRlbnQ6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdjb250ZW50OiVzJ1xuICAgIH0sXG4gICAgLy8gQkZDUCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDU4M1xuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JjdHJsOmMtc1xuICAgICAgbmFtZTogJ2JmY3BGbG9vckN0cmwnLFxuICAgICAgcmVnOiAvXmZsb29yY3RybDooYy1vbmx5fHMtb25seXxjLXMpLyxcbiAgICAgIGZvcm1hdDogJ2Zsb29yY3RybDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29uZmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwQ29uZklkJyxcbiAgICAgIHJlZzogL15jb25maWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ2NvbmZpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9dXNlcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwVXNlcklkJyxcbiAgICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JpZDoxXG4gICAgICBuYW1lOiAnYmZjcEZsb29ySWQnLFxuICAgICAgcmVnOiAvXmZsb29yaWQ6KC4rKSAoPzptLXN0cmVhbXxtc3RybSk6KC4rKS8sXG4gICAgICBuYW1lczogWydpZCcsICdtU3RyZWFtJ10sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmlkOiVzIG1zdHJtOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYW55IGE9IHRoYXQgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpcyBrZXB0IHZlcmJhdGltIG9uIG1lZGlhLmludmFsaWRcbiAgICAgIHB1c2g6ICdpbnZhbGlkJyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ11cbiAgICB9XG4gIF1cbn07XG5cbi8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xuT2JqZWN0LmtleXMoZ3JhbW1hcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBvYmpzID0gZ3JhbW1hcltrZXldO1xuICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLnJlZykge1xuICAgICAgb2JqLnJlZyA9IC8oLiopLztcbiAgICB9XG4gICAgaWYgKCFvYmouZm9ybWF0KSB7XG4gICAgICBvYmouZm9ybWF0ID0gJyVzJztcbiAgICB9XG4gIH0pO1xufSk7XG4iLCJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciB3cml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpO1xuXG5leHBvcnRzLndyaXRlID0gd3JpdGVyO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlci5wYXJzZTtcbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBwYXJzZXIucGFyc2VQYXJhbXM7XG5leHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IHBhcnNlci5wYXJzZUZtdHBDb25maWc7IC8vIEFsaWFzIG9mIHBhcnNlUGFyYW1zKCkuXG5leHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBwYXJzZXIucGFyc2VQYXlsb2FkcztcbmV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gcGFyc2VyLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcztcbmV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBwYXJzZXIucGFyc2VJbWFnZUF0dHJpYnV0ZXM7XG5leHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IHBhcnNlci5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3Q7XG4iLCJ2YXIgdG9JbnRJZkludCA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XG59O1xuXG52YXIgYXR0YWNoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChtYXRjaCwgbG9jYXRpb24sIG5hbWVzLCByYXdOYW1lKSB7XG4gIGlmIChyYXdOYW1lICYmICFuYW1lcykge1xuICAgIGxvY2F0aW9uW3Jhd05hbWVdID0gdG9JbnRJZkludChtYXRjaFsxXSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKG1hdGNoW2krMV0gIT0gbnVsbCkge1xuICAgICAgICBsb2NhdGlvbltuYW1lc1tpXV0gPSB0b0ludElmSW50KG1hdGNoW2krMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHBhcnNlUmVnID0gZnVuY3Rpb24gKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpIHtcbiAgdmFyIG5lZWRzQmxhbmsgPSBvYmoubmFtZSAmJiBvYmoubmFtZXM7XG4gIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XG4gICAgbG9jYXRpb25bb2JqLnB1c2hdID0gW107XG4gIH1cbiAgZWxzZSBpZiAobmVlZHNCbGFuayAmJiAhbG9jYXRpb25bb2JqLm5hbWVdKSB7XG4gICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XG4gIH1cbiAgdmFyIGtleUxvY2F0aW9uID0gb2JqLnB1c2ggP1xuICAgIHt9IDogIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgbmVlZHNCbGFuayA/IGxvY2F0aW9uW29iai5uYW1lXSA6IGxvY2F0aW9uOyAvLyBvdGhlcndpc2UsIG5hbWVkIGxvY2F0aW9uIG9yIHJvb3RcblxuICBhdHRhY2hQcm9wZXJ0aWVzKGNvbnRlbnQubWF0Y2gob2JqLnJlZyksIGtleUxvY2F0aW9uLCBvYmoubmFtZXMsIG9iai5uYW1lKTtcblxuICBpZiAob2JqLnB1c2gpIHtcbiAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gIH1cbn07XG5cbnZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG52YXIgdmFsaWRMaW5lID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oW2Etel0pPSguKikvKTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzZHApIHtcbiAgdmFyIHNlc3Npb24gPSB7fVxuICAgICwgbWVkaWEgPSBbXVxuICAgICwgbG9jYXRpb24gPSBzZXNzaW9uOyAvLyBwb2ludHMgYXQgd2hlcmUgcHJvcGVydGllcyBnbyB1bmRlciAob25lIG9mIHRoZSBhYm92ZSlcblxuICAvLyBwYXJzZSBsaW5lcyB3ZSB1bmRlcnN0YW5kXG4gIHNkcC5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pLmZpbHRlcih2YWxpZExpbmUpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICB2YXIgdHlwZSA9IGxbMF07XG4gICAgdmFyIGNvbnRlbnQgPSBsLnNsaWNlKDIpO1xuICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgIG1lZGlhLnB1c2goe3J0cDogW10sIGZtdHA6IFtdfSk7XG4gICAgICBsb2NhdGlvbiA9IG1lZGlhW21lZGlhLmxlbmd0aC0xXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IChncmFtbWFyW3R5cGVdIHx8IFtdKS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgdmFyIG9iaiA9IGdyYW1tYXJbdHlwZV1bal07XG4gICAgICBpZiAob2JqLnJlZy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlZyhvYmosIGxvY2F0aW9uLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHNlc3Npb24ubWVkaWEgPSBtZWRpYTsgLy8gbGluayBpdCB1cFxuICByZXR1cm4gc2Vzc2lvbjtcbn07XG5cbnZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XG4gIHZhciBzID0gZXhwci5zcGxpdCgvPSguKykvLCAyKTtcbiAgaWYgKHMubGVuZ3RoID09PSAyKSB7XG4gICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcbiAgfSBlbHNlIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBleHByLmxlbmd0aCA+IDEpIHtcbiAgICBhY2Nbc1swXV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn07XG5cbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLztcXHM/LykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xufTtcblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbmV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cy5wYXJzZVBhcmFtcztcblxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnRvU3RyaW5nKCkuc3BsaXQoJyAnKS5tYXAoTnVtYmVyKTtcbn07XG5cbmV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJyAnKS5tYXAodG9JbnRJZkludCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgY29tcG9uZW50OiBwYXJ0c1tpXSxcbiAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICBwb3J0OiBwYXJ0c1tpICsgMl1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5zdWJzdHJpbmcoMSwgaXRlbS5sZW5ndGgtMSkuc3BsaXQoJywnKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgdmFyIHNjaWQsIHBhdXNlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZm9ybWF0WzBdICE9PSAnficpIHtcbiAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdC5zdWJzdHJpbmcoMSwgZm9ybWF0Lmxlbmd0aCkpO1xuICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2lkOiBzY2lkLFxuICAgICAgICBwYXVzZWQ6IHBhdXNlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59O1xuIiwidmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcblxuLy8gY3VzdG9taXplZCB1dGlsLmZvcm1hdCAtIGRpc2NhcmRzIGV4Y2VzcyBhcmd1bWVudHMgYW5kIGNhbiB2b2lkIG1pZGRsZSBvbmVzXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2R2JV0vZztcbnZhciBmb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0U3RyKSB7XG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgcmV0dXJuIGZvcm1hdFN0ci5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgIHJldHVybiB4OyAvLyBtaXNzaW5nIGFyZ3VtZW50XG4gICAgfVxuICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgIGkgKz0gMTtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICBjYXNlICclJSc6XG4gICAgICByZXR1cm4gJyUnO1xuICAgIGNhc2UgJyVzJzpcbiAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICBjYXNlICclZCc6XG4gICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgY2FzZSAnJXYnOlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSk7XG4gIC8vIE5COiB3ZSBkaXNjYXJkIGV4Y2VzcyBhcmd1bWVudHMgLSB0aGV5IGFyZSB0eXBpY2FsbHkgdW5kZWZpbmVkIGZyb20gbWFrZUxpbmVcbn07XG5cbnZhciBtYWtlTGluZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmosIGxvY2F0aW9uKSB7XG4gIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gP1xuICAgIChvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pKSA6XG4gICAgb2JqLmZvcm1hdDtcblxuICB2YXIgYXJncyA9IFt0eXBlICsgJz0nICsgc3RyXTtcbiAgaWYgKG9iai5uYW1lcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbiA9IG9iai5uYW1lc1tpXTtcbiAgICAgIGlmIChvYmoubmFtZSkge1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdW25dKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBmb3IgbUxpbmUgYW5kIHB1c2ggYXR0cmlidXRlc1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xuICB9XG4gIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG59O1xuXG4vLyBSRkMgc3BlY2lmaWVkIG9yZGVyXG4vLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxudmFyIGRlZmF1bHRPdXRlck9yZGVyID0gW1xuICAndicsICdvJywgJ3MnLCAnaScsXG4gICd1JywgJ2UnLCAncCcsICdjJyxcbiAgJ2InLCAndCcsICdyJywgJ3onLCAnYSdcbl07XG52YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XG4gIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcbiAgfVxuICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxuICB9XG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xuICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBvdXRlck9yZGVyID0gb3B0cy5vdXRlck9yZGVyIHx8IGRlZmF1bHRPdXRlck9yZGVyO1xuICB2YXIgaW5uZXJPcmRlciA9IG9wdHMuaW5uZXJPcmRlciB8fCBkZWZhdWx0SW5uZXJPcmRlcjtcbiAgdmFyIHNkcCA9IFtdO1xuXG4gIC8vIGxvb3AgdGhyb3VnaCBvdXRlck9yZGVyIGZvciBtYXRjaGluZyBwcm9wZXJ0aWVzIG9uIHNlc3Npb25cbiAgb3V0ZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmIChvYmoubmFtZSBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBzZXNzaW9uKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmoucHVzaCBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB0aGVuIGZvciBlYWNoIG1lZGlhIGxpbmUsIGZvbGxvdyB0aGUgaW5uZXJPcmRlclxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XG5cbiAgICBpbm5lck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoubmFtZSBpbiBtTGluZSAmJiBtTGluZVtvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgbUxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoucHVzaCBpbiBtTGluZSAmJiBtTGluZVtvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICAgIG1MaW5lW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xufTtcbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbnZhciBTRFBVdGlscyA9IHt9O1xuXG4vLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cbi8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG5TRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxMCk7XG59O1xuXG4vLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cblNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuLy8gU3BsaXRzIFNEUCBpbnRvIGxpbmVzLCBkZWFsaW5nIHdpdGggYm90aCBDUkxGIGFuZCBMRi5cblNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS50cmltKCk7XG4gIH0pO1xufTtcbi8vIFNwbGl0cyBTRFAgaW50byBzZXNzaW9ucGFydCBhbmQgbWVkaWFzZWN0aW9ucy4gRW5zdXJlcyBDUkxGLlxuU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdmFyIHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbihwYXJ0LCBpbmRleCkge1xuICAgIHJldHVybiAoaW5kZXggPiAwID8gJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJztcbiAgfSk7XG59O1xuXG4vLyByZXR1cm5zIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uLlxuU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gIHJldHVybiBzZWN0aW9ucyAmJiBzZWN0aW9uc1swXTtcbn07XG5cbi8vIHJldHVybnMgdGhlIGluZGl2aWR1YWwgbWVkaWEgc2VjdGlvbnMuXG5TRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICBzZWN0aW9ucy5zaGlmdCgpO1xuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDA7XG4gIH0pO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG5TRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzO1xuICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICBpZiAobGluZS5pbmRleE9mKCdhPWNhbmRpZGF0ZTonKSA9PT0gMCkge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTIpLnNwbGl0KCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGUgPSB7XG4gICAgZm91bmRhdGlvbjogcGFydHNbMF0sXG4gICAgY29tcG9uZW50OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgIHByaW9yaXR5OiBwYXJzZUludChwYXJ0c1szXSwgMTApLFxuICAgIGlwOiBwYXJ0c1s0XSxcbiAgICBhZGRyZXNzOiBwYXJ0c1s0XSwgLy8gYWRkcmVzcyBpcyBhbiBhbGlhcyBmb3IgaXAuXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcbiAgICAvLyBza2lwIHBhcnRzWzZdID09ICd0eXAnXG4gICAgdHlwZTogcGFydHNbN11cbiAgfTtcblxuICBmb3IgKHZhciBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc3dpdGNoIChwYXJ0c1tpXSkge1xuICAgICAgY2FzZSAncmFkZHInOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncnBvcnQnOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0Y3B0eXBlJzpcbiAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWZyYWcnOlxuICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYWJpbGl0eS5cbiAgICAgICAgY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnXG4gICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlO1xufTtcblxuLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIHZhciBzZHAgPSBbXTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmZvdW5kYXRpb24pO1xuICBzZHAucHVzaChjYW5kaWRhdGUuY29tcG9uZW50KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgdmFyIHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgc2RwLnB1c2goJ3R5cCcpO1xuICBzZHAucHVzaCh0eXBlKTtcbiAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiZcbiAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCkge1xuICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XG4gICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUgJiYgY2FuZGlkYXRlLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICd0Y3AnKSB7XG4gICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xuICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZyk7XG4gIH1cbiAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbi8vIGE9aWNlLW9wdGlvbnM6Zm9vIGJhclxuU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24obGluZSkge1xuICByZXR1cm4gbGluZS5zdWJzdHIoMTQpLnNwbGl0KCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYW4gcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuU0RQVXRpbHMucGFyc2VSdHBNYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHZhciBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSAvLyB3YXM6IGlkXG4gIH07XG5cbiAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuXG4gIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XG4gIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICBwYXJzZWQuY2hhbm5lbHMgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogMTtcbiAgLy8gbGVnYWN5IGFsaWFzLCBnb3QgcmVuYW1lZCBiYWNrIHRvIGNoYW5uZWxzIGluIE9SVEMuXG4gIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnNlZC5jaGFubmVscztcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlIGFuIGE9cnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3Jcbi8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwTWFwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICB2YXIgY2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscyB8fCBjb2RlYy5udW1DaGFubmVscyB8fCAxO1xuICByZXR1cm4gJ2E9cnRwbWFwOicgKyBwdCArICcgJyArIGNvZGVjLm5hbWUgKyAnLycgKyBjb2RlYy5jbG9ja1JhdGUgK1xuICAgICAgKGNoYW5uZWxzICE9PSAxID8gJy8nICsgY2hhbm5lbHMgOiAnJykgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhbiBhPWV4dG1hcCBsaW5lIChoZWFkZXJleHRlbnNpb24gZnJvbSBSRkMgNTI4NSkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG5TRFBVdGlscy5wYXJzZUV4dG1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZXMgYT1leHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3Jcbi8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cblNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24oaGVhZGVyRXh0ZW5zaW9uKSB7XG4gIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnXG4gICAgICAgID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvblxuICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYW4gZnRtcCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga3Y7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgIGt2ID0gcGFydHNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGVzIGFuIGE9ZnRtcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlRm10cCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSkge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSArICc9JyArIGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBsaW5lO1xufTtcblxuLy8gUGFyc2VzIGFuIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpXG4gIH07XG59O1xuLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgdmFyIGxpbmVzID0gJyc7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XG4gICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZnVuY3Rpb24oZmIpIHtcbiAgICAgIGxpbmVzICs9ICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnICsgZmIudHlwZSArXG4gICAgICAoZmIucGFyYW1ldGVyICYmIGZiLnBhcmFtZXRlci5sZW5ndGggPyAnICcgKyBmYi5wYXJhbWV0ZXIgOiAnJykgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBsaW5lcztcbn07XG5cbi8vIFBhcnNlcyBhbiBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG5TRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHNwID0gbGluZS5pbmRleE9mKCcgJyk7XG4gIHZhciBwYXJ0cyA9IHtcbiAgICBzc3JjOiBwYXJzZUludChsaW5lLnN1YnN0cig3LCBzcCAtIDcpLCAxMClcbiAgfTtcbiAgdmFyIGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICBpZiAoY29sb24gPiAtMSkge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyKHNwICsgMSwgY29sb24gLSBzcCAtIDEpO1xuICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHIoY29sb24gKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cihzcCArIDEpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn07XG5cblNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cigxMykuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgc3NyY3M6IHBhcnRzLm1hcChmdW5jdGlvbihzc3JjKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoc3NyYywgMTApO1xuICAgIH0pXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4vLyByZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cblNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XG4gIGlmIChtaWQpIHtcbiAgICByZXR1cm4gbWlkLnN1YnN0cig2KTtcbiAgfVxufTtcblxuU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMTQpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAvLyBhbGdvcml0aG0gaXMgY2FzZS1zZW5zaXRpdmUgaW4gRWRnZS5cbiAgICB2YWx1ZTogcGFydHNbMV1cbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cblNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1maW5nZXJwcmludDonKTtcbiAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZS5cbiAgLy8gTm90ZTI6ICdhbGdvcml0aG0nIGlzIG5vdCBjYXNlIHNlbnNpdGl2ZSBleGNlcHQgaW4gRWRnZS5cbiAgcmV0dXJuIHtcbiAgICByb2xlOiAnYXV0bycsXG4gICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludClcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMsIHNldHVwVHlwZSkge1xuICB2YXIgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnVuY3Rpb24oZnApIHtcbiAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gIH0pO1xuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIGE9Y3J5cHRvIGxpbmVzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNkaWN0aW9uYXJ5LXJ0Y3NydHBzZGVzcGFyYW1ldGVycy1tZW1iZXJzXG5TRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGNyeXB0b1N1aXRlOiBwYXJ0c1sxXSxcbiAgICBrZXlQYXJhbXM6IHBhcnRzWzJdLFxuICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpLFxuICB9O1xufTtcblxuU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICByZXR1cm4gJ2E9Y3J5cHRvOicgKyBwYXJhbWV0ZXJzLnRhZyArICcgJyArXG4gICAgcGFyYW1ldGVycy5jcnlwdG9TdWl0ZSArICcgJyArXG4gICAgKHR5cGVvZiBwYXJhbWV0ZXJzLmtleVBhcmFtcyA9PT0gJ29iamVjdCdcbiAgICAgID8gU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMocGFyYW1ldGVycy5rZXlQYXJhbXMpXG4gICAgICA6IHBhcmFtZXRlcnMua2V5UGFyYW1zKSArXG4gICAgKHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcyA/ICcgJyArIHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcy5qb2luKCcgJykgOiAnJykgK1xuICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI3J0Y3NydHBrZXlwYXJhbSpcblNEUFV0aWxzLnBhcnNlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24oa2V5UGFyYW1zKSB7XG4gIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cig3KS5zcGxpdCgnfCcpO1xuICByZXR1cm4ge1xuICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWQsXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6J1xuICAgICsga2V5UGFyYW1zLmtleVNhbHQgK1xuICAgIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgK1xuICAgIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA6ICcnKTtcbn07XG5cbi8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtdGVycy5cblNEUFV0aWxzLmdldENyeXB0b1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWNyeXB0bzonKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xufTtcblxuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIHVmcmFnID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9aWNlLXVmcmFnOicpWzBdO1xuICB2YXIgcHdkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9aWNlLXB3ZDonKVswXTtcbiAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWVGcmFnbWVudDogdWZyYWcuc3Vic3RyKDEyKSxcbiAgICBwYXNzd29yZDogcHdkLnN1YnN0cigxMCksXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gJ2E9aWNlLXVmcmFnOicgKyBwYXJhbXMudXNlcm5hbWVGcmFnbWVudCArICdcXHJcXG4nICtcbiAgICAgICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBkZXNjcmlwdGlvbiA9IHtcbiAgICBjb2RlY3M6IFtdLFxuICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgIGZlY01lY2hhbmlzbXM6IFtdLFxuICAgIHJ0Y3A6IFtdXG4gIH07XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgdmFyIHB0ID0gbWxpbmVbaV07XG4gICAgdmFyIHJ0cG1hcGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRwbWFwOicgKyBwdCArICcgJylbMF07XG4gICAgaWYgKHJ0cG1hcGxpbmUpIHtcbiAgICAgIHZhciBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgdmFyIGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOicgKyBwdCArICcgJylcbiAgICAgICAgLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cbiAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ1JFRCc6XG4gICAgICAgIGNhc2UgJ1VMUEZFQyc6XG4gICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIG9ubHkgUkVEIGFuZCBVTFBGRUMgYXJlIHJlY29nbml6ZWQgYXMgRkVDIG1lY2hhbmlzbXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIGRlc2NyaXB0aW9uLmhlYWRlckV4dGVuc2lvbnMucHVzaChTRFBVdGlscy5wYXJzZUV4dG1hcChsaW5lKSk7XG4gIH0pO1xuICAvLyBGSVhNRTogcGFyc2UgcnRjcC5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufTtcblxuLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xuLy8gcGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihraW5kLCBjYXBzKSB7XG4gIHZhciBzZHAgPSAnJztcblxuICAvLyBCdWlsZCB0aGUgbWxpbmUuXG4gIHNkcCArPSAnbT0nICsga2luZCArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXG4gIHNkcCArPSAnIFVEUC9UTFMvUlRQL1NBVlBGICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuXG4gIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gIHNkcCArPSAnYT1ydGNwOjkgSU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuXG4gIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICB9KTtcbiAgdmFyIG1heHB0aW1lID0gMDtcbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICBtYXhwdGltZSA9IGNvZGVjLm1heHB0aW1lO1xuICAgIH1cbiAgfSk7XG4gIGlmIChtYXhwdGltZSA+IDApIHtcbiAgICBzZHAgKz0gJ2E9bWF4cHRpbWU6JyArIG1heHB0aW1lICsgJ1xcclxcbic7XG4gIH1cbiAgc2RwICs9ICdhPXJ0Y3AtbXV4XFxyXFxuJztcblxuICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgY2Fwcy5oZWFkZXJFeHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgICB9KTtcbiAgfVxuICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2Zcbi8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgdmFyIGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBoYXNSZWQgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1JFRCcpICE9PSAtMTtcbiAgdmFyIGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgdmFyIHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICByZXR1cm4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnO1xuICAgIH0pO1xuICB2YXIgcHJpbWFyeVNzcmMgPSBzc3Jjcy5sZW5ndGggPiAwICYmIHNzcmNzWzBdLnNzcmM7XG4gIHZhciBzZWNvbmRhcnlTc3JjO1xuXG4gIHZhciBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKVxuICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMTcpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhcnQsIDEwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgfVxuXG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgIHZhciBlbmNQYXJhbSA9IHtcbiAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMClcbiAgICAgIH07XG4gICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICBlbmNQYXJhbS5ydHggPSB7c3NyYzogc2Vjb25kYXJ5U3NyY307XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJ1xuICAgICAgICB9O1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGggPT09IDAgJiYgcHJpbWFyeVNzcmMpIHtcbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICBzc3JjOiBwcmltYXJ5U3NyY1xuICAgIH0pO1xuICB9XG5cbiAgLy8gd2Ugc3VwcG9ydCBib3RoIGI9QVMgYW5kIGI9VElBUyBidXQgaW50ZXJwcmV0IEFTIGFzIFRJQVMuXG4gIHZhciBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xuICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1USUFTOicpID09PSAwKSB7XG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyKDcpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgLy8gdXNlIGZvcm11bGEgZnJvbSBKU0VQIHRvIGNvbnZlcnQgYj1BUyB0byBUSUFTIHZhbHVlLlxuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cig1KSwgMTApICogMTAwMCAqIDAuOTVcbiAgICAgICAgICAtICg1MCAqIDQwICogOCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xufTtcblxuLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXG5TRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhIHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXG4gIC8vIFNTUkNzLlxuICB2YXIgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgIH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnO1xuICAgIH0pWzBdO1xuICBpZiAocmVtb3RlU3NyYykge1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICB9XG5cbiAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgdmFyIHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgdmFyIG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcbiAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG5cbiAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xufTtcblxuLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cblNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgcGFydHM7XG4gIHZhciBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xuICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyKDcpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG4gIHZhciBwbGFuQiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgIH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbihtc2lkUGFydHMpIHtcbiAgICAgIHJldHVybiBtc2lkUGFydHMuYXR0cmlidXRlID09PSAnbXNpZCc7XG4gICAgfSk7XG4gIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XG4gICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gcGFyc2VzIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IGZpcnN0IGFuZCBmYWxscyBiYWNrXG4vLyB0byBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNVxuU0RQVXRpbHMucGFyc2VTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIG1saW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gIHZhciBtYXhNZXNzYWdlU2l6ZTtcbiAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cigxOSksIDEwKTtcbiAgfVxuICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgfVxuICB2YXIgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcbiAgaWYgKHNjdHBQb3J0Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyKDEyKSwgMTApLFxuICAgICAgcHJvdG9jb2w6IG1saW5lLmZtdCxcbiAgICAgIG1heE1lc3NhZ2VTaXplOiBtYXhNZXNzYWdlU2l6ZVxuICAgIH07XG4gIH1cbiAgdmFyIHNjdHBNYXBMaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKTtcbiAgaWYgKHNjdHBNYXBMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBhcnRzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpWzBdXG4gICAgICAuc3Vic3RyKDEwKVxuICAgICAgLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICBtYXhNZXNzYWdlU2l6ZTogbWF4TWVzc2FnZVNpemVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4vLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxuLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbi8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcblNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWEsIHNjdHApIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJ1xuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsXG4gICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsXG4gICAgICAnYT1zY3RwbWFwOicgKyBzY3RwLnBvcnQgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJyA2NTUzNVxcclxcbidcbiAgICBdO1xuICB9XG4gIGlmIChzY3RwLm1heE1lc3NhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQucHVzaCgnYT1tYXgtbWVzc2FnZS1zaXplOicgKyBzY3RwLm1heE1lc3NhZ2VTaXplICsgJ1xcclxcbicpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcbi8vIHJlY29tbWVuZHMgdXNpbmcgYSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gK3ZlIDY0LWJpdCB2YWx1ZVxuLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXG5TRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMSk7XG59O1xuXG4vLyBXcml0ZSBib2lsZGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcbi8vIHNlc3NJZCBhcmd1bWVudCBpcyBvcHRpb25hbCAtIGlmIG5vdCBzdXBwbGllZCBpdCB3aWxsXG4vLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcbi8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXG4vLyBzZXNzVXNlciBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RoaXNpc2FkYXB0ZXJvcnRjJ1xuU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbihzZXNzSWQsIHNlc3NWZXIsIHNlc3NVc2VyKSB7XG4gIHZhciBzZXNzaW9uSWQ7XG4gIHZhciB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XG4gIGlmIChzZXNzSWQpIHtcbiAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gIH0gZWxzZSB7XG4gICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgfVxuICB2YXIgdXNlciA9IHNlc3NVc2VyIHx8ICd0aGlzaXNhZGFwdGVyb3J0Yyc7XG4gIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICByZXR1cm4gJ3Y9MFxcclxcbicgK1xuICAgICAgJ289JyArIHVzZXIgKyAnICcgKyBzZXNzaW9uSWQgKyAnICcgKyB2ZXJzaW9uICtcbiAgICAgICAgJyBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArXG4gICAgICAncz0tXFxyXFxuJyArXG4gICAgICAndD0wIDBcXHJcXG4nO1xufTtcblxuU0RQVXRpbHMud3JpdGVNZWRpYVNlY3Rpb24gPSBmdW5jdGlvbih0cmFuc2NlaXZlciwgY2FwcywgdHlwZSwgc3RyZWFtKSB7XG4gIHZhciBzZHAgPSBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uKHRyYW5zY2VpdmVyLmtpbmQsIGNhcHMpO1xuXG4gIC8vIE1hcCBJQ0UgcGFyYW1ldGVycyAodWZyYWcsIHB3ZCkgdG8gU0RQLlxuICBzZHAgKz0gU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzKFxuICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLmdldExvY2FsUGFyYW1ldGVycygpKTtcblxuICAvLyBNYXAgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgc2RwICs9IFNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMoXG4gICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5nZXRMb2NhbFBhcmFtZXRlcnMoKSxcbiAgICB0eXBlID09PSAnb2ZmZXInID8gJ2FjdHBhc3MnIDogJ2FjdGl2ZScpO1xuXG4gIHNkcCArPSAnYT1taWQ6JyArIHRyYW5zY2VpdmVyLm1pZCArICdcXHJcXG4nO1xuXG4gIGlmICh0cmFuc2NlaXZlci5kaXJlY3Rpb24pIHtcbiAgICBzZHAgKz0gJ2E9JyArIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiArICdcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1zZW5kcmVjdlxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRvbmx5XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1yZWN2b25seVxcclxcbic7XG4gIH0gZWxzZSB7XG4gICAgc2RwICs9ICdhPWluYWN0aXZlXFxyXFxuJztcbiAgfVxuXG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAvLyBzcGVjLlxuICAgIHZhciBtc2lkID0gJ21zaWQ6JyArIHN0cmVhbS5pZCArICcgJyArXG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci50cmFjay5pZCArICdcXHJcXG4nO1xuICAgIHNkcCArPSAnYT0nICsgbXNpZDtcblxuICAgIC8vIGZvciBDaHJvbWUuXG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArXG4gICAgICAgICcgJyArIG1zaWQ7XG4gICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJyAnICsgbXNpZDtcbiAgICAgIHNkcCArPSAnYT1zc3JjLWdyb3VwOkZJRCAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgKyAnICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuICAvLyBGSVhNRTogdGhpcyBzaG91bGQgYmUgd3JpdHRlbiBieSB3cml0ZVJ0cERlc2NyaXB0aW9uLlxuICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAobGluZXNbaV0pIHtcbiAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICBjYXNlICdhPXJlY3Zvbmx5JzpcbiAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyKDIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUU6IFdoYXQgc2hvdWxkIGhhcHBlbiBoZXJlP1xuICAgIH1cbiAgfVxuICBpZiAoc2Vzc2lvbnBhcnQpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgfVxuICByZXR1cm4gJ3NlbmRyZWN2Jztcbn07XG5cblNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cblNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgcGFydHMgPSBsaW5lc1swXS5zdWJzdHIoMikuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBwYXJ0c1swXSxcbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXSxcbiAgICBmbXQ6IHBhcnRzLnNsaWNlKDMpLmpvaW4oJyAnKVxuICB9O1xufTtcblxuU0RQVXRpbHMucGFyc2VPTGluZSA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ289JylbMF07XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzVdXG4gIH07XG59O1xuXG4vLyBhIHZlcnkgbmFpdmUgaW50ZXJwcmV0YXRpb24gb2YgYSB2YWxpZCBTRFAuXG5TRFBVdGlscy5pc1ZhbGlkU0RQID0gZnVuY3Rpb24oYmxvYikge1xuICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFja29mZiA9IHZvaWQgMDtcbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gICAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gICAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cbmV4cG9ydHMuQmFja29mZiA9IEJhY2tvZmY7XG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gICAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgICAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uIChtaW4pIHtcbiAgICB0aGlzLm1zID0gbWluO1xufTtcbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24gKG1heCkge1xuICAgIHRoaXMubWF4ID0gbWF4O1xufTtcbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbiAoaml0dGVyKSB7XG4gICAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmNvbm5lY3QgPSBleHBvcnRzLmlvID0gZXhwb3J0cy5Tb2NrZXQgPSBleHBvcnRzLk1hbmFnZXIgPSBleHBvcnRzLnByb3RvY29sID0gdm9pZCAwO1xuY29uc3QgdXJsX2pzXzEgPSByZXF1aXJlKFwiLi91cmwuanNcIik7XG5jb25zdCBtYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi9tYW5hZ2VyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFuYWdlcl9qc18xLk1hbmFnZXI7IH0gfSk7XG5jb25zdCBzb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3NvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0X2pzXzEuU29ja2V0OyB9IH0pO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdChcInNvY2tldC5pby1jbGllbnRcIik7IC8vIGRlYnVnKClcbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgdXJpID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBjb25zdCBwYXJzZWQgPSB1cmxfanNfMS51cmwodXJpLCBvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gICAgY29uc3QgaWQgPSBwYXJzZWQuaWQ7XG4gICAgY29uc3QgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICAgIGNvbnN0IHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF1bXCJuc3BzXCJdO1xuICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8XG4gICAgICAgIG9wdHNbXCJmb3JjZSBuZXcgY29ubmVjdGlvblwiXSB8fFxuICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHxcbiAgICAgICAgc2FtZU5hbWVzcGFjZTtcbiAgICBsZXQgaW87XG4gICAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgZGVidWcoXCJpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzXCIsIHNvdXJjZSk7XG4gICAgICAgIGlvID0gbmV3IG1hbmFnZXJfanNfMS5NYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgICAgICAgZGVidWcoXCJuZXcgaW8gaW5zdGFuY2UgZm9yICVzXCIsIHNvdXJjZSk7XG4gICAgICAgICAgICBjYWNoZVtpZF0gPSBuZXcgbWFuYWdlcl9qc18xLk1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpbyA9IGNhY2hlW2lkXTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgICAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkLnF1ZXJ5S2V5O1xuICAgIH1cbiAgICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cbmV4cG9ydHMuaW8gPSBsb29rdXA7XG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5leHBvcnRzLmRlZmF1bHQgPSBsb29rdXA7XG4vLyBzbyB0aGF0IFwibG9va3VwXCIgY2FuIGJlIHVzZWQgYm90aCBhcyBhIGZ1bmN0aW9uIChlLmcuIGBpbyguLi4pYCkgYW5kIGFzIGFcbi8vIG5hbWVzcGFjZSAoZS5nLiBgaW8uY29ubmVjdCguLi4pYCksIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5PYmplY3QuYXNzaWduKGxvb2t1cCwge1xuICAgIE1hbmFnZXI6IG1hbmFnZXJfanNfMS5NYW5hZ2VyLFxuICAgIFNvY2tldDogc29ja2V0X2pzXzEuU29ja2V0LFxuICAgIGlvOiBsb29rdXAsXG4gICAgY29ubmVjdDogbG9va3VwLFxufSk7XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm90b2NvbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0X2lvX3BhcnNlcl8xLnByb3RvY29sOyB9IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb2t1cDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBlbmdpbmVfaW9fY2xpZW50XzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLWNsaWVudFwiKTtcbmNvbnN0IHNvY2tldF9qc18xID0gcmVxdWlyZShcIi4vc29ja2V0LmpzXCIpO1xuY29uc3QgcGFyc2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpKTtcbmNvbnN0IG9uX2pzXzEgPSByZXF1aXJlKFwiLi9vbi5qc1wiKTtcbmNvbnN0IGJhY2tvMl9qc18xID0gcmVxdWlyZShcIi4vY29udHJpYi9iYWNrbzIuanNcIik7XG5jb25zdCBjb21wb25lbnRfZW1pdHRlcl8xID0gcmVxdWlyZShcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7IC8vIGRlYnVnKClcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KFwic29ja2V0LmlvLWNsaWVudDptYW5hZ2VyXCIpOyAvLyBkZWJ1ZygpXG5jbGFzcyBNYW5hZ2VyIGV4dGVuZHMgY29tcG9uZW50X2VtaXR0ZXJfMS5FbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5zcHMgPSB7fTtcbiAgICAgICAgdGhpcy5zdWJzID0gW107XG4gICAgICAgIGlmICh1cmkgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVyaSkge1xuICAgICAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IFwiL3NvY2tldC5pb1wiO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBlbmdpbmVfaW9fY2xpZW50XzEuaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgICAgICAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKChfYSA9IG9wdHMucmFuZG9taXphdGlvbkZhY3RvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC41KTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvMl9qc18xLkJhY2tvZmYoe1xuICAgICAgICAgICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgICAgICAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICAgICAgICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgY29uc3QgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuX2F1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvQ29ubmVjdClcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb24odikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb25BdHRlbXB0cyh2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkRlbGF5KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldE1pbih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJhbmRvbWl6YXRpb25GYWN0b3Iodikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgICAgICAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEppdHRlcih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldE1heCh2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRpbWVvdXQodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAgICAgKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbWF5YmVSZWNvbm5lY3RPbk9wZW4oKSB7XG4gICAgICAgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9yZWNvbm5lY3RpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBvcHRpb25hbCwgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgb3Blbihmbikge1xuICAgICAgICBkZWJ1ZyhcInJlYWR5U3RhdGUgJXNcIiwgdGhpcy5fcmVhZHlTdGF0ZSk7XG4gICAgICAgIGlmICh+dGhpcy5fcmVhZHlTdGF0ZS5pbmRleE9mKFwib3BlblwiKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBkZWJ1ZyhcIm9wZW5pbmcgJXNcIiwgdGhpcy51cmkpO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyBlbmdpbmVfaW9fY2xpZW50XzEuU29ja2V0KHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIjtcbiAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIC8vIGVtaXQgYG9wZW5gXG4gICAgICAgIGNvbnN0IG9wZW5TdWJEZXN0cm95ID0gb25fanNfMS5vbihzb2NrZXQsIFwib3BlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9ub3BlbigpO1xuICAgICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVtaXQgYGVycm9yYFxuICAgICAgICBjb25zdCBlcnJvclN1YiA9IG9uX2pzXzEub24oc29ja2V0LCBcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3JcIik7XG4gICAgICAgICAgICBzZWxmLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHNlbGYuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZFwiLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb3BlblN1YkRlc3Ryb3koKTsgLy8gcHJldmVudHMgYSByYWNlIGNvbmRpdGlvbiB3aXRoIHRoZSAnb3BlbicgZXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB0aW1lclxuICAgICAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkXCIsIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIG9wZW5TdWJEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKGZ1bmN0aW9uIHN1YkRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWJEZXN0cm95KTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIG9wZW4oKVxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNvbm5lY3QoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbihmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbm9wZW4oKSB7XG4gICAgICAgIGRlYnVnKFwib3BlblwiKTtcbiAgICAgICAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIC8vIG1hcmsgYXMgb3BlblxuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICAgICAgLy8gYWRkIG5ldyBzdWJzXG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICAgICAgICB0aGlzLnN1YnMucHVzaChvbl9qc18xLm9uKHNvY2tldCwgXCJwaW5nXCIsIHRoaXMub25waW5nLmJpbmQodGhpcykpLCBvbl9qc18xLm9uKHNvY2tldCwgXCJkYXRhXCIsIHRoaXMub25kYXRhLmJpbmQodGhpcykpLCBvbl9qc18xLm9uKHNvY2tldCwgXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSksIG9uX2pzXzEub24oc29ja2V0LCBcImNsb3NlXCIsIHRoaXMub25jbG9zZS5iaW5kKHRoaXMpKSwgb25fanNfMS5vbih0aGlzLmRlY29kZXIsIFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25waW5nKCkge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGF0YShkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJwYXJzZSBlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kZWNvZGVkKHBhY2tldCkge1xuICAgICAgICAvLyB0aGUgbmV4dFRpY2sgY2FsbCBwcmV2ZW50cyBhbiBleGNlcHRpb24gaW4gYSB1c2VyLXByb3ZpZGVkIGV2ZW50IGxpc3RlbmVyIGZyb20gdHJpZ2dlcmluZyBhIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGEgXCJwYXJzZSBlcnJvclwiXG4gICAgICAgIGVuZ2luZV9pb19jbGllbnRfMS5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgICAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25lcnJvcihlcnIpIHtcbiAgICAgICAgZGVidWcoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldChuc3AsIG9wdHMpIHtcbiAgICAgICAgbGV0IHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0ID0gbmV3IHNvY2tldF9qc18xLlNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYXV0b0Nvbm5lY3QgJiYgIXNvY2tldC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc29ja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVzdHJveShzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgbnNwcyA9IE9iamVjdC5rZXlzKHRoaXMubnNwcyk7XG4gICAgICAgIGZvciAoY29uc3QgbnNwIG9mIG5zcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICAgICAgaWYgKHNvY2tldC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNvY2tldCAlcyBpcyBzdGlsbCBhY3RpdmUsIHNraXBwaW5nIGNsb3NlXCIsIG5zcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGRlYnVnKFwid3JpdGluZyBwYWNrZXQgJWpcIiwgcGFja2V0KTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGRlYnVnKFwiY2xlYW51cFwiKTtcbiAgICAgICAgdGhpcy5zdWJzLmZvckVhY2goKHN1YkRlc3Ryb3kpID0+IHN1YkRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuc3Vicy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbG9zZSgpIHtcbiAgICAgICAgZGVidWcoXCJkaXNjb25uZWN0XCIpO1xuICAgICAgICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbmNsb3NlKFwiZm9yY2VkIGNsb3NlXCIpO1xuICAgICAgICBpZiAodGhpcy5lbmdpbmUpXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgY2xvc2UoKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zZWQgZHVlIHRvICVzXCIsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlY29ubmVjdCBmYWlsZWRcIik7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0X2ZhaWxlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICAgICAgICAgIGRlYnVnKFwid2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0XCIsIGRlbGF5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVidWcoXCJhdHRlbXB0aW5nIHJlY29ubmVjdFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9hdHRlbXB0XCIsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNlbGYub3BlbigoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVjb25uZWN0IGF0dGVtcHQgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9lcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZWNvbm5lY3Qgc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hdXRvVW5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzLnB1c2goZnVuY3Rpb24gc3ViRGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ucmVjb25uZWN0KCkge1xuICAgICAgICBjb25zdCBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0XCIsIGF0dGVtcHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFuYWdlciA9IE1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub24gPSB2b2lkIDA7XG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICAgIG9iai5vbihldiwgZm4pO1xuICAgIHJldHVybiBmdW5jdGlvbiBzdWJEZXN0cm95KCkge1xuICAgICAgICBvYmoub2ZmKGV2LCBmbik7XG4gICAgfTtcbn1cbmV4cG9ydHMub24gPSBvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2NrZXQgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNvbnN0IG9uX2pzXzEgPSByZXF1aXJlKFwiLi9vbi5qc1wiKTtcbmNvbnN0IGNvbXBvbmVudF9lbWl0dGVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoXCJzb2NrZXQuaW8tY2xpZW50OnNvY2tldFwiKTsgLy8gZGVidWcoKVxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqL1xuY29uc3QgUkVTRVJWRURfRVZFTlRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgY29ubmVjdDogMSxcbiAgICBjb25uZWN0X2Vycm9yOiAxLFxuICAgIGRpc2Nvbm5lY3Q6IDEsXG4gICAgZGlzY29ubmVjdGluZzogMSxcbiAgICAvLyBFdmVudEVtaXR0ZXIgcmVzZXJ2ZWQgZXZlbnRzOiBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19ldmVudF9uZXdsaXN0ZW5lclxuICAgIG5ld0xpc3RlbmVyOiAxLFxuICAgIHJlbW92ZUxpc3RlbmVyOiAxLFxufSk7XG4vKipcbiAqIEEgU29ja2V0IGlzIHRoZSBmdW5kYW1lbnRhbCBjbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc2VydmVyLlxuICpcbiAqIEEgU29ja2V0IGJlbG9uZ3MgdG8gYSBjZXJ0YWluIE5hbWVzcGFjZSAoYnkgZGVmYXVsdCAvKSBhbmQgdXNlcyBhbiB1bmRlcmx5aW5nIHtAbGluayBNYW5hZ2VyfSB0byBjb21tdW5pY2F0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAqXG4gKiBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAqICAgY29uc29sZS5sb2coXCJjb25uZWN0ZWRcIik7XG4gKiB9KTtcbiAqXG4gKiAvLyBzZW5kIGFuIGV2ZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqIHNvY2tldC5vbihcImZvb2JhclwiLCAoKSA9PiB7XG4gKiAgIC8vIGFuIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAqIH0pO1xuICpcbiAqIC8vIHVwb24gZGlzY29ubmVjdGlvblxuICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBkaXNjb25uZWN0ZWQgZHVlIHRvICR7cmVhc29ufWApO1xuICogfSk7XG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIGNvbXBvbmVudF9lbWl0dGVyXzEuRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW8sIG5zcCwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgICAgICpcbiAgICAgICAgICogc29ja2V0Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uZWN0ZWQpOyAvLyBmYWxzZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIHdhcyByZWNvdmVyZWQgYWZ0ZXIgYSB0ZW1wb3JhcnkgZGlzY29ubmVjdGlvbi4gSW4gdGhhdCBjYXNlLCBhbnkgbWlzc2VkIHBhY2tldHMgd2lsbFxuICAgICAgICAgKiBiZSB0cmFuc21pdHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBmb3IgcGFja2V0cyByZWNlaXZlZCBiZWZvcmUgdGhlIENPTk5FQ1QgcGFja2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBmb3IgcGFja2V0cyB0aGF0IHdpbGwgYmUgc2VudCBvbmNlIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBxdWV1ZSBvZiBwYWNrZXRzIHRvIGJlIHNlbnQgd2l0aCByZXRyeSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhY2tldHMgYXJlIHNlbnQgb25lIGJ5IG9uZSwgZWFjaCB3YWl0aW5nIGZvciB0aGUgc2VydmVyIGFja25vd2xlZGdlbWVudCwgaW4gb3JkZXIgdG8gZ3VhcmFudGVlIHRoZSBkZWxpdmVyeSBvcmRlci5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNlcXVlbmNlIHRvIGdlbmVyYXRlIHRoZSBJRCBvZiB0aGUge0BsaW5rIFF1ZXVlZFBhY2tldH0uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9xdWV1ZVNlcSA9IDA7XG4gICAgICAgIHRoaXMuaWRzID0gMDtcbiAgICAgICAgdGhpcy5hY2tzID0ge307XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5pbyA9IGlvO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5pby5fYXV0b0Nvbm5lY3QpXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBkaXNjb25uZWN0ZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRpc2Nvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kaXNjb25uZWN0ZWQpOyAvLyB0cnVlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbm5lY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN1YkV2ZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3VicylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW8gPSB0aGlzLmlvO1xuICAgICAgICB0aGlzLnN1YnMgPSBbXG4gICAgICAgICAgICBvbl9qc18xLm9uKGlvLCBcIm9wZW5cIiwgdGhpcy5vbm9wZW4uYmluZCh0aGlzKSksXG4gICAgICAgICAgICBvbl9qc18xLm9uKGlvLCBcInBhY2tldFwiLCB0aGlzLm9ucGFja2V0LmJpbmQodGhpcykpLFxuICAgICAgICAgICAgb25fanNfMS5vbihpbywgXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBvbl9qc18xLm9uKGlvLCBcImNsb3NlXCIsIHRoaXMub25jbG9zZS5iaW5kKHRoaXMpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgU29ja2V0IHdpbGwgdHJ5IHRvIHJlY29ubmVjdCB3aGVuIGl0cyBNYW5hZ2VyIGNvbm5lY3RzIG9yIHJlY29ubmVjdHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldCA9IGlvKCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhzb2NrZXQuYWN0aXZlKTsgLy8gdHJ1ZVxuICAgICAqXG4gICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gICAgICogICBpZiAocmVhc29uID09PSBcImlvIHNlcnZlciBkaXNjb25uZWN0XCIpIHtcbiAgICAgKiAgICAgLy8gdGhlIGRpc2Nvbm5lY3Rpb24gd2FzIGluaXRpYXRlZCBieSB0aGUgc2VydmVyLCB5b3UgbmVlZCB0byBtYW51YWxseSByZWNvbm5lY3RcbiAgICAgKiAgICAgY29uc29sZS5sb2coc29ja2V0LmFjdGl2ZSk7IC8vIGZhbHNlXG4gICAgICogICB9XG4gICAgICogICAvLyBlbHNlIHRoZSBzb2NrZXQgd2lsbCBhdXRvbWF0aWNhbGx5IHRyeSB0byByZWNvbm5lY3RcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5hY3RpdmUpOyAvLyB0cnVlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zdWJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oe1xuICAgICAqICAgYXV0b0Nvbm5lY3Q6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQuY29ubmVjdCgpO1xuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLnN1YkV2ZW50cygpO1xuICAgICAgICBpZiAoIXRoaXMuaW9bXCJfcmVjb25uZWN0aW5nXCJdKVxuICAgICAgICAgICAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5pby5fcmVhZHlTdGF0ZSlcbiAgICAgICAgICAgIHRoaXMub25vcGVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIGNvbm5lY3QoKX0uXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQuc2VuZChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogc29ja2V0LmVtaXQoXCJtZXNzYWdlXCIsIFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KFwibWVzc2FnZVwiKTtcbiAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYGVtaXRgLlxuICAgICAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAvLyBhbGwgc2VyaWFsaXphYmxlIGRhdGFzdHJ1Y3R1cmVzIGFyZSBzdXBwb3J0ZWQgKG5vIG5lZWQgdG8gY2FsbCBKU09OLnN0cmluZ2lmeSlcbiAgICAgKiBzb2NrZXQuZW1pdChcImhlbGxvXCIsIDEsIFwiMlwiLCB7IDM6IFtcIjRcIl0sIDU6IFVpbnQ4QXJyYXkuZnJvbShbNl0pIH0pO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgc2VydmVyXG4gICAgICogc29ja2V0LmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIsICh2YWwpID0+IHtcbiAgICAgKiAgIC8vIC4uLlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoUkVTRVJWRURfRVZFTlRTLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBldi50b1N0cmluZygpICsgJ1wiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MudW5zaGlmdChldik7XG4gICAgICAgIGlmICh0aGlzLl9vcHRzLnJldHJpZXMgJiYgIXRoaXMuZmxhZ3MuZnJvbVF1ZXVlICYmICF0aGlzLmZsYWdzLnZvbGF0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1F1ZXVlKGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICAgICAgICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9IHRoaXMuZmxhZ3MuY29tcHJlc3MgIT09IGZhbHNlO1xuICAgICAgICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmlkcysrO1xuICAgICAgICAgICAgZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgY29uc3QgYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjayk7XG4gICAgICAgICAgICBwYWNrZXQuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1RyYW5zcG9ydFdyaXRhYmxlID0gdGhpcy5pby5lbmdpbmUgJiZcbiAgICAgICAgICAgIHRoaXMuaW8uZW5naW5lLnRyYW5zcG9ydCAmJlxuICAgICAgICAgICAgdGhpcy5pby5lbmdpbmUudHJhbnNwb3J0LndyaXRhYmxlO1xuICAgICAgICBjb25zdCBkaXNjYXJkUGFja2V0ID0gdGhpcy5mbGFncy52b2xhdGlsZSAmJiAoIWlzVHJhbnNwb3J0V3JpdGFibGUgfHwgIXRoaXMuY29ubmVjdGVkKTtcbiAgICAgICAgaWYgKGRpc2NhcmRQYWNrZXQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZGlzY2FyZCBwYWNrZXQgYXMgdGhlIHRyYW5zcG9ydCBpcyBub3QgY3VycmVudGx5IHdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF9hID0gdGhpcy5mbGFncy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9vcHRzLmFja1RpbWVvdXQ7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNrc1tpZF0gPSBhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuaW8uc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZW5kQnVmZmVyW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlbW92aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCBmcm9tIHRoZSBidWZmZXJcIiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKFwiZXZlbnQgd2l0aCBhY2sgaWQgJWQgaGFzIHRpbWVkIG91dCBhZnRlciAlZCBtc1wiLCBpZCwgdGltZW91dCk7XG4gICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFja3NbaWRdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuaW8uY2xlYXJUaW1lb3V0Rm4odGltZXIpO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIFtudWxsLCAuLi5hcmdzXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHdpdGhvdXQgdGltZW91dFxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSBzcGVjaWZpYyB0aW1lb3V0XG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqIH0gY2F0Y2ggKGVycikge1xuICAgICAqICAgLy8gdGhlIHNlcnZlciBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHNlcnZlciBhY2tub3dsZWRnZXMgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gdGhlIHRpbWVvdXQgZmxhZyBpcyBvcHRpb25hbFxuICAgICAgICBjb25zdCB3aXRoRXJyID0gdGhpcy5mbGFncy50aW1lb3V0ICE9PSB1bmRlZmluZWQgfHwgdGhpcy5fb3B0cy5hY2tUaW1lb3V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAod2l0aEVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMSA/IHJlamVjdChhcmcxKSA6IHJlc29sdmUoYXJnMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHBhY2tldCB0byB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRUb1F1ZXVlKGFyZ3MpIHtcbiAgICAgICAgbGV0IGFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5fcXVldWVTZXErKyxcbiAgICAgICAgICAgIHRyeUNvdW50OiAwLFxuICAgICAgICAgICAgcGVuZGluZzogZmFsc2UsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgZmxhZ3M6IE9iamVjdC5hc3NpZ24oeyBmcm9tUXVldWU6IHRydWUgfSwgdGhpcy5mbGFncyksXG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MucHVzaCgoZXJyLCAuLi5yZXNwb25zZUFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChwYWNrZXQgIT09IHRoaXMuX3F1ZXVlWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhY2tldCBoYXMgYWxyZWFkeSBiZWVuIGFja25vd2xlZGdlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0Vycm9yID0gZXJyICE9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldC50cnlDb3VudCA+IHRoaXMuX29wdHMucmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInBhY2tldCBbJWRdIGlzIGRpc2NhcmRlZCBhZnRlciAlZCB0cmllc1wiLCBwYWNrZXQuaWQsIHBhY2tldC50cnlDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJwYWNrZXQgWyVkXSB3YXMgc3VjY2Vzc2Z1bGx5IHNlbnRcIiwgcGFja2V0LmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYWNrKG51bGwsIC4uLnJlc3BvbnNlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFja2V0LnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhY2tldCk7XG4gICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgZmlyc3QgcGFja2V0IG9mIHRoZSBxdWV1ZSwgYW5kIHdhaXQgZm9yIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIGZvcmNlIC0gd2hldGhlciB0byByZXNlbmQgYSBwYWNrZXQgdGhhdCBoYXMgbm90IGJlZW4gYWNrbm93bGVkZ2VkIHlldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZHJhaW5RdWV1ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGRlYnVnKFwiZHJhaW5pbmcgcXVldWVcIik7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQgfHwgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcXVldWVbMF07XG4gICAgICAgIGlmIChwYWNrZXQucGVuZGluZyAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicGFja2V0IFslZF0gaGFzIGFscmVhZHkgYmVlbiBzZW50IGFuZCBpcyB3YWl0aW5nIGZvciBhbiBhY2tcIiwgcGFja2V0LmlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYWNrZXQucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHBhY2tldC50cnlDb3VudCsrO1xuICAgICAgICBkZWJ1ZyhcInNlbmRpbmcgcGFja2V0IFslZF0gKHRyeSBuwrAlZClcIiwgcGFja2V0LmlkLCBwYWNrZXQudHJ5Q291bnQpO1xuICAgICAgICB0aGlzLmZsYWdzID0gcGFja2V0LmZsYWdzO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgcGFja2V0LmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICAgICAgICB0aGlzLmlvLl9wYWNrZXQocGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25vcGVuKCkge1xuICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZ1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmF1dGggPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGgoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQ29ubmVjdFBhY2tldChkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbm5lY3RQYWNrZXQodGhpcy5hdXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIENPTk5FQ1QgcGFja2V0IHRvIGluaXRpYXRlIHRoZSBTb2NrZXQuSU8gc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VuZENvbm5lY3RQYWNrZXQoZGF0YSkge1xuICAgICAgICB0aGlzLnBhY2tldCh7XG4gICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNULFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fcGlkXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHsgcGlkOiB0aGlzLl9waWQsIG9mZnNldDogdGhpcy5fbGFzdE9mZnNldCB9LCBkYXRhKVxuICAgICAgICAgICAgICAgIDogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGVuZ2luZSBvciBtYW5hZ2VyIGBlcnJvcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NlICglcylcIiwgcmVhc29uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdFwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ucGFja2V0KHBhY2tldCkge1xuICAgICAgICBjb25zdCBzYW1lTmFtZXNwYWNlID0gcGFja2V0Lm5zcCA9PT0gdGhpcy5uc3A7XG4gICAgICAgIGlmICghc2FtZU5hbWVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUOlxuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuZGF0YSAmJiBwYWNrZXQuZGF0YS5zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNvbm5lY3QocGFja2V0LmRhdGEuc2lkLCBwYWNrZXQuZGF0YS5waWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0X2Vycm9yXCIsIG5ldyBFcnJvcihcIkl0IHNlZW1zIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWNoIGEgU29ja2V0LklPIHNlcnZlciBpbiB2Mi54IHdpdGggYSB2My54IGNsaWVudCwgYnV0IHRoZXkgYXJlIG5vdCBjb21wYXRpYmxlIChtb3JlIGluZm9ybWF0aW9uIGhlcmU6IGh0dHBzOi8vc29ja2V0LmlvL2RvY3MvdjMvbWlncmF0aW5nLWZyb20tMi14LXRvLTMtMC8pXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUjpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IocGFja2V0LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGVyci5kYXRhID0gcGFja2V0LmRhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXZlbnQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgICAgICAgZGVidWcoXCJlbWl0dGluZyBldmVudCAlalwiLCBhcmdzKTtcbiAgICAgICAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnRcIik7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKE9iamVjdC5mcmVlemUoYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRFdmVudChhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlMaXN0ZW5lcnMgJiYgdGhpcy5fYW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGlmICh0aGlzLl9waWQgJiYgYXJncy5sZW5ndGggJiYgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdE9mZnNldCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhY2soaWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAoc2VudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZGluZyBhY2sgJWpcIiwgYXJncyk7XG4gICAgICAgICAgICBzZWxmLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQUNLLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25hY2socGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWNrKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNhbGxpbmcgYWNrICVzIHdpdGggJWpcIiwgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJiYWQgYWNrICVzXCIsIHBhY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY29ubmVjdChpZCwgcGlkKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGNvbm5lY3RlZCB3aXRoIGlkICVzXCIsIGlkKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IHBpZCAmJiB0aGlzLl9waWQgPT09IHBpZDtcbiAgICAgICAgdGhpcy5fcGlkID0gcGlkOyAvLyBkZWZpbmVkIG9ubHkgaWYgY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0XCIpO1xuICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlbWl0QnVmZmVyZWQoKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5mb3JFYWNoKChhcmdzKSA9PiB0aGlzLmVtaXRFdmVudChhcmdzKSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgocGFja2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwic2VydmVyIGRpc2Nvbm5lY3QgKCVzKVwiLCB0aGlzLm5zcCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAgICAgKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICAgICAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzKSB7XG4gICAgICAgICAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKChzdWJEZXN0cm95KSA9PiBzdWJEZXN0cm95KCkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW9bXCJfZGVzdHJveVwiXSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS4gSW4gdGhhdCBjYXNlLCB0aGUgc29ja2V0IHdpbGwgbm90IHRyeSB0byByZWNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIHRoZSBsYXN0IGFjdGl2ZSBTb2NrZXQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBNYW5hZ2VyfSwgdGhlIGxvdy1sZXZlbCBjb25uZWN0aW9uIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICAgICAqXG4gICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gICAgICogICAvLyBjb25zb2xlLmxvZyhyZWFzb24pOyBwcmludHMgXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInBlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpXCIsIHRoaXMubnNwKTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBmaXJlIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKFwiaW8gY2xpZW50IGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgZGlzY29ubmVjdCgpfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBtZXNzYWdlIHdpbGwgYmUgZHJvcHBlZCB3aGVuIHRoaXMgc29ja2V0IGlzIG5vdFxuICAgICAqIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBzZXJ2ZXIgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgdGhpcy5mbGFncy52b2xhdGlsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgICogZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgd2l0aG91dCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgc2VydmVyOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyB0aGUgc2VydmVyIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLmZsYWdzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQub25BbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnByZXBlbmRBbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBnb3QgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzb2NrZXQub25BbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAqIHNvY2tldC5vZmZBbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyBvciByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqIHNvY2tldC5vZmZBbnkoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9mZkFueShsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueUxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogTm90ZTogYWNrbm93bGVkZ2VtZW50cyBzZW50IHRvIHRoZSBzZXJ2ZXIgYXJlIG5vdCBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0Lm9uQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgc2VydmVyIGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5wcmVwZW5kQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgcHJlcGVuZEFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogc29ja2V0Lm9uQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAqIHNvY2tldC5vZmZBbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogc29ja2V0Lm9mZkFueU91dGdvaW5nKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2xpc3RlbmVyXSAtIHRoZSBjYXRjaC1hbGwgbGlzdGVuZXIgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIG9mZkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55T3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBsaXN0ZW5lcnMgZm9yIGVhY2ggcGFja2V0IHNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyAmJiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVybCA9IHZvaWQgMDtcbmNvbnN0IGVuZ2luZV9pb19jbGllbnRfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tY2xpZW50XCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdChcInNvY2tldC5pby1jbGllbnQ6dXJsXCIpOyAvLyBkZWJ1ZygpXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHVyaSAtIHVybFxuICogQHBhcmFtIHBhdGggLSB0aGUgcmVxdWVzdCBwYXRoIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gbG9jIC0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVybCh1cmksIHBhdGggPSBcIlwiLCBsb2MpIHtcbiAgICBsZXQgb2JqID0gdXJpO1xuICAgIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gICAgbG9jID0gbG9jIHx8ICh0eXBlb2YgbG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgbG9jYXRpb24pO1xuICAgIGlmIChudWxsID09IHVyaSlcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgXCIvL1wiICsgbG9jLmhvc3Q7XG4gICAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKFwiL1wiID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBpZiAoXCIvXCIgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgICAgICAgZGVidWcoXCJwcm90b2NvbC1sZXNzIHVybCAlc1wiLCB1cmkpO1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBcImh0dHBzOi8vXCIgKyB1cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFyc2VcbiAgICAgICAgZGVidWcoXCJwYXJzZSAlc1wiLCB1cmkpO1xuICAgICAgICBvYmogPSBlbmdpbmVfaW9fY2xpZW50XzEucGFyc2UodXJpKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gICAgaWYgKCFvYmoucG9ydCkge1xuICAgICAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgIG9iai5wb3J0ID0gXCI4MFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgICAgICAgb2JqLnBvcnQgPSBcIjQ0M1wiO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9iai5wYXRoID0gb2JqLnBhdGggfHwgXCIvXCI7XG4gICAgY29uc3QgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoXCI6XCIpICE9PSAtMTtcbiAgICBjb25zdCBob3N0ID0gaXB2NiA/IFwiW1wiICsgb2JqLmhvc3QgKyBcIl1cIiA6IG9iai5ob3N0O1xuICAgIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyBcIjovL1wiICsgaG9zdCArIFwiOlwiICsgb2JqLnBvcnQgKyBwYXRoO1xuICAgIC8vIGRlZmluZSBocmVmXG4gICAgb2JqLmhyZWYgPVxuICAgICAgICBvYmoucHJvdG9jb2wgK1xuICAgICAgICAgICAgXCI6Ly9cIiArXG4gICAgICAgICAgICBob3N0ICtcbiAgICAgICAgICAgIChsb2MgJiYgbG9jLnBvcnQgPT09IG9iai5wb3J0ID8gXCJcIiA6IFwiOlwiICsgb2JqLnBvcnQpO1xuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLnVybCA9IHVybDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IHZvaWQgMDtcbmNvbnN0IGlzX2JpbmFyeV9qc18xID0gcmVxdWlyZShcIi4vaXMtYmluYXJ5LmpzXCIpO1xuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciB8IEJsb2IgfCBGaWxlIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29uc3RydWN0UGFja2V0KHBhY2tldCkge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICBjb25zdCBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gICAgY29uc3QgcGFjayA9IHBhY2tldDtcbiAgICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gICAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgICByZXR1cm4geyBwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnMgfTtcbn1cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBkZWNvbnN0cnVjdFBhY2tldDtcbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICBpZiAoKDAsIGlzX2JpbmFyeV9qc18xLmlzQmluYXJ5KShkYXRhKSkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlY29uc3RydWN0UGFja2V0KHBhY2tldCwgYnVmZmVycykge1xuICAgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgICBkZWxldGUgcGFja2V0LmF0dGFjaG1lbnRzOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gICAgcmV0dXJuIHBhY2tldDtcbn1cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSByZWNvbnN0cnVjdFBhY2tldDtcbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlciA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBpc0luZGV4VmFsaWQgPSB0eXBlb2YgZGF0YS5udW0gPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIGRhdGEubnVtID49IDAgJiZcbiAgICAgICAgICAgIGRhdGEubnVtIDwgYnVmZmVycy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0luZGV4VmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlY29kZXIgPSBleHBvcnRzLkVuY29kZXIgPSBleHBvcnRzLlBhY2tldFR5cGUgPSBleHBvcnRzLnByb3RvY29sID0gdm9pZCAwO1xuY29uc3QgY29tcG9uZW50X2VtaXR0ZXJfMSA9IHJlcXVpcmUoXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCIpO1xuY29uc3QgYmluYXJ5X2pzXzEgPSByZXF1aXJlKFwiLi9iaW5hcnkuanNcIik7XG5jb25zdCBpc19iaW5hcnlfanNfMSA9IHJlcXVpcmUoXCIuL2lzLWJpbmFyeS5qc1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7IC8vIGRlYnVnKClcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW8tcGFyc2VyXCIpOyAvLyBkZWJ1ZygpXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLnByb3RvY29sID0gNTtcbnZhciBQYWNrZXRUeXBlO1xuKGZ1bmN0aW9uIChQYWNrZXRUeXBlKSB7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ09OTkVDVFwiXSA9IDBdID0gXCJDT05ORUNUXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiRElTQ09OTkVDVFwiXSA9IDFdID0gXCJESVNDT05ORUNUXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiRVZFTlRcIl0gPSAyXSA9IFwiRVZFTlRcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJBQ0tcIl0gPSAzXSA9IFwiQUNLXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ09OTkVDVF9FUlJPUlwiXSA9IDRdID0gXCJDT05ORUNUX0VSUk9SXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0VWRU5UXCJdID0gNV0gPSBcIkJJTkFSWV9FVkVOVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkJJTkFSWV9BQ0tcIl0gPSA2XSA9IFwiQklOQVJZX0FDS1wiO1xufSkoUGFja2V0VHlwZSA9IGV4cG9ydHMuUGFja2V0VHlwZSB8fCAoZXhwb3J0cy5QYWNrZXRUeXBlID0ge30pKTtcbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICovXG5jbGFzcyBFbmNvZGVyIHtcbiAgICAvKipcbiAgICAgKiBFbmNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXBsYWNlciAtIGN1c3RvbSByZXBsYWNlciB0byBwYXNzIGRvd24gdG8gSlNPTi5wYXJzZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcGxhY2VyKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gICAgICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICAgICAqL1xuICAgIGVuY29kZShvYmopIHtcbiAgICAgICAgZGVidWcoXCJlbmNvZGluZyBwYWNrZXQgJWpcIiwgb2JqKTtcbiAgICAgICAgaWYgKG9iai50eXBlID09PSBQYWNrZXRUeXBlLkVWRU5UIHx8IG9iai50eXBlID09PSBQYWNrZXRUeXBlLkFDSykge1xuICAgICAgICAgICAgaWYgKCgwLCBpc19iaW5hcnlfanNfMS5oYXNCaW5hcnkpKG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVBc0JpbmFyeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9iai50eXBlID09PSBQYWNrZXRUeXBlLkVWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFBhY2tldFR5cGUuQklOQVJZX0FDSyxcbiAgICAgICAgICAgICAgICAgICAgbnNwOiBvYmoubnNwLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBvYmouZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5pZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMuZW5jb2RlQXNTdHJpbmcob2JqKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICAgICAgICAvLyBmaXJzdCBpcyB0eXBlXG4gICAgICAgIGxldCBzdHIgPSBcIlwiICsgb2JqLnR5cGU7XG4gICAgICAgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfQUNLKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAgICAgICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgICAgICAgaWYgKG9iai5uc3AgJiYgXCIvXCIgIT09IG9iai5uc3ApIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmoubnNwICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gICAgICAgIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgICAgICAgICAgc3RyICs9IG9iai5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBqc29uIGRhdGFcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICAgICAgICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmouZGF0YSwgdGhpcy5yZXBsYWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJlbmNvZGVkICVqIGFzICVzXCIsIG9iaiwgc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gICAgICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICAgICAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICAgICAqL1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaikge1xuICAgICAgICBjb25zdCBkZWNvbnN0cnVjdGlvbiA9ICgwLCBiaW5hcnlfanNfMS5kZWNvbnN0cnVjdFBhY2tldCkob2JqKTtcbiAgICAgICAgY29uc3QgcGFjayA9IHRoaXMuZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG4gICAgICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICAgIH1cbn1cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqL1xuY2xhc3MgRGVjb2RlciBleHRlbmRzIGNvbXBvbmVudF9lbWl0dGVyXzEuRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmV2aXZlciAtIGN1c3RvbSByZXZpdmVyIHRvIHBhc3MgZG93biB0byBKU09OLnN0cmluZ2lmeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldml2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBlbmNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICAgICAqL1xuICAgIGFkZChvYmopIHtcbiAgICAgICAgbGV0IHBhY2tldDtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnb3QgcGxhaW50ZXh0IGRhdGEgd2hlbiByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhY2tldCA9IHRoaXMuZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeUV2ZW50ID0gcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UO1xuICAgICAgICAgICAgaWYgKGlzQmluYXJ5RXZlbnQgfHwgcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgICAgIHBhY2tldC50eXBlID0gaXNCaW5hcnlFdmVudCA/IFBhY2tldFR5cGUuRVZFTlQgOiBQYWNrZXRUeXBlLkFDSztcbiAgICAgICAgICAgICAgICAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpc19iaW5hcnlfanNfMS5pc0JpbmFyeSkob2JqKSB8fCBvYmouYmFzZTY0KSB7XG4gICAgICAgICAgICAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvLyBsb29rIHVwIHR5cGVcbiAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFBhY2tldFR5cGVbcC50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHBhY2tldCB0eXBlIFwiICsgcC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gICAgICAgIGlmIChwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09IFwiLVwiICYmIGkgIT0gc3RyLmxlbmd0aCkgeyB9XG4gICAgICAgICAgICBjb25zdCBidWYgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gICAgICAgIGlmIChcIi9cIiA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiLFwiID09PSBjKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLm5zcCA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5uc3AgPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGlkXG4gICAgICAgIGNvbnN0IG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgaWYgKFwiXCIgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmlkID0gTnVtYmVyKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMudHJ5UGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgICAgICAgICBpZiAoRGVjb2Rlci5pc1BheWxvYWRWYWxpZChwLnR5cGUsIHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcImRlY29kZWQgJXMgYXMgJWpcIiwgc3RyLCBwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHRyeVBhcnNlKHN0cikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCB0aGlzLnJldml2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzUGF5bG9hZFZhbGlkKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCI7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXlsb2FkID09PSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQUNLOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQmluYXJ5UmVjb25zdHJ1Y3RvciB7XG4gICAgY29uc3RydWN0b3IocGFja2V0KSB7XG4gICAgICAgIHRoaXMucGFja2V0ID0gcGFja2V0O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAgICAgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICAgICAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gICAgICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAgICovXG4gICAgdGFrZUJpbmFyeURhdGEoYmluRGF0YSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9ICgwLCBiaW5hcnlfanNfMS5yZWNvbnN0cnVjdFBhY2tldCkodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBmaW5pc2hlZFJlY29uc3RydWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNCaW5hcnkgPSBleHBvcnRzLmlzQmluYXJ5ID0gdm9pZCAwO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1ZpZXcgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IEFycmF5QnVmZmVyLmlzVmlldyhvYmopXG4gICAgICAgIDogb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKEJsb2IpID09PSBcIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXVwiKTtcbmNvbnN0IHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKEZpbGUpID09PSBcIltvYmplY3QgRmlsZUNvbnN0cnVjdG9yXVwiKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIEJ1ZmZlciwgYW4gQXJyYXlCdWZmZXIsIGEgQmxvYiBvciBhIEZpbGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gICAgcmV0dXJuICgod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcob2JqKSkpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpO1xufVxuZXhwb3J0cy5pc0JpbmFyeSA9IGlzQmluYXJ5O1xuZnVuY3Rpb24gaGFzQmluYXJ5KG9iaiwgdG9KU09OKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0JpbmFyeShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnRvSlNPTiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNCaW5hcnkgPSBoYXNCaW5hcnk7XG4iLCJ2YXIgdjEgPSByZXF1aXJlKCcuL3YxJyk7XG52YXIgdjQgPSByZXF1aXJlKCcuL3Y0Jyk7XG5cbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2FkYXB0ZXJfZmFjdG9yeSA9IHJlcXVpcmUoJy4vYWRhcHRlcl9mYWN0b3J5LmpzJyk7XG5cbnZhciBhZGFwdGVyID0gKDAsIF9hZGFwdGVyX2ZhY3RvcnkuYWRhcHRlckZhY3RvcnkpKHsgd2luZG93OiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IHdpbmRvdyB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkYXB0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkYXB0ZXJGYWN0b3J5ID0gYWRhcHRlckZhY3Rvcnk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbnZhciBfY2hyb21lX3NoaW0gPSByZXF1aXJlKCcuL2Nocm9tZS9jaHJvbWVfc2hpbScpO1xuXG52YXIgY2hyb21lU2hpbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jaHJvbWVfc2hpbSk7XG5cbnZhciBfZWRnZV9zaGltID0gcmVxdWlyZSgnLi9lZGdlL2VkZ2Vfc2hpbScpO1xuXG52YXIgZWRnZVNoaW0gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZWRnZV9zaGltKTtcblxudmFyIF9maXJlZm94X3NoaW0gPSByZXF1aXJlKCcuL2ZpcmVmb3gvZmlyZWZveF9zaGltJyk7XG5cbnZhciBmaXJlZm94U2hpbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9maXJlZm94X3NoaW0pO1xuXG52YXIgX3NhZmFyaV9zaGltID0gcmVxdWlyZSgnLi9zYWZhcmkvc2FmYXJpX3NoaW0nKTtcblxudmFyIHNhZmFyaVNoaW0gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfc2FmYXJpX3NoaW0pO1xuXG52YXIgX2NvbW1vbl9zaGltID0gcmVxdWlyZSgnLi9jb21tb25fc2hpbScpO1xuXG52YXIgY29tbW9uU2hpbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb21tb25fc2hpbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIFNoaW1taW5nIHN0YXJ0cyBoZXJlLlxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5mdW5jdGlvbiBhZGFwdGVyRmFjdG9yeSgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgd2luZG93ID0gX3JlZi53aW5kb3c7XG5cbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBzaGltQ2hyb21lOiB0cnVlLFxuICAgIHNoaW1GaXJlZm94OiB0cnVlLFxuICAgIHNoaW1FZGdlOiB0cnVlLFxuICAgIHNoaW1TYWZhcmk6IHRydWVcbiAgfTtcblxuICAvLyBVdGlscy5cbiAgdmFyIGxvZ2dpbmcgPSB1dGlscy5sb2c7XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICB2YXIgYWRhcHRlciA9IHtcbiAgICBicm93c2VyRGV0YWlsczogYnJvd3NlckRldGFpbHMsXG4gICAgY29tbW9uU2hpbTogY29tbW9uU2hpbSxcbiAgICBleHRyYWN0VmVyc2lvbjogdXRpbHMuZXh0cmFjdFZlcnNpb24sXG4gICAgZGlzYWJsZUxvZzogdXRpbHMuZGlzYWJsZUxvZyxcbiAgICBkaXNhYmxlV2FybmluZ3M6IHV0aWxzLmRpc2FibGVXYXJuaW5nc1xuICB9O1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHwgIW9wdGlvbnMuc2hpbUNocm9tZSkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gY2FuIG5vdCBkZXRlcm1pbmUgdmVyc2lvbiwgbm90IHNoaW1taW5nLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU1lZGlhU3RyZWFtKHdpbmRvdyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltT25UcmFjayh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5maXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3cpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVBbGxvd0V4dG1hcE1peGVkKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIWZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIGZpcmVmb3hTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbU9uVHJhY2sod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SZW1vdmVTdHJlYW0od2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlQW5zd2VyKHdpbmRvdyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlZGdlJzpcbiAgICAgIGlmICghZWRnZVNoaW0gfHwgIWVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRWRnZSkge1xuICAgICAgICBsb2dnaW5nKCdNUyBlZGdlIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZWRnZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZWRnZVNoaW07XG5cbiAgICAgIGVkZ2VTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIGVkZ2VTaGltLnNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93KTtcbiAgICAgIGVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpO1xuICAgICAgZWRnZVNoaW0uc2hpbVJlcGxhY2VUcmFjayh3aW5kb3cpO1xuXG4gICAgICAvLyB0aGUgZWRnZSBzaGltIGltcGxlbWVudHMgdGhlIGZ1bGwgUlRDSWNlQ2FuZGlkYXRlIG9iamVjdC5cblxuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgc2FmYXJpU2hpbS5zaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQXVkaW9Db250ZXh0KHdpbmRvdyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVBbGxvd0V4dG1hcE1peGVkKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbi8vIEJyb3dzZXIgc2hpbXMuXG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0RGlzcGxheU1lZGlhID0gZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZ2V0dXNlcm1lZGlhID0gcmVxdWlyZSgnLi9nZXR1c2VybWVkaWEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzaGltR2V0VXNlck1lZGlhJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldHVzZXJtZWRpYS5zaGltR2V0VXNlck1lZGlhO1xuICB9XG59KTtcblxudmFyIF9nZXRkaXNwbGF5bWVkaWEgPSByZXF1aXJlKCcuL2dldGRpc3BsYXltZWRpYScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NoaW1HZXREaXNwbGF5TWVkaWEnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0ZGlzcGxheW1lZGlhLnNoaW1HZXREaXNwbGF5TWVkaWE7XG4gIH1cbn0pO1xuZXhwb3J0cy5zaGltTWVkaWFTdHJlYW0gPSBzaGltTWVkaWFTdHJlYW07XG5leHBvcnRzLnNoaW1PblRyYWNrID0gc2hpbU9uVHJhY2s7XG5leHBvcnRzLnNoaW1HZXRTZW5kZXJzV2l0aER0bWYgPSBzaGltR2V0U2VuZGVyc1dpdGhEdG1mO1xuZXhwb3J0cy5zaGltR2V0U3RhdHMgPSBzaGltR2V0U3RhdHM7XG5leHBvcnRzLnNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzID0gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHM7XG5leHBvcnRzLnNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSA9IHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZTtcbmV4cG9ydHMuc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sgPSBzaGltQWRkVHJhY2tSZW1vdmVUcmFjaztcbmV4cG9ydHMuc2hpbVBlZXJDb25uZWN0aW9uID0gc2hpbVBlZXJDb25uZWN0aW9uO1xuZXhwb3J0cy5maXhOZWdvdGlhdGlvbk5lZWRlZCA9IGZpeE5lZ290aWF0aW9uTmVlZGVkO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gc2hpbU1lZGlhU3RyZWFtKHdpbmRvdykge1xuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xufVxuXG5mdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG5cbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgIHRoaXMuX29udHJhY2twb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBvbmFkZHN0cmVhbSBkb2VzIG5vdCBmaXJlIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhbiBleGlzdGluZ1xuICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxuICAgICAgICAgIGUuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgZnVuY3Rpb24gKHRlKSB7XG4gICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBfdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7IHRyYWNrOiB0ZS50cmFjayB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0geyByZWNlaXZlcjogcmVjZWl2ZXIgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IF90aGlzLmdldFJlY2VpdmVycygpLmZpbmQoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0cmFjay5pZDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHsgdHJhY2s6IHRyYWNrIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0geyByZWNlaXZlcjogcmVjZWl2ZXIgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZXZlbiBpZiBSVENSdHBUcmFuc2NlaXZlciBpcyBpbiB3aW5kb3csIGl0IGlzIG9ubHkgdXNlZCBhbmRcbiAgICAvLyBlbWl0dGVkIGluIHVuaWZpZWQtcGxhbi4gVW5mb3J0dW5hdGVseSB0aGlzIG1lYW5zIHdlIG5lZWRcbiAgICAvLyB0byB1bmNvbmRpdGlvbmFsbHkgd3JhcCB0aGUgZXZlbnQuXG4gICAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLCB7IHZhbHVlOiB7IHJlY2VpdmVyOiBlLnJlY2VpdmVyIH0gfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdykge1xuICAvLyBPdmVycmlkZXMgYWRkVHJhY2svcmVtb3ZlVHJhY2ssIGRlcGVuZHMgb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2suXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSAmJiAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHZhciBzaGltU2VuZGVyV2l0aER0bWYgPSBmdW5jdGlvbiBzaGltU2VuZGVyV2l0aER0bWYocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgIGdldCBkdG1mKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBwYy5jcmVhdGVEVE1GU2VuZGVyKHRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgICAgfSxcbiAgICAgICAgX3BjOiBwY1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYXVnbWVudCBhZGRUcmFjayB3aGVuIGdldFNlbmRlcnMgaXMgbm90IGF2YWlsYWJsZS5cbiAgICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kZXJzLnNsaWNlKCk7IC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlLlxuICAgICAgfTtcbiAgICAgIHZhciBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIXNlbmRlcikge1xuICAgICAgICAgIHNlbmRlciA9IHNoaW1TZW5kZXJXaXRoRHRtZih0aGlzLCB0cmFjayk7XG4gICAgICAgICAgdGhpcy5fc2VuZGVycy5wdXNoKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgICAgICBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBfdGhpczIuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYoX3RoaXMyLCB0cmFjaykpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcblxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHZhciBzZW5kZXIgPSBfdGhpczMuX3NlbmRlcnMuZmluZChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAvLyByZW1vdmUgc2VuZGVyXG4gICAgICAgICAgX3RoaXMzLl9zZW5kZXJzLnNwbGljZShfdGhpczMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJiAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmICEoJ2R0bWYnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIHZhciBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5fcGMgPSBfdGhpczQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUsICdkdG1mJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gdGhpcy5fcGMuY3JlYXRlRFRNRlNlbmRlcih0aGlzLnRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1HZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIF9hcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzZWxlY3RvciA9IF9hcmd1bWVudHNbMF0sXG4gICAgICAgIG9uU3VjYyA9IF9hcmd1bWVudHNbMV0sXG4gICAgICAgIG9uRXJyID0gX2FyZ3VtZW50c1syXTtcblxuICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgZnVuY3Rpb24gdGhlbiB3ZSBhcmUgaW4gdGhlIG9sZCBzdHlsZSBzdGF0cyBzbyBqdXN0XG4gICAgLy8gcGFzcyBiYWNrIHRoZSBvcmlnaW5hbCBnZXRTdGF0cyBmb3JtYXQgdG8gYXZvaWQgYnJlYWtpbmcgb2xkIHVzZXJzLlxuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBzcGVjLXN0eWxlIGdldFN0YXRzIGlzIHN1cHBvcnRlZCwgcmV0dXJuIHRob3NlIHdoZW4gY2FsbGVkIHdpdGhcbiAgICAvLyBlaXRoZXIgbm8gYXJndW1lbnRzIG9yIHRoZSBzZWxlY3RvciBhcmd1bWVudCBpcyBudWxsLlxuICAgIGlmIChvcmlnR2V0U3RhdHMubGVuZ3RoID09PSAwICYmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW10pO1xuICAgIH1cblxuICAgIHZhciBmaXhDaHJvbWVTdGF0c18gPSBmdW5jdGlvbiBmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpIHtcbiAgICAgIHZhciBzdGFuZGFyZFJlcG9ydCA9IHt9O1xuICAgICAgdmFyIHJlcG9ydHMgPSByZXNwb25zZS5yZXN1bHQoKTtcbiAgICAgIHJlcG9ydHMuZm9yRWFjaChmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICAgIHZhciBzdGFuZGFyZFN0YXRzID0ge1xuICAgICAgICAgIGlkOiByZXBvcnQuaWQsXG4gICAgICAgICAgdGltZXN0YW1wOiByZXBvcnQudGltZXN0YW1wLFxuICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICAgICAgICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gICAgICAgICAgfVtyZXBvcnQudHlwZV0gfHwgcmVwb3J0LnR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmVwb3J0Lm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHN0YW5kYXJkU3RhdHNbbmFtZV0gPSByZXBvcnQuc3RhdChuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YW5kYXJkUmVwb3J0W3N0YW5kYXJkU3RhdHMuaWRdID0gc3RhbmRhcmRTdGF0cztcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3RhbmRhcmRSZXBvcnQ7XG4gICAgfTtcblxuICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICB2YXIgbWFrZU1hcFN0YXRzID0gZnVuY3Rpb24gbWFrZU1hcFN0YXRzKHN0YXRzKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcChPYmplY3Qua2V5cyhzdGF0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtrZXksIHN0YXRzW2tleV1dO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8gPSBmdW5jdGlvbiBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyhyZXNwb25zZSkge1xuICAgICAgICBvblN1Y2MobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW3N1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfLCBzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIC8vIHByb21pc2Utc3VwcG9ydFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBvcmlnR2V0U3RhdHMuYXBwbHkoX3RoaXM1LCBbZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc29sdmUobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgIH0sIHJlamVjdF0pO1xuICAgIH0pLnRoZW4ob25TdWNjLCBvbkVycik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIHNlbmRlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICB2YXIgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICB2YXIgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgc2VuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgICByZXR1cm4gc2VuZGVyLl9wYyA9IF90aGlzNjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICAgIHZhciBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgdmFyIHNlbmRlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvKiBOb3RlOiB0aGlzIHdpbGwgaW5jbHVkZSBzdGF0cyBvZiBhbGwgc2VuZGVycyB0aGF0XG4gICAgICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcbiAgICAgICAgICAgKiAgIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSB0aGUgUlRDUnRwU2VuZGVyLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHV0aWxzLmZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHNoaW0gcmVjZWl2ZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICB2YXIgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICAgIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICByZWNlaXZlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVjZWl2ZXIpIHtcbiAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIuX3BjID0gX3RoaXM3O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICAgIH07XG4gICAgfVxuICAgIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gICAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZmlsdGVyU3RhdHMocmVzdWx0LCByZWNlaXZlci50cmFjaywgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModHJhY2spLlxuICB2YXIgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgdmFyIHRyYWNrID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHNlbmRlciA9IHZvaWQgMDtcbiAgICAgIHZhciByZWNlaXZlciA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoci50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY2VpdmVyID0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyIHx8IHNlbmRlciAmJiByZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignVGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VuZGVyKSB7XG4gICAgICAgIHJldHVybiBzZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignVGhlcmUgaXMgbm8gc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XG4gIC8vIHNoaW0gYWRkVHJhY2svcmVtb3ZlVHJhY2sgd2l0aCBuYXRpdmUgdmFyaWFudHMgaW4gb3JkZXIgdG8gbWFrZVxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykubWFwKGZ1bmN0aW9uIChzdHJlYW1JZCkge1xuICAgICAgcmV0dXJuIF90aGlzOC5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF1bMF07XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG5cbiAgICB2YXIgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW0sIHNlbmRlcl07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0uaW5kZXhPZihzZW5kZXIpID09PSAtMSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbmRlcjtcbiAgfTtcblxuICB2YXIgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICB2YXIgYWxyZWFkeUV4aXN0cyA9IF90aGlzOS5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZXhpc3RpbmdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCk7XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBuZXdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChuZXdTZW5kZXIpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMTtcbiAgICB9KTtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtXS5jb25jYXQobmV3U2VuZGVycyk7XG4gIH07XG5cbiAgdmFyIG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICByZXR1cm4gb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgaWYgKHNlbmRlcikge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtSWQpIHtcbiAgICAgICAgdmFyIGlkeCA9IF90aGlzMTAuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICBfdGhpczEwLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMxMC5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMTAuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuICAvLyBzaGltIGFkZFRyYWNrIGFuZCByZW1vdmVUcmFjay5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NSkge1xuICAgIHJldHVybiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KTtcbiAgfVxuXG4gIC8vIGFsc28gc2hpbSBwYy5nZXRMb2NhbFN0cmVhbXMgd2hlbiBhZGRUcmFjayBpcyBzaGltbWVkXG4gIC8vIHRvIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyZWFtcy5cbiAgdmFyIG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgdmFyIG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHJldHVybiBfdGhpczExLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIHZhciBhbHJlYWR5RXhpc3RzID0gX3RoaXMxMi5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgaWRlbnRpdHkgbWFwcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBhZGRUcmFjay5cbiAgICAvLyBVbmxlc3MgdGhpcyBpcyBiZWluZyB1c2VkIHdpdGggYSBzdHJlYW0gZnJvbSBhZGRUcmFjay5cbiAgICBpZiAoIXRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIHZhciBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKHN0cmVhbS5nZXRUcmFja3MoKSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgIH1cbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgfTtcblxuICB2YXIgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuXG4gICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdIHx8IHN0cmVhbV0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZXZlcnNlU3RyZWFtc1t0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPyB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0uaWQgOiBzdHJlYW0uaWRdO1xuICAgIGRlbGV0ZSB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF07XG4gIH07XG5cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoc3RyZWFtcy5sZW5ndGggIT09IDEgfHwgIXN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZmluZChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgPT09IHRyYWNrO1xuICAgIH0pKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAvLyBbW2Fzc29jaWF0ZWQgTWVkaWFTdHJlYW1zXV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBhZGFwdGVyLmpzIGFkZFRyYWNrIHBvbHlmaWxsIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgJyArICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsICdOb3RTdXBwb3J0ZWRFcnJvcicpO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgIH0pO1xuICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICB2YXIgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIGlmIChvbGRTdHJlYW0pIHtcbiAgICAgIC8vIHRoaXMgaXMgdXNpbmcgb2RkIENocm9tZSBiZWhhdmlvdXIsIHVzZSB3aXRoIGNhdXRpb246XG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxuICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VuZGVyIHdpdGggYSBkdG1mIHNlbmRlci5cbiAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgIC8vIFRyaWdnZXIgT05OIGFzeW5jLlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHRoaXMuYWRkU3RyZWFtKG5ld1N0cmVhbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcbiAgLy8gdmljZSB2ZXJzYS5cbiAgZnVuY3Rpb24gcmVwbGFjZUludGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGludGVybmFsSWQpIHtcbiAgICAgIHZhciBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIHZhciBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoaW50ZXJuYWxTdHJlYW0uaWQsICdnJyksIGV4dGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwOiBzZHBcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJuYWxJZCkge1xuICAgICAgdmFyIGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgdmFyIGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChleHRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHA6IHNkcFxuICAgIH0pO1xuICB9XG4gIFsnY3JlYXRlT2ZmZXInLCAnY3JlYXRlQW5zd2VyJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICB2YXIgbWV0aG9kT2JqID0gX2RlZmluZVByb3BlcnR5KHt9LCBtZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcblxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgaXNMZWdhY3lDYWxsID0gYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKGlzTGVnYWN5Q2FsbCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFtmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB2YXIgZGVzYyA9IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKF90aGlzMTQsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBhcmdzWzBdLmFwcGx5KG51bGwsIFtkZXNjXSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYXJndW1lbnRzWzJdXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKF90aGlzMTQsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICB9KTtcblxuICB2YXIgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICFhcmd1bWVudHNbMF0udHlwZSkge1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGFyZ3VtZW50c1swXSA9IHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gVE9ETzogbWFuZ2xlIGdldFN0YXRzOiBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjbWVkaWFzdHJlYW1zdGF0cy1zdHJlYW1pZGVudGlmaWVyXG5cbiAgdmFyIG9yaWdMb2NhbERlc2NyaXB0aW9uID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSBvcmlnTG9jYWxEZXNjcmlwdGlvbi5nZXQuYXBwbHkodGhpcyk7XG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gbm90IHlldCBjaGVjayBmb3Igc2VuZGVyIGluc3RhbmNlb2YgUlRDUnRwU2VuZGVyXG4gICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgIGlmICghc2VuZGVyLl9wYykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICsgJ2RvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgUlRDUnRwU2VuZGVyLicsICdUeXBlRXJyb3InKTtcbiAgICB9XG4gICAgdmFyIGlzTG9jYWwgPSBzZW5kZXIuX3BjID09PSB0aGlzO1xuICAgIGlmICghaXNMb2NhbCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5hdGl2ZSBzdHJlYW0gdGhlIHNlbmRlcnMgdHJhY2sgYmVsb25ncyB0by5cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB2YXIgc3RyZWFtID0gdm9pZCAwO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0cmVhbXMpLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbWlkKSB7XG4gICAgICB2YXIgaGFzVHJhY2sgPSBfdGhpczE1Ll9zdHJlYW1zW3N0cmVhbWlkXS5nZXRUcmFja3MoKS5maW5kKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gc2VuZGVyLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc1RyYWNrKSB7XG4gICAgICAgIHN0cmVhbSA9IF90aGlzMTUuX3N0cmVhbXNbc3RyZWFtaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xuICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxuICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbSh0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXG4gICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayhzZW5kZXIudHJhY2spO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93KSB7XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWRkSWNlQ2FuZGlkYXRlTnVsbFN1cHBvcnRlZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlLmxlbmd0aCA9PT0gMDtcblxuICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHZhciBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICB2YXIgbWV0aG9kT2JqID0gX2RlZmluZVByb3BlcnR5KHt9LCBtZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIHZhciBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XG4gICAgaWYgKCFhZGRJY2VDYW5kaWRhdGVOdWxsU3VwcG9ydGVkICYmICFhcmd1bWVudHNbMF0pIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvLyBGaXJlZm94IDY4KyBlbWl0cyBhbmQgcHJvY2Vzc2VzIHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0sIGlnbm9yZVxuICAgIC8vIGluIG9sZGVyIHZlcnNpb25zLiBOYXRpdmUgc3VwcG9ydCBwbGFubmVkIGZvciBDaHJvbWUgTTc3LlxuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzggJiYgYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gQXR0ZW1wdCB0byBmaXggT05OIGluIHBsYW4tYiBtb2RlLlxuZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93KSB7XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgcGMuZ2V0Q29uZmlndXJhdGlvbiAmJiBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0RGlzcGxheU1lZGlhID0gc2hpbUdldERpc3BsYXlNZWRpYTtcbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBnZXRTb3VyY2VJZCkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBnZXRTb3VyY2VJZCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGhcbiAgLy8gdGhlIHNvdXJjZUlkIG9mIHRoZSBzY3JlZW4vd2luZG93L3RhYiB0byBiZSBzaGFyZWQuXG4gIGlmICh0eXBlb2YgZ2V0U291cmNlSWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKCdzaGltR2V0RGlzcGxheU1lZGlhOiBnZXRTb3VyY2VJZCBhcmd1bWVudCBpcyBub3QgJyArICdhIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIHJldHVybiBnZXRTb3VyY2VJZChjb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoc291cmNlSWQpIHtcbiAgICAgIHZhciB3aWR0aFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoO1xuICAgICAgdmFyIGhlaWdodFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodDtcbiAgICAgIHZhciBmcmFtZVJhdGVTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby5mcmFtZVJhdGU7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2U6ICdkZXNrdG9wJyxcbiAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgICBtYXhGcmFtZVJhdGU6IGZyYW1lUmF0ZVNwZWNpZmllZCB8fCAzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAod2lkdGhTcGVjaWZpZWQpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heFdpZHRoID0gd2lkdGhTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U3BlY2lmaWVkKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1hbmRhdG9yeS5tYXhIZWlnaHQgPSBoZWlnaHRTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gc2hpbUdldFVzZXJNZWRpYTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbnZhciBsb2dnaW5nID0gdXRpbHMubG9nO1xuXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICB2YXIgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIHZhciBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIGNvbnN0cmFpbnRzVG9DaHJvbWVfKGMpIHtcbiAgICBpZiAoKHR5cGVvZiBjID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjKSkgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICB2YXIgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByID0gX3R5cGVvZihjW2tleV0pID09PSAnb2JqZWN0JyA/IGNba2V5XSA6IHsgaWRlYWw6IGNba2V5XSB9O1xuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICB9XG4gICAgICB2YXIgb2xkbmFtZV8gPSBmdW5jdGlvbiBvbGRuYW1lXyhwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2RldmljZUlkJyA/ICdzb3VyY2VJZCcgOiBuYW1lO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcbiAgICAgICAgdmFyIG9jID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICAgIG9jID0ge307XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWydtaW4nLCAnbWF4J10uZm9yRWFjaChmdW5jdGlvbiAobWl4KSB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG5cbiAgdmFyIHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbiBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBmdW5jKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjEpIHtcbiAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIF90eXBlb2YoY29uc3RyYWludHMuYXVkaW8pID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHJlbWFwID0gZnVuY3Rpb24gcmVtYXAob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgX3R5cGVvZihjb25zdHJhaW50cy52aWRlbykgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSAmIHN1cmZhY2UgcHJvLlxuICAgICAgdmFyIGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKCh0eXBlb2YgZmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZmFjZSkpID09PSAnb2JqZWN0JyA/IGZhY2UgOiB7IGlkZWFsOiBmYWNlIH0pO1xuICAgICAgdmFyIGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xuXG4gICAgICBpZiAoZmFjZSAmJiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpICYmICEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSAmJiAhZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2JhY2snLCAncmVhciddO1xuICAgICAgICB9IGVsc2UgaWYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydmcm9udCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgbWF0Y2hlcyBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtIGZvciBiYWNrICh0eXBpY2FsKS5cbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09ICd2aWRlb2lucHV0JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRldiA9IGRldmljZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5zb21lKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkZXYgJiYgZGV2aWNlcy5sZW5ndGggJiYgbWF0Y2hlcy5pbmNsdWRlcygnYmFjaycpKSB7XG4gICAgICAgICAgICAgIGRldiA9IGRldmljZXNbZGV2aWNlcy5sZW5ndGggLSAxXTsgLy8gbW9yZSBsaWtlbHkgdGhlIGJhY2sgY2FtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2KSB7XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZmFjZS5leGFjdCA/IHsgZXhhY3Q6IGRldi5kZXZpY2VJZCB9IDogeyBpZGVhbDogZGV2LmRldmljZUlkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcblxuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIHNoaW1FcnJvcl8oZSkge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY0KSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRpc21pc3NlZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgSW52YWxpZFN0YXRlRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBEZXZpY2VzTm90Rm91bmRFcnJvcjogJ05vdEZvdW5kRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcicsXG4gICAgICAgIFRyYWNrU3RhcnRFcnJvcjogJ05vdFJlYWRhYmxlRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUtpbGxTd2l0Y2hPbjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFRhYkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBTY3JlZW5DYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgRGV2aWNlQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQgfHwgZS5jb25zdHJhaW50TmFtZSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYV8oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYV8uYmluZChuYXZpZ2F0b3IpO1xuXG4gIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgLy8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGl0IGRvZXMgbm90IGFjY2VwdCBzcGVjLXN0eWxlXG4gIC8vIGNvbnN0cmFpbnRzLlxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8IGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLnNoaW1SVENJY2VDYW5kaWRhdGUgPSBzaGltUlRDSWNlQ2FuZGlkYXRlO1xuZXhwb3J0cy5zaGltTWF4TWVzc2FnZVNpemUgPSBzaGltTWF4TWVzc2FnZVNpemU7XG5leHBvcnRzLnNoaW1TZW5kVGhyb3dUeXBlRXJyb3IgPSBzaGltU2VuZFRocm93VHlwZUVycm9yO1xuZXhwb3J0cy5zaGltQ29ubmVjdGlvblN0YXRlID0gc2hpbUNvbm5lY3Rpb25TdGF0ZTtcbmV4cG9ydHMucmVtb3ZlQWxsb3dFeHRtYXBNaXhlZCA9IHJlbW92ZUFsbG93RXh0bWFwTWl4ZWQ7XG5cbnZhciBfc2RwID0gcmVxdWlyZSgnc2RwJyk7XG5cbnZhciBfc2RwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NkcCk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICgodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFyZ3MpKSA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHIoMik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmxlbmd0aCkge1xuICAgICAgLy8gQXVnbWVudCB0aGUgbmF0aXZlIGNhbmRpZGF0ZSB3aXRoIHRoZSBwYXJzZWQgZmllbGRzLlxuICAgICAgdmFyIG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gICAgICB2YXIgcGFyc2VkQ2FuZGlkYXRlID0gX3NkcDIuZGVmYXVsdC5wYXJzZUNhbmRpZGF0ZShhcmdzLmNhbmRpZGF0ZSk7XG4gICAgICB2YXIgYXVnbWVudGVkQ2FuZGlkYXRlID0gT2JqZWN0LmFzc2lnbihuYXRpdmVDYW5kaWRhdGUsIHBhcnNlZENhbmRpZGF0ZSk7XG5cbiAgICAgIC8vIEFkZCBhIHNlcmlhbGl6ZXIgdGhhdCBkb2VzIG5vdCBzZXJpYWxpemUgdGhlIGV4dHJhIGF0dHJpYnV0ZXMuXG4gICAgICBhdWdtZW50ZWRDYW5kaWRhdGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbmRpZGF0ZTogYXVnbWVudGVkQ2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNaWQ6IGF1Z21lbnRlZENhbmRpZGF0ZS5zZHBNaWQsXG4gICAgICAgICAgc2RwTUxpbmVJbmRleDogYXVnbWVudGVkQ2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogYXVnbWVudGVkQ2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXVnbWVudGVkQ2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgfTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUgPSBOYXRpdmVSVENJY2VDYW5kaWRhdGUucHJvdG90eXBlO1xuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxuICAgICAgICB3cml0YWJsZTogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG5cbiAgaWYgKCEoJ3NjdHAnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdzY3RwJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNjdHBJbkRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzZWN0aW9ucyA9IF9zZHAyLmRlZmF1bHQuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgdmFyIG1MaW5lID0gX3NkcDIuZGVmYXVsdC5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgICByZXR1cm4gbUxpbmUgJiYgbUxpbmUua2luZCA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBtTGluZS5wcm90b2NvbC5pbmRleE9mKCdTQ1RQJykgIT09IC0xO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiA9IGZ1bmN0aW9uIGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xuICAgIHZhciBtYXRjaCA9IGRlc2NyaXB0aW9uLnNkcC5tYXRjaCgvbW96aWxsYS4uLlRISVNfSVNfU0RQQVJUQS0oXFxkKykvKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2gubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgLy8gVGVzdCBmb3IgTmFOICh5ZXMsIHRoaXMgaXMgdWdseSlcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gdmVyc2lvbiA/IC0xIDogdmVyc2lvbjtcbiAgfTtcblxuICB2YXIgZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIEV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgY2FuIHNlbmQgYXQgbGVhc3QgNjQgS2lCLlxuICAgIC8vIE5vdGU6IEFsdGhvdWdoIENocm9tZSBpcyB0ZWNobmljYWxseSBhYmxlIHRvIHNlbmQgdXAgdG8gMjU2IEtpQiwgdGhlXG4gICAgLy8gICAgICAgZGF0YSBkb2VzIG5vdCByZWFjaCB0aGUgb3RoZXIgcGVlciByZWxpYWJseS5cbiAgICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD04NDE5XG4gICAgdmFyIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcpIHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTcpIHtcbiAgICAgICAgaWYgKHJlbW90ZUlzRmlyZWZveCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBGRiA8IDU3IHdpbGwgc2VuZCBpbiAxNiBLaUIgY2h1bmtzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFBQSURcbiAgICAgICAgICAvLyBmcmFnbWVudGF0aW9uLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDE2Mzg0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIG90aGVyIEZGIChhbmQgUkFXUlRDKSBjYW4gcmVhc3NlbWJsZSBQUElELWZyYWdtZW50ZWRcbiAgICAgICAgICAvLyBtZXNzYWdlcy4gVGh1cywgc3VwcG9ydGluZyB+MiBHaUIgd2hlbiBzZW5kaW5nLlxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDYwKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSwgYWxsIEZGID49IDU3IHdpbGwgcmVzZXQgdGhlIHJlbW90ZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICAvLyB0byB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIGEgZGF0YSBjaGFubmVsIGlzIGNyZWF0ZWQgYXQgYSBsYXRlclxuICAgICAgICAvLyBzdGFnZS4gOihcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3ID8gNjU1MzUgOiA2NTUzNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZGID49IDYwIHN1cHBvcnRzIHNlbmRpbmcgfjIgR2lCXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5TZW5kTWF4TWVzc2FnZVNpemU7XG4gIH07XG5cbiAgdmFyIGdldE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24gZ2V0TWF4TWVzc2FnZVNpemUoZGVzY3JpcHRpb24sIHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIE5vdGU6IDY1NTM2IGJ5dGVzIGlzIHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIFNEUCBzcGVjLiBBbHNvLFxuICAgIC8vICAgICAgIGV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgc3VwcG9ydHMgcmVjZWl2aW5nIDY1NTM2IGJ5dGVzLlxuICAgIHZhciBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuXG4gICAgLy8gRkYgNTcgaGFzIGEgc2xpZ2h0bHkgaW5jb3JyZWN0IGRlZmF1bHQgcmVtb3RlIG1heCBtZXNzYWdlIHNpemUsIHNvXG4gICAgLy8gd2UgbmVlZCB0byBhZGp1c3QgaXQgaGVyZSB0byBhdm9pZCBhIGZhaWx1cmUgd2hlbiBzZW5kaW5nLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNTY5N1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcpIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gX3NkcDIuZGVmYXVsdC5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcblxuICB2YXIgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgLy8gQXMgdXN1YWwsIGFkYXB0ZXIuanMgaGFzIHRvIGRvIGFuICd1Z2x5IHdvcmFrYXJvdW5kJ1xuICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICB2YXIgX2dldENvbmZpZ3VyYXRpb24gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKSxcbiAgICAgICAgICBzZHBTZW1hbnRpY3MgPSBfZ2V0Q29uZmlndXJhdGlvbi5zZHBTZW1hbnRpY3M7XG5cbiAgICAgIGlmIChzZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2N0cCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjdHBJbkRlc2NyaXB0aW9uKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1vdGUgaXMgRkYuXG4gICAgICB2YXIgaXNGaXJlZm94ID0gZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24oYXJndW1lbnRzWzBdKTtcblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSB0aGUgbG9jYWwgcGVlciBpcyBjYXBhYmxlIG9mIHNlbmRpbmdcbiAgICAgIHZhciBjYW5TZW5kTU1TID0gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgdmFyIHJlbW90ZU1NUyA9IGdldE1heE1lc3NhZ2VTaXplKGFyZ3VtZW50c1swXSwgaXNGaXJlZm94KTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICB2YXIgbWF4TWVzc2FnZVNpemUgPSB2b2lkIDA7XG4gICAgICBpZiAoY2FuU2VuZE1NUyA9PT0gMCAmJiByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9IGVsc2UgaWYgKGNhblNlbmRNTVMgPT09IDAgfHwgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5tYXgoY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5taW4oY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgUlRDU2N0cFRyYW5zcG9ydCBvYmplY3QgYW5kIHRoZSAnbWF4TWVzc2FnZVNpemUnXG4gICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICB2YXIgc2N0cCA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjdHAsICdtYXhNZXNzYWdlU2l6ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NjdHAgPSBzY3RwO1xuICAgIH1cblxuICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdjcmVhdGVEYXRhQ2hhbm5lbCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBbHRob3VnaCBGaXJlZm94ID49IDU3IGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgdGhlIG1heGltdW1cbiAgLy8gICAgICAgbWVzc2FnZSBzaXplIGNhbiBiZSByZXNldCBmb3IgYWxsIGRhdGEgY2hhbm5lbHMgYXQgYSBsYXRlciBzdGFnZS5cbiAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXG5cbiAgZnVuY3Rpb24gd3JhcERjU2VuZChkYywgcGMpIHtcbiAgICB2YXIgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aCB8fCBkYXRhLnNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgaWYgKGRjLnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJiBwYy5zY3RwICYmIGxlbmd0aCA+IHBjLnNjdHAubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVzc2FnZSB0b28gbGFyZ2UgKGNhbiBzZW5kIGEgbWF4aW11bSBvZiAnICsgcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ0RhdGFDaGFubmVsU2VuZC5hcHBseShkYywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIHZhciBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XG4gICAgdmFyIGRhdGFDaGFubmVsID0gb3JpZ0NyZWF0ZURhdGFDaGFubmVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgd3JhcERjU2VuZChkYXRhQ2hhbm5lbCwgdGhpcyk7XG4gICAgcmV0dXJuIGRhdGFDaGFubmVsO1xuICB9O1xuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdkYXRhY2hhbm5lbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25uZWN0aW9uU3RhdGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZWQ6ICdjb25uZWN0ZWQnLFxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9LFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uY29ubmVjdGlvbnN0YXRlY2hhbmdlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIHx8IG51bGw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChjYikge1xuICAgICAgaWYgKHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgdmFyIG9yaWdNZXRob2QgPSBwcm90b1ttZXRob2RdO1xuICAgIHByb3RvW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHBjID0gZS50YXJnZXQ7XG4gICAgICAgICAgaWYgKHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlICE9PSBwYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlID0gcGMuY29ubmVjdGlvblN0YXRlO1xuICAgICAgICAgICAgdmFyIG5ld0V2ZW50ID0gbmV3IEV2ZW50KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBlKTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbG93RXh0bWFwTWl4ZWQod2luZG93KSB7XG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYwNSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmF0aXZlU1JEID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xuICAgICAgZGVzYy5zZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0RGlzcGxheU1lZGlhID0gZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldHVzZXJtZWRpYSA9IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hpbUdldFVzZXJNZWRpYScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXR1c2VybWVkaWEuc2hpbUdldFVzZXJNZWRpYTtcbiAgfVxufSk7XG5cbnZhciBfZ2V0ZGlzcGxheW1lZGlhID0gcmVxdWlyZSgnLi9nZXRkaXNwbGF5bWVkaWEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzaGltR2V0RGlzcGxheU1lZGlhJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldGRpc3BsYXltZWRpYS5zaGltR2V0RGlzcGxheU1lZGlhO1xuICB9XG59KTtcbmV4cG9ydHMuc2hpbVBlZXJDb25uZWN0aW9uID0gc2hpbVBlZXJDb25uZWN0aW9uO1xuZXhwb3J0cy5zaGltUmVwbGFjZVRyYWNrID0gc2hpbVJlcGxhY2VUcmFjaztcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbnZhciBfZmlsdGVyaWNlc2VydmVycyA9IHJlcXVpcmUoJy4vZmlsdGVyaWNlc2VydmVycycpO1xuXG52YXIgX3J0Y3BlZXJjb25uZWN0aW9uU2hpbSA9IHJlcXVpcmUoJ3J0Y3BlZXJjb25uZWN0aW9uLXNoaW0nKTtcblxudmFyIF9ydGNwZWVyY29ubmVjdGlvblNoaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnRjcGVlcmNvbm5lY3Rpb25TaGltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdykge1xuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG5cbiAgaWYgKHdpbmRvdy5SVENJY2VHYXRoZXJlcikge1xuICAgIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSkge1xuICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIFJUQ0ljZUNhbmRpZGF0ZShhcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyB0aGlzIGFkZHMgYW4gYWRkaXRpb25hbCBldmVudCBsaXN0ZW5lciB0byBNZWRpYVN0cmFja1RyYWNrIHRoYXQgc2lnbmFsc1xuICAgIC8vIHdoZW4gYSB0cmFja3MgZW5hYmxlZCBwcm9wZXJ0eSB3YXMgY2hhbmdlZC4gV29ya2Fyb3VuZCBmb3IgYSBidWcgaW5cbiAgICAvLyBhZGRTdHJlYW0sIHNlZSBiZWxvdy4gTm8gbG9uZ2VyIHJlcXVpcmVkIGluIDE1MDI1K1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgMTUwMjUpIHtcbiAgICAgIHZhciBvcmlnTVNURW5hYmxlZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93Lk1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLCAnZW5hYmxlZCcpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZSwgJ2VuYWJsZWQnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgb3JpZ01TVEVuYWJsZWQuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgIHZhciBldiA9IG5ldyBFdmVudCgnZW5hYmxlZCcpO1xuICAgICAgICAgIGV2LmVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBPUlRDIGRlZmluZXMgdGhlIERUTUYgc2VuZGVyIGEgYml0IGRpZmZlcmVudC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9vcnRjL2lzc3Vlcy83MTRcbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgISgnZHRtZicgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG5ldyB3aW5kb3cuUlRDRHRtZlNlbmRlcih0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIEVkZ2UgY3VycmVudGx5IG9ubHkgaW1wbGVtZW50cyB0aGUgUlRDRHRtZlNlbmRlciwgbm90IHRoZVxuICAvLyBSVENEVE1GU2VuZGVyIGFsaWFzLiBTZWUgaHR0cDovL2RyYWZ0Lm9ydGMub3JnLyNydGNkdG1mc2VuZGVyMipcbiAgaWYgKHdpbmRvdy5SVENEdG1mU2VuZGVyICYmICF3aW5kb3cuUlRDRFRNRlNlbmRlcikge1xuICAgIHdpbmRvdy5SVENEVE1GU2VuZGVyID0gd2luZG93LlJUQ0R0bWZTZW5kZXI7XG4gIH1cblxuICB2YXIgUlRDUGVlckNvbm5lY3Rpb25TaGltID0gKDAsIF9ydGNwZWVyY29ubmVjdGlvblNoaW0yLmRlZmF1bHQpKHdpbmRvdywgYnJvd3NlckRldGFpbHMudmVyc2lvbik7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbmZpZy5pY2VTZXJ2ZXJzID0gKDAsIF9maWx0ZXJpY2VzZXJ2ZXJzLmZpbHRlckljZVNlcnZlcnMpKGNvbmZpZy5pY2VTZXJ2ZXJzLCBicm93c2VyRGV0YWlscy52ZXJzaW9uKTtcbiAgICAgIHV0aWxzLmxvZygnSUNFIHNlcnZlcnMgYWZ0ZXIgZmlsdGVyaW5nOicsIGNvbmZpZy5pY2VTZXJ2ZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSVENQZWVyQ29ubmVjdGlvblNoaW0oY29uZmlnKTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IFJUQ1BlZXJDb25uZWN0aW9uU2hpbS5wcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIHNoaW1SZXBsYWNlVHJhY2sod2luZG93KSB7XG4gIC8vIE9SVEMgaGFzIHJlcGxhY2VUcmFjayAtLSBodHRwczovL2dpdGh1Yi5jb20vdzNjL29ydGMvaXNzdWVzLzYxNFxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAhKCdyZXBsYWNlVHJhY2snIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLnJlcGxhY2VUcmFjayA9IHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLnNldFRyYWNrO1xuICB9XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maWx0ZXJJY2VTZXJ2ZXJzID0gZmlsdGVySWNlU2VydmVycztcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIEVkZ2UgZG9lcyBub3QgbGlrZVxuLy8gMSkgc3R1bjogZmlsdGVyZWQgYWZ0ZXIgMTQzOTMgdW5sZXNzID90cmFuc3BvcnQ9dWRwIGlzIHByZXNlbnRcbi8vIDIpIHR1cm46IHRoYXQgZG9lcyBub3QgaGF2ZSBhbGwgb2YgdHVybjpob3N0OnBvcnQ/dHJhbnNwb3J0PXVkcFxuLy8gMykgdHVybjogd2l0aCBpcHY2IGFkZHJlc3Nlc1xuLy8gNCkgdHVybjogb2NjdXJyaW5nIG11bGlwbGUgdGltZXNcbmZ1bmN0aW9uIGZpbHRlckljZVNlcnZlcnMoaWNlU2VydmVycywgZWRnZVZlcnNpb24pIHtcbiAgdmFyIGhhc1R1cm4gPSBmYWxzZTtcbiAgaWNlU2VydmVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWNlU2VydmVycykpO1xuICByZXR1cm4gaWNlU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgIGlmIChzZXJ2ZXIgJiYgKHNlcnZlci51cmxzIHx8IHNlcnZlci51cmwpKSB7XG4gICAgICB2YXIgdXJscyA9IHNlcnZlci51cmxzIHx8IHNlcnZlci51cmw7XG4gICAgICBpZiAoc2VydmVyLnVybCAmJiAhc2VydmVyLnVybHMpIHtcbiAgICAgICAgdXRpbHMuZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHVybHMgPT09ICdzdHJpbmcnO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHVybHMgPSBbdXJsc107XG4gICAgICB9XG4gICAgICB1cmxzID0gdXJscy5maWx0ZXIoZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAvLyBmaWx0ZXIgU1RVTiB1bmNvbmRpdGlvbmFsbHkuXG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignc3R1bjonKSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZFR1cm4gPSB1cmwuc3RhcnRzV2l0aCgndHVybicpICYmICF1cmwuc3RhcnRzV2l0aCgndHVybjpbJykgJiYgdXJsLmluY2x1ZGVzKCd0cmFuc3BvcnQ9dWRwJyk7XG4gICAgICAgIGlmICh2YWxpZFR1cm4gJiYgIWhhc1R1cm4pIHtcbiAgICAgICAgICBoYXNUdXJuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRUdXJuICYmICFoYXNUdXJuO1xuICAgICAgfSk7XG5cbiAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgc2VydmVyLnVybHMgPSBpc1N0cmluZyA/IHVybHNbMF0gOiB1cmxzO1xuICAgICAgcmV0dXJuICEhdXJscy5sZW5ndGg7XG4gICAgfVxuICB9KTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0RGlzcGxheU1lZGlhID0gc2hpbUdldERpc3BsYXlNZWRpYTtcbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93KSB7XG4gIGlmICghKCdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmICdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IHdpbmRvdy5uYXZpZ2F0b3IuZ2V0RGlzcGxheU1lZGlhLmJpbmQod2luZG93Lm5hdmlnYXRvcik7XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gc2hpbUdldFVzZXJNZWRpYTtcbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcblxuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIHNoaW1FcnJvcl8oZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7IFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGdldFVzZXJNZWRpYSBlcnJvciBzaGltLlxuICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpO1xuICAgIH0pO1xuICB9O1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2hpbUdldERpc3BsYXlNZWRpYSA9IGV4cG9ydHMuc2hpbUdldFVzZXJNZWRpYSA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2dldHVzZXJtZWRpYSA9IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hpbUdldFVzZXJNZWRpYScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXR1c2VybWVkaWEuc2hpbUdldFVzZXJNZWRpYTtcbiAgfVxufSk7XG5cbnZhciBfZ2V0ZGlzcGxheW1lZGlhID0gcmVxdWlyZSgnLi9nZXRkaXNwbGF5bWVkaWEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzaGltR2V0RGlzcGxheU1lZGlhJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldGRpc3BsYXltZWRpYS5zaGltR2V0RGlzcGxheU1lZGlhO1xuICB9XG59KTtcbmV4cG9ydHMuc2hpbU9uVHJhY2sgPSBzaGltT25UcmFjaztcbmV4cG9ydHMuc2hpbVBlZXJDb25uZWN0aW9uID0gc2hpbVBlZXJDb25uZWN0aW9uO1xuZXhwb3J0cy5zaGltU2VuZGVyR2V0U3RhdHMgPSBzaGltU2VuZGVyR2V0U3RhdHM7XG5leHBvcnRzLnNoaW1SZWNlaXZlckdldFN0YXRzID0gc2hpbVJlY2VpdmVyR2V0U3RhdHM7XG5leHBvcnRzLnNoaW1SZW1vdmVTdHJlYW0gPSBzaGltUmVtb3ZlU3RyZWFtO1xuZXhwb3J0cy5zaGltUlRDRGF0YUNoYW5uZWwgPSBzaGltUlRDRGF0YUNoYW5uZWw7XG5leHBvcnRzLnNoaW1BZGRUcmFuc2NlaXZlciA9IHNoaW1BZGRUcmFuc2NlaXZlcjtcbmV4cG9ydHMuc2hpbUdldFBhcmFtZXRlcnMgPSBzaGltR2V0UGFyYW1ldGVycztcbmV4cG9ydHMuc2hpbUNyZWF0ZU9mZmVyID0gc2hpbUNyZWF0ZU9mZmVyO1xuZXhwb3J0cy5zaGltQ3JlYXRlQW5zd2VyID0gc2hpbUNyZWF0ZUFuc3dlcjtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4geyByZWNlaXZlcjogdGhpcy5yZWNlaXZlciB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpIHtcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgIT09ICdvYmplY3QnIHx8ICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHZhciBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICB2YXIgbWV0aG9kT2JqID0gX2RlZmluZVByb3BlcnR5KHt9LCBtZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgaWdub3Jpbmcge3NkcE1pZCwgY2FuZGlkYXRlOiBcIlwifVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY4KSB7XG4gICAgdmFyIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICAvLyBGaXJlZm94IDY4KyBlbWl0cyBhbmQgcHJvY2Vzc2VzIHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0sIGlnbm9yZVxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuXG4gICAgICBpZiAoYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIG1vZGVyblN0YXRzVHlwZXMgPSB7XG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgY2FuZGlkYXRlcGFpcjogJ2NhbmRpZGF0ZS1wYWlyJyxcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgfTtcblxuICB2YXIgbmF0aXZlR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgdmFyIF9hcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzZWxlY3RvciA9IF9hcmd1bWVudHNbMF0sXG4gICAgICAgIG9uU3VjYyA9IF9hcmd1bWVudHNbMV0sXG4gICAgICAgIG9uRXJyID0gX2FyZ3VtZW50c1syXTtcblxuICAgIHJldHVybiBuYXRpdmVHZXRTdGF0cy5hcHBseSh0aGlzLCBbc2VsZWN0b3IgfHwgbnVsbF0pLnRoZW4oZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzICYmICFvblN1Y2MpIHtcbiAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0LCBpKSB7XG4gICAgICAgICAgICBzdGF0cy5zZXQoaSwgT2JqZWN0LmFzc2lnbih7fSwgc3RhdCwge1xuICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLl9wYyA9IF90aGlzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICB9XG5cbiAgdmFyIG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICB2YXIgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOiBQcm9taXNlLnJlc29sdmUobmV3IE1hcCgpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHJlY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuX3BjID0gX3RoaXMyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgIH07XG4gIH1cbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xuICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICBfdGhpczMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdykge1xuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcbiAgaWYgKHdpbmRvdy5EYXRhQ2hhbm5lbCAmJiAhd2luZG93LlJUQ0RhdGFDaGFubmVsKSB7XG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlciA9IGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIHZhciBpbml0UGFyYW1ldGVycyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzaG91bGRQZXJmb3JtQ2hlY2sgPSBpbml0UGFyYW1ldGVycyAmJiAnc2VuZEVuY29kaW5ncycgaW4gaW5pdFBhcmFtZXRlcnM7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICBpbml0UGFyYW1ldGVycy5zZW5kRW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgdmFyIHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcbiAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2NlaXZlciA9IG9yaWdBZGRUcmFuc2NlaXZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5pdCBvcHRpb25zIHdlcmUgYXBwbGllZC4gSWYgbm90IHdlIGRvIHRoaXMgaW4gYW5cbiAgICAgICAgLy8gYXN5bmNocm9ub3VzIHdheSBhbmQgc2F2ZSB0aGUgcHJvbWlzZSByZWZlcmVuY2UgaW4gYSBnbG9iYWwgb2JqZWN0LlxuICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHNlbmRlciBwYXJhbWV0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNyZWF0ZU9mZmVyXG4gICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IGFmdGVyIHRoZSBjcmVhdGVvZmZlciB3ZSBhcmUgbm90IDEwMCUgc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXG4gICAgICAgIC8vIG9wcG9ydHVuaXR5IHRvIHJlY3JlYXRlIG9mZmVyLlxuICAgICAgICB2YXIgc2VuZGVyID0gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XG4gICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDEgJiYgT2JqZWN0LmtleXMocGFyYW1zLmVuY29kaW5nc1swXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IGluaXRQYXJhbWV0ZXJzLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBpbml0UGFyYW1ldGVycy5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpIHtcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3JpZ0dldFBhcmFtZXRlcnMgPSB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzO1xuICBpZiAob3JpZ0dldFBhcmFtZXRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gZ2V0UGFyYW1ldGVycygpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBvcmlnR2V0UGFyYW1ldGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzLFxuICAgICAgICBfYXJndW1lbnRzMiA9IGFyZ3VtZW50cztcblxuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkoX3RoaXM0LCBfYXJndW1lbnRzMik7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzLFxuICAgICAgICBfYXJndW1lbnRzMyA9IGFyZ3VtZW50cztcblxuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KF90aGlzNSwgX2FyZ3VtZW50czMpO1xuICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoaW1HZXREaXNwbGF5TWVkaWEgPSBzaGltR2V0RGlzcGxheU1lZGlhO1xuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgdmFyIGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgKyAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XG4gICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgZXJyLmNvZGUgPSA4O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7IG1lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gc2hpbUdldFVzZXJNZWRpYTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcbiAgdmFyIG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICB2YXIgTWVkaWFTdHJlYW1UcmFjayA9IHdpbmRvdyAmJiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcblxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICB1dGlscy5kZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJywgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcblxuICBpZiAoIShicm93c2VyRGV0YWlscy52ZXJzaW9uID4gNTUgJiYgJ2F1dG9HYWluQ29udHJvbCcgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpKSkge1xuICAgIHZhciByZW1hcCA9IGZ1bmN0aW9uIHJlbWFwKG9iaiwgYSwgYikge1xuICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG5hdGl2ZUdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKCh0eXBlb2YgYyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYykpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGMuYXVkaW8pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVHZXRVc2VyTWVkaWEoYyk7XG4gICAgfTtcblxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICB2YXIgbmF0aXZlR2V0U2V0dGluZ3MgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JqID0gbmF0aXZlR2V0U2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96QXV0b0dhaW5Db250cm9sJywgJ2F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChvYmosICdtb3pOb2lzZVN1cHByZXNzaW9uJywgJ25vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cykge1xuICAgICAgdmFyIG5hdGl2ZUFwcGx5Q29uc3RyYWludHMgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdhdWRpbycgJiYgKHR5cGVvZiBjID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICAgIHJlbWFwKGMsICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgICAgcmVtYXAoYywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVBcHBseUNvbnN0cmFpbnRzLmFwcGx5KHRoaXMsIFtjXSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5zaGltTG9jYWxTdHJlYW1zQVBJID0gc2hpbUxvY2FsU3RyZWFtc0FQSTtcbmV4cG9ydHMuc2hpbVJlbW90ZVN0cmVhbXNBUEkgPSBzaGltUmVtb3RlU3RyZWFtc0FQSTtcbmV4cG9ydHMuc2hpbUNhbGxiYWNrc0FQSSA9IHNoaW1DYWxsYmFja3NBUEk7XG5leHBvcnRzLnNoaW1HZXRVc2VyTWVkaWEgPSBzaGltR2V0VXNlck1lZGlhO1xuZXhwb3J0cy5zaGltQ29uc3RyYWludHMgPSBzaGltQ29uc3RyYWludHM7XG5leHBvcnRzLnNoaW1SVENJY2VTZXJ2ZXJVcmxzID0gc2hpbVJUQ0ljZVNlcnZlclVybHM7XG5leHBvcnRzLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIgPSBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyO1xuZXhwb3J0cy5zaGltQ3JlYXRlT2ZmZXJMZWdhY3kgPSBzaGltQ3JlYXRlT2ZmZXJMZWdhY3k7XG5leHBvcnRzLnNoaW1BdWRpb0NvbnRleHQgPSBzaGltQXVkaW9Db250ZXh0O1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FkZFN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB2YXIgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXG4gICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gX2FkZFRyYWNrLmNhbGwoX3RoaXMsIHRyYWNrLCBzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gX2FkZFRyYWNrLmNhbGwoX3RoaXMsIHRyYWNrLCBzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzdHJlYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbXMpIHtcbiAgICAgICAgc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICBpZiAoIV90aGlzMi5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgICAgICBfdGhpczIuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzMi5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIF90aGlzMi5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdmFyIHRyYWNrcyA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICBpZiAodHJhY2tzLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICBfdGhpczMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0UmVtb3RlU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXMgPyB0aGlzLl9yZW1vdGVTdHJlYW1zIDogW107XG4gICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25hZGRzdHJlYW07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fb25hZGRzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtID0gZik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIGlmICghX3RoaXM0Ll9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgIF90aGlzNC5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzNC5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgX3RoaXM0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgcGMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLl9vbmFkZHN0cmVhbXBvbHkpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFwYy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBjLl9yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIG9yaWdDcmVhdGVPZmZlciA9IHByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgdmFyIG9yaWdDcmVhdGVBbnN3ZXIgPSBwcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICB2YXIgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB2YXIgc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHZhciBhZGRJY2VDYW5kaWRhdGUgPSBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuXG4gIHByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIHByb21pc2UgPSBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIHByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHJvbWlzZSA9IG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIHZhciB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiB3aXRoQ2FsbGJhY2soZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSBzZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuXG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIHdpdGhDYWxsYmFjayhkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcblxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiB3aXRoQ2FsbGJhY2soY2FuZGlkYXRlLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gYWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIFtjYW5kaWRhdGVdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gd2l0aENhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICB2YXIgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBzaGltIG5vdCBuZWVkZWQgaW4gU2FmYXJpIDEyLjFcbiAgICB2YXIgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICB2YXIgX2dldFVzZXJNZWRpYSA9IG1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChtZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICByZXR1cm4gX2dldFVzZXJNZWRpYShzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBjYiwgZXJyY2IpIHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGNiLCBlcnJjYik7XG4gICAgfS5iaW5kKG5hdmlnYXRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gIGlmIChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzLCB7IHZpZGVvOiB1dGlscy5jb21wYWN0T2JqZWN0KGNvbnN0cmFpbnRzLnZpZGVvKSB9KTtcbiAgfVxuXG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cblxuZnVuY3Rpb24gc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG1pZ3JhdGUgZnJvbSBub24tc3BlYyBSVENJY2VTZXJ2ZXIudXJsIHRvIFJUQ0ljZVNlcnZlci51cmxzXG4gIHZhciBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIHZhciBuZXdJY2VTZXJ2ZXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBjQ29uZmlnLmljZVNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlcnZlciA9IHBjQ29uZmlnLmljZVNlcnZlcnNbaV07XG4gICAgICAgIGlmICghc2VydmVyLmhhc093blByb3BlcnR5KCd1cmxzJykgJiYgc2VydmVyLmhhc093blByb3BlcnR5KCd1cmwnKSkge1xuICAgICAgICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ1JUQ0ljZVNlcnZlci51cmwnLCAnUlRDSWNlU2VydmVyLnVybHMnKTtcbiAgICAgICAgICBzZXJ2ZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlcikpO1xuICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICBkZWxldGUgc2VydmVyLnVybDtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2goc2VydmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gocGNDb25maWcuaWNlU2VydmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBjQ29uZmlnLmljZVNlcnZlcnMgPSBuZXdJY2VTZXJ2ZXJzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gIH07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBPcmlnUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICBpZiAoJ2dlbmVyYXRlQ2VydGlmaWNhdGUnIGluIE9yaWdQZWVyQ29ubmVjdGlvbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBBZGQgZXZlbnQudHJhbnNjZWl2ZXIgbWVtYmVyIG92ZXIgZGVwcmVjYXRlZCBldmVudC5yZWNlaXZlclxuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4geyByZWNlaXZlcjogdGhpcy5yZWNlaXZlciB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpIHtcbiAgdmFyIG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpIHtcbiAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xuICAgICAgfVxuICAgICAgdmFyIGF1ZGlvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nO1xuICAgICAgfSk7XG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlICYmIGF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IHRydWUgJiYgIWF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXG4gICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID0gISFvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgIH1cbiAgICAgIHZhciB2aWRlb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKGZ1bmN0aW9uICh0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJztcbiAgICAgIH0pO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSB0cnVlICYmICF2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSAhPT0gJ29iamVjdCcgfHwgd2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5leHRyYWN0VmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uO1xuZXhwb3J0cy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCA9IHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50O1xuZXhwb3J0cy5kaXNhYmxlTG9nID0gZGlzYWJsZUxvZztcbmV4cG9ydHMuZGlzYWJsZVdhcm5pbmdzID0gZGlzYWJsZVdhcm5pbmdzO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuZXhwb3J0cy5kZXRlY3RCcm93c2VyID0gZGV0ZWN0QnJvd3NlcjtcbmV4cG9ydHMuY29tcGFjdE9iamVjdCA9IGNvbXBhY3RPYmplY3Q7XG5leHBvcnRzLndhbGtTdGF0cyA9IHdhbGtTdGF0cztcbmV4cG9ydHMuZmlsdGVyU3RhdHMgPSBmaWx0ZXJTdGF0cztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGxvZ0Rpc2FibGVkXyA9IHRydWU7XG52YXIgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xuXG4vKipcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gIHZhciBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUludChtYXRjaFtwb3NdLCAxMCk7XG59XG5cbi8vIFdyYXBzIHRoZSBwZWVyY29ubmVjdGlvbiBldmVudCBldmVudE5hbWVUb1dyYXAgaW4gYSBmdW5jdGlvblxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XG4vLyB0aGUgZXZlbnQpLlxuZnVuY3Rpb24gd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCBldmVudE5hbWVUb1dyYXAsIHdyYXBwZXIpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5hZGRFdmVudExpc3RlbmVyO1xuICBwcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXApIHtcbiAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2soZSkge1xuICAgICAgdmFyIG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xuICAgICAgaWYgKG1vZGlmaWVkRXZlbnQpIHtcbiAgICAgICAgaWYgKGNiLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgY2IuaGFuZGxlRXZlbnQobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50TWFwID0gdGhpcy5fZXZlbnRNYXAgfHwge307XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNldChjYiwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB3cmFwcGVkQ2FsbGJhY2tdKTtcbiAgfTtcblxuICB2YXIgbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCB8fCAhdGhpcy5fZXZlbnRNYXAgfHwgIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5oYXMoY2IpKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB2YXIgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB1bndyYXBwZWRDYl0pO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uJyArIGV2ZW50TmFtZVRvV3JhcCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVMb2coYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyAodHlwZW9mIGJvb2wgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGJvb2wpKSArICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGxvZ0Rpc2FibGVkXyA9IGJvb2w7XG4gIHJldHVybiBib29sID8gJ2FkYXB0ZXIuanMgbG9nZ2luZyBkaXNhYmxlZCcgOiAnYWRhcHRlci5qcyBsb2dnaW5nIGVuYWJsZWQnO1xufVxuXG4vKipcbiAqIERpc2FibGUgb3IgZW5hYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG4gKiBAcGFyYW0geyFib29sZWFufSBib29sIHNldCB0byB0cnVlIHRvIGRpc2FibGUgd2FybmluZ3MuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVXYXJuaW5ncyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArICh0eXBlb2YgYm9vbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYm9vbCkpICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nc18gPSAhYm9vbDtcbiAgcmV0dXJuICdhZGFwdGVyLmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzICcgKyAoYm9vbCA/ICdkaXNhYmxlZCcgOiAnZW5hYmxlZCcpO1xufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGxvZ0Rpc2FibGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgc3VnZ2VzdGluZyB0aGUgbW9kZXJuIGFuZCBzcGVjLWNvbXBhdGlibGUgQVBJLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKG9sZE1ldGhvZCwgbmV3TWV0aG9kKSB7XG4gIGlmICghZGVwcmVjYXRpb25XYXJuaW5nc18pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG9sZE1ldGhvZCArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgbmV3TWV0aG9kICsgJyBpbnN0ZWFkLicpO1xufVxuXG4vKipcbiAqIEJyb3dzZXIgZGV0ZWN0b3IuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSByZXN1bHQgY29udGFpbmluZyBicm93c2VyIGFuZCB2ZXJzaW9uXG4gKiAgICAgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpIHtcbiAgLy8gUmV0dXJuZWQgcmVzdWx0IG9iamVjdC5cbiAgdmFyIHJlc3VsdCA9IHsgYnJvd3NlcjogbnVsbCwgdmVyc2lvbjogbnVsbCB9O1xuXG4gIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cblxuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgIC8vIEZpcmVmb3guXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgd2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uICYmICF3aW5kb3cuUlRDSWNlR2F0aGVyZXIpIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMik7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLihcXGQrKSQvKSkge1xuICAgIC8vIEVkZ2UuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnZWRnZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvRWRnZVxcLyhcXGQrKS4oXFxkKykkLywgMik7XG4gIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLykpIHtcbiAgICAvLyBTYWZhcmkuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8sIDEpO1xuICAgIHJlc3VsdC5zdXBwb3J0c1VuaWZpZWRQbGFuID0gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyICYmICdjdXJyZW50RGlyZWN0aW9uJyBpbiB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgc29tZXRoaW5nIHlvdSB3YW50IHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBlbXB0eSBvYmplY3RzIGFuZCB1bmRlZmluZWQgdmFsdWVzXG4gKiBmcm9tIGEgbmVzdGVkIG9iamVjdCAtLSBhbiBlbmhhbmNlZCBhbmQgdmFuaWxsYSB2ZXJzaW9uXG4gKiBvZiBMb2Rhc2gncyBgY29tcGFjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3QoZGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwga2V5KSB7XG4gICAgdmFyIGlzT2JqID0gaXNPYmplY3QoZGF0YVtrZXldKTtcbiAgICB2YXIgdmFsdWUgPSBpc09iaiA/IGNvbXBhY3RPYmplY3QoZGF0YVtrZXldKSA6IGRhdGFba2V5XTtcbiAgICB2YXIgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCB2YWx1ZSkpO1xuICB9LCB7fSk7XG59XG5cbi8qIGl0ZXJhdGVzIHRoZSBzdGF0cyBncmFwaCByZWN1cnNpdmVseS4gKi9cbmZ1bmN0aW9uIHdhbGtTdGF0cyhzdGF0cywgYmFzZSwgcmVzdWx0U2V0KSB7XG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnSWQnKSkge1xuICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoYmFzZVtuYW1lXSksIHJlc3VsdFNldCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCdJZHMnKSkge1xuICAgICAgYmFzZVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChpZCksIHJlc3VsdFNldCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBmaWx0ZXIgZ2V0U3RhdHMgZm9yIGEgc2VuZGVyL3JlY2VpdmVyIHRyYWNrLiAqL1xuZnVuY3Rpb24gZmlsdGVyU3RhdHMocmVzdWx0LCB0cmFjaywgb3V0Ym91bmQpIHtcbiAgdmFyIHN0cmVhbVN0YXRzVHlwZSA9IG91dGJvdW5kID8gJ291dGJvdW5kLXJ0cCcgOiAnaW5ib3VuZC1ydHAnO1xuICB2YXIgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgfVxuICB2YXIgdHJhY2tTdGF0cyA9IFtdO1xuICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJiB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRyYWNrU3RhdHMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tTdGF0KSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICBpZiAoc3RhdHMudHlwZSA9PT0gc3RyZWFtU3RhdHNUeXBlICYmIHN0YXRzLnRyYWNrSWQgPT09IHRyYWNrU3RhdC5pZCkge1xuICAgICAgICB3YWxrU3RhdHMocmVzdWx0LCBzdGF0cywgZmlsdGVyZWRSZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xufVxuIiwiLypcbldpbGRFbWl0dGVyLmpzIGlzIGEgc2xpbSBsaXR0bGUgZXZlbnQgZW1pdHRlciBieSBAaGVucmlram9yZXRlZyBsYXJnZWx5IGJhc2VkXG5vbiBAdmlzaW9ubWVkaWEncyBFbWl0dGVyIGZyb20gVUkgS2l0LlxuXG5XaHk/IEkgd2FudGVkIGl0IHN0YW5kYWxvbmUuXG5cbkkgYWxzbyB3YW50ZWQgc3VwcG9ydCBmb3Igd2lsZGNhcmQgZW1pdHRlcnMgbGlrZSB0aGlzOlxuXG5lbWl0dGVyLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50TmFtZSwgb3RoZXIsIGV2ZW50LCBwYXlsb2Fkcykge1xuXG59KTtcblxuZW1pdHRlci5vbignc29tZW5hbWVzcGFjZSonLCBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXlsb2Fkcykge1xuXG59KTtcblxuUGxlYXNlIG5vdGUgdGhhdCBjYWxsYmFja3MgdHJpZ2dlcmVkIGJ5IHdpbGRjYXJkIHJlZ2lzdGVyZWQgZXZlbnRzIGFsc28gZ2V0XG50aGUgZXZlbnQgbmFtZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdpbGRFbWl0dGVyO1xuXG5mdW5jdGlvbiBXaWxkRW1pdHRlcigpIHsgfVxuXG5XaWxkRW1pdHRlci5taXhpbiA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvcikge1xuICAgIHZhciBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwgY29uc3RydWN0b3I7XG5cbiAgICBwcm90b3R5cGUuaXNXaWxkRW1pdHRlcj0gdHJ1ZTtcblxuICAgIC8vIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuIFN0b3JlIGEgZ3JvdXAgbmFtZSBpZiBwcmVzZW50LlxuICAgIHByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgZ3JvdXBOYW1lLCBmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICB2YXIgaGFzR3JvdXAgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyksXG4gICAgICAgICAgICBncm91cCA9IGhhc0dyb3VwID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZnVuYyA9IGhhc0dyb3VwID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzFdO1xuICAgICAgICBmdW5jLl9ncm91cE5hbWUgPSBncm91cDtcbiAgICAgICAgKHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICAgIC8vIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gICAgcHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGdyb3VwTmFtZSwgZm4pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaGFzR3JvdXAgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyksXG4gICAgICAgICAgICBncm91cCA9IGhhc0dyb3VwID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZnVuYyA9IGhhc0dyb3VwID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzFdO1xuICAgICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbihldmVudCwgZ3JvdXAsIG9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIFVuYmluZHMgYW4gZW50aXJlIGdyb3VwXG4gICAgcHJvdG90eXBlLnJlbGVhc2VHcm91cCA9IGZ1bmN0aW9uIChncm91cE5hbWUpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgdmFyIGl0ZW0sIGksIGxlbiwgaGFuZGxlcnM7XG4gICAgICAgIGZvciAoaXRlbSBpbiB0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLmNhbGxiYWNrc1tpdGVtXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzW2ldLl9ncm91cE5hbWUgPT09IGdyb3VwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZW1vdmluZycpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgaXQgYW5kIHNob3J0ZW4gdGhlIGFycmF5IHdlJ3JlIGxvb3BpbmcgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICAgIC8vIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgIHByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MgfHwge307XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICBpID0gY2FsbGJhY2tzLmluZGV4T2YoZm4pO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vLyBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAgICAvLyBhbHNvIGNhbGxzIGFueSBgKmAgaGFuZGxlcnNcbiAgICBwcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XSxcbiAgICAgICAgICAgIHNwZWNpYWxDYWxsYmFja3MgPSB0aGlzLmdldFdpbGRjYXJkQ2FsbGJhY2tzKGV2ZW50KSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgbGlzdGVuZXJzO1xuXG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjaWFsQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBsZW4gPSBzcGVjaWFsQ2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IHNwZWNpYWxDYWxsYmFja3Muc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgW2V2ZW50XS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEhlbHBlciBmb3IgZm9yIGZpbmRpbmcgc3BlY2lhbCB3aWxkY2FyZCBldmVudCBoYW5kbGVycyB0aGF0IG1hdGNoIHRoZSBldmVudFxuICAgIHByb3RvdHlwZS5nZXRXaWxkY2FyZENhbGxiYWNrcyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcyB8fCB7fTtcbiAgICAgICAgdmFyIGl0ZW0sXG4gICAgICAgICAgICBzcGxpdCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoaXRlbSBpbiB0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgc3BsaXQgPSBpdGVtLnNwbGl0KCcqJyk7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gJyonIHx8IChzcGxpdC5sZW5ndGggPT09IDIgJiYgZXZlbnROYW1lLnNsaWNlKDAsIHNwbGl0WzBdLmxlbmd0aCkgPT09IHNwbGl0WzBdKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5jYWxsYmFja3NbaXRlbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxufTtcblxuV2lsZEVtaXR0ZXIubWl4aW4oV2lsZEVtaXR0ZXIpO1xuIl19\n\n\n//# sourceURL=webpack://assets/./src/nexmoClient.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/nexmoClient.js");
/******/ 	
/******/ })()
;