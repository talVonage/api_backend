import { a as attr, F as FoundationElement, D as DOM, h as html, r as registerFactory } from './index.js';
import { P as Popup, p as popupRegistries } from './definition58.js';
import { w as when } from './when.js';
import { c as classNames } from './class-names.js';

const styles = "/**\n * Do not edit directly\n * Generated on Tue, 17 Oct 2023 15:27:52 GMT\n */\n.control {\n  display: inline-block;\n}\n\n.content-wrapper {\n  width: var(--toggletip-inline-size, auto);\n  padding: 16px;\n}\n\n.headline {\n  font: var(--vvd-typography-base-bold);\n}\n\n.action-items {\n  display: flex;\n  justify-content: flex-end;\n  gap: 10px;\n}\n\n::slotted([slot=action-items]) {\n  margin-block-start: 16px;\n}";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class Toggletip extends FoundationElement {
  constructor() {
    super(...arguments);
    this.#anchorEl = null;
    this.#observeMissingAnchor = (anchorId) => {
      this.#observer = new MutationObserver(() => {
        const anchor = document.getElementById(anchorId);
        if (anchor) {
          this.#anchorEl = anchor;
          this.#setupAnchor(this.#anchorEl);
          this.#observer.disconnect();
          this.#observer = void 0;
        }
      });
      this.#observer.observe(document.body, { childList: true, subtree: true });
    };
    this.#ANCHOR_ARIA_LABEL_SUFFIX = " ; Show more information";
    this.alternate = false;
    this.placement = "right";
    this.anchor = "";
    this.open = false;
    this.#openIfClosed = () => {
      if (!this.open)
        DOM.queueUpdate(() => this.open = true);
    };
    this.#closeOnClickOutside = (e) => {
      if (!this.contains(e.target))
        this.open = false;
    };
    this.#closeOnEscape = (e) => {
      if (e.key === "Escape")
        this.open = false;
    };
  }
  #observer;
  #anchorEl;
  #observeMissingAnchor;
  #ANCHOR_ARIA_LABEL_SUFFIX;
  anchorChanged(_, newValue) {
    if (this.#anchorEl)
      this.#cleanupAnchor(this.#anchorEl);
    this.#observer?.disconnect();
    this.#anchorEl = newValue instanceof HTMLElement ? newValue : document.getElementById(newValue);
    if (this.#anchorEl) {
      this.#setupAnchor(this.#anchorEl);
    } else {
      this.#observeMissingAnchor(newValue);
    }
  }
  openChanged(oldValue, newValue) {
    if (oldValue === void 0)
      return;
    if (newValue) {
      document.addEventListener("click", this.#closeOnClickOutside);
      document.addEventListener("keydown", this.#closeOnEscape);
      this.setAttribute("role", "status");
    } else {
      document.removeEventListener("click", this.#closeOnClickOutside);
      document.removeEventListener("keydown", this.#closeOnEscape);
      this.removeAttribute("role");
    }
    if (this.#anchorEl) {
      this.#anchorEl.ariaExpanded = this.open.toString();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#anchorEl)
      this.#cleanupAnchor(this.#anchorEl);
    this.#observer?.disconnect();
    document.removeEventListener("keydown", this.#closeOnEscape);
  }
  #setupAnchor(a) {
    a.addEventListener("click", this.#openIfClosed, true);
    a.ariaLabel = (a.ariaLabel ?? "") + this.#ANCHOR_ARIA_LABEL_SUFFIX;
  }
  #cleanupAnchor(a) {
    a.removeEventListener("click", this.#openIfClosed, true);
    if (a.ariaLabel)
      a.ariaLabel = a.ariaLabel.replace(this.#ANCHOR_ARIA_LABEL_SUFFIX, "");
  }
  #openIfClosed;
  #closeOnClickOutside;
  #closeOnEscape;
}
__decorateClass([
  attr
], Toggletip.prototype, "headline", 2);
__decorateClass([
  attr({ mode: "boolean" })
], Toggletip.prototype, "alternate", 2);
__decorateClass([
  attr({ mode: "fromView" })
], Toggletip.prototype, "placement", 2);
__decorateClass([
  attr({ mode: "fromView" })
], Toggletip.prototype, "anchor", 2);
__decorateClass([
  attr({ mode: "boolean" })
], Toggletip.prototype, "open", 2);

const getClasses = (_) => classNames("control");
const ToggletipTemplate = (context) => {
  const popup = context.tagFor(Popup);
  return html`
		<${popup}
			class="${getClasses}"
			arrow
			:anchor="${(x) => x.anchor}"
			:open="${(x) => x.open}"
			?alternate="${(x) => !x.alternate}"
			placement="${(x) => x.placement}"
			exportparts="vvd-theme-alternate"
		>
			<div class="content-wrapper">
				${when((x) => x.headline, html`<header class="headline">${(x) => x.headline}</header>`)}
				<slot></slot>
				<footer class="action-items"><slot name="action-items"></slot></footer>
			</div>
		</${popup}>
	`;
};

const toggletipDefinition = Toggletip.compose({
  baseName: "toggletip",
  template: ToggletipTemplate,
  styles
});
const toggletipRegistries = [toggletipDefinition(), ...popupRegistries];
const registerToggletip = registerFactory(toggletipRegistries);

export { toggletipRegistries as a, registerToggletip as r, toggletipDefinition as t };
