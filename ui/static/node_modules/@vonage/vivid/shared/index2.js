import { I as Icon } from './icon.js';
import { a as attr, o as observable, h as html } from './index.js';
import { w as when } from './when.js';
import enUS from '../locales/en-US.js';

const messageStyles = "/**\n * Do not edit directly\n * Generated on Tue, 17 Oct 2023 15:27:52 GMT\n */\n.message {\n  display: flex;\n  contain: inline-size;\n  font: var(--vvd-typography-base-condensed);\n  gap: 4px;\n  grid-column: 1/-1;\n}\n.message-text {\n  color: var(--vvd-color-canvas-text);\n}\n.helper-message .message-text {\n  color: var(--_low-ink-color);\n}\n.message-icon {\n  font-size: 16px;\n}\n.success-message .message-icon {\n  color: var(--vvd-color-success-500);\n}\n.error-message .message-icon {\n  color: var(--vvd-color-alert-500);\n}";

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
class FormElementHelperText {
}
__decorateClass$1([
  attr({ attribute: "helper-text" })
], FormElementHelperText.prototype, "helperText", 2);
class FormElementSuccessText {
}
__decorateClass$1([
  attr({ attribute: "success-text" })
], FormElementSuccessText.prototype, "successText", 2);
class FormElementCharCount {
  constructor() {
    this.charCount = false;
  }
}
__decorateClass$1([
  attr({
    attribute: "char-count",
    mode: "boolean"
  })
], FormElementCharCount.prototype, "charCount", 2);
function formElements(constructor) {
  class Decorated extends constructor {
    constructor(...args) {
      super(...args);
      this.errorValidationMessage = "";
      this.#forceErrorDisplay = false;
      this.#hasBeenTouched = false;
      this.#handleInvalidEvent = () => {
        this.#forceErrorDisplay = true;
        this.validate();
      };
      this.validate = () => {
        super.validate();
        const shouldShowValidationError = this.#forceErrorDisplay || this.#hasBeenTouched && this.dirtyValue;
        this.errorValidationMessage = shouldShowValidationError ? this.validationMessage : "";
      };
      this.addEventListener("blur", () => {
        this.#hasBeenTouched = true;
        this.#forceErrorDisplay = false;
        this.validate();
      });
      this.addEventListener("focus", () => {
        this.#hasBeenTouched = false;
      });
      this.addEventListener("invalid", () => {
        this.proxy.dispatchEvent(new Event("invalid"));
      });
    }
    #forceErrorDisplay;
    #hasBeenTouched;
    connectedCallback() {
      super.connectedCallback();
      this.proxy.addEventListener("invalid", this.#handleInvalidEvent);
    }
    #handleInvalidEvent;
    disconnectedCallback() {
      super.disconnectedCallback();
      this.proxy.removeEventListener("invalid", this.#handleInvalidEvent);
    }
    formResetCallback() {
      this.#forceErrorDisplay = false;
      super.formResetCallback();
      this.validate();
    }
  }
  __decorateClass$1([
    attr
  ], Decorated.prototype, "label", 2);
  __decorateClass$1([
    observable
  ], Decorated.prototype, "errorValidationMessage", 2);
  return Decorated;
}
function getFeedbackTemplate(messageType, context) {
  const MessageTypeMap = {
    helper: {
      messageProperty: "helperText",
      className: "helper",
      iconType: ""
    },
    error: {
      messageProperty: "errorValidationMessage",
      className: "error",
      iconType: "info-line"
    },
    success: {
      messageProperty: "successText",
      className: "success",
      iconType: "check-circle-line"
    }
  };
  const iconTag = context.tagFor(Icon);
  const messageTypeConfig = MessageTypeMap[messageType];
  const iconType = messageTypeConfig.iconType;
  return html` <style>
			${messageStyles}
		</style>
		<div class="message ${MessageTypeMap[messageType].className}-message">
			${when(
    () => iconType,
    html`
					  <${iconTag} class="message-icon" name="${iconType}"></${iconTag}>`
  )}
			${feedbackMessage({
    messageProperty: MessageTypeMap[messageType].messageProperty
  })}
		</div>`;
}
function feedbackMessage({
  messageProperty
}) {
  return html`
		<span class="message-text">${(x) => x[messageProperty]}</span>
	`;
}
function errorText(constructor) {
  class Decorated extends constructor {
    constructor(...args) {
      super(...args);
      this.#blockValidateCalls = false;
      this._validate = this.validate;
      this.validate = () => {
        if (!this.#blockValidateCalls)
          this._validate();
      };
    }
    #blockValidateCalls;
    errorTextChanged(_, newErrorText) {
      if (newErrorText) {
        this.#forceCustomError(newErrorText);
      } else {
        this.#clearCustomErrorAndRevalidate();
      }
    }
    #forceCustomError(errorMessage) {
      this.setValidity({ customError: true }, errorMessage, this.control);
      this.errorValidationMessage = errorMessage;
      this.#blockValidateCalls = true;
    }
    #clearCustomErrorAndRevalidate() {
      this.setValidity({ customError: false }, "", this.control);
      this.#blockValidateCalls = false;
      this.validate();
    }
  }
  __decorateClass$1([
    attr({ attribute: "error-text" })
  ], Decorated.prototype, "errorText", 2);
  return Decorated;
}

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class CurrentLocale {
  constructor() {
    this.locale = enUS;
  }
}
__decorateClass([
  observable
], CurrentLocale.prototype, "locale", 2);
const currentLocale = new CurrentLocale();
const setLocale = (locale) => {
  currentLocale.locale = locale;
};

export { FormElementSuccessText as F, FormElementHelperText as a, FormElementCharCount as b, currentLocale as c, errorText as e, formElements as f, getFeedbackTemplate as g, setLocale as s };
