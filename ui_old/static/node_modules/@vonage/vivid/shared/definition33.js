import { F as FoundationElement, D as DOM, _ as __decorate, a as attr, n as nullableNumberConverter, o as observable, h as html, r as registerFactory } from './index.js';
import { B as Button, S as Shape, a as buttonRegistries } from './definition10.js';
import { D as Divider, a as dividerRegistries } from './definition20.js';
import { A as AffixIcon } from './affix.js';
import { e as errorText, f as formElements, F as FormElementSuccessText, a as FormElementHelperText, b as FormElementCharCount, g as getFeedbackTemplate } from './index2.js';
import { S as StartEnd } from './start-end.js';
import { a as applyMixins } from './apply-mixins.js';
import { D as DelegatesARIATextbox } from './text-field2.js';
import { F as FormAssociated } from './form-associated.js';
import { d as keyArrowDown, e as keyArrowUp } from './key-codes.js';
import { f as focusTemplateFactory } from './focus2.js';
import { w as when } from './when.js';
import { r as ref } from './ref.js';
import { c as classNames } from './class-names.js';

class _NumberField extends FoundationElement {
}
/**
 * A form-associated base class for the {@link @microsoft/fast-foundation#(NumberField:class)} component.
 *
 * @internal
 */
class FormAssociatedNumberField extends FormAssociated(_NumberField) {
    constructor() {
        super(...arguments);
        this.proxy = document.createElement("input");
    }
}

/**
 * A Number Field Custom HTML Element.
 * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number | <input type="number" /> element }.
 *
 * @slot start - Content which can be provided before the number field input
 * @slot end - Content which can be provided after the number field input
 * @slot - The default slot for the label
 * @slot step-up-glyph - The glyph for the step up control
 * @slot step-down-glyph - The glyph for the step down control
 * @csspart label - The label
 * @csspart root - The element wrapping the control, including start and end slots
 * @csspart control - The element representing the input
 * @csspart controls - The step up and step down controls
 * @csspart step-up - The step up control
 * @csspart step-down - The step down control
 * @fires input - Fires a custom 'input' event when the value has changed
 * @fires change - Fires a custom 'change' event when the value has changed
 *
 * @public
 */
let NumberField$1 = class NumberField extends FormAssociatedNumberField {
    constructor() {
        super(...arguments);
        /**
         * When true, spin buttons will not be rendered
         * @public
         * @remarks
         * HTML Attribute: autofocus
         */
        this.hideStep = false;
        /**
         * Amount to increment or decrement the value by
         * @public
         * @remarks
         * HTMLAttribute: step
         */
        this.step = 1;
        /**
         * Flag to indicate that the value change is from the user input
         * @internal
         */
        this.isUserInput = false;
    }
    /**
     * Ensures that the max is greater than the min and that the value
     *  is less than the max
     * @param previous - the previous max value
     * @param next - updated max value
     *
     * @internal
     */
    maxChanged(previous, next) {
        var _a;
        this.max = Math.max(next, (_a = this.min) !== null && _a !== void 0 ? _a : next);
        const min = Math.min(this.min, this.max);
        if (this.min !== undefined && this.min !== min) {
            this.min = min;
        }
        this.value = this.getValidValue(this.value);
    }
    /**
     * Ensures that the min is less than the max and that the value
     *  is greater than the min
     * @param previous - previous min value
     * @param next - updated min value
     *
     * @internal
     */
    minChanged(previous, next) {
        var _a;
        this.min = Math.min(next, (_a = this.max) !== null && _a !== void 0 ? _a : next);
        const max = Math.max(this.min, this.max);
        if (this.max !== undefined && this.max !== max) {
            this.max = max;
        }
        this.value = this.getValidValue(this.value);
    }
    /**
     * The value property, typed as a number.
     *
     * @public
     */
    get valueAsNumber() {
        return parseFloat(super.value);
    }
    set valueAsNumber(next) {
        this.value = next.toString();
    }
    /**
     * Validates that the value is a number between the min and max
     * @param previous - previous stored value
     * @param next - value being updated
     * @param updateControl - should the text field be updated with value, defaults to true
     * @internal
     */
    valueChanged(previous, next) {
        this.value = this.getValidValue(next);
        if (next !== this.value) {
            return;
        }
        if (this.control && !this.isUserInput) {
            this.control.value = this.value;
        }
        super.valueChanged(previous, this.value);
        if (previous !== undefined && !this.isUserInput) {
            this.$emit("input");
            this.$emit("change");
        }
        this.isUserInput = false;
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate() {
        super.validate(this.control);
    }
    /**
     * Sets the internal value to a valid number between the min and max properties
     * @param value - user input
     *
     * @internal
     */
    getValidValue(value) {
        var _a, _b;
        let validValue = parseFloat(parseFloat(value).toPrecision(12));
        if (isNaN(validValue)) {
            validValue = "";
        }
        else {
            validValue = Math.min(validValue, (_a = this.max) !== null && _a !== void 0 ? _a : validValue);
            validValue = Math.max(validValue, (_b = this.min) !== null && _b !== void 0 ? _b : validValue).toString();
        }
        return validValue;
    }
    /**
     * Increments the value using the step value
     *
     * @public
     */
    stepUp() {
        const value = parseFloat(this.value);
        const stepUpValue = !isNaN(value)
            ? value + this.step
            : this.min > 0
                ? this.min
                : this.max < 0
                    ? this.max
                    : !this.min
                        ? this.step
                        : 0;
        this.value = stepUpValue.toString();
    }
    /**
     * Decrements the value using the step value
     *
     * @public
     */
    stepDown() {
        const value = parseFloat(this.value);
        const stepDownValue = !isNaN(value)
            ? value - this.step
            : this.min > 0
                ? this.min
                : this.max < 0
                    ? this.max
                    : !this.min
                        ? 0 - this.step
                        : 0;
        this.value = stepDownValue.toString();
    }
    /**
     * Sets up the initial state of the number field
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        this.proxy.setAttribute("type", "number");
        this.validate();
        this.control.value = this.value;
        if (this.autofocus) {
            DOM.queueUpdate(() => {
                this.focus();
            });
        }
    }
    /**
     * Selects all the text in the number field
     *
     * @public
     */
    select() {
        this.control.select();
        /**
         * The select event does not permeate the shadow DOM boundary.
         * This fn effectively proxies the select event,
         * emitting a `select` event whenever the internal
         * control emits a `select` event
         */
        this.$emit("select");
    }
    /**
     * Handles the internal control's `input` event
     * @internal
     */
    handleTextInput() {
        this.control.value = this.control.value.replace(/[^0-9\-+e.]/g, "");
        this.isUserInput = true;
        this.value = this.control.value;
    }
    /**
     * Change event handler for inner control.
     * @remarks
     * "Change" events are not `composable` so they will not
     * permeate the shadow DOM boundary. This fn effectively proxies
     * the change event, emitting a `change` event whenever the internal
     * control emits a `change` event
     * @internal
     */
    handleChange() {
        this.$emit("change");
    }
    /**
     * Handles the internal control's `keydown` event
     * @internal
     */
    handleKeyDown(e) {
        const key = e.key;
        switch (key) {
            case keyArrowUp:
                this.stepUp();
                return false;
            case keyArrowDown:
                this.stepDown();
                return false;
        }
        return true;
    }
    /**
     * Handles populating the input field with a validated value when
     *  leaving the input field.
     * @internal
     */
    handleBlur() {
        this.control.value = this.value;
    }
};
__decorate([
    attr({ attribute: "readonly", mode: "boolean" })
], NumberField$1.prototype, "readOnly", void 0);
__decorate([
    attr({ mode: "boolean" })
], NumberField$1.prototype, "autofocus", void 0);
__decorate([
    attr({ attribute: "hide-step", mode: "boolean" })
], NumberField$1.prototype, "hideStep", void 0);
__decorate([
    attr
], NumberField$1.prototype, "placeholder", void 0);
__decorate([
    attr
], NumberField$1.prototype, "list", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "maxlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "minlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "size", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "step", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "max", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], NumberField$1.prototype, "min", void 0);
__decorate([
    observable
], NumberField$1.prototype, "defaultSlottedNodes", void 0);
applyMixins(NumberField$1, StartEnd, DelegatesARIATextbox);

const styles = "/**\n * Do not edit directly\n * Generated on Tue, 17 Oct 2023 15:27:52 GMT\n */\n:host {\n  display: inline-block;\n}\n\n.base {\n  --_text-field-gutter: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) / 2.5);\n  --_text-field-icon-size: calc(calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2))) / 2);\n  display: inline-grid;\n  width: 100%;\n  gap: 4px;\n  grid-template-columns: min-content 1fr max-content;\n}\n.base {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-intermediate);\n}\n.base.appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-firm);\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)).appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: var(--vvd-color-neutral-100);\n  --_appearance-color-outline: var(--vvd-color-neutral-300);\n}\n.base:where(:disabled, .disabled).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--vvd-color-neutral-200);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-600);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base.connotation-success {\n  /* @cssprop [--vvd-text-field-success-primary=var(--vvd-color-success-500)] */\n  --_connotation-color-primary: var(--vvd-text-field-success-primary, var(--vvd-color-success-500));\n  /* @cssprop [--vvd-text-field-success-backdrop=var(--vvd-color-success-50)] */\n  --_connotation-color-backdrop: var(--vvd-text-field-success-backdrop, var(--vvd-color-success-50));\n  /* @cssprop [--vvd-text-field-success-intermediate=var(--vvd-color-success-500)] */\n  --_connotation-color-intermediate: var(--vvd-text-field-success-intermediate, var(--vvd-color-success-500));\n  /* @cssprop [--vvd-text-field-success-firm=var(--vvd-color-success-600)] */\n  --_connotation-color-firm: var(--vvd-text-field-success-firm, var(--vvd-color-success-600));\n  /* @cssprop [--vvd-text-field-success-faint=var(--vvd-color-success-50)] */\n  --_connotation-color-faint: var(--vvd-text-field-success-faint, var(--vvd-color-success-50));\n  /* @cssprop [--vvd-text-field-success-soft=var(--vvd-color-success-100)] */\n  --_connotation-color-soft: var(--vvd-text-field-success-soft, var(--vvd-color-success-100));\n}\n.base.connotation-alert {\n  /* @cssprop [--vvd-text-field-alert-primary=var(--vvd-color-alert-500)] */\n  --_connotation-color-primary: var(--vvd-text-field-alert-primary, var(--vvd-color-alert-500));\n  /* @cssprop [--vvd-text-field-alert-backdrop=var(--vvd-color-alert-50)] */\n  --_connotation-color-backdrop: var(--vvd-text-field-alert-backdrop, var(--vvd-color-alert-50));\n  /* @cssprop [--vvd-text-field-alert-intermediate=var(--vvd-color-alert-500)] */\n  --_connotation-color-intermediate: var(--vvd-text-field-alert-intermediate, var(--vvd-color-alert-500));\n  /* @cssprop [--vvd-text-field-alert-firm=var(--vvd-color-alert-600)] */\n  --_connotation-color-firm: var(--vvd-text-field-alert-firm, var(--vvd-color-alert-600));\n  /* @cssprop [--vvd-text-field-alert-faint=var(--vvd-color-alert-50)] */\n  --_connotation-color-faint: var(--vvd-text-field-alert-faint, var(--vvd-color-alert-50));\n  /* @cssprop [--vvd-text-field-alert-soft=var(--vvd-color-alert-100)] */\n  --_connotation-color-soft: var(--vvd-text-field-alert-soft, var(--vvd-color-alert-100));\n}\n.base:not(.connotation-success, .connotation-alert) {\n  /* @cssprop [--vvd-text-field-accent-primary=var(--vvd-color-canvas-text)] */\n  --_connotation-color-primary: var(--vvd-text-field-accent-primary, var(--vvd-color-canvas-text));\n  /* @cssprop [--vvd-text-field-accent-backdrop=var(--vvd-color-canvas)] */\n  --_connotation-color-backdrop: var(--vvd-text-field-accent-backdrop, var(--vvd-color-canvas));\n  /* @cssprop [--vvd-text-field-accent-intermediate=var(--vvd-color-neutral-500)] */\n  --_connotation-color-intermediate: var(--vvd-text-field-accent-intermediate, var(--vvd-color-neutral-500));\n  /* @cssprop [--vvd-text-field-accent-firm=var(--vvd-color-canvas-text)] */\n  --_connotation-color-firm: var(--vvd-text-field-accent-firm, var(--vvd-color-canvas-text));\n  /* @cssprop [--vvd-text-field-accent-faint=var(--vvd-color-neutral-50)] */\n  --_connotation-color-faint: var(--vvd-text-field-accent-faint, var(--vvd-color-neutral-50));\n  /* @cssprop [--vvd-text-field-accent-soft=var(--vvd-color-neutral-100)] */\n  --_connotation-color-soft: var(--vvd-text-field-accent-soft, var(--vvd-color-neutral-100));\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  --_low-ink-color: var(--vvd-color-neutral-600);\n}\n.base.disabled {\n  --_low-ink-color: var(--_appearance-color-text);\n}\n\n.label {\n  color: var(--vvd-color-canvas-text);\n  contain: inline-size;\n  font: var(--vvd-typography-base);\n  grid-column: 1/4;\n  grid-row: 1;\n}\n.char-count + .label {\n  grid-column: 1/3;\n}\n\n.char-count {\n  color: var(--_low-ink-color);\n  font: var(--vvd-typography-base);\n  grid-column: 3/4;\n}\n\n.fieldset {\n  position: relative;\n  display: flex;\n  align-items: center;\n  background-color: var(--_appearance-color-fill);\n  font: var(--vvd-typography-base);\n  grid-column: 1/4;\n  padding-block: 0;\n  transition: color 0.2s, background-color 0.2s;\n  /* Shape */\n}\n.fieldset::after {\n  position: absolute;\n  display: block;\n  block-size: 100%;\n  border-radius: inherit;\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  content: \"\";\n  inline-size: 100%;\n  pointer-events: none;\n  transition: box-shadow 0.2s;\n}\n.fieldset:focus-visible {\n  outline: none;\n}\n.base > .fieldset {\n  block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n}\n.base:not(.shape-pill) .fieldset {\n  border-radius: 6px;\n}\n.base.shape-pill .fieldset {\n  border-radius: 24px;\n}\n\n.wrapper {\n  block-size: 100%;\n  border-radius: inherit;\n  inline-size: 100%;\n}\n.wrapper:focus-visible {\n  outline: none;\n}\n\n.control {\n  width: 100%;\n  box-sizing: border-box;\n  border: 0 none;\n  appearance: none; /* for box-shadow visibility on IOS */\n  background-color: transparent;\n  block-size: 100%;\n  border-radius: inherit;\n  color: inherit;\n  font: inherit;\n  padding-block: 0;\n  padding-inline-end: var(--_text-field-gutter);\n  padding-inline-start: var(--_text-field-gutter);\n}\n.control:disabled {\n  cursor: not-allowed;\n  opacity: 1; /* 2. correct opacity on iOS */\n  -webkit-text-fill-color: var(--_appearance-color-text); /* 1. sets text fill to current `color` for safari */\n}\n.control::placeholder, .control:disabled::placeholder {\n  opacity: 1; /* 2. correct opacity on iOS */\n  -webkit-text-fill-color: var(--_low-ink-color); /* 1. sets text fill to current `color` for safari */\n}\n.control:focus-visible {\n  outline: none;\n}\n.has-icon .control {\n  padding-inline-start: calc(var(--_text-field-icon-size) + var(--_text-field-gutter) * 2);\n}\n\n.icon {\n  position: absolute;\n  z-index: 1;\n  color: var(--_low-ink-color);\n  font-size: var(--_text-field-icon-size);\n  inset-block-start: 50%;\n  inset-inline-start: calc(100% + var(--_text-field-gutter));\n  line-height: 1;\n  transform: translateY(-50%);\n}\n\n.leading-items-wrapper {\n  position: relative;\n}\n.base.no-leading .leading-items-wrapper {\n  display: none;\n}\n\n.action-items-wrapper {\n  margin-inline-end: 4px;\n}\n.base:not(.action-items) .action-items-wrapper {\n  display: none;\n}\n\n.focus-indicator {\n  --focus-stroke-gap-color: transparent;\n  pointer-events: none;\n}\n.wrapper:not(:focus-visible, :focus-within) > .focus-indicator, .fieldset:not(:focus-visible, :focus-within) > .focus-indicator {\n  display: none;\n}\n\n.control {\n  padding-inline-end: 70px;\n}\n.control::-webkit-outer-spin-button, .control::-webkit-inner-spin-button {\n  appearance: none;\n}\n.control-buttons {\n  position: absolute;\n  z-index: 1;\n  right: 3px;\n  display: flex;\n}\n.readonly .control-buttons, .disabled .control-buttons {\n  pointer-events: none;\n}\n.control-buttons .divider {\n  margin-block: 8px;\n}\n.control-buttons > * {\n  flex-shrink: 0;\n}\n\n.disabled .focus-indicator {\n  display: none;\n  pointer-events: none;\n}";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
const STEP_DIRECTION = {
  up: 1,
  down: -1
};
const PROXY_REFLECTED_ATTRIBUTES = {
  max: true,
  min: true
};
function makeStep(element, direction) {
  const value = parseFloat(element.value);
  const stepUpValue = !isNaN(value) ? value + direction * element.step : element.min > 0 ? element.min : element.max < 0 ? element.max : !element.min ? direction * element.step : 0;
  element.value = Number(stepUpValue.toFixed(12)).toString();
}
let NumberField = class extends NumberField$1 {
  stepChanged(_previous, next) {
    this.proxy.setAttribute("step", Number.isFinite(next) ? next.toString() : "");
  }
  attributeChangedCallback(name, previous, next) {
    super.attributeChangedCallback(name, previous, next);
    if (PROXY_REFLECTED_ATTRIBUTES[name]) {
      this.proxy.setAttribute(name, next);
    }
  }
  stepUp() {
    makeStep(this, STEP_DIRECTION.up);
  }
  stepDown() {
    makeStep(this, STEP_DIRECTION.down);
  }
};
__decorateClass([
  attr
], NumberField.prototype, "appearance", 2);
__decorateClass([
  attr
], NumberField.prototype, "shape", 2);
__decorateClass([
  attr
], NumberField.prototype, "autoComplete", 2);
NumberField = __decorateClass([
  errorText,
  formElements
], NumberField);
const numberInput = document.createElement("input");
numberInput.type = "number";
NumberField.prototype.getValidValue = function(value) {
  if (!this.isUserInput) {
    numberInput.value = value;
    return numberInput.value;
  }
  if (value === "" || value === "-" || value === ".") {
    return value;
  }
  const decimalSplit = value.split(".");
  let valueSuffix = "";
  if (decimalSplit.length === 2 && decimalSplit[1] === "") {
    valueSuffix = ".";
    numberInput.value = value.slice(0, -1);
  } else {
    numberInput.value = value;
  }
  if (numberInput.value === "") {
    return this.currentValue;
  }
  return numberInput.value + valueSuffix;
};
applyMixins(NumberField, AffixIcon, FormElementCharCount, FormElementHelperText, FormElementSuccessText);

const getStateClasses = ({
  errorValidationMessage,
  disabled,
  value,
  readOnly,
  placeholder,
  appearance,
  shape,
  label,
  successText
}) => classNames(
  ["error connotation-alert", Boolean(errorValidationMessage)],
  ["disabled", disabled],
  ["has-value", Boolean(value)],
  ["readonly", readOnly],
  ["placeholder", Boolean(placeholder)],
  [`appearance-${appearance}`, Boolean(appearance)],
  [`shape-${shape}`, Boolean(shape)],
  ["no-label", !label],
  ["success connotation-success", !!successText]
);
function renderLabel() {
  return html`
	  <label for="control" class="label">
		  ${(x) => x.label}
	  </label>`;
}
function setControlButtonShape(numberField) {
  return numberField.shape === Shape.Pill ? Shape.Pill : null;
}
function getTabIndex(numberField) {
  return numberField.disabled || numberField.readOnly ? "-1" : null;
}
function numberControlButtons(context) {
  const buttonTag = context.tagFor(Button);
  const dividerTag = context.tagFor(Divider);
  return html`
			<div class="control-buttons"
			     ?inert="${(x) => x.disabled || x.readOnly}">
				<${buttonTag} id="subtract" icon="minus-line"
					            shape="${setControlButtonShape}"
								type="button"
					            size="condensed"
					  					tabindex="${getTabIndex}"
					            @click="${(x) => x.stepDown()}"></${buttonTag}>
				<${dividerTag} class="divider" orientation="vertical"></${dividerTag}>
				<${buttonTag} id="add" icon="plus-line"
					            shape="${setControlButtonShape}"
								type="button"
					            size="condensed"
					  					tabindex="${getTabIndex}"
					            @click="${(x) => x.stepUp()}"></${buttonTag}>
		    </div>
	`;
}
const NumberFieldTemplate = (context) => {
  const focusTemplate = focusTemplateFactory(context);
  return html`
	<div class="base ${getStateClasses}">
    ${when((x) => x.label, renderLabel())}
    <div class="fieldset">
			<div class="wrapper">
				<input class="control"
							 id="control"
							 @input="${(x) => x.handleTextInput()}"
							 @change="${(x) => x.handleChange()}"
							 ?autofocus="${(x) => x.autofocus}"
							 ?disabled="${(x) => x.disabled}"
							 list="${(x) => x.list}"
							 step="${(x) => x.step ? x.step : null}"
							 max="${(x) => x.max}"
							 min="${(x) => x.min}"
							 maxlength="${(x) => x.maxlength}"
							 minlength="${(x) => x.minlength}"
							 placeholder="${(x) => x.placeholder}"
							 ?readonly="${(x) => x.readOnly}"
							 ?required="${(x) => x.required}"
							 size="${(x) => x.size}"
							 autocomplete="${(x) => x.autoComplete}"
							 name="${(x) => x.name}"
							 ?spellcheck="${(x) => x.spellcheck}"
							 :value="${(x) => x.value}"
							 type="text"
							 aria-atomic="${(x) => x.ariaAtomic}"
							 aria-busy="${(x) => x.ariaBusy}"
							 aria-controls="${(x) => x.ariaControls}"
							 aria-current="${(x) => x.ariaCurrent}"
							 aria-describedby="${(x) => x.ariaDescribedby}"
							 aria-details="${(x) => x.ariaDetails}"
							 aria-disabled="${(x) => x.ariaDisabled}"
							 aria-errormessage="${(x) => x.ariaErrormessage}"
							 aria-flowto="${(x) => x.ariaFlowto}"
							 aria-haspopup="${(x) => x.ariaHaspopup}"
							 aria-hidden="${(x) => x.ariaHidden}"
							 aria-invalid="${(x) => x.ariaInvalid}"
							 aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
							 aria-label="${(x) => x.ariaLabel}"
							 aria-labelledby="${(x) => x.ariaLabelledby}"
							 aria-live="${(x) => x.ariaLive}"
							 aria-owns="${(x) => x.ariaOwns}"
							 aria-relevant="${(x) => x.ariaRelevant}"
							 aria-roledescription="${(x) => x.ariaRoledescription}"
							 ${ref("control")}
				/>
				${() => focusTemplate}
			</div>
			${() => numberControlButtons(context)}
    </div>
	  ${when((x) => !x.successText && !x.errorValidationMessage && x.helperText?.length, getFeedbackTemplate("helper", context))}
	  ${when((x) => !x.successText && x.errorValidationMessage, getFeedbackTemplate("error", context))}
	  ${when((x) => x.successText, getFeedbackTemplate("success", context))}
	</div>
`;
};

const numberFieldDefinition = NumberField.compose({
  baseName: "number-field",
  template: NumberFieldTemplate,
  styles,
  shadowOptions: {
    delegatesFocus: true
  }
});
const numberFieldRegistries = [numberFieldDefinition(), ...buttonRegistries, ...dividerRegistries];
const registerNumberField = registerFactory(numberFieldRegistries);

export { numberFieldRegistries as a, numberFieldDefinition as n, registerNumberField as r };
