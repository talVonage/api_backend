import { D as DOM, O as Observable, _ as __decorate, a as attr, v as volatile, o as observable, h as html, r as registerFactory } from './index.js';
import { f as focusRegistries } from './definition56.js';
import { P as Popup, p as popupRegistries } from './definition58.js';
import { a as iconRegistries } from './definition25.js';
import { L as ListboxOption, a as listboxOptionRegistries } from './definition34.js';
import { b as AffixIconWithTrailing, a as affixIconTemplateFactory, I as IconWrapper } from './affix.js';
import { e as errorText, f as formElements, F as FormElementSuccessText, a as FormElementHelperText, g as getFeedbackTemplate } from './index2.js';
import { L as ListboxElement, b as Listbox, D as DelegatesARIAListbox, a as Listbox$1 } from './listbox.js';
import { S as StartEnd } from './start-end.js';
import { a as applyMixins } from './apply-mixins.js';
import { F as FormAssociated } from './form-associated.js';
import { S as SelectPosition } from './select.options.js';
import { u as uniqueId } from './strings.js';
import { g as keyTab, f as keyEscape, k as keyEnter, b as keyEnd, c as keyHome, a as keySpace, d as keyArrowDown, e as keyArrowUp } from './key-codes.js';
import { f as focusTemplateFactory } from './focus2.js';
import { w as when } from './when.js';
import { r as ref } from './ref.js';
import { s as slotted } from './slotted.js';
import { c as classNames } from './class-names.js';

class _Select extends ListboxElement {
}
/**
 * A form-associated base class for the {@link @microsoft/fast-foundation#(Select:class)} component.
 *
 * @internal
 */
class FormAssociatedSelect extends FormAssociated(_Select) {
    constructor() {
        super(...arguments);
        this.proxy = document.createElement("select");
    }
}

/**
 * A Select Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#select | ARIA select }.
 *
 * @slot start - Content which can be provided before the button content
 * @slot end - Content which can be provided after the button content
 * @slot button-container - The element representing the select button
 * @slot selected-value - The selected value
 * @slot indicator - The visual indicator for the expand/collapse state of the button
 * @slot - The default slot for slotted options
 * @csspart control - The element representing the select invoking element
 * @csspart selected-value - The element wrapping the selected value
 * @csspart indicator - The element wrapping the visual indicator
 * @csspart listbox - The listbox element
 * @fires input - Fires a custom 'input' event when the value updates
 * @fires change - Fires a custom 'change' event when the value updates
 *
 * @public
 */
let Select$1 = class Select extends FormAssociatedSelect {
    constructor() {
        super(...arguments);
        /**
         * The open attribute.
         *
         * @public
         * @remarks
         * HTML Attribute: open
         */
        this.open = false;
        /**
         * Indicates the initial state of the position attribute.
         *
         * @internal
         */
        this.forcedPosition = false;
        /**
         * The unique id for the internal listbox element.
         *
         * @internal
         */
        this.listboxId = uniqueId("listbox-");
        /**
         * The max height for the listbox when opened.
         *
         * @internal
         */
        this.maxHeight = 0;
    }
    /**
     * Sets focus and synchronizes ARIA attributes when the open property changes.
     *
     * @param prev - the previous open value
     * @param next - the current open value
     *
     * @internal
     */
    openChanged(prev, next) {
        if (!this.collapsible) {
            return;
        }
        if (this.open) {
            this.ariaControls = this.listboxId;
            this.ariaExpanded = "true";
            this.setPositioning();
            this.focusAndScrollOptionIntoView();
            this.indexWhenOpened = this.selectedIndex;
            // focus is directed to the element when `open` is changed programmatically
            DOM.queueUpdate(() => this.focus());
            return;
        }
        this.ariaControls = "";
        this.ariaExpanded = "false";
    }
    /**
     * The component is collapsible when in single-selection mode with no size attribute.
     *
     * @internal
     */
    get collapsible() {
        return !(this.multiple || typeof this.size === "number");
    }
    /**
     * The value property.
     *
     * @public
     */
    get value() {
        Observable.track(this, "value");
        return this._value;
    }
    set value(next) {
        var _a, _b, _c, _d, _e, _f, _g;
        const prev = `${this._value}`;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.length) {
            const selectedIndex = this._options.findIndex(el => el.value === next);
            const prevSelectedValue = (_c = (_b = this._options[this.selectedIndex]) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : null;
            const nextSelectedValue = (_e = (_d = this._options[selectedIndex]) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : null;
            if (selectedIndex === -1 || prevSelectedValue !== nextSelectedValue) {
                next = "";
                this.selectedIndex = selectedIndex;
            }
            next = (_g = (_f = this.firstSelectedOption) === null || _f === void 0 ? void 0 : _f.value) !== null && _g !== void 0 ? _g : next;
        }
        if (prev !== next) {
            this._value = next;
            super.valueChanged(prev, next);
            Observable.notify(this, "value");
            this.updateDisplayValue();
        }
    }
    /**
     * Sets the value and display value to match the first selected option.
     *
     * @param shouldEmit - if true, the input and change events will be emitted
     *
     * @internal
     */
    updateValue(shouldEmit) {
        var _a, _b;
        if (this.$fastController.isConnected) {
            this.value = (_b = (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : "";
        }
        if (shouldEmit) {
            this.$emit("input");
            this.$emit("change", this, {
                bubbles: true,
                composed: undefined,
            });
        }
    }
    /**
     * Updates the proxy value when the selected index changes.
     *
     * @param prev - the previous selected index
     * @param next - the next selected index
     *
     * @internal
     */
    selectedIndexChanged(prev, next) {
        super.selectedIndexChanged(prev, next);
        this.updateValue();
    }
    positionChanged(prev, next) {
        this.positionAttribute = next;
        this.setPositioning();
    }
    /**
     * Calculate and apply listbox positioning based on available viewport space.
     *
     * @public
     */
    setPositioning() {
        const currentBox = this.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const availableBottom = viewportHeight - currentBox.bottom;
        this.position = this.forcedPosition
            ? this.positionAttribute
            : currentBox.top > availableBottom
                ? SelectPosition.above
                : SelectPosition.below;
        this.positionAttribute = this.forcedPosition
            ? this.positionAttribute
            : this.position;
        this.maxHeight =
            this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
    }
    /**
     * The value displayed on the button.
     *
     * @public
     */
    get displayValue() {
        var _a, _b;
        Observable.track(this, "displayValue");
        return (_b = (_a = this.firstSelectedOption) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    }
    /**
     * Synchronize the `aria-disabled` property when the `disabled` property changes.
     *
     * @param prev - The previous disabled value
     * @param next - The next disabled value
     *
     * @internal
     */
    disabledChanged(prev, next) {
        if (super.disabledChanged) {
            super.disabledChanged(prev, next);
        }
        this.ariaDisabled = this.disabled ? "true" : "false";
    }
    /**
     * Reset the element to its first selectable option when its parent form is reset.
     *
     * @internal
     */
    formResetCallback() {
        this.setProxyOptions();
        // Call the base class's implementation setDefaultSelectedOption instead of the select's
        // override, in order to reset the selectedIndex without using the value property.
        super.setDefaultSelectedOption();
        if (this.selectedIndex === -1) {
            this.selectedIndex = 0;
        }
    }
    /**
     * Handle opening and closing the listbox when the select is clicked.
     *
     * @param e - the mouse event
     * @internal
     */
    clickHandler(e) {
        // do nothing if the select is disabled
        if (this.disabled) {
            return;
        }
        if (this.open) {
            const captured = e.target.closest(`option,[role=option]`);
            if (captured && captured.disabled) {
                return;
            }
        }
        super.clickHandler(e);
        this.open = this.collapsible && !this.open;
        if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
            this.updateValue(true);
        }
        return true;
    }
    /**
     * Handles focus state when the element or its children lose focus.
     *
     * @param e - The focus event
     * @internal
     */
    focusoutHandler(e) {
        var _a;
        super.focusoutHandler(e);
        if (!this.open) {
            return true;
        }
        const focusTarget = e.relatedTarget;
        if (this.isSameNode(focusTarget)) {
            this.focus();
            return;
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.includes(focusTarget))) {
            this.open = false;
            if (this.indexWhenOpened !== this.selectedIndex) {
                this.updateValue(true);
            }
        }
    }
    /**
     * Updates the value when an option's value changes.
     *
     * @param source - the source object
     * @param propertyName - the property to evaluate
     *
     * @internal
     * @override
     */
    handleChange(source, propertyName) {
        super.handleChange(source, propertyName);
        if (propertyName === "value") {
            this.updateValue();
        }
    }
    /**
     * Synchronize the form-associated proxy and updates the value property of the element.
     *
     * @param prev - the previous collection of slotted option elements
     * @param next - the next collection of slotted option elements
     *
     * @internal
     */
    slottedOptionsChanged(prev, next) {
        this.options.forEach(o => {
            const notifier = Observable.getNotifier(o);
            notifier.unsubscribe(this, "value");
        });
        super.slottedOptionsChanged(prev, next);
        this.options.forEach(o => {
            const notifier = Observable.getNotifier(o);
            notifier.subscribe(this, "value");
        });
        this.setProxyOptions();
        this.updateValue();
    }
    /**
     * Prevents focus when size is set and a scrollbar is clicked.
     *
     * @param e - the mouse event object
     *
     * @override
     * @internal
     */
    mousedownHandler(e) {
        var _a;
        if (e.offsetX >= 0 && e.offsetX <= ((_a = this.listbox) === null || _a === void 0 ? void 0 : _a.scrollWidth)) {
            return super.mousedownHandler(e);
        }
        return this.collapsible;
    }
    /**
     * Sets the multiple property on the proxy element.
     *
     * @param prev - the previous multiple value
     * @param next - the current multiple value
     */
    multipleChanged(prev, next) {
        super.multipleChanged(prev, next);
        if (this.proxy) {
            this.proxy.multiple = next;
        }
    }
    /**
     * Updates the selectedness of each option when the list of selected options changes.
     *
     * @param prev - the previous list of selected options
     * @param next - the current list of selected options
     *
     * @override
     * @internal
     */
    selectedOptionsChanged(prev, next) {
        var _a;
        super.selectedOptionsChanged(prev, next);
        (_a = this.options) === null || _a === void 0 ? void 0 : _a.forEach((o, i) => {
            var _a;
            const proxyOption = (_a = this.proxy) === null || _a === void 0 ? void 0 : _a.options.item(i);
            if (proxyOption) {
                proxyOption.selected = o.selected;
            }
        });
    }
    /**
     * Sets the selected index to match the first option with the selected attribute, or
     * the first selectable option.
     *
     * @override
     * @internal
     */
    setDefaultSelectedOption() {
        var _a;
        const options = (_a = this.options) !== null && _a !== void 0 ? _a : Array.from(this.children).filter(Listbox.slottedOptionFilter);
        const selectedIndex = options === null || options === void 0 ? void 0 : options.findIndex(el => el.hasAttribute("selected") || el.selected || el.value === this.value);
        if (selectedIndex !== -1) {
            this.selectedIndex = selectedIndex;
            return;
        }
        this.selectedIndex = 0;
    }
    /**
     * Resets and fills the proxy to match the component's options.
     *
     * @internal
     */
    setProxyOptions() {
        if (this.proxy instanceof HTMLSelectElement && this.options) {
            this.proxy.options.length = 0;
            this.options.forEach(option => {
                const proxyOption = option.proxy ||
                    (option instanceof HTMLOptionElement ? option.cloneNode() : null);
                if (proxyOption) {
                    this.proxy.options.add(proxyOption);
                }
            });
        }
    }
    /**
     * Handle keyboard interaction for the select.
     *
     * @param e - the keyboard event
     * @internal
     */
    keydownHandler(e) {
        super.keydownHandler(e);
        const key = e.key || e.key.charCodeAt(0);
        switch (key) {
            case keySpace: {
                e.preventDefault();
                if (this.collapsible && this.typeAheadExpired) {
                    this.open = !this.open;
                }
                break;
            }
            case keyHome:
            case keyEnd: {
                e.preventDefault();
                break;
            }
            case keyEnter: {
                e.preventDefault();
                this.open = !this.open;
                break;
            }
            case keyEscape: {
                if (this.collapsible && this.open) {
                    e.preventDefault();
                    this.open = false;
                }
                break;
            }
            case keyTab: {
                if (this.collapsible && this.open) {
                    e.preventDefault();
                    this.open = false;
                }
                return true;
            }
        }
        if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
            this.updateValue(true);
            this.indexWhenOpened = this.selectedIndex;
        }
        return !(key === keyArrowDown || key === keyArrowUp);
    }
    connectedCallback() {
        super.connectedCallback();
        this.forcedPosition = !!this.positionAttribute;
        this.addEventListener("contentchange", this.updateDisplayValue);
    }
    disconnectedCallback() {
        this.removeEventListener("contentchange", this.updateDisplayValue);
        super.disconnectedCallback();
    }
    /**
     * Updates the proxy's size property when the size attribute changes.
     *
     * @param prev - the previous size
     * @param next - the current size
     *
     * @override
     * @internal
     */
    sizeChanged(prev, next) {
        super.sizeChanged(prev, next);
        if (this.proxy) {
            this.proxy.size = next;
        }
    }
    /**
     *
     * @internal
     */
    updateDisplayValue() {
        if (this.collapsible) {
            Observable.notify(this, "displayValue");
        }
    }
};
__decorate([
    attr({ attribute: "open", mode: "boolean" })
], Select$1.prototype, "open", void 0);
__decorate([
    volatile
], Select$1.prototype, "collapsible", null);
__decorate([
    observable
], Select$1.prototype, "control", void 0);
__decorate([
    attr({ attribute: "position" })
], Select$1.prototype, "positionAttribute", void 0);
__decorate([
    observable
], Select$1.prototype, "position", void 0);
__decorate([
    observable
], Select$1.prototype, "maxHeight", void 0);
/**
 * Includes ARIA states and properties relating to the ARIA select role.
 *
 * @public
 */
class DelegatesARIASelect {
}
__decorate([
    observable
], DelegatesARIASelect.prototype, "ariaControls", void 0);
applyMixins(DelegatesARIASelect, DelegatesARIAListbox);
applyMixins(Select$1, StartEnd, DelegatesARIASelect);

const styles = "/**\n * Do not edit directly\n * Generated on Tue, 17 Oct 2023 15:27:52 GMT\n */\n@supports selector(:focus-visible) {\n  :host(:focus-visible) {\n    outline: none;\n  }\n}\n:host {\n  display: inline-flex;\n  flex-direction: column;\n  gap: 4px;\n  --_low-ink-color: var(--vvd-color-neutral-600);\n}\n\n:host([disabled]) {\n  --_low-ink-color: var(--vvd-color-neutral-400);\n  cursor: not-allowed;\n}\n\n.label {\n  color: var(--vvd-color-canvas-text);\n  contain: inline-size;\n  font: var(--vvd-typography-base);\n}\n\n.control {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  background-color: var(--_appearance-color-fill);\n  block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n  border-radius: var(--_select-control-border-radius);\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  color: var(--_appearance-color-text);\n  font: var(--vvd-typography-base);\n  gap: 8px;\n  padding-inline: 16px;\n  transition: box-shadow 0.2s, background-color 0.2s;\n}\n.control {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-intermediate);\n}\n.control.appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.control:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-firm);\n}\n.control:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)).appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.control:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: var(--vvd-color-neutral-100);\n  --_appearance-color-outline: var(--vvd-color-neutral-300);\n}\n.control:where(:disabled, .disabled).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.control:where(.readonly):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--vvd-color-neutral-200);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.control:where(.readonly):where(:not(:disabled, .disabled)).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-600);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.control.connotation-success {\n  /* @cssprop [--vvd-select-success-primary=var(--vvd-color-success-500)] */\n  --_connotation-color-primary: var(--vvd-select-success-primary, var(--vvd-color-success-500));\n  /* @cssprop [--vvd-select-success-backdrop=var(--vvd-color-success-50)] */\n  --_connotation-color-backdrop: var(--vvd-select-success-backdrop, var(--vvd-color-success-50));\n  /* @cssprop [--vvd-select-success-intermediate=var(--vvd-color-success-500)] */\n  --_connotation-color-intermediate: var(--vvd-select-success-intermediate, var(--vvd-color-success-500));\n  /* @cssprop [--vvd-select-success-firm=var(--vvd-color-success-600)] */\n  --_connotation-color-firm: var(--vvd-select-success-firm, var(--vvd-color-success-600));\n}\n.control.connotation-alert {\n  /* @cssprop [--vvd-select-alert-primary=var(--vvd-color-alert-500)] */\n  --_connotation-color-primary: var(--vvd-select-alert-primary, var(--vvd-color-alert-500));\n  /* @cssprop [--vvd-select-alert-backdrop=var(--vvd-color-alert-50)] */\n  --_connotation-color-backdrop: var(--vvd-select-alert-backdrop, var(--vvd-color-alert-50));\n  /* @cssprop [--vvd-select-alert-intermediate=var(--vvd-color-alert-500)] */\n  --_connotation-color-intermediate: var(--vvd-select-alert-intermediate, var(--vvd-color-alert-500));\n  /* @cssprop [--vvd-select-alert-firm=var(--vvd-color-alert-600)] */\n  --_connotation-color-firm: var(--vvd-select-alert-firm, var(--vvd-color-alert-600));\n}\n.control:not(.connotation-success, .connotation-alert) {\n  /* @cssprop [--vvd-select-accent-primary=var(--vvd-color-canvas-text)] */\n  --_connotation-color-primary: var(--vvd-select-accent-primary, var(--vvd-color-canvas-text));\n  /* @cssprop [--vvd-select-accent-backdrop=var(--vvd-color-canvas)] */\n  --_connotation-color-backdrop: var(--vvd-select-accent-backdrop, var(--vvd-color-canvas));\n  /* @cssprop [--vvd-select-accent-intermediate=var(--vvd-color-neutral-500)] */\n  --_connotation-color-intermediate: var(--vvd-select-accent-intermediate, var(--vvd-color-neutral-500));\n  /* @cssprop [--vvd-select-accent-firm=var(--vvd-color-canvas-text)] */\n  --_connotation-color-firm: var(--vvd-select-accent-firm, var(--vvd-color-canvas-text));\n}\n.control-wrapper {\n  position: relative;\n}\n.control:not(.disabled) {\n  cursor: pointer;\n}\n.control.disabled {\n  pointer-events: none;\n}\n.control:not(.shape-pill) {\n  --_select-control-border-radius: 6px;\n}\n.control.shape-pill {\n  --_select-control-border-radius: 24px;\n}\n\n.listbox {\n  display: flex;\n  max-height: var(--select-height, 408px);\n  flex-direction: column;\n  padding: 4px;\n  gap: 2px;\n  overflow-y: auto;\n}\n\n.icon {\n  display: flex;\n  flex-shrink: 0;\n}\n\n.selected-value {\n  display: flex;\n  overflow: hidden;\n  flex-grow: 1;\n  align-items: center;\n  column-gap: 12px;\n  white-space: nowrap;\n}\n.selected-value .text {\n  overflow: hidden;\n  max-inline-size: 100%;\n  text-overflow: ellipsis;\n}\n.selected-value slot[name=icon] {\n  flex: 0 0 20px;\n  font-size: 20px;\n  line-height: 1;\n}\n.control.has-meta .selected-value {\n  padding-inline-end: 8px;\n}\n\n::part(popup-base) {\n  inline-size: max-content;\n  min-inline-size: var(--_select-fixed-width, 100%);\n}\n:host([multiple]) ::part(popup-base) {\n  position: static;\n}\n\n.focus-indicator {\n  --focus-stroke-gap-color: transparent;\n  border-radius: var(--_select-control-border-radius);\n  pointer-events: none;\n}\n:host(:not(:focus-visible)) .focus-indicator {\n  display: none;\n}\n:host([multiple]) .focus-indicator {\n  --_select-control-border-radius: 6px;\n}";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
let Select = class extends Select$1 {
  constructor() {
    super(...arguments);
    this.fixedDropdown = false;
    this.placeholderOption = null;
  }
  connectedCallback() {
    super.connectedCallback();
    this._popup.anchor = this._anchor;
  }
  get displayValue() {
    Observable.track(this, "displayValue");
    return this.firstSelectedOption?.getAttribute("label") ?? this.firstSelectedOption?.text ?? this.placeholder ?? "";
  }
  setDefaultSelectedOption() {
    const options = Array.from(this.children).filter(Listbox$1.slottedOptionFilter);
    const selectedIndex = options.findIndex(
      (el) => el.hasAttribute("selected") || el.selected || el.value === this.value
    );
    if (selectedIndex === -1 && !this.placeholderOption) {
      this.selectedIndex = 0;
      return;
    }
    if (selectedIndex !== -1 || this.placeholder !== "") {
      this.selectedIndex = selectedIndex;
      return;
    }
  }
};
__decorateClass([
  attr
], Select.prototype, "appearance", 2);
__decorateClass([
  attr
], Select.prototype, "shape", 2);
__decorateClass([
  attr({ mode: "boolean", attribute: "fixed-dropdown" })
], Select.prototype, "fixedDropdown", 2);
__decorateClass([
  attr
], Select.prototype, "placeholder", 2);
__decorateClass([
  observable
], Select.prototype, "placeholderOption", 2);
__decorateClass([
  observable
], Select.prototype, "metaSlottedContent", 2);
Select = __decorateClass([
  errorText,
  formElements
], Select);
applyMixins(Select, AffixIconWithTrailing, FormElementHelperText, FormElementSuccessText);

const getStateClasses = ({
  shape,
  disabled,
  appearance,
  metaSlottedContent,
  errorValidationMessage,
  successText
}) => classNames(
  ["disabled", disabled],
  [`appearance-${appearance}`, Boolean(appearance)],
  [`shape-${shape}`, Boolean(shape)],
  ["has-meta", Boolean(metaSlottedContent?.length)],
  ["error connotation-alert", Boolean(errorValidationMessage)],
  ["success connotation-success", !!successText],
  ["has-meta", Boolean(metaSlottedContent?.length)]
);
function renderLabel() {
  return html`
	  <label for="control" class="label">
		  ${(x) => x.label}
	  </label>`;
}
function renderPlaceholder(context) {
  const optionTag = context.tagFor(ListboxOption);
  return html`
		<${optionTag} ${ref("placeholderOption")}
			text="${(x) => x.placeholder}" hidden disabled>
		</${optionTag}>`;
}
function selectValue(context) {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  return html`
		<div class="control ${getStateClasses}" ${ref("_anchor")}
			id="control" ?disabled="${(x) => x.disabled}">
			<div class="selected-value">
				${(x) => affixIconTemplate(x.icon, IconWrapper.Slot)}
				<span class="text">${(x) => x.displayValue}</span>
				<slot name="meta" ${slotted("metaSlottedContent")}></slot>
			</div>
			${() => affixIconTemplate("chevron-down-line")}
			${() => focusTemplate}
		</div>`;
}
function setFixedDropdownVarWidth(x) {
  return x.open && x.fixedDropdown ? `--_select-fixed-width: ${Math.round(x.getBoundingClientRect().width)}px` : null;
}
function renderControl(context) {
  const focusTemplate = focusTemplateFactory(context);
  const popupTag = context.tagFor(Popup);
  return html`
			${when((x) => x.label, renderLabel())}
			<div class="control-wrapper">
				${when((x) => !x.multiple, selectValue(context))}
				<${popupTag} class="popup" ${ref("_popup")}
					style="${setFixedDropdownVarWidth}"
					?open="${(x) => x.collapsible ? x.open : true}"
					anchor="control"
					placement="bottom-start"
					strategy="${(x) => x.fixedDropdown ? null : "absolute"}">
					<div class="listbox"
						id="${(x) => x.listboxId}"
						role="listbox"
						?disabled="${(x) => x.disabled}"
						?hidden="${(x) => x.collapsible ? !x.open : false}"
						${ref("listbox")}>
						${when((x) => x.placeholder, renderPlaceholder(context))}
						${when((x) => x.multiple, focusTemplate)}
						<slot
							${slotted({ filter: Listbox$1.slottedOptionFilter, flatten: true, property: "slottedOptions" })}>
						</slot>
           			 </div>
				</${popupTag}>
			</div>
			${when((x) => x.helperText?.length, getFeedbackTemplate("helper", context))}
			${when((x) => !x.successText && x.errorValidationMessage, getFeedbackTemplate("error", context))}
			${when((x) => x.successText, getFeedbackTemplate("success", context))}
		`;
}
const SelectTemplate = (context) => {
  return html`
		<template class="base"
			aria-label="${(x) => x.ariaLabel ? x.ariaLabel : x.label}"
			aria-activedescendant="${(x) => x.ariaActiveDescendant}"
			aria-controls="${(x) => x.ariaControls}"
			aria-disabled="${(x) => x.ariaDisabled}"
			aria-expanded="${(x) => x.ariaExpanded}"
			aria-haspopup="${(x) => x.collapsible ? "listbox" : null}"
			aria-multiselectable="${(x) => x.ariaMultiSelectable}"
			?open="${(x) => x.open}"
			role="combobox"
			tabindex="${(x) => !x.disabled ? "0" : null}"
			@click="${(x, c) => x.clickHandler(c.event)}"
			@focusin="${(x, c) => x.focusinHandler(c.event)}"
			@focusout="${(x, c) => x.focusoutHandler(c.event)}"
			@keydown="${(x, c) => x.keydownHandler(c.event)}"
			@mousedown="${(x, c) => x.mousedownHandler(c.event)}">
				${renderControl(context)}
		</template>`;
};

const selectDefinition = Select.compose({
  baseName: "select",
  template: SelectTemplate,
  styles
});
const selectRegistries = [selectDefinition(), ...focusRegistries, ...popupRegistries, ...iconRegistries, ...listboxOptionRegistries];
const registerSelect = registerFactory(selectRegistries);

export { selectRegistries as a, registerSelect as r, selectDefinition as s };
