import { F as FoundationElement, _ as __decorate, a as attr, n as nullableNumberConverter, o as observable, h as html, r as registerFactory } from './index.js';
import { a as iconRegistries } from './definition25.js';
import { f as focusRegistries } from './definition56.js';
import './affix.js';
import { e as errorText, f as formElements, F as FormElementSuccessText, a as FormElementHelperText, b as FormElementCharCount, g as getFeedbackTemplate } from './index2.js';
import { D as DelegatesARIATextbox } from './text-field2.js';
import { a as applyMixins } from './apply-mixins.js';
import { F as FormAssociated } from './form-associated.js';
import { w as when } from './when.js';
import { r as ref } from './ref.js';
import { c as classNames } from './class-names.js';

class _TextArea extends FoundationElement {
}
/**
 * A form-associated base class for the {@link @microsoft/fast-foundation#(TextArea:class)} component.
 *
 * @internal
 */
class FormAssociatedTextArea extends FormAssociated(_TextArea) {
    constructor() {
        super(...arguments);
        this.proxy = document.createElement("textarea");
    }
}

/**
 * Resize mode for a TextArea
 * @public
 */
const TextAreaResize = {
    /**
     * No resize.
     */
    none: "none",
    /**
     * Resize vertically and horizontally.
     */
    both: "both",
    /**
     * Resize horizontally.
     */
    horizontal: "horizontal",
    /**
     * Resize vertically.
     */
    vertical: "vertical",
};

/**
 * A Text Area Custom HTML Element.
 * Based largely on the {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea | <textarea> element }.
 *
 * @slot - The default slot for the label
 * @csspart label - The label
 * @csspart root - The element wrapping the control
 * @csspart control - The textarea element
 * @fires change - Emits a custom 'change' event when the textarea emits a change event
 *
 * @public
 */
let TextArea$1 = class TextArea extends FormAssociatedTextArea {
    constructor() {
        super(...arguments);
        /**
         * The resize mode of the element.
         * @public
         * @remarks
         * HTML Attribute: resize
         */
        this.resize = TextAreaResize.none;
        /**
         * Sizes the element horizontally by a number of character columns.
         *
         * @public
         * @remarks
         * HTML Attribute: cols
         */
        this.cols = 20;
        /**
         * @internal
         */
        this.handleTextInput = () => {
            this.value = this.control.value;
        };
    }
    readOnlyChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.readOnly = this.readOnly;
        }
    }
    autofocusChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.autofocus = this.autofocus;
        }
    }
    listChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.setAttribute("list", this.list);
        }
    }
    maxlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.maxLength = this.maxlength;
        }
    }
    minlengthChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.minLength = this.minlength;
        }
    }
    spellcheckChanged() {
        if (this.proxy instanceof HTMLTextAreaElement) {
            this.proxy.spellcheck = this.spellcheck;
        }
    }
    /**
     * Selects all the text in the text area
     *
     * @public
     */
    select() {
        this.control.select();
        /**
         * The select event does not permeate the shadow DOM boundary.
         * This fn effectively proxies the select event,
         * emitting a `select` event whenever the internal
         * control emits a `select` event
         */
        this.$emit("select");
    }
    /**
     * Change event handler for inner control.
     * @remarks
     * "Change" events are not `composable` so they will not
     * permeate the shadow DOM boundary. This fn effectively proxies
     * the change event, emitting a `change` event whenever the internal
     * control emits a `change` event
     * @internal
     */
    handleChange() {
        this.$emit("change");
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate() {
        super.validate(this.control);
    }
};
__decorate([
    attr({ mode: "boolean" })
], TextArea$1.prototype, "readOnly", void 0);
__decorate([
    attr
], TextArea$1.prototype, "resize", void 0);
__decorate([
    attr({ mode: "boolean" })
], TextArea$1.prototype, "autofocus", void 0);
__decorate([
    attr({ attribute: "form" })
], TextArea$1.prototype, "formId", void 0);
__decorate([
    attr
], TextArea$1.prototype, "list", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], TextArea$1.prototype, "maxlength", void 0);
__decorate([
    attr({ converter: nullableNumberConverter })
], TextArea$1.prototype, "minlength", void 0);
__decorate([
    attr
], TextArea$1.prototype, "name", void 0);
__decorate([
    attr
], TextArea$1.prototype, "placeholder", void 0);
__decorate([
    attr({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea$1.prototype, "cols", void 0);
__decorate([
    attr({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea$1.prototype, "rows", void 0);
__decorate([
    attr({ mode: "boolean" })
], TextArea$1.prototype, "spellcheck", void 0);
__decorate([
    observable
], TextArea$1.prototype, "defaultSlottedNodes", void 0);
applyMixins(TextArea$1, DelegatesARIATextbox);

const styles = "/**\n * Do not edit directly\n * Generated on Tue, 17 Oct 2023 15:27:52 GMT\n */\n:host {\n  display: inline-block;\n}\n\n.base {\n  display: inline-grid;\n  grid-template-columns: 1fr max-content;\n  inline-size: 100%;\n  row-gap: 4px;\n}\n.base {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-intermediate);\n}\n.base.appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--_connotation-color-backdrop);\n  --_appearance-color-outline: var(--_connotation-color-firm);\n}\n.base:where(:hover, .hover):where(:not(:disabled, .disabled, .readonly)).appearance-ghost {\n  --_appearance-color-text: var(--_connotation-color-primary);\n  --_appearance-color-fill: var(--_connotation-color-faint);\n  --_appearance-color-outline: transparent;\n}\n.base:where(:disabled, .disabled) {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: var(--vvd-color-neutral-100);\n  --_appearance-color-outline: var(--vvd-color-neutral-300);\n}\n.base:where(:disabled, .disabled).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-300);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)) {\n  --_appearance-color-text: var(--vvd-color-canvas-text);\n  --_appearance-color-fill: var(--vvd-color-neutral-200);\n  --_appearance-color-outline: var(--vvd-color-neutral-400);\n}\n.base:where(.readonly):where(:not(:disabled, .disabled)).appearance-ghost {\n  --_appearance-color-text: var(--vvd-color-neutral-600);\n  --_appearance-color-fill: transparent;\n  --_appearance-color-outline: transparent;\n}\n.base.connotation-success {\n  /* @cssprop [--vvd-text-area-success-primary=var(--vvd-color-success-500)] */\n  --_connotation-color-primary: var(--vvd-text-area-success-primary, var(--vvd-color-success-500));\n  /* @cssprop [--vvd-text-area-success-backdrop=var(--vvd-color-success-50)] */\n  --_connotation-color-backdrop: var(--vvd-text-area-success-backdrop, var(--vvd-color-success-50));\n  /* @cssprop [--vvd-text-area-success-intermediate=var(--vvd-color-success-500)] */\n  --_connotation-color-intermediate: var(--vvd-text-area-success-intermediate, var(--vvd-color-success-500));\n  /* @cssprop [--vvd-text-area-success-firm=var(--vvd-color-success-600)] */\n  --_connotation-color-firm: var(--vvd-text-area-success-firm, var(--vvd-color-success-600));\n  /* @cssprop [--vvd-text-area-success-faint=var(--vvd-color-success-50)] */\n  --_connotation-color-faint: var(--vvd-text-area-success-faint, var(--vvd-color-success-50));\n  /* @cssprop [--vvd-text-area-success-soft=var(--vvd-color-success-100)] */\n  --_connotation-color-soft: var(--vvd-text-area-success-soft, var(--vvd-color-success-100));\n}\n.base.connotation-alert {\n  /* @cssprop [--vvd-text-area-alert-primary=var(--vvd-color-alert-500)] */\n  --_connotation-color-primary: var(--vvd-text-area-alert-primary, var(--vvd-color-alert-500));\n  /* @cssprop [--vvd-text-area-alert-backdrop=var(--vvd-color-alert-50)] */\n  --_connotation-color-backdrop: var(--vvd-text-area-alert-backdrop, var(--vvd-color-alert-50));\n  /* @cssprop [--vvd-text-area-alert-intermediate=var(--vvd-color-alert-500)] */\n  --_connotation-color-intermediate: var(--vvd-text-area-alert-intermediate, var(--vvd-color-alert-500));\n  /* @cssprop [--vvd-text-area-alert-firm=var(--vvd-color-alert-600)] */\n  --_connotation-color-firm: var(--vvd-text-area-alert-firm, var(--vvd-color-alert-600));\n  /* @cssprop [--vvd-text-area-alert-faint=var(--vvd-color-alert-50)] */\n  --_connotation-color-faint: var(--vvd-text-area-alert-faint, var(--vvd-color-alert-50));\n  /* @cssprop [--vvd-text-area-alert-soft=var(--vvd-color-alert-100)] */\n  --_connotation-color-soft: var(--vvd-text-area-alert-soft, var(--vvd-color-alert-100));\n}\n.base:not(.connotation-success, .connotation-alert) {\n  /* @cssprop [--vvd-text-area-accent-primary=var(--vvd-color-canvas-text)] */\n  --_connotation-color-primary: var(--vvd-text-area-accent-primary, var(--vvd-color-canvas-text));\n  /* @cssprop [--vvd-text-area-accent-backdrop=var(--vvd-color-canvas)] */\n  --_connotation-color-backdrop: var(--vvd-text-area-accent-backdrop, var(--vvd-color-canvas));\n  /* @cssprop [--vvd-text-area-accent-intermediate=var(--vvd-color-neutral-500)] */\n  --_connotation-color-intermediate: var(--vvd-text-area-accent-intermediate, var(--vvd-color-neutral-500));\n  /* @cssprop [--vvd-text-area-accent-firm=var(--vvd-color-canvas-text)] */\n  --_connotation-color-firm: var(--vvd-text-area-accent-firm, var(--vvd-color-canvas-text));\n  /* @cssprop [--vvd-text-area-accent-faint=var(--vvd-color-neutral-50)] */\n  --_connotation-color-faint: var(--vvd-text-area-accent-faint, var(--vvd-color-neutral-50));\n  /* @cssprop [--vvd-text-area-accent-soft=var(--vvd-color-neutral-100)] */\n  --_connotation-color-soft: var(--vvd-text-area-accent-soft, var(--vvd-color-neutral-100));\n}\n@supports (user-select: none) {\n  .base {\n    user-select: none;\n  }\n}\n.base:not(.disabled) {\n  --_low-ink-color: var(--vvd-color-neutral-600);\n}\n.base.disabled {\n  --_low-ink-color: var(--_appearance-color-text);\n  cursor: not-allowed;\n}\n\n.label {\n  color: var(--vvd-color-canvas-text);\n  contain: inline-size;\n  font: var(--vvd-typography-base);\n  grid-column: 1/2;\n  grid-row: 1;\n  line-height: 20px;\n}\n\n.char-count {\n  color: var(--_low-ink-color);\n  font: var(--vvd-typography-base);\n  grid-column: 2/-1;\n}\n\n.control {\n  padding: 8px 16px;\n  border: 0 none;\n  appearance: none; /* for box-shadow visibility on IOS */\n  background-color: var(--_appearance-color-fill);\n  border-radius: 6px;\n  box-shadow: inset 0 0 0 1px var(--_appearance-color-outline);\n  color: var(--_appearance-color-text);\n  font: var(--vvd-typography-base);\n  grid-column: 1/-1;\n  min-block-size: calc(1px * (40 + 4 * clamp(-1, var(--vvd-size-density, 0), 2)));\n  resize: none;\n  transition: box-shadow 0.2s, background-color 0.2s, color 0.2s;\n}\n.control:disabled {\n  opacity: 1; /* 2. correct opacity on iOS */\n  pointer-events: none;\n  -webkit-text-fill-color: var(--_appearance-color-text); /* 1. sets text fill to current `color` for safari */\n}\n.control::placeholder, .control:disabled::placeholder {\n  opacity: 1; /* 2. correct opacity on iOS */\n  pointer-events: none;\n  -webkit-text-fill-color: var(--_low-ink-color); /* 1. sets text fill to current `color` for safari */\n}\n.control:focus {\n  outline: 2px solid var(--focus-stroke-color, currentColor);\n  outline-offset: -2px;\n}\n:host([resize=both]) .control {\n  resize: both;\n}\n:host([resize=horizontal]) .control {\n  resize: horizontal;\n}\n:host([resize=vertical]) .control {\n  resize: vertical;\n}";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
let TextArea = class extends TextArea$1 {
};
__decorateClass([
  attr
], TextArea.prototype, "wrap", 2);
TextArea = __decorateClass([
  errorText,
  formElements
], TextArea);
applyMixins(TextArea, FormElementCharCount, FormElementHelperText, FormElementSuccessText);

const getClasses = ({ value, errorValidationMessage, disabled, placeholder, readOnly, successText }) => classNames(
  "base",
  ["readonly", readOnly],
  ["placeholder", Boolean(placeholder)],
  ["disabled", disabled],
  ["error connotation-alert", Boolean(errorValidationMessage)],
  ["has-value", Boolean(value)],
  ["success connotation-success", !!successText]
);
function renderLabel() {
  return html`
	  <label for="control" class="label">
		  ${(x) => x.label}
	  </label>`;
}
function renderCharCount() {
  return html`
		<span class="char-count">${(x) => x.value ? x.value.length : 0} / ${(x) => x.maxlength}</span>
	`;
}
const TextAreaTemplate = (context) => {
  return html`
	  <div class="${getClasses}">
		${when((x) => x.charCount && x.maxlength, renderCharCount())}
		${when((x) => x.label, renderLabel())}
			<textarea class="control" id="control"
				?autofocus="${(x) => x.autofocus}"
				placeholder="${(x) => x.placeholder ? x.placeholder : null}"
				name="${(x) => x.name ? x.name : null}"
				maxlength="${(x) => x.maxlength ? x.maxlength : null}"
				rows="${(x) => x.rows ? x.rows : null}"
				cols="${(x) => x.cols ? x.cols : null}"
				wrap="${(x) => x.wrap ? x.wrap : null}"
				?readonly="${(x) => x.readOnly}"
				?disabled="${(x) => x.disabled}"
				?required="${(x) => x.required}"
				?spellcheck="${(x) => x.spellcheck}"
				:value="${(x) => x.value}"
				aria-atomic="${(x) => x.ariaAtomic}"
				aria-busy="${(x) => x.ariaBusy}"
				aria-controls="${(x) => x.ariaControls}"
				aria-current="${(x) => x.ariaCurrent}"
				aria-describedby="${(x) => x.ariaDescribedby}"
				aria-details="${(x) => x.ariaDetails}"
				aria-disabled="${(x) => x.ariaDisabled}"
				aria-errormessage="${(x) => x.ariaErrormessage}"
				aria-flowto="${(x) => x.ariaFlowto}"
				aria-haspopup="${(x) => x.ariaHaspopup}"
				aria-hidden="${(x) => x.ariaHidden}"
				aria-invalid="${(x) => x.ariaInvalid}"
				aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
				aria-label="${(x) => x.ariaLabel}"
				aria-labelledby="${(x) => x.ariaLabelledby}"
				aria-live="${(x) => x.ariaLive}"
				aria-owns="${(x) => x.ariaOwns}"
				aria-relevant="${(x) => x.ariaRelevant}"
				aria-roledescription="${(x) => x.ariaRoledescription}"
				@input="${(x) => x.handleTextInput()}"
				@change="${(x) => x.handleChange()}"
				${ref("control")}
	  >
			</textarea>
		${when((x) => !x.successText && !x.errorValidationMessage && x.helperText?.length, getFeedbackTemplate("helper", context))}
		${when((x) => !x.successText && x.errorValidationMessage, getFeedbackTemplate("error", context))}
		${when((x) => x.successText, getFeedbackTemplate("success", context))}
	  </div>
	`;
};

const textAreaDefinition = TextArea.compose({
  baseName: "text-area",
  template: TextAreaTemplate,
  styles,
  shadowOptions: {
    delegatesFocus: true
  }
});
const textAreaRegistries = [textAreaDefinition(), ...iconRegistries, ...focusRegistries];
const registerTextArea = registerFactory(textAreaRegistries);

export { textAreaRegistries as a, registerTextArea as r, textAreaDefinition as t };
