import { a as attr, o as observable, h as html, r as registerFactory } from './index.js';
import { f as focusRegistries } from './definition56.js';
import { a as iconRegistries } from './definition25.js';
import { A as AffixIcon, a as affixIconTemplateFactory } from './affix.js';
import { e as errorText, f as formElements, F as FormElementSuccessText, a as FormElementHelperText, b as FormElementCharCount, g as getFeedbackTemplate } from './index2.js';
import { T as TextField$1 } from './text-field2.js';
import { a as applyMixins } from './apply-mixins.js';
import { s as styles } from './text-field.js';
import { f as focusTemplateFactory } from './focus2.js';
import { w as when } from './when.js';
import { s as slotted } from './slotted.js';
import { r as ref } from './ref.js';
import { c as classNames } from './class-names.js';

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
let TextField = class extends TextField$1 {
};
__decorateClass([
  attr
], TextField.prototype, "appearance", 2);
__decorateClass([
  attr
], TextField.prototype, "shape", 2);
__decorateClass([
  attr
], TextField.prototype, "autoComplete", 2);
__decorateClass([
  observable
], TextField.prototype, "actionItemsSlottedContent", 2);
__decorateClass([
  observable
], TextField.prototype, "leadingActionItemsSlottedContent", 2);
TextField = __decorateClass([
  errorText,
  formElements
], TextField);
applyMixins(TextField, AffixIcon, FormElementCharCount, FormElementHelperText, FormElementSuccessText);

const getStateClasses = ({
  errorValidationMessage,
  disabled,
  value,
  readOnly,
  placeholder,
  appearance,
  shape,
  label,
  successText,
  actionItemsSlottedContent,
  leadingActionItemsSlottedContent,
  icon
}) => classNames(
  ["error connotation-alert", Boolean(errorValidationMessage)],
  ["disabled", disabled],
  ["has-value", Boolean(value)],
  ["readonly", readOnly],
  ["placeholder", Boolean(placeholder)],
  [`appearance-${appearance}`, Boolean(appearance)],
  [`shape-${shape}`, Boolean(shape)],
  ["no-label", !label],
  ["has-icon", !!icon],
  ["success connotation-success", Boolean(successText)],
  ["action-items", !!actionItemsSlottedContent?.length],
  ["leading-action-items", !!leadingActionItemsSlottedContent?.length],
  ["no-leading", !(leadingActionItemsSlottedContent?.length || icon)]
);
function renderLabel() {
  return html`
	  <label for="control" class="label">
		  ${(x) => x.label}
	  </label>`;
}
function renderCharCount() {
  return html`
		<span class="char-count">${(x) => x.value ? x.value.length : 0} / ${(x) => x.maxlength}</span>
	`;
}
const TextfieldTemplate = (context) => {
  const affixIconTemplate = affixIconTemplateFactory(context);
  const focusTemplate = focusTemplateFactory(context);
  return html`
	<div class="base ${getStateClasses}">
    ${when((x) => x.charCount && x.maxlength, renderCharCount())}
    ${when((x) => x.label, renderLabel())}
    <div class="fieldset">
			<div class="leading-items-wrapper">
				<slot name="leading-action-items"  ${slotted("leadingActionItemsSlottedContent")}></slot>
				${(x) => affixIconTemplate(x.icon)}
			</div>

			<div class="wrapper">
				<input class="control"
            id="control"
            @input="${(x) => x.handleTextInput()}"
            @change="${(x) => x.handleChange()}"
            ?autofocus="${(x) => x.autofocus}"
            ?disabled="${(x) => x.disabled}"
            list="${(x) => x.list}"
            maxlength="${(x) => x.maxlength}"
            minlength="${(x) => x.minlength}"
            pattern="${(x) => x.pattern}"
            placeholder="${(x) => x.placeholder}"
            ?readonly="${(x) => x.readOnly}"
            ?required="${(x) => x.required}"
            size="${(x) => x.size}"
            autocomplete="${(x) => x.autoComplete}"
            name="${(x) => x.name}"
            ?spellcheck="${(x) => x.spellcheck}"
            :value="${(x) => x.value}"
            type="${(x) => x.type}"
            aria-atomic="${(x) => x.ariaAtomic}"
            aria-busy="${(x) => x.ariaBusy}"
            aria-controls="${(x) => x.ariaControls}"
            aria-current="${(x) => x.ariaCurrent}"
            aria-describedby="${(x) => x.ariaDescribedby}"
            aria-details="${(x) => x.ariaDetails}"
            aria-disabled="${(x) => x.ariaDisabled}"
            aria-errormessage="${(x) => x.ariaErrormessage}"
            aria-flowto="${(x) => x.ariaFlowto}"
            aria-haspopup="${(x) => x.ariaHaspopup}"
            aria-hidden="${(x) => x.ariaHidden}"
            aria-invalid="${(x) => x.ariaInvalid}"
            aria-keyshortcuts="${(x) => x.ariaKeyshortcuts}"
            aria-label="${(x) => x.ariaLabel}"
            aria-labelledby="${(x) => x.ariaLabelledby}"
            aria-live="${(x) => x.ariaLive}"
            aria-owns="${(x) => x.ariaOwns}"
            aria-relevant="${(x) => x.ariaRelevant}"
            aria-roledescription="${(x) => x.ariaRoledescription}"
            ${ref("control")}
      />
				${() => focusTemplate}
			</div>
			<div class="action-items-wrapper">
				<slot name="action-items"  ${slotted("actionItemsSlottedContent")}></slot>
			</div>

    </div>
	  ${when((x) => !x.successText && !x.errorValidationMessage && x.helperText?.length, getFeedbackTemplate("helper", context))}
	  ${when((x) => !x.successText && x.errorValidationMessage, getFeedbackTemplate("error", context))}
	  ${when((x) => x.successText, getFeedbackTemplate("success", context))}
	</div>`;
};

const textFieldDefinition = TextField.compose({
  baseName: "text-field",
  template: TextfieldTemplate,
  styles,
  shadowOptions: {
    delegatesFocus: true
  }
});
const textFieldRegistries = [textFieldDefinition(), ...iconRegistries, ...focusRegistries];
const registerTextField = registerFactory(textFieldRegistries);

export { TextField as T, textFieldRegistries as a, registerTextField as r, textFieldDefinition as t };
