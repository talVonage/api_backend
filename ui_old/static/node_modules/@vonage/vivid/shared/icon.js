import { _ as _curry1, a as _curry2, b as _has } from './_has.js';
import { F as FoundationElement, a as attr, o as observable, v as volatile } from './index.js';

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };

    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };

    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };

    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };

    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };

    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };

    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };

    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };

    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };

    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };

    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };

    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

function _identity(x) {
  return x;
}

/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      const obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */

var identity =
/*#__PURE__*/
_curry1(_identity);

const identity$1 = identity;

/**
 * Creates a new function that, when invoked, caches the result of calling `fn`
 * for a given argument set and returns the result. Subsequent calls to the
 * memoized `fn` with the same argument set will not result in an additional
 * call to `fn`; instead, the cached result for that set of arguments will be
 * returned.
 *
 * Care must be taken when implementing key generation to avoid key collision,
 * or if tracking references, memory leaks and mutating arguments.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Function
 * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to generate the cache key.
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @example
 *
 *      let count = 0;
 *      const factorial = R.memoizeWith(Number, n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */

var memoizeWith =
/*#__PURE__*/
_curry2(function memoizeWith(mFn, fn) {
  var cache = {};
  return _arity(fn.length, function () {
    var key = mFn.apply(this, arguments);

    if (!_has(key, cache)) {
      cache[key] = fn.apply(this, arguments);
    }

    return cache[key];
  });
});

const memoizeWith$1 = memoizeWith;

const ICONS_BASE_URL = "https://icon.resources.vonage.com";
const ICONS_VERSION = "4.4.0";

const PLACEHOLDER_ICON = `<svg width="80%" height="80%" viewBox="0 0 64 64">
    <g>
        <g stroke-width="6" stroke-linecap="round" fill="none">
            <path stroke="currentColor" d="M4,32 c0,15,12,28,28,28c8,0,16-4,21-9">
            </path>
            <path d="M60,32 C60,16,47.464,4,32,4S4,16,4,32">
            </path>
            <animateTransform values="0,32,32;360,32,32" attributeName="transform" type="rotate" repeatCount="indefinite" dur="750ms">
            </animateTransform>
        </g>
    </g>
</svg>`;

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
const PLACEHOLDER_DELAY = 500;
const PLACEHOLDER_TIMEOUT = 2e3;
const baseUrlTemplate = (resource, version) => [ICONS_BASE_URL, `v${version}`, resource].join("/");
const assertIsValidResponse = ({ ok, headers }) => {
  if (!ok || headers.get("content-type") !== "image/svg+xml") {
    throw new Error("Something went wrong");
  }
};
const extractSvg = (response) => {
  assertIsValidResponse(response);
  return response.text();
};
const loadSvg = (iconId) => fetch(baseUrlTemplate([iconId, "svg"].join("."), ICONS_VERSION)).then(extractSvg);
const resolveIcon = memoizeWith$1(identity$1, (iconId = "") => iconId.trim() ? loadSvg(iconId) : Promise.resolve(""));
class Icon extends FoundationElement {
  constructor() {
    super(...arguments);
    this.iconLoaded = false;
  }
  get iconUrl() {
    return !this.name ? this._svg : baseUrlTemplate(`${this.name}.svg`, ICONS_VERSION);
  }
  async nameChanged() {
    this._svg = void 0;
    this.iconLoaded = false;
    let timeout = setTimeout(() => {
      this._svg = PLACEHOLDER_ICON;
      timeout = setTimeout(() => {
        if (this._svg === PLACEHOLDER_ICON) {
          this._svg = void 0;
        }
      }, PLACEHOLDER_TIMEOUT);
    }, PLACEHOLDER_DELAY);
    await resolveIcon(this.name).then((svg) => {
      this._svg = svg;
    }).catch(() => {
      this._svg = void 0;
    }).finally(() => {
      clearTimeout(timeout);
      this.iconLoaded = true;
    });
  }
}
__decorateClass([
  attr
], Icon.prototype, "connotation", 2);
__decorateClass([
  attr
], Icon.prototype, "size", 2);
__decorateClass([
  observable
], Icon.prototype, "_svg", 2);
__decorateClass([
  observable
], Icon.prototype, "iconLoaded", 2);
__decorateClass([
  attr
], Icon.prototype, "name", 2);
__decorateClass([
  volatile
], Icon.prototype, "iconUrl", 1);

export { Icon as I };
